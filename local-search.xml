<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>02.索引</title>
    <link href="/2023/08/19/02-%E7%B4%A2%E5%BC%95/"/>
    <url>/2023/08/19/02-%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p>翻译自《build your own database fromscratch》, 转代码为C++</p><span id="more"></span><h1 id="02-索引"><a href="#02-索引" class="headerlink" title="02. 索引"></a>02. 索引</h1><h1 id="2-1-键值存储和关系数据库"><a href="#2-1-键值存储和关系数据库" class="headerlink" title="2.1 键值存储和关系数据库"></a>2.1 键值存储和关系数据库</h1><p>　　尽管关系数据库支持多种类型的查询，但几乎所有查询都可以分解为三种类型的磁盘操作：</p><p>　　1、扫描整个数据集。（未使用索引）。</p><p>　　2、点查询：通过特定的键查询索引。</p><p>　　3、范围查询：按范围查询索引。（索引已排序）。<br>数据库索引主要是关于范围查询和点查询，很容易看出范围查询只是点查询的超集。如果我们提取数据库索引的功能，那么创建一个键值存储是很简单的。但关键是，数据库系统可以建立在KV存储之上。在尝试关系数据库之前，我们将构建一个KV存储，但让我们先探索一下我们的选择。</p><h1 id="2-2-哈希表"><a href="#2-2-哈希表" class="headerlink" title="2.2 哈希表"></a>2.2 哈希表</h1><p>　　哈希表是在设计通用KV存储时首先被排除的。主要原因是排序——许多实际应用程序确实需要排序。但是，可以在专门的应用程序中使用哈希表。使用哈希表的另一个令人头疼的问题是调整大小操作。一般调整的时间复杂度是O（n），会导致磁盘空间和IO的突然增加。可以增量调整哈希表的大小，但这会增加复杂性。</p><h1 id="2-3-B-树"><a href="#2-3-B-树" class="headerlink" title="2.3 B-树"></a>2.3 B-树</h1><p>　　平衡的二叉树可以在O（log（n））中查询和更新，并且可以进行范围查询。B树大致是一个平衡的n叉树。为什么使用n叉树而不是二叉树？原因有几个：</p><p>　　1、更少的空间开销。 二叉树中的每个叶节点都是通过父节点的指针到达的，父节点也可能有一个父节点。平均而言，每个叶节点需要1~2个指针。这与B树形成对比，在B树中，叶节点中的多个数据共享一个父节点。n元树也更短。更少的空间浪费在指针上。<br>2、更快的内存速度。由于现代CPU内存缓存和其他因素，n叉树可能比二叉树更快，即使它们的大-O复杂度相同。<br>3、磁盘IO更少。<br>B树更短，这意味着更少的磁盘寻道。</p><p>　　磁盘IO的最小大小通常是内存页的大小（可能是4K）。即使你读的是更小的尺寸，操作系统也会填满整个4K页面。如果我们利用4K页面中的所有信息（通过选择至少一个页面的节点大小），这是最佳的。<br>我们将在这本书中使用B-树。但B树并不是唯一的选择。</p><h1 id="2-4-LSM树"><a href="#2-4-LSM树" class="headerlink" title="2.4 LSM树"></a>2.4 LSM树</h1><p>　　Log-structured merge-tree。以下是LSM树操作的高级概述。</p><p>　　如何查询：</p><ol><li>LSM树包含多个级别的数据。</li><li>每个级别都被排序并拆分为多个文件。</li><li>点查询从顶级开始，如果找不到关键字，则搜索将继续到下一级。</li><li>范围查询合并所有级别的结果，合并时级别越高优先级越高。</li></ol><p>　　如何更新：</p><ol><li>更新key时，key首先从顶层插入到文件中。</li><li>如果文件大小超过阈值，请将其与下一级别合并。</li><li>文件大小阈值随每个级别呈指数级增加，这意味着数据量也呈指数级增长。</li></ol><p>　　让我们分析一下这是如何工作的。</p><p>　　查询：</p><p>　　1。每个级别都是排序的，可以通过二分查找找到关键字，范围查询只是顺序文件IO。这很有效。<br>更新：</p><p>　　2、顶级文件的大小很小，所以插入到顶级只需要少量的IO。<br>3、数据最终被合并到较低级别。合并是顺序IO，这是一个优势。<br>4、更高级别更频繁地触发合并，但合并也更小。5、当将一个文件合并到较低级别时，范围相交的任何较低文件都会被合并的结果（可以是多个文件）所取代。我们可以理解为什么级别被拆分为多个文件——以减少合并的大小。<br>6、可以在后台进行合并。然而，低级别合并可能会突然导致高IO使用率，从而降低系统性能。<br>读完这本书后，读者可以尝试使用LSM树而不是B树。并比较了B树和LSM树的优缺点。</p><p>　　‍</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01.文件VS数据库</title>
    <link href="/2023/08/19/01-%E6%96%87%E4%BB%B6VS%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2023/08/19/01-%E6%96%87%E4%BB%B6VS%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>翻译自《build your own database fromscratch》, 转代码为C++</p><span id="more"></span><h1 id="01-文件VS数据库"><a href="#01-文件VS数据库" class="headerlink" title="01. 文件VS数据库"></a>01. 文件VS数据库</h1><p>　　使用B-树构建一个简单的持久键值存储。</p><p>　　本章展示了简单地将数据转储到文件的局限性以及数据库解决的问题。</p><h1 id="1-1-将数据持久化到文件"><a href="#1-1-将数据持久化到文件" class="headerlink" title="1.1 将数据持久化到文件"></a>1.1 将数据持久化到文件</h1><p>　　假设您有一些数据需要持久化到一个文件；这是一种典型的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SaveData1</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; path, <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">uint8_t</span>&gt;&amp; data)</span> </span>&#123;<br>    <span class="hljs-function">std::ofstream <span class="hljs-title">file</span><span class="hljs-params">(path, std::ios::binary | std::ios::out)</span></span>;<br><br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">is_open</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Return an error indication</span><br>    &#125;<br><br>    file.<span class="hljs-built_in">write</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(data.<span class="hljs-built_in">data</span>()), data.<span class="hljs-built_in">size</span>());<br><br>    <span class="hljs-keyword">return</span> !file.<span class="hljs-built_in">bad</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>　　这种天真的方法有一些缺点：</p><ol><li>它会在更新文件之前截断文件。如果需要同时读取该文件，该怎么办？</li><li>将数据写入文件可能不是原子的，这取决于写入的大小。并发读可能会得到不完整的数据。</li><li>数据实际何时持久化到磁盘？写入系统调用返回后，数据可能仍在操作系统的页面缓存中。当系统崩溃并重新启动时，文件的状态是什么？</li></ol><h1 id="1-2-原子重命名"><a href="#1-2-原子重命名" class="headerlink" title="1.2 原子重命名"></a>1.2 原子重命名</h1><p>　　为了解决这些问题，让我们提出一个更好的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span> <span class="hljs-comment">// For random number generation</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span>   <span class="hljs-comment">// For seeding random number generator</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span>  <span class="hljs-comment">// For renaming and removing files</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">RandomInt</span><span class="hljs-params">()</span> </span>&#123;<br>    std::<span class="hljs-built_in">srand</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(std::<span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>)));<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">rand</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SaveData2</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; path, <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">uint8_t</span>&gt;&amp; data)</span> </span>&#123;<br>    std::string tmp = path + <span class="hljs-string">&quot;.tmp.&quot;</span> + std::<span class="hljs-built_in">to_string</span>(<span class="hljs-built_in">RandomInt</span>());<br>    <span class="hljs-function">std::ofstream <span class="hljs-title">file</span><span class="hljs-params">(tmp, std::ios::binary | std::ios::out | std::ios::trunc)</span></span>;<br><br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">is_open</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Return an error indication</span><br>    &#125;<br><br>    file.<span class="hljs-built_in">write</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(data.<span class="hljs-built_in">data</span>()), data.<span class="hljs-built_in">size</span>());<br><br>    <span class="hljs-keyword">if</span> (file.<span class="hljs-built_in">bad</span>()) &#123;<br>        std::<span class="hljs-built_in">remove</span>(tmp.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    file.<span class="hljs-built_in">close</span>();<br><br>    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">rename</span>(tmp.<span class="hljs-built_in">c_str</span>(), path.<span class="hljs-built_in">c_str</span>()) != <span class="hljs-number">0</span>) &#123;<br>        std::<span class="hljs-built_in">remove</span>(tmp.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>　　这种方法稍微复杂一些，它首先将数据转储到一个临时文件，然后将临时文件重命名为目标文件。这似乎没有直接更新文件的非原子性问题——重命名操作是原子性的。如果系统在重命名前崩溃，则原始文件保持不变，应用程序同时读取文件也没有问题。然而，这仍然是有问题的，因为它无法控制数据何时持久化到磁盘，并且元数据（文件大小）可能在数据之前持久化到硬盘，从而可能在系统崩溃后损坏文件。（您可能已经注意到，一些日志文件在断电后会出现零值，这是文件损坏的迹象。）</p><h1 id="1-3-fsync"><a href="#1-3-fsync" class="headerlink" title="1.3 fsync"></a>1.3 fsync</h1><p>　　要解决这个问题，我们必须先将数据刷新到磁盘，然后再重命名它。Linux对此的系统调用是“fsync”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span> <span class="hljs-comment">// For random number generation</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span>   <span class="hljs-comment">// For seeding random number generator</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span>  <span class="hljs-comment">// For renaming and removing files</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">RandomInt</span><span class="hljs-params">()</span> </span>&#123;<br>    std::<span class="hljs-built_in">srand</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(std::<span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>)));<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">rand</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SaveData3</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; path, <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">uint8_t</span>&gt;&amp; data)</span> </span>&#123;<br>    std::string tmp = path + <span class="hljs-string">&quot;.tmp.&quot;</span> + std::<span class="hljs-built_in">to_string</span>(<span class="hljs-built_in">RandomInt</span>());<br>    <span class="hljs-function">std::ofstream <span class="hljs-title">file</span><span class="hljs-params">(tmp, std::ios::binary | std::ios::out | std::ios::trunc)</span></span>;<br><br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">is_open</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Return an error indication</span><br>    &#125;<br><br>    file.<span class="hljs-built_in">write</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(data.<span class="hljs-built_in">data</span>()), data.<span class="hljs-built_in">size</span>());<br><br>    <span class="hljs-keyword">if</span> (file.<span class="hljs-built_in">bad</span>()) &#123;<br>        std::<span class="hljs-built_in">remove</span>(tmp.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    file.<span class="hljs-built_in">flush</span>(); <span class="hljs-comment">// Flush data to disk</span><br><br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">good</span>()) &#123;<br>        std::<span class="hljs-built_in">remove</span>(tmp.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    file.<span class="hljs-built_in">close</span>();<br><br>    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">rename</span>(tmp.<span class="hljs-built_in">c_str</span>(), path.<span class="hljs-built_in">c_str</span>()) != <span class="hljs-number">0</span>) &#123;<br>        std::<span class="hljs-built_in">remove</span>(tmp.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">uint8_t</span>&gt; data = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>    std::string path = <span class="hljs-string">&quot;data.bin&quot;</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SaveData3</span>(path, data)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Data saved successfully.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to save data.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　我们完成了吗？答案是否定的。我们已经将数据刷新到磁盘，但元数据呢？我们是否也应该在包含该文件的目录上调用fsync？这个问题很复杂，这就是为什么数据库比文件更适合将数据持久化到磁盘的原因。</p><h1 id="1-4-仅追加日志"><a href="#1-4-仅追加日志" class="headerlink" title="1.4 仅追加日志"></a>1.4 仅追加日志</h1><p>　　在某些用例中，使用仅追加日志持久化数据是有意义的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function">std::ofstream <span class="hljs-title">LogCreate</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; path)</span> </span>&#123;<br>    <span class="hljs-function">std::ofstream <span class="hljs-title">file</span><span class="hljs-params">(path, std::ios::out | std::ios::app)</span></span>;<br><br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">is_open</span>()) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Failed to open or create file.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> file;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LogAppend</span><span class="hljs-params">(std::ofstream&amp; file, <span class="hljs-type">const</span> std::string&amp; line)</span> </span>&#123;<br>    file &lt;&lt; line &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">good</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    file.<span class="hljs-built_in">flush</span>(); <span class="hljs-comment">// Flush data to disk</span><br><br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">good</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string path = <span class="hljs-string">&quot;logfile.txt&quot;</span>;<br>        std::ofstream file = <span class="hljs-built_in">LogCreate</span>(path);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LogAppend</span>(file, <span class="hljs-string">&quot;This is a log line.&quot;</span>)) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Log line appended successfully.&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to append log line.&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br><br>        file.<span class="hljs-built_in">close</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>　　仅追加日志的好处在于它不修改现有数据，它是否处理重命名操作，使其更耐损坏。但是，仅靠日志是不足以建立数据库的。</p><ol><li>数据库使用额外的“索引”来高效地查询数据。现在只有暴力的方法查询一堆随机顺序的记录。</li><li>日志如何处理删除的数据？它们不可能永远增长。</li></ol><p>　　我们已经看到了一些我们必须处理的问题。让我们从下一章的索引开始。</p><p>　　‍</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction</title>
    <link href="/2023/08/19/Introduction/"/>
    <url>/2023/08/19/Introduction/</url>
    
    <content type="html"><![CDATA[<p>翻译自《build your own database fromscratch》, 转代码为C++</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h1 id="0-1-这本书是关于什么的？"><a href="#0-1-这本书是关于什么的？" class="headerlink" title="0.1 这本书是关于什么的？"></a>0.1 这本书是关于什么的？</h1><p>　　数据库不是黑盒。通过从头开始构建自己的来理解它们！本书介绍了一个最小持久性数据库实现。我们从B树开始，然后是一个简单的KV存储，最后是一个小型关系数据库。这本书关注的是重要的想法，而不是实施细节。真实世界的数据库很复杂，很难掌握。我们可以从数据库的分条版本中更快、更容易地学习。“从头开始”的方法迫使你学习得更深。尽管这本书篇幅很短，实施也很少，但它旨在涵盖三个重要主题：</p><p>　　1、持久化：如何不丢失或损坏您的数据。从崩溃中恢复。</p><p>　　2、索引：高效查询和操作数据。（B-树）。</p><p>　　3、并发：如何处理多个（大量）客户端和事务。</p><p>　　如果你想理解“数据库如何存储我的数据”或“索引为什么这么快”的话，这本书很适合你。</p><p>　　‍</p><h1 id="0-2-如何使用这本书？"><a href="#0-2-如何使用这本书？" class="headerlink" title="0.2 如何使用这本书？"></a>0.2 如何使用这本书？</h1><p>　　这本书采取了循序渐进的方法。每一步都建立在前一步的基础上，并添加了一个新的概念。本书使用Golang作为示例代码，但主题与语言无关。建议读者编写自己版本的数据库代码，而不仅仅是阅读文本。章节草案可访问官方网站：<a href="https://build-your-own.org/">https://build-your-own.org</a></p><h1 id="0-3-主题一：持久化"><a href="#0-3-主题一：持久化" class="headerlink" title="0.3 主题一：持久化"></a>0.3 主题一：持久化</h1><p>　　为什么我们需要数据库？为什么不直接将数据转储到文件中？我们的第一个主题是持久化。</p><p>　　假设您的进程在写入文件时中途崩溃，或者您失去了电源，那么文件的状态是什么？</p><ul><li>文件是否刚刚丢失最后一次写入？</li><li>或者最终得到一个写了一半的文件？</li><li>或者最终处于更加糟糕的状态？</li></ul><p>　　任何结果都是可能的。当您简单地写入文件时，不能保证您的数据能够持久保存在磁盘上，这是数据库关心的问题。数据库在意外关闭后启动时将恢复到可用状态。</p><p>　　我们可以在不使用数据库的情况下实现持久性吗？有一种方法：</p><ol><li>将整个更新后的数据集写入一个新文件。</li><li>对新文件调用fsync。</li><li>通过将新文件重命名为旧文件来覆盖旧文件，这是由文件系统保证的原子性。</li></ol><p>　　<br>只有当数据集很小时，这才是可以接受的。像SQLite这样的数据库可以进行增量更新。</p><h1 id="0-4-主题二：索引"><a href="#0-4-主题二：索引" class="headerlink" title="0.4 主题二：索引"></a>0.4 主题二：索引</h1><p>　　有两种不同类型的数据库查询：分析型（OLAP）和事务型（OLTP）。</p><ul><li>分析型（OLAP）查询通常涉及大量数据，包括聚合、分组或联接操作。</li><li>相反，事务性（OLTP）查询通常只涉及少量索引数据。最常见的查询类型是索引点查询和索引范围查询。</li></ul><p>　　请注意，正如您所知，“transactional”一词与数据库事务无关。计算机术语经常被不同的含义所淹没。本书只关注OLTP技术。虽然许多应用程序不是实时系统，但大多数面向用户的软件应该使用合理数量的资源（内存、IO）在合理（少量）的时间内做出响应。这属于OLTP类别。即使数据集很大，我们如何快速找到数据？（在O（log（n））中），这就是我们需要索引的原因。</p><p>　　如果我们忽略持久性方面，并假设数据集适合内存，那么快速找到数据就是数据结构的问题。在数据库系统中，持久存在于磁盘上以查找数据的数据结构称为“索引”。数据库索引可以大于内存。有句话说：如果你的问题符合记忆，那就是一个容易的问题。用于索引的常见数据结构包括B-树和LSM树。</p><h1 id="0-5-主题三：并发"><a href="#0-5-主题三：并发" class="headerlink" title="0.5 主题三：并发"></a>0.5 主题三：并发</h1><p>　　现代应用程序不只是按顺序执行所有操作，数据库也不一样。有不同的并发级别：</p><ul><li>读者之间的并发性。</li><li>读者和写者之间的并发性，写者是否需要对数据库进行独占访问？</li></ul><p>　　即使是基于文件的SQLite也支持一些并发性。但在一个进程中并发更容易，这就是为什么大多数数据库系统只能通过“服务器”访问的原因。在并发的情况下，应用程序通常需要以原子方式进行操作，例如读-修改-写操作。这为数据库添加了一个新概念：事务</p><p>　　‍</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网-HTTP</title>
    <link href="/2023/08/12/%E8%AE%A1%E7%BD%91-HTTP/"/>
    <url>/2023/08/12/%E8%AE%A1%E7%BD%91-HTTP/</url>
    
    <content type="html"><![CDATA[<p>总结计算机网络HTTP相关的面试题目和知识点</p><span id="more"></span><p>HTTP常见题目分类：<br>​<img src="/2023/08/12/%E8%AE%A1%E7%BD%91-HTTP/image-20230812130837-3c6gjsb.png" alt="image">​</p><h1 id="1、HTTP基本概念"><a href="#1、HTTP基本概念" class="headerlink" title="1、HTTP基本概念"></a>1、HTTP基本概念</h1><h2 id="什么是HTTP？"><a href="#什么是HTTP？" class="headerlink" title="什么是HTTP？"></a>什么是HTTP？</h2><p>　　<strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><blockquote><p>那「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议」，这种说法正确吗？</p></blockquote><p>　　这种说法是<strong>不正确</strong>的。因为也可以是「服务器&lt; – &gt;服务器」，所以采用<strong>两点之间</strong>的描述会更准确</p><h2 id="HTTP常见状态码有哪些？"><a href="#HTTP常见状态码有哪些？" class="headerlink" title="HTTP常见状态码有哪些？"></a>HTTP常见状态码有哪些？</h2><p>　　​<img src="/2023/08/12/%E8%AE%A1%E7%BD%91-HTTP/image-20230812131140-4isjrsv.png" alt="image">​</p><p>　　​<code>1xx</code>​ 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p><p>　　​<code>2xx</code>​ 类状态码表示服务器<strong>成功</strong>处理了客户端的请求</p><ul><li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code>​ 请求，服务器返回的响应头都会有 body 数据。</li><li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li><li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><p>　　​<code>3xx</code>​ 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li></ul><p>　　301 和 302 都会在响应头里使用字段 <code>Location</code>​，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><ul><li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul><p>　　​<code>4xx</code>​ 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p>　　​<code>5xx</code>​ 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思</li></ul><p>　　500记忆方法： 先问有没有这个功能 有的话通过网关代理访问  然后最后是服务器无响应</p><p>　　400系列也是一样，先确认你有没有权限能不能访问 然后再确认有没有</p><h2 id="HTTP常见字段有哪些？"><a href="#HTTP常见字段有哪些？" class="headerlink" title="HTTP常见字段有哪些？"></a>HTTP常见字段有哪些？</h2><p>　　<strong>Host字段</strong>：客户端发送请求时，用来指定服务器的域名。</p><p>　　<strong>Content-Length</strong>字段：服务器在返回数据时，会有Content-Length字段，表示本次回应的数据长度。HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题。什么是TCP拆包和粘包问题？怎么解决？</p><p>　　<strong>Connection</strong>字段：常用于客户端要求服务器使用HTTP长连接机制，以便其他请求复用。</p><p>　　<a href="https://xiaolincoding.com/network/3_tcp/tcp_http_keepalive.html#http-%E7%9A%84-keep-alive">4.15 TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？ | 小林coding (xiaolincoding.com)</a></p><p>　　<strong>Content-Type</strong>字段：用于服务器回应时，告诉客户端，本次数据是什么格式。客户端请求的时候，可以使用 <code>Accept</code>​ 字段声明自己可以接受哪些数据格式。</p><p>　　<strong>Content-Type</strong>字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。客户端在请求时，用 <code>Accept-Encoding</code>​ 字段说明自己可以接受哪些压缩方法。</p><h2 id="HTTP断点续传原理？"><a href="#HTTP断点续传原理？" class="headerlink" title="HTTP断点续传原理？"></a>HTTP断点续传原理？</h2><p>　　<a href="https://www.jianshu.com/p/012c8a4dc661">HTTP必知必会——断点续传原理 - 简书 (jianshu.com)</a></p><p>　　简单来说多了 Range和Content-Range字段，来确认续传位置 同时返回码也变为206</p><h1 id="GET和POST？"><a href="#GET和POST？" class="headerlink" title="GET和POST？"></a>GET和POST？</h1><p>　　先说明下安全和幂等的概念：</p><ul><li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li><li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li></ul><p>　　GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。</p><p>　　POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存</p><blockquote><p>RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。</p><p>另外，URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的</p></blockquote><h2 id="除了POST和GET，你还知道什么及其作用（HTTP有哪些请求方法）？"><a href="#除了POST和GET，你还知道什么及其作用（HTTP有哪些请求方法）？" class="headerlink" title="除了POST和GET，你还知道什么及其作用（HTTP有哪些请求方法）？"></a>除了POST和GET，你还知道什么及其作用（HTTP有哪些请求方法）？</h2><table><thead><tr><th align="center">请求</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">GET</td><td align="center">请求页面，并返回页面内容</td></tr><tr><td align="center">POST</td><td align="center">大多用于提交表单或者上传文件，数据包括在body中</td></tr><tr><td align="center">HEAD</td><td align="center">类似于GET请求，只不过返回的响应中没有具体的内容，用于获取包头</td></tr><tr><td align="center">PUT</td><td align="center">从客户端向服务器传送的数据取代指定文档中的内容</td></tr><tr><td align="center">DELETE</td><td align="center">请求服务器删除指定的页面</td></tr><tr><td align="center">CONNECT</td><td align="center">服务器当作跳板，让服务器代替客户端访问其他网页</td></tr><tr><td align="center">OPTIONS</td><td align="center">允许客户端查看服务器的性能</td></tr><tr><td align="center">TRACE</td><td align="center">回显服务器收到的请求，主要用于测试或者诊断</td></tr></tbody></table><h1 id="为什么HTTP是无状态的？"><a href="#为什么HTTP是无状态的？" class="headerlink" title="为什么HTTP是无状态的？"></a>为什么HTTP是无状态的？</h1><p>　　<a href="https://blog.csdn.net/mr_zhangxg/article/details/88580236">HTTP协议为什么是无状态的？无状态指的是什么_名称解释 完全无状态是什么意思_窝窝头蘸番茄酱的博客-CSDN博客</a></p><p>　　简而言之，最初http协议只是浏览静态文件，无状态足够，后面加一层就行，维持状态负担太大。</p><p>　　实现有状态：cookies，session，application</p><p>　　​<img src="/2023/08/12/%E8%AE%A1%E7%BD%91-HTTP/image-20230812135057-aq8xw72.png" alt="image">​</p><h1 id="如果浏览器禁用Cookie，如何记录HTTP状态信息？"><a href="#如果浏览器禁用Cookie，如何记录HTTP状态信息？" class="headerlink" title="如果浏览器禁用Cookie，如何记录HTTP状态信息？"></a>如果浏览器禁用Cookie，如何记录HTTP状态信息？</h1><p>　　如果浏览器禁用Cookie，如何记录HTTP状态信息？</p><p>　　一种方法是<strong>使用URL重写，把会话ID附加在HTML页面中所有的URL上</strong>，这样每次请求时会话ID都会作为URL的一部分发送回服务器。</p><p>　　另一种方法是<strong>在登录成功后将会话ID返回给前端，然后前端通过其他可用的数据持久化技术，将会话ID保存在客户端硬盘中</strong>​<a href="https://www.bing.com/ck/a?!&&p=70b3cb00ffcf2132JmltdHM9MTY5MTcxMjAwMCZpZ3VpZD0xY2RmZjg0OS1mYzI1LTY1ODQtMTVjMS1lYTEyZmQ2ZjY0YTImaW5zaWQ9NTU4NA&ptn=3&hsh=3&fclid=1cdff849-fc25-6584-15c1-ea12fd6f64a2&psq=%E5%A6%82%E6%9E%9C%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A6%81%E7%94%A8+Cookie%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BD%95+HTTP+%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF%EF%BC%9F&u=a1aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1emhlbnY1L2FydGljbGUvZGV0YWlscy8xMDQ1Mjc0MTY&ntb=1">^2^</a>，然后在后续的请求中，根据浏览器是否禁用Cookie来判断是否需要将”;jsessionid&#x3D;xxx”加入到请求的URL末尾。</p><h1 id="如果让你来设计Cookie，你会怎么实现？"><a href="#如果让你来设计Cookie，你会怎么实现？" class="headerlink" title="如果让你来设计Cookie，你会怎么实现？"></a>如果让你来设计Cookie，你会怎么实现？</h1><p>　　需要为 Cookie 设置一个有效时间</p><p>　　需要为 Cookie 设置路径</p><p>　　使用一个唯一的标识符作为 Cookie 的键，然后在服务器端保存与该标识符相关的用户信息。这样可以避免在 Cookie 中直接存储用户信息，提高安全性和效率。</p><h1 id="如果让你来设计-Session，你会怎么实现？"><a href="#如果让你来设计-Session，你会怎么实现？" class="headerlink" title="如果让你来设计 Session，你会怎么实现？"></a>如果让你来设计 Session，你会怎么实现？</h1><ul><li>用户首次访问时生成唯一ID(<code>session_id</code>​)</li><li>根据session_id作为唯一标示，生成session_id为名称的文件(储存session内容，当然也可以存到redis或者mysql中)</li><li>通过cookie下发<code>session_id</code>​到客户端</li><li>用户再次访问时会通过cookie将<code>session_id</code>​带上</li><li>服务端通过<code>session_id</code>​获取对应的session内容(文件、Cache、数据库)</li></ul><h1 id="HTTP1-0-x2F-1-1-x2F-2-x2F-3区别？"><a href="#HTTP1-0-x2F-1-1-x2F-2-x2F-3区别？" class="headerlink" title="HTTP1.0&#x2F;1.1&#x2F;2&#x2F;3区别？"></a>HTTP1.0&#x2F;1.1&#x2F;2&#x2F;3区别？</h1><p>　　​<img src="/2023/08/12/%E8%AE%A1%E7%BD%91-HTTP/image-20230812140914-jg3gwry.png" alt="image">​</p><p>　　HTTP1.0：短连接</p><p>　　HTTP1.1：长连接，管道传输   HTTP层队头阻塞</p><p>　　HTTP2：  TCP层队头阻塞</p><p>　　基于HTTPS，安全保障；</p><p>　　<strong>头部压缩</strong>（头信息表，发送头索引），<strong>二进制格式</strong>（头信息帧，数据帧），<strong>并发传输</strong>（Stream复用连接，&#x3D;&gt;Message&#x3D;&gt;frame），<strong>服务器主动推送资源</strong></p><p>　　​<img src="/2023/08/12/%E8%AE%A1%E7%BD%91-HTTP/image-20230812140602-jwsz87r.png" alt="image">​</p><p>　　客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p><p>　　HTTP3</p><p>　　改下层TCP为UDP，使用基于UDP的QUIC协议实现可靠传输。</p><p>　　QUIC特点：</p><ol><li>无队头阻塞 只会阻塞stream</li><li>更快的连接建立</li><li>连接迁移</li></ol><p>　　​<img src="/2023/08/12/%E8%AE%A1%E7%BD%91-HTTP/image-20230812141245-hutq1te.png" alt="image">​</p><blockquote><p>QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能</p></blockquote><h1 id="HTTP缓存技术？"><a href="#HTTP缓存技术？" class="headerlink" title="HTTP缓存技术？"></a>HTTP缓存技术？</h1><p>　　对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都<strong>缓存在本地</strong>，那么下次就直接读取本地的数据</p><p>　　缓存实现方式：强制缓存和协商缓存</p><p>　　强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边</p><p>　　强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：</p><ul><li>​<code>Cache-Control</code>​， 是一个相对时间；</li><li>​<code>Expires</code>​，是一个绝对时间；</li></ul><p>　　通过比较过期时间和请求资源时间来计算出资源是否过期</p><p>　　<strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。</p><p>　　​<img src="/2023/08/12/%E8%AE%A1%E7%BD%91-HTTP/image-20230812142930-7fg3bo8.png" alt="image">​</p><h1 id="HTTP特性？"><a href="#HTTP特性？" class="headerlink" title="HTTP特性？"></a>HTTP特性？</h1><p>　　HTTP最突出的优点是简单、灵活和易于扩展、应用广泛和跨平台。</p><p>　　其他的就分版本特性展开讲。</p><h1 id="HTTPS-从客户端到服务器端全流程，包括-CA-验证体系"><a href="#HTTPS-从客户端到服务器端全流程，包括-CA-验证体系" class="headerlink" title="HTTPS 从客户端到服务器端全流程，包括 CA 验证体系"></a>HTTPS 从客户端到服务器端全流程，包括 CA 验证体系</h1><p>　　HTTPS 是如何解决三个风险的？</p><ul><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li><li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li></ul><p>　　SSL&#x2F;TLS 协议基本流程：</p><ul><li>客户端向服务器索要并验证服务器的公钥。</li><li>双方协商生产「会话秘钥」。</li><li>双方采用「会话秘钥」进行加密通信。</li></ul><p>　　前两步也就是 SSL&#x2F;TLS 的建立过程，也就是 TLS 握手阶段。</p><p>　　TLS 的「握手阶段」涉及<strong>四次</strong>通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：<a href="https://xiaolincoding.com/network/2_http/https_rsa.html">RSA 算法 </a>​<a href="https://xiaolincoding.com/network/2_http/https_rsa.html"><strong>(opens new window)</strong></a>和 <a href="https://xiaolincoding.com/network/2_http/https_ecdhe.html">ECDHE 算法 </a>​<a href="https://xiaolincoding.com/network/2_http/https_ecdhe.html"><strong>(opens new window)</strong></a>。</p><h2 id="TLS-协议建立的详细流程"><a href="#TLS-协议建立的详细流程" class="headerlink" title="TLS 协议建立的详细流程"></a>TLS 协议建立的详细流程</h2><p>　　<em>1. ClientHello</em></p><p>　　首先，由客户端向服务器发起加密通信请求，也就是 <code>ClientHello</code>​ 请求。</p><p>　　在这一步，客户端主要向服务器发送以下信息：</p><p>　　（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。</p><p>　　（2）客户端生产的随机数（<code>Client Random</code>​），后面用于生成「会话秘钥」条件之一。</p><p>　　（3）客户端支持的密码套件列表，如 RSA 加密算法。</p><p>　　<em>2. SeverHello</em></p><p>　　服务器收到客户端请求后，向客户端发出响应，也就是 <code>SeverHello</code>​。服务器回应的内容有如下内容：</p><p>　　（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。</p><p>　　（2）服务器生产的随机数（<code>Server Random</code>​），也是后面用于生产「会话秘钥」条件之一。</p><p>　　（3）确认的密码套件列表，如 RSA 加密算法。</p><p>　　（4）服务器的数字证书。</p><p>　　<em>3.客户端回应</em></p><p>　　客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p><p>　　如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：</p><p>　　（1）一个随机数（<code>pre-master key</code>​）。该随机数会被服务器公钥加密。</p><p>　　（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>　　（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p><p>　　上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。</p><p>　　<strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p><p>　　<em>4. 服务器的最后回应</em></p><p>　　服务器收到客户端的第三个随机数（<code>pre-master key</code>​）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。</p><p>　　然后，向客户端发送最后的信息：</p><p>　　（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>　　（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p><p>　　至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p><p>　　‍</p><h2 id="CA验证体系"><a href="#CA验证体系" class="headerlink" title="CA验证体系"></a>CA验证体系</h2><p>　　CA 签发证书的过程：</p><ul><li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li><li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li><li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li></ul><p>　　客户端校验服务端的数字证书的过程：</p><ul><li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li><li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li><li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li></ul><p>　　HTTP数据保证完整性：TLS记录协议。</p><p>　　TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p><ul><li>TLS 握手协议即TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；</li><li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；</li></ul><p>　　TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证</p><p>　　具体过程如下：</p><ul><li>首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。</li><li>接下来，经过压缩的片段会被<strong>加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证</strong>。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</li><li>再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。</li><li>最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li></ul><p>　　记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。</p><p>　　‍</p><h1 id="知道哪些非对称密钥算法？"><a href="#知道哪些非对称密钥算法？" class="headerlink" title="知道哪些非对称密钥算法？"></a>知道哪些非对称密钥算法？</h1><p>　　<a href="https://www.jianshu.com/p/5c6a12cfdd26">非对称加密算法 (RSA、DSA、ECC、DH) - 简书 (jianshu.com)</a></p><h1 id="对称加密和非对称加密的适用场景"><a href="#对称加密和非对称加密的适用场景" class="headerlink" title="对称加密和非对称加密的适用场景"></a>对称加密和非对称加密的适用场景</h1><p>　　对称场景：加密会话</p><p>　　非对称：<strong>签名</strong>(&#x3D;&#x3D;服务端加签、客户端解签验证&#x3D;&#x3D;)、加解密</p><p>　　对称加密主要的运算是<strong>位运算</strong>，速度非常快，如果使用硬件计算，速度会更快</p><p>　　非对称加密计算一般都比较复杂，比如 RSA，它里面涉及到大数乘法、大数模等等运算，速度较慢</p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11特性</title>
    <link href="/2023/08/11/C++11%E7%89%B9%E6%80%A7/"/>
    <url>/2023/08/11/C++11%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>本篇总结 C++11 特性，参考书目为《深入理解 C++11：C++11 新特性解析与应用》</p><span id="more"></span><h1 id="其一：关键字"><a href="#其一：关键字" class="headerlink" title="其一：关键字"></a>其一：关键字</h1><h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h2><p>　　C++ 中 const 类型只在初始化后才意味着它的值应该是常量表达式，从而在运行时不能被改变。不过由于初始化依旧是动态的，这对 ROM 设备来说并不适用。这就要求在动态初始化前就将常量计算出来。为此标准增加了 constexpr，它让函数和变量可以被编译时的常量取代。</p><h3 id="使用范围："><a href="#使用范围：" class="headerlink" title="使用范围："></a>使用范围：</h3><ul><li>修饰的函数只能包括 return 语句。</li><li>修饰的函数只能引用全局不变常量。</li><li>修饰的函数只能调用其他 constexpr 修饰的函数。</li><li>函数不能为 void 类型和，并且 prefix operation（v++）不允许出现。</li></ul><p>　　对于<strong>自定义类型</strong>的数据，需要<strong>自定义常量构造函数</strong>来使其成为常量表达式值。</p><p>　　常量表达式的构造函数使用要求;</p><ul><li>函数体必须为空</li><li>初始化列表只能由常量表达式来赋值</li></ul><p>　　注意：不允许常量表达式作用于virtual的成员函数。“运行时”与“可以在编译时进行值计算”的constexpr的意义时冲突的。</p><p>　　常量表达式构造函数也可用于非常量表达式中的类型构造，不必为该类型再重写一个非常量表达式版本。</p><p>　　‍</p><h3 id="与-const-区别："><a href="#与-const-区别：" class="headerlink" title="与 const 区别："></a>与 const 区别：</h3><p>　　修饰函数的时候两者之间最基本的区别是：</p><p>　　const 修饰一个对象表示它是常量。这暗示对象一经初始化就不会再变动了，并且允许编译器使用这个特点优化程序。这也防止程序员修改了本不应该修改的对象。</p><p>　　constexpr 是修饰一个常量表达式。但请注意 constexpr 不是修饰常量表达式的唯一途径。</p><ul><li><p>const 只能用于非静态成员的函数而不是所有函数。它保证成员函数不修改任何非静态数据。</p></li><li><p>constexpr 可以用于含参和无参函数。</p></li><li><p>constexpr 函数适用于常量表达式，只有在下面的情况下编译器才会接受 constexpr 函数： </p><ul><li><ol><li>函数体必须足够简单，除了 typedef 和静态元素，只允许有 return 语句。如构造函数只能有初始化列表，typedef 和静态元素 (实际上在 C++14 标准中已经允许定义语句存在于 constexpr 函数体内了</li></ol></li><li><ol start="2"><li>参数和返回值必须是字面值类型</li></ol></li></ul></li></ul><h2 id="static-assert"><a href="#static-assert" class="headerlink" title="static_assert"></a>static_assert</h2><p>　　断言（assertion）是一种编程中常用的手段。在通常情况下，断言就是将一个返回值总是需要为真的判别式放在语句中，用于排除在设计的逻辑上不应该产生的情况。在 C++ 中，程序员也可以定义宏 NDEBUG 来禁用 assert 宏。</p><p>　　通过预处理指令 if 和 error 的配合，也可以让程序员在预处理阶段进行断言。</p><p>　　断言 assert 宏只有在程序运行时才能起作用。而#error 只在编译器预处理时才能起作用,有的时候，我们希望在<strong>编译时能做一些断言</strong>.</p><p>　　在 C++11 标准中，引入了 static_assert 断言来解决这个问题。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>　　接收两个参数，一个是断言表达式，这个表达式通常需要返回一个 bool 值；一个则是警告信息，它通常也就是一段字符串。</p><ul><li>static_assert 是编译时期的断言</li><li>static_assert 可以用于任何名字空间</li><li>static_assert 的断言表达式的结果必须是在编译时期可以计算的表达式，即必须是常量表达式。如果读者使用了变量，则会导致错误</li></ul><h2 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h2><p>　　<strong>noexcept 形如其名地，表示其修饰的函数不会抛出异常</strong></p><p>　　在 C++11 中如果 noexcept 修饰的函数抛出了异常，编译器可以选择直接调用 std::terminate()函数来终止程序的运行，这比基于异常机制的 throw()在效率上会高一些</p><p>　　虽然 noexcept 修饰的函数通过 std::terminate 的调用来结束程序的执行的方式可能会带来很多问题，比如无法保证对象的析构函数的正常调用，无法保证栈的自动释放等，但很多时候，“暴力”地终止整个程序确实是很简单有效的做法</p><p>　　C++11 默认将 delete 函数设置成 noexcept</p><p>　　C++11 标准中让类的析构函数默认也是 noexcept(true)的。</p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>　　final 关键字的作用是使<strong>派生类不可覆盖它所修饰的虚函数</strong></p><p>　　final 通常只在继承关系的“中途”终止派生类的重载中有意义</p><p>　　final&#x2F;override 也可以定义为正常变量名，只有在其出现在函数后时才是能够控制继承&#x2F;派生的关键字</p><p>　　‍</p><h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>　　<a href="https://weread.qq.com/web/reader/596325a059346c59642f910">在C++11中，标准将explicit的使用范围扩展到了自定义的类型转换操作符上，以支持所谓的“显式类型转换”</a></p><p>　　显式类型转换并没完全禁止从源类型到目标类型的转换，不过由于此时拷贝构造和非显式类型转换不被允许，那么我们通常就不能通过赋值表达式或者函数参数的方式来产生这样一个目标类型</p><p>　　‍</p><h2 id="auto类型推导"><a href="#auto类型推导" class="headerlink" title="auto类型推导"></a>auto类型推导</h2><h3 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h3><p>　　静态类型和动态类型的主要区别在于对变量进行类型检查的时间点。</p><p>　　对于所谓的<strong>静态类型，类型检查主要发生在编译阶段</strong>；而对于<strong>动态类型，类型检查主要发生在运行阶段</strong>。</p><p>　　auto声明变量的类型必须由编译器在编译时期推导而得</p><p>　　auto声明的变量必须被初始化，以使编译器能够从其初始化表达式中推导出其类型。从这个意义上来讲，auto并非一种“类型”声明，而是一个类型声明时的“占位符”，编译器在编译时期会将auto替代为变量实际的类型。</p><h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><p>　　<strong>结合volatile和const</strong></p><p>volatile和const代表了变量的两种不同的属性：易失的和常量的。在C++标准中，它们常常被一起叫作<strong>cv限制符（cv-qualifier）</strong></p><p>C++11标准规定auto可以与cv限制符一起使用，不过声明为auto的变量并<strong>不能</strong>从其初始化表达式中“带走”cv限制符</p><p>例外是引用，<strong>声明为引用的变量e、g都保持了其引用的对象相同的属性</strong></p><p>　　‍</p><p>　　用auto来声明多个变量类型时，只有第一个变量用于auto的类型推导，然后推导出来的数据类型被作用于其他的变量，所以不允许这些变量的类型不相同</p><p>　　‍</p><h3 id="不能推导的情况"><a href="#不能推导的情况" class="headerlink" title="不能推导的情况"></a>不能推导的情况</h3><ul><li>auto是不能做形参的类型的。如果程序员需要泛型的参数，还是需要求助于模板。</li><li>对于结构体来说，非静态成员变量的类型不能是auto的</li><li>声明auto z[3]这样的数组同样会被编译器禁止</li><li>实例化模板的时候使用auto作为模板参数</li></ul><p>　　‍</p><p>　　‍</p><p>　　‍</p><p>　　‍</p><p>　　‍</p><p>　　‍</p><p>　　‍</p><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><h3 id="RTTI——运行时类型识别"><a href="#RTTI——运行时类型识别" class="headerlink" title="RTTI——运行时类型识别"></a>RTTI——运行时类型识别</h3><ul><li>RTTI的机制是为每个类型产生一个type_info类型的数据，程序员可以在程序中使用typeid随时查询一个变量的类型，typeid就会返回变量相应的type_info数据</li><li>除了typeid外，RTTI还包括了C++中的dynamic_cast等特性。</li></ul><p>很多时候，运行时才确定出类型对于程序员来说为时过晚，程序员更多需要的是在编译时期确定出类型（标准库中非常常见）。而通常程序员是要使用这样的类型而不是识别该类型，因此RTTI无法满足需求</p><p>decltype的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，decltype总是以一个普通的表达式为参数，返回该表达式的类型。</p><h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><p>　　当程序员用decltype(e)来获取类型时，编译器将依序判断以下四规则：</p><ol><li>如果e是一个没有带括号的标记符表达式（id-expression）或者类成员访问表达式，那么decltype(e)就是e所命名的实体的类型。此外，如果e是一个被重载的函数，则会导致编译时错误。</li><li>否则，假设e的类型是T，如果e是一个将亡值(xvalue)，那么decltype(e)为T&amp;&amp;。</li><li>否则，假设e的类型是T，如果e是一个左值，则decltype(e)为T&amp;。</li><li>否则，假设e的类型是T，则decltype(e)为T。</li></ol><p>　　与auto类型推导时不能“带走”cv限制符不同，decltype是能够“带走”表达式的cv限制符的。不过，如果<strong>对象的定义中有const或volatile限制符，使用decltype进行推导时，其成员不会继承const或volatile限制符</strong></p><p>　　decltype从表达式推导出类型后，进行类型定义时，也会允许一些冗余的符号。比如cv限制符以及引用符号&amp;，通常情况下，如果推导出的类型已经有了这些属性，冗余的符号则会被忽略</p><p>　　<a href="https://weread.qq.com/web/reader/596325a059346c59642f910kd3d322001ad3d9446802347">深入理解C++11：C++11新特性解析与应用-Michael Wong IBM XL编译器中国开发团队-微信读书</a></p><p>　　<img src="/2023/08/11/C++11%E7%89%B9%E6%80%A7/image-20230612163638-6bn5t4v.png" alt="image"></p><p>　　综合auto decltype 和追踪返回类型</p><p>　　追踪返回类型的函数和普通函数的声明最大的区别在于返回类型的后置。</p><p>　　‍</p><h2 id="四种类型转换"><a href="#四种类型转换" class="headerlink" title="四种类型转换"></a>四种类型转换</h2><p>　　RTTI——运行时类型识别</p><p>　　为什么会有RTTI？多态需要运行时类型识别</p><p>　　缺点：破坏了抽象；由于类型不确定，程序变脆弱；程序缺乏扩展性</p><p>　　typeid操作符返回结果是名为type_info的标准库类型的对象的引用。在头文件typeinfo中定义，有两种形式：1、typeid（type） 2、typeid（expression）</p><p>　　表达式的类型是类类型且至少含有一个虚函数，typeid操作符返回表达式的动态类型，需要在运行时计算，否则返回表达式的静态类型。</p><p>　　​<code>type_info</code>​类提供了public虚析构函数，以使用户能够用其作为基类。它的默认构造函数和复制构造函数及赋值操作符都定义为private，所以不能定义或复制type_info 类型的对象。 程序中创建type_info对象的唯一方法是使用typeid操作符。 由此可见，如果把typeid看作函数的话，其应该是type_info的友元。 这具体由编译器的实现所决定，标准只要求实现为每个类型返回唯一的字符串。</p><p>　　问题：<strong>C++里面的typeid运箕符返回值是什么？</strong></p><p>　　答: 常量对象的引用。</p><p>　　如果p是基类指针，并且指向一个派生类型的对象，并且基类中有虚函数，那么<code>typeid(*p)</code>​返回p所指向的派生类类型，<code>typeid(p)</code>​返回基类类型。</p><p>　　<strong>RTTI的实现原理</strong>: 通过在虚表中放一个额外的指针，每个新类只产生一个typeinfo实例，额外指针指向typeinfo, typeid返回对它的一个引用。</p><p>　　‍</p><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>　　static_cast<type>(expression) ：把expression转换为type类型</p><p>　　使用场景：</p><ol><li>进行void*类型指针和有类型指针之间的转换</li><li>执行语言支持的基本类型转换</li><li>在继承层次中执行向下的强制转换（下行转换，不安全，没有类型检查）</li><li>子类指针或引用向上转成父类的指针或引用 （上行转换，安全）</li><li>枚举间，枚举与int float间转换</li></ol><p>　　注意：</p><ul><li>static_cast不能转换掉expression的const、volatile和_unaligned属性</li><li>编译器隐式执行任何类型转换都可以由static_cast显示完成</li><li>static_cast用于有直接或间接关系的指针或引用之间转换，没有继承关系的指针不能用此转换</li><li>static_cast效率比dynamic_cast高。大部分情况下static_cast编译时就可以确定指针移动多少偏移量，但是对于虚继承要用到虚指针确定一个到虚基类的偏移量。</li></ul><p>　　‍</p><p>　　‍</p><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>　　动态映射可以映射到中间层级，将派生类映射到任何一个基类，然后在基类之间可以互相映射</p><p>　　dynamic_cast安全性：包含类型检查，转换成功会返回目标类型指针，失败会返回NULL，相对于static_cast安全</p><p>　　工作原理：</p><p>　　type_info是C++ Standard所定义的类型描述器，放置着每个类的类型信息，而<strong>虚表</strong>中的第一个slot变指向type_info的地址。</p><p>　　derived*的类型会由编译器产生出来，b的类型则在运行时由dynamic_cast从虚表中取出。</p><p>　　dynamic_cast对比两种类型，再决定能否转化。</p><p>　　<strong>由上可知：运行时的对象信息储存在虚表中。所以要使用dynamic_cast，类中必须要有一个虚方法，否则会导致编译错误。</strong></p><p>　　‍</p><blockquote><p>dynamic_cast 运算符可以去掉 cv 属性。如果源类型和目标类型的 cv 属性不同，dynamic_cast 运算符会将 cv 属性从源类型中去掉，然后进行转换。¹²</p><p>如果源类型和目标类型的 cv 属性相同，dynamic_cast 运算符会执行与 static_cast 运算符相同的转换。³</p><p>源: 与必应的对话， 2023&#x2F;6&#x2F;21<br>(1) dynamic_cast 运算符 | Microsoft Learn. <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/dynamic-cast-operator?view=msvc-170">https://learn.microsoft.com/zh-cn/cpp/cpp/dynamic-cast-operator?view=msvc-170</a>.<br>(2) 这下可以安心使用 dynamic_cast 了：dynamic_cast 的实现 …. <a href="https://zhuanlan.zhihu.com/p/580330672">https://zhuanlan.zhihu.com/p/580330672</a>.<br>(3) C++类型转换之dynamic_cast - 知乎. <a href="https://zhuanlan.zhihu.com/p/459523323">https://zhuanlan.zhihu.com/p/459523323</a>.</p></blockquote><h3 id="static-cast与dynamic-cast"><a href="#static-cast与dynamic-cast" class="headerlink" title="static_cast与dynamic_cast"></a>static_cast与dynamic_cast</h3><ul><li>dynamic_cast可以将一个多态虚基类转换成子类或邻近兄弟类。但是static_cast不能，因为它不会对它的操作对象进行检查类型。</li><li>编译器无法预知被void<em>指针指向的内存的信息。因此，对于需要查看对象类型的dynamic_cast而言，它无法对void</em>进行转换。而static_cast在这种情况下可以做到。</li></ul><h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>　　static_cast是不能去掉const，const_cast是专门用来去掉const</p><p>　　添加const，static_cast也可以添加上const，只是不能去掉const</p><p>　　‍</p><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>　　为操作数的位模式提供较低层的重新解释。</p><p>　　最不安全，可以把指针转换一个整数，也可以把整数转换成指针</p><p>　　尽量避免使用</p><p>　　‍</p><p>　　‍</p><h2 id="“-x3D-default”与”-x3D-deleted”"><a href="#“-x3D-default”与”-x3D-deleted”" class="headerlink" title="“&#x3D;default”与”&#x3D;deleted”"></a>“&#x3D;default”与”&#x3D;deleted”</h2><p>　　C++11标准称“&#x3D; default”修饰的函数为显式缺省（explicit defaulted）函数，而称“&#x3D; delete”修饰的函数为删除（deleted）函数</p><p>　　C++11引入显式缺省和显式删除是为了增强对类默认函数的控制，让程序员能够更加精细地控制默认版本的函数。不过这并不是它们的唯一功能，而且使用上，也不仅仅局限在类的定义内。事实上，显式缺省不仅可以用于在类的定义中修饰成员函数，也可以在类定义之外修饰成员函数</p><p>　　‍</p><p>　　程序员在使用显式删除时候，应该总是避免explicit关键字修饰的函数，反之亦然。</p><p>　　‍</p><p>　　在一些情况下，我们需要对象在指定内存位置进行内存分配，并且不需要析构函数来完成一些对象级别的清理。这个时候，我们可以通过显式删除析构函数来限制自定义类型在栈上或者静态的构造</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">void</span>* p;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoStackAlloc</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>      ～<span class="hljs-built_in">NoStackAlloc</span>() = <span class="hljs-keyword">delete</span>;<br>  &#125;;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>      NoStackAlloc nsa;    <span class="hljs-comment">// 无法通过编译</span><br>      <span class="hljs-keyword">new</span> (p) <span class="hljs-built_in">NoStackAlloc</span>(); <span class="hljs-comment">// placement new, 假设p无需调用析构函数</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-comment">// 编译选项:g++ 7-2-10.cpp -std=c++11-c</span><br></code></pre></td></tr></table></figure><p>　　由于placement new构造的对象，编译器不会为其调用析构函数，因此析构函数被删除的类能够正常地构造。</p><p>　　<a href="https://zhuanlan.zhihu.com/p/228001107">placement new机制 - 知乎 (zhihu.com)</a></p><h1 id="其二：预定义宏"><a href="#其二：预定义宏" class="headerlink" title="其二：预定义宏"></a>其二：预定义宏</h1><h2 id="func"><a href="#func" class="headerlink" title="func"></a><strong>func</strong></h2><p>　　预定义标识符功能，其基本功能就是返回所在函数的名字</p><p>　　按照标准定义，编译器会隐式地在函数的定义之后定义__func__标识符。不过将__fun__标识符作为函数参数的默认值是不允许的，这是由于在参数声明时，__func__还未被定义</p><h2 id="Pragma"><a href="#Pragma" class="headerlink" title="_Pragma"></a>_Pragma</h2><p>　　类似#pragma，是用来向编译器传达语言标准以外的一些信息。</p><h3 id="使用格式："><a href="#使用格式：" class="headerlink" title="使用格式："></a>使用格式：</h3><p>　　_Pragma(字符串字面量)</p><p>　　例如 _Pragma(“once”)</p><h3 id="与预处理指令-pragma-区别："><a href="#与预处理指令-pragma-区别：" class="headerlink" title="与预处理指令#pragma 区别："></a>与预处理指令#pragma 区别：</h3><p>　　相比预处理指令#pragma，由于_Pragma 是一个操作符，因此可以用在一些宏中。</p><p>　　#pragma 则不能在宏中展开，因此从灵活性上来讲，C++11 的_Pragma 具有更大的灵活性。</p><p>　　_<em>VA_ARGS</em></p><p>　　变长参数的宏定义是指在宏定义中参数列表的最后一个参数为省略号，而预定义宏__VA_ARGS__则可以在宏定义的实现部分替换省略号所代表的字符串。</p><p>　　        #define PR(…) printf(<strong>VA_ARGS</strong>)</p><h2 id="cplusplus"><a href="#cplusplus" class="headerlink" title="__cplusplus"></a>__cplusplus</h2><p>　　‍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">// 一些代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>　　_cplusplus 这个宏通常被定义为一个整型值。</p><p>　　由于 extern “C”可以抑制 C++ 对函数名、变量名等符号（symbol）进行名称重整（name mangling)，因此编译出的 C 目标文件和 C++ 目标文件中的变量、函数名称等符号都是相同的（否则不相同），链接器可以可靠地对两种类型的目标文件进行链接。这样该做法成为了 C 与 C++ 混用头文件的典型做法。</p><h1 id="其三：基础类型"><a href="#其三：基础类型" class="headerlink" title="其三：基础类型"></a>其三：基础类型</h1><p>　　在 C++11 标准中，在将窄字符串和宽字符串进行连接时，支持 C++11 标准的编译器会将窄字符串转换成宽字符串，然后再与宽字符串进行连接。</p><p>　　在 C++11 中，标准要求 long long 整型可以在不同平台上有不同的长度，但至少有 64 位。</p><p>　　long long int lli &#x3D; -9000000000000000000LL;       </p><p>　　unsigned long long int ulli &#x3D; -9000000000000000000ULL;</p><p>　　同其他的整型一样，要了解平台上 long long 大小的方法就是查看 <climits>（或 &lt;limits. h&gt; 中的宏）</p><p>　　对于 printf 函数来说，输出有符号的 long long 类型变量可以用符号 %lld，而无符号的 unsigned long long 则可以采用 %llu。</p><p>　　C++11 中一共只定义了以下 5 种标准的有符号整型：</p><ul><li>signed char</li><li>short int</li><li>int</li><li>long int</li><li>long long int</li></ul><p>　　每一种有符号整型都有一种对应的无符号整数版本，且有符号整型与其对应的无符号整型具有相同的存储空间大小。</p><p>　　而在进行隐式的整型转换的时候，一般是按照低等级整型转换为高等级整型，有符号的转换为无符号。</p><h2 id="POD类型"><a href="#POD类型" class="headerlink" title="POD类型"></a>POD类型</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>　　<a href="https://weread.qq.com/web/reader/596325a059346c59642f910">概念解释</a></p><p>　　两个基本概念：平凡的（trivial）和标准布局的（standard layout）</p><p>平凡定义：</p><p>1、拥有默认构造函数和析构函数，也就是什么都不干</p><p>2、平凡的拷贝构造函数，基本上等同于使用memcpy进行类型构造</p><p>3、平凡的拷贝赋值运算符和移动赋值运算符</p><p>4、不包含虚函数和虚基类</p><p>　　‍</p><p>　　标准布局定义：</p><ul><li><p>所有非静态成员有相同的访问权限</p></li><li><p>在类或者结构体继承时，满足以下两种情况之一：</p><ul><li><p>派生类中有非静态成员，且只有一个仅包含静态成员的基类。</p></li><li><p>基类有非静态成员，而派生类没有非静态成员。</p><p>也就是非静态成员只要同时出现在派生类和基类间，其即不属于标准布局的</p><p>一旦非静态成员出现在多个基类中，派生类也不属于标准布局的。</p></li></ul></li><li><p>类中第一个非静态成员的类型和其基类不同 <a href="https://weread.qq.com/web/reader/596325a059346c59642f910">深入理解C++11：C++11新特性解析与应用-Michael Wong IBM XL编译器中国开发团队-微信读书</a></p></li><li><p>没有虚函数和基类</p></li><li><p>所有非静态数据成员均符合标准布局类型，基类也符合标准布局</p></li></ul><h3 id="使用好处"><a href="#使用好处" class="headerlink" title="使用好处"></a>使用好处</h3><ul><li>字节赋值，代码中我们可以安全地使用memset和memcpy对POD类型进行初始化和拷贝等操作</li><li>提供对C内存布局兼容。C++程序可以与C函数进行相互操作，因为POD类型的数据在C与C++间的操作总是安全的</li><li>保证了静态初始化的安全有效。静态初始化在很多时候能够提高程序的性能，而POD类型的对象初始化往往更加简单（比如放入目标文件的.bss段，在初始化中直接被赋0）</li></ul><p>　　‍</p><p>　　‍</p><h2 id="指针空值nullptr"><a href="#指针空值nullptr" class="headerlink" title="指针空值nullptr"></a>指针空值nullptr</h2><p>　　在C++11标准中，nullptr是一个所谓“指针空值类型”的常量。指针空值类型被命名为nullptr_t</p><ul><li>所有定义为nullptr_t类型的数据都是等价的，行为也是完全一致</li><li>nullptr_t类型数据可以隐式转换成任意一个指针类型</li><li>nullptr_t类型数据不能转换为非指针类型，即使使用reinterpret_cast<nullptr_t>()的方式也是不可以的。</li><li>nullptr_t类型数据不适用于算术运算表达式。</li><li>nullptr_t类型数据可以用于关系运算表达式，但仅能与nullptr_t类型数据或者指针类型数据进行比较，当且仅当关系运算符为&#x3D;&#x3D;、&lt;&#x3D;、&gt;&#x3D;等时返回true。</li></ul><p>　　‍</p><p>　　<strong>在把nullptr_t应用于模板中时候，我们会发现模板却只能把它作为一个普通的类型来进行推导（并不会将其视为T*指针</strong></p><p>　　<strong>要让编译器成功推导出nullptr的类型，必须做显式的类型转换</strong></p><p>　　‍</p><p>　　在C++11标准中，nullptr类型数据所占用的内存空间大小跟void*相同的</p><p>　　与(void*)0区别：</p><p>　　nullptr是一个编译时期的常量，它的名字是一个编译时期的关键字，能够为编译器所识别。</p><p>　　而(void*)0只是一个强制转换表达式，其返回的也是一个void<em>指针类型。而且最为重要的是，在C++语言中，nullptr到任何指针的转换是隐式的，而(void</em>)0则必须经过类型转换后才能使用</p><p>　　‍</p><p>　　<strong>nullptr被定义为一个右值常量，取其地址并没有意义，不过C++11标准并没有禁止声明一个nullptr的右值引用，并打印其地址</strong></p><h1 id="其四：其他特性"><a href="#其四：其他特性" class="headerlink" title="其四：其他特性"></a>其四：其他特性</h1><h2 id="快速初始化成员变量"><a href="#快速初始化成员变量" class="headerlink" title="快速初始化成员变量"></a>快速初始化成员变量</h2><p>　　在 C++98 中，支持了在类声明中使用等号“&#x3D;”加初始值的方式，来初始化类中静态成员常量。这种声明方式我们也称之为“就地”声明。</p><p>　　不过 C++98 对类中就地声明的要求却非常高。如果静态成员不满足常量性，则不可以就地声明，而且即使常量的静态成员也只能是整型或者枚举型才能就地初始化。而非静态成员变量的初始化则必须在构造函数中进行。</p><p>　　​<img src="/2023/08/11/C++11%E7%89%B9%E6%80%A7/net-img-312u03b7cd32b86a65cd65975ef373caded5-20230612152703-natdmtv.png">​</p><ul><li>在 C++11 中，标准允许非静态成员变量的初始化有多种形式。具体而言，除了初始化列表外，在 C++11 中，标准还允许使用等号&#x3D;或者花括号{}进行就地的非静态成员变量初始化。</li><li>初始化列表的效果总是优先于就地初始化</li><li>对于非常量的静态成员变量，C++11 则与 C++98 保持了一致。程序员还是需要到头文件以外去定义它，这会保证编译时，类静态成员的定义最后只存在于一个目标文件中。</li></ul><p>　　使用列表初始化的一个最大优势是防止类型收窄 <a href="https://weread.qq.com/web/reader/596325a059346c59642f910">深入理解C++11：C++11新特性解析与应用-Michael Wong IBM XL编译器中国开发团队-微信读书</a></p><h2 id="扩展的-friend-语法"><a href="#扩展的-friend-语法" class="headerlink" title="扩展的 friend 语法"></a>扩展的 friend 语法</h2><p>　　在 C++11 中，声明一个类为另外一个类的友元时，不再需要使用 class 关键字</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">P</span>;<br><span class="hljs-keyword">template</span>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;<br>    <span class="hljs-keyword">friend</span> T;<br>&#125;;<br>People PP;    <span class="hljs-comment">// 类型P在这里是People类型的友元</span><br>People Pi; <span class="hljs-comment">// 对于int类型模板参数，友元声明被忽略</span><br><span class="hljs-comment">// 编译选项:g++ -std=c++11 2-9-2.cpp</span><br><br></code></pre></td></tr></table></figure><p>　　内置类型 int 作为模板参数的时候，People<int> 会被实例化为一个普通的没有友元定义的类型</p><p>　　这样一来，我们就可以在模板实例化时才确定一个模板类是否有友元，以及谁是这个模板类的友元</p><h2 id="模板函数的默认模板参数"><a href="#模板函数的默认模板参数" class="headerlink" title="模板函数的默认模板参数"></a>模板函数的默认模板参数</h2><p>　　与类模板有些不同的是，在为多个默认模板参数声明指定默认值的时候，程序员必须遵照“从右往左”的规则进行指定。而这个条件对函数模板来说并不是必须的</p><p>　　模板函数的默认形参不是模板参数推导的依据。函数模板参数的选择，总是由函数的实参推导而来的</p><h2 id="外部模板"><a href="#外部模板" class="headerlink" title="外部模板"></a>外部模板</h2><p>　　部模板的使用实际依赖于 C++98 中一个已有的特性，即显式实例化（Explicit Instantiation）。显式实例化的语法很简单，比如对于以下模板：</p><p>　　template <typename T> void fun(T) {}</p><p>　　 我们只需要声明</p><p>　　template void fun(int);</p><p>　　这就可以使编译器在本编译单元中实例化出一个 fun<int>(int)版本的函数（这种做法也被称为强制实例化</p><p>　　可以通过：        extern template void fun<int>(int);这样的语法完成一个外部模板的声明。</p><p>　　外部模板声明不能用于一个静态函数（即文件域函数），但可以用于类静态成员函数（这一点是显而易见的，因为静态函数没有外部链接属性，不可能在本编译单元之外出现）。</p><p>　　‍</p><h2 id="模板的别名"><a href="#模板的别名" class="headerlink" title="模板的别名"></a>模板的别名</h2><p>　　在C++11中，定义别名已经不再是typedef的专属能力，使用using同样也可以定义类型的别名，而且从语言能力上看，using丝毫不比typedef逊色</p><p>　　‍</p><p>　　‍</p><h2 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h2><p>　　假设基类有很多构造函数，派生类只是修改了一点代码，但是如果想要拥有同样多的构造函数的话需要一一”透传“各个接口。</p><p>　　如果派生类要使用基类的成员函数的话，可以通过 using 声明（using-declaration）来完成。</p><p>　　子类可以通过使用 using 声明来声明继承基类的构造函数。</p><p>　　​<img src="/2023/08/11/C++11%E7%89%B9%E6%80%A7/net-img-312uba93a630c652d565c5f8d62c3a6385ae-20230612152703-nd5aexr.png">​</p><ul><li>C++11 标准继承构造函数被设计为跟派生类中的各种类默认函数（默认构造、析构、拷贝构造等）一样，是隐式声明的。这意味着如果一个继承构造函数不被相关代码使用，编译器不会为其产生真正的函数代码。这无疑比“透传”方案总是生成派生类的各种构造函数更加节省目标代码空间。</li><li>对于继承构造函数来讲，参数的默认值是不会被继承的</li><li>如果基类的构造函数被声明为私有成员函数，或者派生类是从基类中虚继承的，那么就不能够在派生类中声明继承构造函数</li><li>如果一旦使用了继承构造函数，编译器就不会再为派生类生成默认构造函数了</li></ul><h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><ul><li>在 C++11 中，所谓委派构造，就是指委派函数将构造的任务委派给了目标构造函数来完成这样一种类构造的方式，C++11 中的委派构造函数是在构造函数的初始化列表位置进行构造的、委派的。</li><li>在 C++ 中，构造函数不能同时“委派”和使用初始化列表，所以如果委派构造函数要给变量赋初值，初始化代码必须放在函数体中。</li><li>在使用委派构造函数的时候，我们也建议程序员抽象出最为“通用”的行为做目标构造函数</li><li>在委托构造的链状关系中，有一点程序员必须注意，就是不能形成委托环</li><li>委派构造的一个很实际的应用就是使用构造模板函数产生目标构造函数，委托构造使得构造函数的泛型编程也成为了一种可能。</li><li>此外，在异常处理方面，如果在委派构造函数中使用 try 的话，那么从目标构造函数中产生的异常，都可以在委派构造函数中被捕捉到。</li></ul><h2 id="右值引用：移动语义和完美转发"><a href="#右值引用：移动语义和完美转发" class="headerlink" title="右值引用：移动语义和完美转发"></a>右值引用：移动语义和完美转发</h2><p>　　编写 C++ 程序有一条必须注意的规则，就是在类中包含了一个指针成员的话，那么就要特别小心拷贝构造函数的编写，因为一不小心，就会出现内存泄露。</p><p>　　传递临时对象，临时对象将在语句结束后被析构，会释放堆内存资源，而在拷贝构造的时候又会被分配堆内存。这样一去一来没有意义，所以要在临时对象传递来后构造新的变量的时候不重新分配内存，也就是偷走临时变量中的资源。</p><p>　　在 C++11 中，这样的“偷走”临时变量中资源的构造函数，就被称为“移动构造函数”。而这样的“偷”的行为，则称之为“移动语义”（move semantics）。</p><h3 id="右值概念"><a href="#右值概念" class="headerlink" title="右值概念"></a>右值概念</h3><p>　　可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值。</p><p>　　更为细致地，在 C++11 中，右值是由两个概念构成的，一个是将亡值（xvalue，eXpiring Value），另一个则是纯右值（prvalue，Pure Rvalue）。</p><p>　　纯右值就是 C++98 标准中右值的概念，讲的是用于辨识临时变量和一些不跟对象关联的值。比如非引用返回的函数返回的临时变量值（我们在前面多次提到了）就是一个纯右值。一些运算表达式，比如 1 + 3 产生的临时变量值，也是纯右值。而不跟对象关联的字面量值，比如：2、‘c’、true，也是纯右值。此外，类型转换函数的返回值、lambda 表达式（见 7.3 节）等，也都是右值。</p><p>　　将亡值则是 C++11 新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用 T&amp;&amp;的函数返回值、std::move 的返回值（稍后解释），或者转换为 T&amp;&amp;的类型转换函数的返回值（稍后解释</p><p>　　无论是声明一个左值引用还是右值引用，都必须立即进行初始化。</p><p>　　在常量左值引用在 C++98 标准中开始就是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。而且在使用右值对其初始化的时候，常量左值引用还可以像右值引用一样将右值的生命期延长。不过相比于右值引用所引用的右值，常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。</p><h3 id="C-11-引用类型及其可以引用的值类型"><a href="#C-11-引用类型及其可以引用的值类型" class="headerlink" title="C++11 引用类型及其可以引用的值类型"></a>C++11 引用类型及其可以引用的值类型</h3><p>　　​<img src="/2023/08/11/C++11%E7%89%B9%E6%80%A7/net-img-312u57e8701a86e963412246d91390d845a4-20230612152703-nb0j3fj.png">​</p><p>　　标准库在 <type_traits> 头文件中提供了 3 个模板类：is_rvalue_reference、is_lvalue_reference、is_reference，可供我们进行判断。</p><h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><ul><li>std::move 并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用</li><li>被转化的左值，其生命期并没有随着左右值的转化而改变</li><li>因此需要自己确定该不该用，我们需要转换成为右值引用的是一个确实生命期即将结束的对象</li><li>为了保证移动语义的传递，程序员在编写移动构造函数的时候，应该总是记得使用 std::move 转换拥有形如堆内存、文件句柄等资源的成员为右值，这样一来，如果成员支持移动构造的话，就可以实现其移动语义。</li></ul><p>　　移动语义，还有一个比较典型的应用是可以实现高性能的置换（swap）函数</p><p>　　​<img src="/2023/08/11/C++11%E7%89%B9%E6%80%A7/net-img-312ua29d02df1aecea3eed8d2fbd49c82875-20230612152703-j0f3fg0.png">​</p><p>　　如果 T 是可以移动的，那么移动构造和移动赋值将会被用于这个置换。代码中，a 先将自己的资源交给 tmp，随后 b 再将资源交给 a，tmp 随后又将从 a 中得到的资源交给 b，从而完成了一个置换动作。整个过程，代码都只会按照移动语义进行指针交换，不会有资源的释放与申请。而如果 T 不可移动却是可拷贝的，那么拷贝语义会被用来进行置换。这就跟普通的置换语句是相同的了</p><p>　　为了避免移动语义还没完成就抛出异常，导致指针成为悬空指针可以用一个 std::move_if_noexcept 的模板函数替代 move 函数。该函数在类的移动构造函数没有 noexcept 关键字修饰时返回一个左值引用从而使变量可以使用拷贝语义，而在类的移动构造函数有 noexcept 关键字时，返回一个右值引用，从而使变量可以使用移动语义</p><h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><p>　　完美转发（perfect forwarding），是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另外一个函数</p><p>　　C++11是通过引入一条所谓“引用折叠”（reference collapsing）的新语言规则，并结合新的模板推导规则来完成完美转发</p><p>　　<img src="/2023/08/11/C++11%E7%89%B9%E6%80%A7/image-20230612154151-ugstjud.png" alt="image"></p><p>　　完美转发的一个作用就是做包装函数，这是一个很方便的功能</p><p>　　‍</p><h2 id="非受限联合体（Union）"><a href="#非受限联合体（Union）" class="headerlink" title="非受限联合体（Union）"></a>非受限联合体（Union）</h2><p>　　标准规定，任何非引用类型都可以成为联合体的数据成员，这样的联合体即所谓的非受限联合体（Unrestricted Union）</p><p>　　匿名非受限联合体可以运用于类的声明中，这样的类也被称为“枚举式的类”（union-like class）</p><p>　　<a href="https://weread.qq.com/web/reader/596325a059346c59642f910">深入理解C++11：C++11新特性解析与应用-Michael Wong IBM XL编译器中国开发团队-微信读书</a></p><p>　　‍</p><h2 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h2><p>　　for循环后的括号由冒号“：”分为两部分，第一部分是范围内用于迭代的变量，第二部分则表示将被迭代的范围</p><p>　　基于范围的循环使用在标准库的容器中时，如果使用auto来声明迭代的对象的话，那么这个对象不会是迭代器对象</p><p>　　<img src="/2023/08/11/C++11%E7%89%B9%E6%80%A7/image-20230612163941-3jvmz8d.png" alt="image"></p><p>　　‍</p><h2 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h2><p>　　非强类型枚举：</p><p>　　C&#x2F;C++的enum有个很“奇怪”的设定，就是具名（有名字）的enum类型的名字，以及enum的成员的名字都是全局可见的。这与C++中具名的namespace、class&#x2F;struct及union必须通过“名字::成员名”的方式访问相比是格格不入的。</p><p>　　另外，由于C中枚举被设计为常量数值的“别名”的本性，所以枚举的成员总是可以被隐式地转换为整型，很多时候，这也是不安全的。</p><p>　　<strong>非强类型作用域，允许隐式转换为整型，占用存储空间及符号性不确定，都是枚举类的缺点</strong>。</p><p>　　针对这些缺点，新标准C++11引入了一种新的枚举类型，即<strong>“枚举类”，又称“强类型枚举”</strong> (strong-typed enum)。</p><p>　　声明强类型枚举非常简单，只需要在enum后加上关键字class。</p><p>　　强类型枚举具有以下几点优势：</p><p>　　<strong>强作用域，强类型枚举成员的名称不会被输出到其父作用域空间</strong>。</p><p>　　<strong>转换限制，强类型枚举成员的值不可以与整型隐式地相互转换</strong>。</p><p>　　可以指定底层类型。强类型枚举默认的底层类型为int,但也可以显式地指定底层类型，具体方法为在枚举名称后面加上“：type”，其中type可以是除wchar_t以外的任何整型</p><p>　　如</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Type: <span class="hljs-symbol">char</span></span> &#123; General, Light, Medium, Heavy &#125;;<br></code></pre></td></tr></table></figure><p>　　使用enum class的时候，应该总是为enum class提供一个名字,匿名的什么都做不了</p><p>　　‍</p><h3 id="对原来枚举的改进"><a href="#对原来枚举的改进" class="headerlink" title="对原来枚举的改进"></a>对原来枚举的改进</h3><p>　　也可以指定底层数据类型</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">Type</span>: <span class="hljs-built_in">char</span> &#123; General, Light, Medium, Heavy &#125;;<br></code></pre></td></tr></table></figure><p>　　枚举成员的名字除了会自动输出到父作用域，也可以在枚举类型定义的作用域内有效</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Type</span> &#123; General, Light, Medium, Heavy &#125;;<br>Type t1 = General;<br>Type t2 = Type::General;<br></code></pre></td></tr></table></figure><p>　　‍</p><h2 id="变长模板"><a href="#变长模板" class="headerlink" title="变长模板"></a>变长模板</h2><p>　　语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Elements&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">tuple</span>;<br></code></pre></td></tr></table></figure><p>　　可以看到，我们在标示符Elements之前的使用了省略号（三个“点”）来表示该参数是变长的。</p><p>　　在C++11中，Elements被称作是一个“模板参数包”（template parameter pack）。这是一种新的模板参数类型。有了这样的参数包，类模板tuple就可以接受任意多个参数作为模板参数。</p><p>　　‍</p><p>　　通过定义递归的模板偏特化定义，我们可以使得模板参数包在实例化时能够层层展开，直到参数包中的参数逐渐耗尽或到达某个数量的边界为止</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Elements&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">tuple</span>;     <span class="hljs-comment">// 变长模板的声明</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Head, <span class="hljs-keyword">typename</span>... Tail&gt;        <span class="hljs-comment">// 递归的偏特化定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">tuple</span>&lt;Head, Tail...&gt; : <span class="hljs-keyword">private</span> tuple&lt;Tail...&gt; &#123;<br>      Head head;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">tuple</span>&lt;&gt; &#123;&#125;;                             <span class="hljs-comment">// 边界条件</span><br><span class="hljs-comment">// 编译选项:g++ -std=c++11 6-2-2.cpp</span><br></code></pre></td></tr></table></figure><p>　　在C++11中，标准要求函数参数包必须唯一，且是函数的最后一个参数（模板参数包没有这样的要求）。</p><p>　　‍</p><h2 id="退出函数"><a href="#退出函数" class="headerlink" title="退出函数"></a>退出函数</h2><ol><li>terminate</li><li>abort</li><li>exit</li></ol><p>　　直观地讲，只要C++程序中出现了非程序员预期的行为，都有可能导致terminate的调用。而terminate函数在默认情况下，是去调用abort函数的。不过用户可以通过set_terminate函数来改变默认的行为。因此，可以认为在C++程序的层面，termiante就是“终止”。</p><p>　　C中（头文件<cstdlib>）的abort则更加低层。abort函数不会调用任何的析构函数，默认情况下，它会向合乎POSIX标准的系统抛出一个信号（signal）：SIGABRT。如果程序员为信号设定一个信号处理程序的话（signal handler），那么操作系统将默认地释放进程所有的资源，从而终止程序</p><p>　　exit函数会正常调用自动变量的析构函数，并且还会调用atexit注册的函数。这跟main函数结束时的清理工作是一样的。在程序退出时（调用ANSI C定义的exit函数的时候），所有注册的函数都被调用，值得注意的是，注册的函数被调用的次序与其注册顺序相反，这多少跟析构函数的执行与其声明的顺序相反是一致的</p><p>　　‍</p><p>　　但是，一一调用析构太慢，操作系统统一回收更快</p><p>　　多线程下，exit可能会阻塞，无法退出</p><p>　　C++11引入了<strong>quick_exit</strong></p><p>　　该函数并不执行析构函数而只是使程序终止。与abort不同的是，abort的结果通常是异常退出（可能系统还会进行coredump等以辅助程序员进行问题分析），而quick_exit与exit同属于正常退出。此外，使用at_quick_exit注册的函数也可以在quick_exit的时候被调用。这样一来，我们同样可以像exit一样做一些清理的工作（这与很多平台上使用_exit函数直接正常退出还是有不同的）。在C++11标准中，at_quick_exit和at_exit一样，标准要求编译器至少支持32个注册函数的调用。</p><p>　　‍</p><h1 id="其五：智能指针"><a href="#其五：智能指针" class="headerlink" title="其五：智能指针"></a>其五：智能指针</h1><p>　　<a href="https://zhuanlan.zhihu.com/p/436290273">C++ 智能指针最佳实践&amp;源码分析 - 知乎 (zhihu.com)</a></p><p>　　​<code>std::weak_ptr</code>​的内部实现主要涉及以下几个关键点：</p><ol><li>弱引用计数（weak reference count）：<code>std::weak_ptr</code>​内部维护了一个弱引用计数，用于记录有多少个<code>std::weak_ptr</code>​对象共享同一个底层对象。</li><li>引用计数（reference count）：底层对象使用<code>std::shared_ptr</code>​来管理引用计数，记录有多少个<code>std::shared_ptr</code>​对象共享该底层对象。</li><li>控制块（control block）：<code>std::shared_ptr</code>​和<code>std::weak_ptr</code>​共享一个控制块，其中包含了指向底层对象的指针以及引用计数信息。</li><li>弱引用指针（weak reference pointer）：<code>std::weak_ptr</code>​内部包含了一个指向控制块的指针，通过该指针可以访问底层对象。</li></ol><p>　　当一个<code>std::shared_ptr</code>​对象创建时，它会分配一个控制块并将指向底层对象的指针保存在该控制块中。同时，引用计数和弱引用计数都初始化为1。</p><p>　　当另一个<code>std::shared_ptr</code>​对象通过拷贝构造或拷贝赋值创建时，它会与原有的<code>std::shared_ptr</code>​对象共享同一个控制块，并将引用计数加1。</p><p>　　当一个<code>std::shared_ptr</code>​对象被销毁或重置时，它会将引用计数减1。如果减1后引用计数为0，表示没有任何<code>std::shared_ptr</code>​对象引用底层对象，此时会释放底层对象并销毁控制块。</p><p>　　当一个<code>std::weak_ptr</code>​对象通过拷贝构造或拷贝赋值创建时，它会与原有的<code>std::weak_ptr</code>​对象共享同一个控制块，并将弱引用计数加1。</p><p>　　​<code>std::weak_ptr</code>​对象可以通过<code>lock()</code>​方法获取一个有效的<code>std::shared_ptr</code>​对象。该方法会检查控制块是否存在（即弱引用计数是否大于0），如果存在则返回一个指向底层对象的<code>std::shared_ptr</code>​对象，同时将引用计数加1。如果控制块不存在，则返回一个空的<code>std::shared_ptr</code>​对象。</p><p>　　当一个<code>std::shared_ptr</code>​对象被销毁或重置时，它会将引用计数减1。如果减1后引用计数为0，表示没有任何<code>std::shared_ptr</code>​对象引用底层对象，此时会释放底层对象并销毁控制块。同时，会将弱引用计数减1。当弱引用计数也减为0时，控制块会被销毁，此时无法通过<code>lock()</code>​方法获取有效的<code>std::shared_ptr</code>​对象。</p><p>　　通过上述机制，<code>std::weak_ptr</code>​可以安全地观测被<code>std::shared_ptr</code>​管理的对象，而不会增加其引用计数。这在解决循环引用问题、避免内存泄漏等场景中非常有用。</p><p>　　​<code>std::weak_ptr</code>​提供了两个主要的成员函数：<code>lock()</code>​和<code>expired()</code>​。</p><ol><li><p>​<code>lock()</code>​函数：</p><ul><li>​<code>lock()</code>​函数用于获取<code>std::weak_ptr</code>​指向的对象的强引用（<code>std::shared_ptr</code>​），如果对象存在的话。</li><li>当你调用<code>lock()</code>​函数时，它会检查<code>std::weak_ptr</code>​是否指向一个有效的对象。如果指向的对象仍然存在，则<code>lock()</code>​函数会返回一个有效的<code>std::shared_ptr</code>​，它可以被用于访问和操作该对象。</li><li>如果<code>std::weak_ptr</code>​已经过期（指向的对象已经被释放），则<code>lock()</code>​函数会返回一个空的<code>std::shared_ptr</code>​。</li><li>使用<code>lock()</code>​函数之前，建议先使用<code>expired()</code>​函数进行检查，以避免抛出异常。</li></ul></li><li><p>​<code>expired()</code>​函数：</p><ul><li>​<code>expired()</code>​函数用于检查<code>std::weak_ptr</code>​指向的对象是否已经被释放（过期）。</li><li>当你调用<code>expired()</code>​函数时，它会返回一个布尔值。如果返回<code>true</code>​，表示<code>std::weak_ptr</code>​已经过期，指向的对象已经被释放；如果返回<code>false</code>​，表示<code>std::weak_ptr</code>​仍然有效，指向的对象仍然存在。</li></ul></li></ol><p>　　综上所述，<code>lock()</code>​函数用于获取指向对象的强引用（<code>std::shared_ptr</code>​），而<code>expired()</code>​函数用于检查<code>std::weak_ptr</code>​是否已经过期。通常，你可以先使用<code>expired()</code>​函数进行检查，然后再决定是否调用<code>lock()</code>​函数获取对象的强引用。这样可以确保在访问对象之前，先判断对象是否仍然存在，避免出现悬空指针的情况。</p><p>　　‍</p><h1 id="其六：C-并行编程"><a href="#其六：C-并行编程" class="headerlink" title="其六：C++并行编程"></a>其六：C++并行编程</h1><p>　　常见的并行编程有多种模型，如共享内存、多线程、消息传递等。</p><p>　　多线程模型允许同一时间有多个处理器单元执行统一进程中的代码部分，而通过分离的栈空间和共享的数据区及堆栈空间，线程可以拥有独立的执行状态以及进行快速的数据共享。</p><p>　　C&#x2F;C++对线程的支持，一个最为重要的部分，就是在原子操作中引入了<strong>原子类型</strong>的概念。</p><p>　　通过#include<cstdatomic>头文件来使用对应于内置类型的原子类型定义。定义表如下：</p><p>　　​<img src="/2023/08/11/C++11%E7%89%B9%E6%80%A7/image-20230613165247-0v5oihw.png" alt="image">​</p><p>　　‍</p><p>　　不过更普遍地，可以使用atomic类模板。</p><p>　　在C++11中，原子类型只能从其模板参数类型中进行构造，标准不允许原子类型进行拷贝构造、移动构造，以及使用operator&#x3D;等，以防止发生意外</p><p>　　‍</p><h3 id="内存模型，顺序一致性"><a href="#内存模型，顺序一致性" class="headerlink" title="内存模型，顺序一致性"></a>内存模型，顺序一致性</h3><p>　　默认情况下，在C++11中的原子类型的变量在线程中总是保持着顺序执行的特性</p><p>　　称这样的特性为“顺序一致”的，即代码在线程中运行的顺序与程序员看到的代码顺序一致，a的赋值语句永远发生于b的赋值语句之前</p><p>　　为了解除性能约束，使得编译器可以优化指令执行，采用<strong>memory_order：让程序员指定内存顺序</strong></p><p>　　C++11中，标准一共定义了7种memory_order的枚举值：</p><p>　　​<img src="/2023/08/11/C++11%E7%89%B9%E6%80%A7/image-20230613170539-3z8h1p1.png" alt="image">​</p><p>　　由于memory_order_release和memory_order_acquire常常结合使用，我们也称这种内存顺序为release-acquire内存顺序。</p><p>　　顺序一致、松散、release-acquire和release-consume通常是最为典型的4种内存顺序</p><p>　　‍</p><h3 id="线程局部存储"><a href="#线程局部存储" class="headerlink" title="线程局部存储"></a>线程局部存储</h3><p>　　线程局部存储（TLS, thread local storage）是一个已有的概念。简单地说，所谓线程局部存储变量，就是拥有线程生命期及线程可见性的变量。</p><p>　　全局、静态变量在多线程模型下总是在线程间共享的，但是有时候不希望这样。</p><p>　　例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> errorCode = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">MaySetErr</span><span class="hljs-params">(<span class="hljs-type">void</span> * input)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*)input == <span class="hljs-number">1</span>)<br>        errorCode = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*)input == <span class="hljs-number">2</span>)<br>        errorCode = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span><br>        errorCode = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> input_a = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> input_b = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">pthread_t</span> thread1, thread2;<br>    <span class="hljs-built_in">pthread_create</span>(&amp;thread1, <span class="hljs-literal">NULL</span>, &amp;MaySetErr, &amp;input_a);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;thread2, <span class="hljs-literal">NULL</span>, &amp;MaySetErr, &amp;input_b);<br>    <span class="hljs-built_in">pthread_join</span>(thread2, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(thread1, <span class="hljs-literal">NULL</span>);<br>    cout &lt;&lt; errorCode &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 编译选项:g++ 6-4-1.cpp -lpthread</span><br></code></pre></td></tr></table></figure><p>　　当两个线程运行函数的时候，最终的errorCode的值是不确定的。一旦errno在线程间共享，一些程序中的错误将会隐藏。</p><p>　　解决方法：线程局部存储</p><p>　　语法：通过thread_local修饰符声明变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> <span class="hljs-keyword">thread_local</span> errCode;<br></code></pre></td></tr></table></figure><p>　　一旦声明一个变量为thread_local，其值将在线程开始时被初始化，而在线程结束时，该值也将不再有效。对于thread_local变量地址取值（&amp;），也只可以获得当前线程中的TLS变量的地址值</p><p>　　‍</p><p>　　‍</p><h1 id="其七：lambda函数"><a href="#其七：lambda函数" class="headerlink" title="其七：lambda函数"></a>其七：lambda函数</h1><h2 id="语法定义："><a href="#语法定义：" class="headerlink" title="语法定义："></a>语法定义：</h2><p>　　通常情况下，lambda函数的语法定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture](parameters) <span class="hljs-keyword">mutable</span>-&gt;<span class="hljs-keyword">return</span>-type &#123;statement&#125;<br></code></pre></td></tr></table></figure><p>　　其中，</p><p>　　❑ [capture]：捕捉列表。捕捉列表总是出现在lambda函数的开始处。事实上，[]是lambda引出符。编译器根据该引出符判断接下来的代码是否是lambda函数。捕捉列表能够捕捉上下文中的变量以供lambda函数使用</p><p>　　❑ (parameters)：参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号()一起<strong>省略</strong>。</p><p>　　❑ mutable：mutable修饰符。默认情况下，lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。</p><p>　　❑ -&gt;return-type：返回类型。用追踪返回类型形式声明函数的返回类型。出于方便，不需要返回值的时候也可以连同符号-&gt;一起<strong>省略</strong>。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。</p><p>　　❑ {statement}：函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。</p><p>　　最简单的lambda函数 []{}</p><p>　　‍</p><p>　　语法上，捕捉列表由多个捕捉项组成，并以逗号分割。捕捉列表有如下几种形式：</p><p>　　❑ [var]表示值传递方式捕捉变量var。</p><p>　　❑ [&#x3D;]表示值传递方式捕捉所有父作用域的变量（包括this）。</p><p>　　❑ [&amp;var]表示引用传递捕捉变量var。</p><p>　　❑ [&amp;]表示引用传递捕捉所有父作用域的变量（包括this）。</p><p>　　❑ [this]表示值传递方式捕捉当前的this指针。</p><p>　　注意 父作用域：enclosing scope，这里指的是包含lambda函数的语句块</p><p>　　捕捉列表可以任意组合，但是要避免重复</p><p>　　‍</p><p>　　在块作用域中的lambda函数仅能捕捉父作用域中的自动变量，捕捉任何非此作用域或者是非自动变量（如静态变量等）都会导致编译器报错</p><p>　　‍</p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网-TCP</title>
    <link href="/2023/08/11/%E8%AE%A1%E7%BD%91-TCP/"/>
    <url>/2023/08/11/%E8%AE%A1%E7%BD%91-TCP/</url>
    
    <content type="html"><![CDATA[<p>总结计算机网络TCP相关的面试题目和知识点</p><span id="more"></span><h1 id="1、TCP三次握手"><a href="#1、TCP三次握手" class="headerlink" title="1、TCP三次握手"></a>1、TCP三次握手</h1><h2 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h2><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-TCP/net-img-312wbaeda2199e49be9df8115889ea788e4f-20230811162629-mffovm8.png"></p><p>　　Tip：<strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong>，这也是面试常问的题。</p><p>　　TCP 的连接状态查看，在 Linux 可以通过 <code>netstat -napt</code> 命令查看。</p><h2 id="为什么要是三次，2次呢，四次呢"><a href="#为什么要是三次，2次呢，四次呢" class="headerlink" title="为什么要是三次，2次呢，四次呢"></a>为什么要是三次，2次呢，四次呢</h2><ul><li><strong>三次握手才可以阻止重复历史连接的初始化（主要原因）：在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费</strong></li><li>三次握手才可以同步双方的初始序列号</li><li>三次握手才可以避免资源浪费</li></ul><blockquote><p>两次握手不是也可以根据上下文信息丢弃 syn 历史报文吗？</p></blockquote><blockquote><p>我这里两次握手是假设「由于没有第三次握手，服务端不清楚客户端是否收到了自己发送的建立连接的 <code>ACK</code> 确认报文，所以每收到一个 <code>SYN</code> 就只能先主动建立一个连接」这个场景</p></blockquote><h2 id="为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h2><p>　　主要原因有两个方面：</p><ul><li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li><li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</li></ul><h2 id="IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h2><p>　　因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传</p><p>　　<strong>当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">MTU：一个网络包的最大长度，以太网中一般为 1500 字节；<br>MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度<br></code></pre></td></tr></table></figure><h2 id="在建立连接的不同阶段握手丢失，会发生什么情况？"><a href="#在建立连接的不同阶段握手丢失，会发生什么情况？" class="headerlink" title="在建立连接的不同阶段握手丢失，会发生什么情况？"></a>在建立连接的不同阶段握手丢失，会发生什么情况？</h2><table><thead><tr><th>阶段</th><th>后果</th></tr></thead><tbody><tr><td>第一次握手丢失</td><td>超时重传SYN报文，序列号一样，每次超时的时间是上一次的 2 倍，5次后等待32秒，无反应则断开连接</td></tr><tr><td>第二次握手丢失</td><td>客户端和服务端都会重传，SYN和SYN-ACK</td></tr><tr><td>第三次握手丢失</td><td>服务端重传SYN-ACK</td></tr></tbody></table><p>　　注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p><h2 id="如何防范TCP洪泛攻击？"><a href="#如何防范TCP洪泛攻击？" class="headerlink" title="如何防范TCP洪泛攻击？"></a>如何防范TCP洪泛攻击？</h2><h3 id="什么是-SYN-Flood？"><a href="#什么是-SYN-Flood？" class="headerlink" title="什么是 SYN Flood？"></a>什么是 SYN Flood？</h3><p>　　SYN Flood（SYN 洪泛攻击）就是 <strong>Client 在短时间内伪造大量不存在的源 IP 地址，并向 Server 不断地发送 SYN 包</strong>，Server 一旦接收到 Client 发来的 Syn 报文，就<strong>立即</strong>为该请求分配一个 <strong>TCB（Transmission Control Block）</strong>，并回复 ACK 确认包，等待 Client 确认。由于源地址不存在，因此 Server 需要不断重发直至超时</p><p>　　<strong>这些伪造的 SYN 包将长时间占用「半连接队列」，并请求分配大量 TCB，消耗服务器资源，同时也导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪</strong></p><h3 id="如何防御-SYN-Flood？"><a href="#如何防御-SYN-Flood？" class="headerlink" title="如何防御 SYN Flood？"></a>如何防御 SYN Flood？</h3><ol><li>配置防火墙：防火墙可以通过限制每秒钟接收的 SYN 请求数量，或限制源地址的数量来降低攻击的威力。</li><li>使用反向代理：将流量分配到多个服务器上，通过负载均衡来减轻单台服务器的负担，从而使服务器更难受到攻击。</li><li>使用 CDN：使用 CDN 可以帮助过滤掉大部分的攻击流量，并将请求转发到最近的可用服务器上。</li><li>限制连接数：限制每个 IP 地址的连接数量，通过对 TCP 连接进行监控和记录，及时发现异常连接行为，限制同一 IP 地址的连接数量。</li><li>绕过半连接队列，使用cookies确认验证，<code>cookies</code>​并不会有一个专门的队列保存，它是通过<strong>通信双方的IP地址端口、时间戳、MSS</strong>等信息进行<strong>实时计算</strong>的，保存在<strong>TCP报头</strong>的<code>seq</code>​里。</li></ol><h1 id="2、TCP四次挥手"><a href="#2、TCP四次挥手" class="headerlink" title="2、TCP四次挥手"></a>2、TCP四次挥手</h1><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-TCP/net-img-312waa4a7ece5bdd5f6ea4e11454fd7ba381-20230811162629-7fau260.png"></p><h2 id="为什么要是四次，可以变成三次吗？"><a href="#为什么要是四次，可以变成三次吗？" class="headerlink" title="为什么要是四次，可以变成三次吗？"></a>为什么要是四次，可以变成三次吗？</h2><p>　　Q1：</p><blockquote><p>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</p></blockquote><blockquote><p>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</p></blockquote><p>　　Q2：</p><p>　　可以</p><p>　　次数由服务端的应用程序决定，看是否还有数据要发送</p><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-TCP/net-img-312w387bd90eb57a4f4e57de2d816def9a61-20230811162629-gc3u3wd.png"></p><p>　　两种关闭函数：close、shutdown</p><table><thead><tr><th>close</th><th>关闭发送方向和读取方向</th><th>socket引用计数-1，其他线程还可以读写，直到计数为0，发出FIN报文</th><th>粗暴关闭，不会四次</th></tr></thead><tbody><tr><td>shutdown</td><td>只关闭发送方向而不关闭读取方向</td><td>直接使得该 socket 不可用，然后发出 FIN 报文</td><td>优雅关闭，四次</td></tr></tbody></table><p>　　<strong>当被动关闭方（上图的服务端）在 TCP 挥手过程中，「没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p><blockquote><p>TCP 延迟确认的策略：</p></blockquote><blockquote><p>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</p></blockquote><blockquote><p>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</p></blockquote><blockquote><p>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</p></blockquote><h2 id="四次挥手丢失"><a href="#四次挥手丢失" class="headerlink" title="四次挥手丢失"></a>四次挥手丢失</h2><p>　　注意永远不会重传ack报文</p><table><thead><tr><th>阶段</th><th>影响</th></tr></thead><tbody><tr><td>第一次丢失</td><td>客户端超时重传FIN</td></tr><tr><td>第二次丢失</td><td>客户端超时重传FIN；使用close关闭，超过60s直接断开连接；使用shutdown，死等，一直处于finwait2状态</td></tr><tr><td>第三次丢失</td><td>服务端超时重传FIN</td></tr><tr><td>第四次丢失</td><td>服务端重发FIN，客户端收到重置2MSL，当等待 2MSL 时长后，客户端就会断开连接</td></tr></tbody></table><h2 id="为什么需要TIME-WAIT状态？"><a href="#为什么需要TIME-WAIT状态？" class="headerlink" title="为什么需要TIME_WAIT状态？"></a>为什么需要TIME_WAIT状态？</h2><p>　　需要 TIME-WAIT 状态，主要是两个原因：</p><ul><li><strong>防止历史连接中的数据，被后面相同四元组的连接错误的接收</strong>；</li><li>保证「被动关闭连接」的一方，能被正确的关闭；</li></ul><blockquote><p><strong>序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据</strong>。这个2MSL时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的</strong></p></blockquote><h2 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">MSL 是 Maximum Segment Lifetime，报文最大生存时间<br></code></pre></td></tr></table></figure><p>网络中可能存在来自发送方的数据包，<strong>一来一回需要等待 2 倍的时间</strong>。</p><p><strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。</p><h2 id="TIME-WAIT过多危害"><a href="#TIME-WAIT过多危害" class="headerlink" title="TIME_WAIT过多危害"></a>TIME_WAIT过多危害</h2><p>　　发起连接方：端口被占满，但<strong>不同服务端端口可以复用</strong></p><p>　　连接接收方：端口不受限，但占用系统资源</p><h2 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h2><p>　　<a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F-time-wait-%E7%8A%B6%E6%80%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B">4.1 TCP 三次握手与四次挥手面试题</a></p><h1 id="3、讲讲你对套接字编程的理解，它的协议是如何的？"><a href="#3、讲讲你对套接字编程的理解，它的协议是如何的？" class="headerlink" title="3、讲讲你对套接字编程的理解，它的协议是如何的？"></a>3、<strong>讲讲你对套接字编程的理解，它的协议是如何的？</strong></h1><p>　　<strong>socket通常称为“套接字”，用于描述IP地址和端口</strong></p><p>　　应用程序通过套接字向网络发出请求或应答网络请求。</p><p>　　服务器和客户端通过socket进行交互。服务器需要绑定在本机的某个端口号上，客户端需要声明自己连接哪个地址的哪个端口，这样服务器和客户端就能连接了。</p><p>　　连接步骤：<strong>服务器监听，客户端请求，连接确认</strong></p><p>　　socket是对TCP&#x2F;IP协议的封装和应用。结合TCP三次握手。</p><p>　　<a href="https://zhuanlan.zhihu.com/p/136689020">套接字Socket面试题</a></p><h2 id="TCP-socket编程流程"><a href="#TCP-socket编程流程" class="headerlink" title="TCP socket编程流程"></a>TCP socket编程流程</h2><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-TCP/net-img-312w36ebf7bd277592a4ffda7f90b214ecd7-20230811162629-6hqspuk.png"></p><ul><li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li><li>服务端调用 <code>bind</code>，将 socket 绑定在指定的 IP 地址和端口;</li><li>服务端调用 <code>listen</code>，进行监听；</li><li>服务端调用 <code>accept</code>，等待客户端连接；</li><li>客户端调用 <code>connect</code>，向服务端的地址和端口发起连接请求；</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li><li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li><li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li></ul><p>　　监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p><p>　　成功连接建立之后，双方开始通过 read 和 write 函数来读写数据</p><p>　　<strong>结合图片理解</strong></p><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-TCP/net-img-312we21312d2a8ee660da18fc2530819b5d1-20230811162629-p6kve99.png"></p><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-TCP/net-img-312w49b68e92039b54101ddf8c6d4d88c23b-20230811162630-i6lgz1y.png"></p><p>　　几个点：</p><p>　　listen的时候参数backlog代表accept队列长度</p><p>　　<strong>客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后</strong></p><p>　　<strong>半连接队列结构：哈希表</strong></p><p>　　<strong>全连接队列结构：链表</strong></p><p>　　针对半连接的攻击：SYN_FLOOD, 客户端死活不发第三次握手过来,挂着你</p><p>　　解决方法：绕过半连接队列，使用cookie，<code>cookies</code>并不会有一个专门的队列保存，它是通过<strong>通信双方的IP地址端口、时间戳、MSS</strong>等信息进行<strong>实时计算</strong>的，保存在<strong>TCP报头</strong>的<code>seq</code>里。</p><p>　　<a href="https://xiaolincoding.com/network/3_tcp/tcp_no_accpet.html#%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E8%A6%81%E6%98%AF%E6%BB%A1%E4%BA%86%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7">4.20 没有 accept，能建立 TCP 连接吗？</a></p><h2 id="没有-accept，能建立-TCP-连接吗？"><a href="#没有-accept，能建立-TCP-连接吗？" class="headerlink" title="没有 accept，能建立 TCP 连接吗？"></a>没有 accept，能建立 TCP 连接吗？</h2><p>　　答案：<strong>可以的</strong>。</p><p>　　accept 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了。</p><h2 id="没有-listen，能建立-TCP-连接吗？"><a href="#没有-listen，能建立-TCP-连接吗？" class="headerlink" title="没有 listen，能建立 TCP 连接吗？"></a>没有 listen，能建立 TCP 连接吗？</h2><p>　　答案：<strong>可以的</strong>。</p><blockquote><p>客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是没有服务端参与，也就是没有 listen，就能 TCP 建立连接。</p></blockquote><blockquote><p>在 TCP 自连接的情况中，客户端在 connect 方法时，最后会将自己的连接信息放入到这个全局 hash 表中，然后将信息发出，消息在经过回环地址重新回到 TCP 传输层的时候，就会根据 IP + 端口信息，再一次从这个全局 hash 中取出信息。于是握手包一来一回，最后成功建立连接</p></blockquote><p>　　<a href="https://xiaolincoding.com/network/3_tcp/tcp_no_listen.html#%E5%81%9A%E4%B8%AA%E5%AE%9E%E9%AA%8C">4.19 服务端没有 listen，客户端发起连接建立，会发生什么？</a></p><p>　　<strong>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文</strong></p><h2 id="Socket和Web-Socket区别？"><a href="#Socket和Web-Socket区别？" class="headerlink" title="Socket和Web Socket区别？"></a>Socket和Web Socket区别？</h2><p>　　<a href="https://zhuanlan.zhihu.com/p/336232244">一文搞懂WebSocket介绍，与Socket的区别</a></p><p>　　WebSocket是应用层协议，基于TCP，模拟Socket协议，可以双向发送或接受信息，需要三次握手：</p><blockquote><ol><li>浏览器、服务器建立TCP连接，三次握手。这是通信的基础，传输控制层，若失败后续都不执行。</li></ol></blockquote><blockquote><ol start="2"><li>TCP连接成功后，浏览器通过HTTP协议向服务器传送WebSocket支持的版本号等信息。（开始前的HTTP握手）</li></ol></blockquote><blockquote><ol start="3"><li>服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据。</li></ol></blockquote><blockquote><ol start="4"><li>当收到了连接成功的消息后，通过TCP通道进行传输通信。</li></ol></blockquote><p>　　Socket其实并不是一个协议，而是为了方便使用TCP或UDP而抽象出来的一层，是位于应用层和传输控制层之间的一组接口</p><h1 id="4、TCP和UDP区别？"><a href="#4、TCP和UDP区别？" class="headerlink" title="4、TCP和UDP区别？"></a>4、TCP和UDP区别？</h1><p>　　衍生题目：如何基于UDP实现可靠传输，使用UDP，TCP的协议</p><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-TCP/net-img-312w7f723f2be36db6899744ee26d7f6fc31-20230811162630-r8vl21n.png"></p><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-TCP/net-img-312wd0050164ce65cbe20451be996bf2f3b7-20230811162630-do8dxbr.png"></p><h1 id="5、TCP-怎么保证可靠传输？"><a href="#5、TCP-怎么保证可靠传输？" class="headerlink" title="5、TCP 怎么保证可靠传输？"></a>5、TCP 怎么保证可靠传输？</h1><p>　　详细介绍下 TCP 滑动窗口（累积确认、流量控制、拥塞控制）？</p><p>　　TCP 是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输的。</p><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-TCP/net-img-312w63bca50be9db10d11bb11c0fe8915044-20230811162630-jc22f5h.png"></p><h2 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h2><p>　　<strong>超时重传</strong></p><table><thead><tr><th>RTT</th><th>Round-Trip Time</th><th>往返时延</th><th>数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间</th></tr></thead><tbody><tr><td>RTO</td><td>Retransmission Timeout</td><td>超时重传时间</td><td>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。</td></tr></tbody></table><ul><li>当超时时间 <strong>RTO 较大</strong>时，重发就慢，丢了老半天才重发，没有效率，性能差；</li><li>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发</li></ul><p>　　<strong>快速重传</strong>的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p><p>　　<code>SACK</code>（ Selective Acknowledgment）， <strong>选择性确认，将已收到的数据的信息发送给「发送方」，只重传丢失的数据</strong></p><p>　　Duplicate SACK 又称 <code>D-SACK</code>，其主要<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</strong></p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>　　结合<strong>累计确认</strong></p><p>　　窗口的大小是由接收方的窗口大小来决定的，接收窗口的大小是<strong>约等于</strong>发送窗口的大小的</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>　　<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p><p>　　发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会<strong>被操作系统调整</strong></p><p>　　<strong>TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况</strong></p><p>　　窗口关闭：<strong>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</strong></p><p>　　当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失，这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象</p><p>　　解决窗口死锁：</p><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-TCP/net-img-312w4c3245c47ce008785dab7a42e9cae60c-20230811162630-c2soyk0.png"></p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>　　慢启动、拥塞避免、拥塞发生、快速恢复</p><p>　　指标：<strong>cwnd 拥塞窗口</strong></p><p>　　慢启动指数增长，拥塞避免线性增长</p><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-TCP/net-img-312w0ed8be25d628153040d7b5c901d8cb8c-20230811162630-t4cqtyw.png"></p><p>　　丢包触发重传机制：<strong>超时和快速</strong>两种</p><p>　　当发生了「超时重传」，则就会使用拥塞发生算法。</p><p>　　这个时候，ssthresh 和 cwnd 的值会发生变化：</p><ul><li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li><li><code>cwnd</code> 重置为 <code>1</code> （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）</li></ul><p>　　缺点：变化太剧烈</p><p>　　使用快重传</p><ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li><li>进入快速恢复算法</li></ul><p>　　​<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-TCP/net-img-312wdd652bebf8c0748266591e2c92162de9-20230811162630-8hfs467.png"></p><p>　　‍</p><h1 id="什么是TCP拆包和粘包问题？怎么解决？"><a href="#什么是TCP拆包和粘包问题？怎么解决？" class="headerlink" title="什么是TCP拆包和粘包问题？怎么解决？"></a>什么是TCP拆包和粘包问题？怎么解决？</h1><p>首先明确原因：</p><ul><li>TCP面向字节流</li><li>用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统分组成多个的 TCP 报文</strong></li><li>不知道消息边界无法读出有效的用户消息</li></ul><h2 id="为什么UDP没有？"><a href="#为什么UDP没有？" class="headerlink" title="为什么UDP没有？"></a>为什么UDP没有？</h2><p>粘包拆包问题在数据链路层、网络层以及传输层都有可能发生。日常的网络应用开发大都在传输层进行，由于<strong>UDP有消息保护边界</strong>，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。</p><p>操作系统在收到 UDP 报文后，会将其插入到队列里，<strong>队列里的每一个元素就是一个 UDP 报文</strong>，这样当用户调用 recvfrom() 系统调用读数据的时候，就会从队列里取出一个数据，然后从内核里拷贝给用户缓冲区。</p><h2 id="粘包拆包发生场景："><a href="#粘包拆包发生场景：" class="headerlink" title="粘包拆包发生场景："></a>粘包拆包发生场景：</h2><p>因为TCP是面向流，没有边界，而操作系统在发送TCP数据时，会通过缓冲区来进行优化，例如缓冲区为1024个字节大小。</p><p>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将<strong>多个请求合并为同一个请求</strong>进行发送，这就形成了粘包问题。</p><p>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其<strong>拆分为多次发送</strong>，这就是拆包。</p><h2 id="常见解决方案："><a href="#常见解决方案：" class="headerlink" title="常见解决方案："></a>常见解决方案：</h2><ul><li>发送端将每个包都封装成<strong>固定的长度</strong>，比如100字节大小。如果不足100字节可通过补0或空等进行填充到指定长度；</li><li>发送端在每个包的<strong>末尾</strong>使用<strong>固定的分隔符</strong>，例如\r\n。如果发生拆包需等待多个包发送过来之后再找到其中的\r\n进行合并；例如，FTP协议；</li><li>将<strong>消息分为头部和消息体</strong>，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息；</li><li>通过<strong>自定义协议</strong>进行粘包和拆包的处理。</li></ul><p>　　‍</p><h1 id="TCP糊涂窗口综合症（SWS）和解决方案？"><a href="#TCP糊涂窗口综合症（SWS）和解决方案？" class="headerlink" title="TCP糊涂窗口综合症（SWS）和解决方案？"></a>TCP糊涂窗口综合症（SWS）和解决方案？</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>　　当发送端应用进程产生数据很慢、或接收端应用进程处理接收缓冲区数据很慢，或二者兼而有之；就会使应用进程间传送的报文段很小，特别是有效载荷很小。极端情况下，有效载荷可能只有1个字节；而传输开销有40字节(20字节的IP头+20字节的TCP头) 这种现象就叫糊涂窗口综合症。</p><h2 id="解决方案？"><a href="#解决方案？" class="headerlink" title="解决方案？"></a>解决方案？</h2><p>　　发送方：</p><p>　　Nagle 算法：指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送的一种处理机制。具体来说，当满足已发送的数据都已经收到确认应答时；或者可以发送的数据大小 &gt;&#x3D; 内核缓冲区大小的一半时，才可以发送数据。这样，从发送方的角度去防止了小报文的发送</p><p>　　接收方：</p><p>　　方案 1：只要窗口大小 &lt; 某个值（内核缓冲区大小的一半）的时候，就直接将窗口大小设置为 0，防止发送方发送小数据；然后等到窗口大小 &gt;&#x3D; 内核缓冲区大小的一半 的时候，才打开窗口，通告发送方，告知其可以发送数据。这样就可以防止发送方发送小报文了</p><p>　　方案 2（延迟确认应答）：延迟确认应答其实是针对如果接受数据的主机在接收到报文的时候就立刻返回 ACK 应答的话，这时候返回的窗口可能比较小。如果接收方稍微等一会再应答，那么这个时候接收的数据已经被处理完了，从缓冲区中被清理出去了，这样的话，窗口就变大了，发送方能够发送的数据也就更多了</p><p>　　‍</p><h1 id="TCP首部包含哪些字段？"><a href="#TCP首部包含哪些字段？" class="headerlink" title="TCP首部包含哪些字段？"></a>TCP首部包含哪些字段？</h1><p>　　​<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-TCP/image-20230811220001-43qia5z.png" alt="image">​</p><p>　　<strong>TCP 首部包含可选项，所以总体长度可变，但包含 20 字节的固定部分（和 IP 首部一样）</strong></p><ul><li><strong>确认 ACK</strong>：仅当 ACK &#x3D; 1 时确认号字段 ack 才有效。TCP 规定，TCP 规定除了最初建立连接时的 <code>SYN</code>​ 包之外该位必须设置为 1</li><li><strong>推送 PSH</strong>（Push）：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作。这时，发送方 TCP 把 PSH 置为 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH &#x3D; 1 的报文段，就尽快地交付接收应用进程。而不用等到整个缓存都填满了后再向上交付。</li><li><strong>复位 RST</strong>（Reset）：当 RST &#x3D; 1 时，表明 TCP 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立连接</li><li><strong>同步 SYN</strong>：SYN &#x3D; 1 表示这是希望建立连接</li><li><strong>终止 FIN</strong>（Finish）：用来释放一个连接。当 FIN &#x3D; 1时，表明此报文段的发送发的数据已发送完毕，并要求释放连接</li></ul><h1 id="TCP中有哪些定时器？"><a href="#TCP中有哪些定时器？" class="headerlink" title="TCP中有哪些定时器？"></a>TCP中有哪些定时器？</h1><p>　　对于每个TCP连接，TCP一般要管理4个不同的定时器：<strong>重传定时器</strong>、<strong>坚持定时器</strong>、<strong>保活定时器</strong>、<strong>2MSL定时器</strong>。</p><p>　　重传定时器：计算超时重传时间</p><p>　　坚持定时器：也叫持续计数器，为了解决窗口为0的问题</p><blockquote><p>若坚持定时器设置的时间到期，就发送一个零窗体控測报文段（该报文段仅仅有一个字节的数据，它有一个序号，但该序号永远不须要确认，因此该序号能够持续重传），之后会出现下面三种情况：</p><pre><code class="hljs">1、对方在收到探測报文段后，在对该报文段的确认中给出如今的窗体值，假设窗体值仍未零，则收到这个报文段的一方将坚持定时器的值加倍并重新启动。坚持计数器最大仅仅能添加到约60秒，在此之后，每次收到零窗体通知，坚持计数器的值就定位60秒。2、对方在收到探測报文段后，在对该报文段的确认中给出如今的窗体值，假设窗体不为零，那么死锁的僵局就被打破了。3、该探測报文发出后，会同一时候启动重传定时器，假设重传定时器的时间到期，还没有收到接收到发来的响应，则超时重传探測报文。</code></pre></blockquote><p>　　保活定时器：应对两个TCP连接间长时间没有传输数据的情况。 通常为2小时，以后每隔75s发送一次，连续10次终止连接。</p><p>　　2MSL定时器：为什么 TIME_WAIT 等待的时间是 2MSL？</p><h1 id="怎么快速回收TCP资源？"><a href="#怎么快速回收TCP资源？" class="headerlink" title="怎么快速回收TCP资源？"></a>怎么快速回收TCP资源？</h1><p>　　<strong>快速回收和重用TIME-WAIT</strong></p><p>　　不再等待2MSL，等待一个重传时间直接释放。</p><p>　　IP层可以保存一个peer信息，有peer的IP地址信息以及TCP最后一次触摸它的时间戳，遵循一定规范就可快速接入。</p><p>　　<a href="https://blog.csdn.net/dog250/article/details/13760985">TCP的TIME_WAIT快速回收与重用_dog250的博客-CSDN博客</a></p><p>　　‍</p><h1 id="DNS协议为什么同时使用TCP和UDP？"><a href="#DNS协议为什么同时使用TCP和UDP？" class="headerlink" title="DNS协议为什么同时使用TCP和UDP？"></a>DNS协议为什么同时使用TCP和UDP？</h1><p>　　DNS使用<strong>TCP协议进行区域传输</strong>，使用<strong>UDP协议进行名称查询</strong>。</p><p>　　UDP协议用于交换小信息，而TCP协议必须用于交换大于<strong>512字节</strong>的信息。</p><p>　　如果客户端未从DNS获取响应，则必须在间隔3-5秒后使用TCP重新传输数据。</p><p>　　当域名解析的反馈报文的长度超过512字节时，将不能使用UDP协议进行解析，此时必须使用TCP。</p><p>　　区域传输的数据量相比单次DNS查询的数据量要大得多，区域传输对数据的可靠性和准确性相比普通的DNS查询要高得多，因此使用TCP协议。</p><h1 id="一台机器最大支持多少TCP连接？"><a href="#一台机器最大支持多少TCP连接？" class="headerlink" title="一台机器最大支持多少TCP连接？"></a>一台机器最大支持多少TCP连接？</h1><p>　　<a href="https://zhuanlan.zhihu.com/p/290651392">一台机器最多能撑多少个TCP连接? 今天掰扯清楚！ - 知乎 (zhihu.com)</a></p><ul><li><strong>TCP连接的客户端机：</strong>每一个ip可建立的TCP连接理论受限于ip_local_port_range参数，也受限于65535。但可以通过配置多ip的方式来加大自己的建立连接的能力。</li><li><strong>TCP连接的服务器机：</strong>每一个监听的端口虽然理论值很大，但这个数字没有实际意义。最大并发数取决你的内存大小，每一条静止状态的TCP连接大约需要吃3<br>.3K的内存。</li></ul><h1 id="一台主机可以有多少端口？"><a href="#一台主机可以有多少端口？" class="headerlink" title="一台主机可以有多少端口？"></a>一台主机可以有多少端口？</h1><p>　　TCP&#x2F;IP协议中的服务端口通过不同的逻辑端口来区分不同的服务。一个IP地址的端口通过16bit进行编号，最多可以有65535个端口。</p><p>　　<a href="https://www.cnblogs.com/innershare/">Innershar</a></p><h2 id="常见的端口号及其用途"><a href="#常见的端口号及其用途" class="headerlink" title="常见的端口号及其用途"></a><a href="https://www.cnblogs.com/innershare/p/10749981.html">常见的端口号及其用途</a></h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">一些常见的端口号及其用途如下：</span><br><span class="hljs-number">21</span><span class="hljs-string">端口：FTP</span> <span class="hljs-string">文件传输服务</span><br><span class="hljs-number">22</span><span class="hljs-string">端口：SSH</span> <span class="hljs-string">端口</span><br><span class="hljs-number">23</span><span class="hljs-string">端口：TELNET</span> <span class="hljs-string">终端仿真服务</span><br><span class="hljs-number">25</span><span class="hljs-string">端口：SMTP</span> <span class="hljs-string">简单邮件传输服务</span><br><span class="hljs-number">53</span><span class="hljs-string">端口：DNS</span> <span class="hljs-string">域名解析服务</span><br><span class="hljs-number">80</span><span class="hljs-string">端口：HTTP</span> <span class="hljs-string">超文本传输服务</span><br><span class="hljs-number">110</span><span class="hljs-string">端口：POP3</span> <span class="hljs-string">“邮局协议版本3”使用的端口</span><br><span class="hljs-number">443</span><span class="hljs-string">端口：HTTPS</span> <span class="hljs-string">加密的超文本传输服务</span><br><span class="hljs-number">1433</span><span class="hljs-string">端口：MS</span> <span class="hljs-string">SQL*SERVER数据库</span> <span class="hljs-string">默认端口号</span><br><span class="hljs-number">1521</span><span class="hljs-string">端口：Oracle数据库服务</span><br><span class="hljs-number">1863</span><span class="hljs-string">端口：MSN</span> <span class="hljs-string">Messenger的文件传输功能所使用的端口</span><br><span class="hljs-number">3306</span><span class="hljs-string">端口：MYSQL</span> <span class="hljs-string">默认端口号</span><br><span class="hljs-number">3389</span><span class="hljs-string">端口：Microsoft</span> <span class="hljs-string">RDP</span> <span class="hljs-string">微软远程桌面使用的端口</span><br><span class="hljs-number">5631</span><span class="hljs-string">端口：Symantec</span> <span class="hljs-string">pcAnywhere</span> <span class="hljs-string">远程控制数据传输时使用的端口</span><br><span class="hljs-number">5632</span><span class="hljs-string">端口：Symantec</span> <span class="hljs-string">pcAnywhere</span> <span class="hljs-string">主控端扫描被控端时使用的端口</span><br><span class="hljs-number">5000</span><span class="hljs-string">端口：MS</span> <span class="hljs-string">SQL</span> <span class="hljs-string">Server使用的端口</span><br><span class="hljs-number">8000</span><span class="hljs-string">端口：腾讯QQ</span><br></code></pre></td></tr></table></figure><p>　　‍</p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网-基础</title>
    <link href="/2023/08/11/%E8%AE%A1%E7%BD%91-%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/08/11/%E8%AE%A1%E7%BD%91-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>总结计算机网络基础面试题目和知识点</p><span id="more"></span><h1 id="1、OSI-七层模型、TCP-x2F-IP-五层模型以及各层的代表协议"><a href="#1、OSI-七层模型、TCP-x2F-IP-五层模型以及各层的代表协议" class="headerlink" title="1、OSI 七层模型、TCP&#x2F;IP 五层模型以及各层的代表协议"></a>1、OSI 七层模型、TCP&#x2F;IP 五层模型以及各层的代表协议</h1><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-%E5%9F%BA%E7%A1%80/net-img-312w2b05d4945e39821c3ba65c798af0e040-20230811162623-1g6bk71.png"></p><p>　　<a href="https://zhuanlan.zhihu.com/p/143654140">一文读懂OSI七层模型和TCP&#x2F;IP五层模型</a></p><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-%E5%9F%BA%E7%A1%80/net-img-312wb212ee7ee25b134350aff53004cc0887-20230811162623-76r6tmo.png"></p><p>　　网络接口层的传输单位是<strong>帧</strong>（frame），IP 层的传输单位是<strong>包</strong>（packet），TCP 层的传输单位是<strong>段</strong>（segment），HTTP 的传输单位则是<strong>消息或报文</strong>（message）</p><h2 id="为什么协议分层？是为了解决什么问题？"><a href="#为什么协议分层？是为了解决什么问题？" class="headerlink" title="为什么协议分层？是为了解决什么问题？"></a>为什么协议分层？是为了解决什么问题？</h2><p>　　总结原因： 简化、灵活、易维护、标准化</p><p>　　<a href="https://zhuanlan.zhihu.com/p/593911743">每日一道面试题-为什么要对网络协议分层？</a></p><h2 id="两台计算机通信过程"><a href="#两台计算机通信过程" class="headerlink" title="两台计算机通信过程"></a>两台计算机通信过程</h2><p>　　<a href="https://zhuanlan.zhihu.com/p/349790772">💻 一文读懂两台计算机之间是如何通信的</a></p><h1 id="2、浏览器中输入URL到返回页面的全过程"><a href="#2、浏览器中输入URL到返回页面的全过程" class="headerlink" title="2、浏览器中输入URL到返回页面的全过程"></a>2、浏览器中输入URL到返回页面的全过程</h1><h2 id="总步骤"><a href="#总步骤" class="headerlink" title="总步骤"></a>总步骤</h2><ul><li>1.根据域名，进行DNS域名解析；</li><li>2.拿到解析的IP地址，建立TCP连接；</li><li>3.向IP地址，发送HTTP请求；</li><li>4.服务器处理请求；</li><li>5.返回响应结果；</li><li>6.关闭TCP连接；</li><li>7.浏览器解析HTML；</li><li>8.浏览器布局渲染；</li></ul><h2 id="查找域名：-本-根-顶级-权威"><a href="#查找域名：-本-根-顶级-权威" class="headerlink" title="查找域名： 本-根-顶级-权威"></a>查找域名： 本-根-顶级-权威</h2><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-%E5%9F%BA%E7%A1%80/net-img-312s00a468fa4b8476af1ff806d30170e1da-20230811162623-7rk1ryn.png"></p><p>　　浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」</p><h2 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h2><p>　　通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的<strong>协议栈</strong>。</p><p>　　协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。</p><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-%E5%9F%BA%E7%A1%80/net-img-312s2e792c2f092d1b299fb27dd4990c1611-20230811162623-r8baoud.png"></p><ul><li><code>ICMP</code> 用于告知网络包传送过程中产生的错误以及各种控制信息。</li><li><code>ARP</code> 用于根据 IP 地址查询相应的以太网 MAC 地址。</li></ul><h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>　　ping&#x2F;traceroute 命令是基于 ICMP 协议来实现的。</p><p>　　ICMP是 Internet Control Message Protocol 的缩写，即互联网控制消息协议。它是互联网协议族的核心协议之一。它用于 TCP&#x2F;IP 网络中发送控制消息，提供可能发生在通信环境中的各种问题反馈，通过这些信息，使网络管理者可以对所发生的问题作出诊断，然后采取适当的措施解决问题。</p><p>　　从 ICMP 的报文格式来说，ICMP 是 IP 的上层协议。但是 ICMP 是分担了 IP 的一部分功能。所以，他也被认为是与 IP 同层的协议</p><p>　　虽然 ICMP 是网络层协议，但是它不像 IP 协议和 ARP 协议一样直接传递给数据链路层，而是先封装成 IP 数据包然后再传递给数据链路层。所以在 IP 数据包中如果协议类型字段的值是 1 的话，就表示 IP 数据是 ICMP 报文。IP 数据包就是靠这个协议类型字段来区分不同的数据包的。</p><p>　　在 IP 通信中如果某个包因为未知原因没有到达目的地址，那么这个具体的原因就是由 ICMP 负责告知。而 ICMP 协议的类型定义中就清楚的描述了各种报文的含义。</p><p>　　ICMP协议的类型分为两大类，<strong>查询报文</strong>和<strong>差错报文</strong>。</p><p>　　<strong>ping命令原理</strong></p><ol><li><strong>向目的服务器发送回显请求</strong>    ：主机会构建一个 ICMP 回显请求消息数据包（类型是8，代码是0），在这个回显请求数据包中，除了类型和代码字段，还被追加了标识符（填写进程号）和序号字段（每送出一个数据包数值就增加1）。</li><li><strong>目的服务器发送回显应答</strong> ：（类型是0，代码是0）</li><li><strong>源服务器显示相关数据</strong>： 记住发送回显请求数据包的时间，与接收到回显应答数据包的时间差，就能计算出数据包一去一回所需要的时间。这个时候ping命令就会将目的服务器的 IP 地址，数据大小，往返花费的时间打印到屏幕上。</li></ol><p>　　<strong>traceroute命令原理</strong></p><p>　　利用ICMP差错报文，原理就是利用 IP 包的 TTL 从 1 开始按照顺序递增的同时发送 UDP 包，强制接收 ICMP 超时消息的方法。</p><p>　　（1）首先 traceroute 会将 IP 包的 TTL 设置 为 1，然后发送 UDP 包，他会填入一个端口号作为 UDP 目标端口号（默认是：33434-33534）</p><p>　　（2）当目的主机收到 UDP 包后，会返回 ICMP 差错报文消息（类型 3，代码 3）。该报文类型是端口不可达，说明发送方发出的 UDP 包到达了目的主机。</p><p>　　这样的过程，traceroute 就可以拿到了所有的路由器 IP，这样子就可以看到从源主机到目的主机过程中的所有路由信息。</p><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-%E5%9F%BA%E7%A1%80/net-img-312sd2c31d0d6ea16923e9b4d23e8458c6ec-20230811162623-mmbl356.png"></p><p>　　traceroute 在类 Unix&#x2F;Linux 系统中默认使用的是 UDP 协议，也可以通过参数修改为使用 ICMP 协议；Windows 操作系统中只使用 ICMP 协议。</p><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>　　地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p><p>　　**ARP表 **</p><p>　　网络设备一般都有一个ARP缓存（ARP Cache），ARP缓存用来存放IP地址和MAC地址的关联信息。</p><p>　　ARP表项又分为动态ARP表项和静态ARP表项。</p><p>　　<strong>动态ARP表项</strong>：</p><p>　　动态ARP表项由ARP协议通过ARP报文自动生成和维护，可以被老化，可以被新的ARP报文更新，可以被静态ARP表项覆盖。每个动态ARP缓存项的潜在生命周期是10分钟。新加到缓存中的项目带有时间戳，如果某个项目添加后2分钟内没有再使用，则此项目过期并从ARP缓存中删除；如果某个项目已在使用，则又收到2分钟的生命周期；如果某个项目始终在使用，则会另外收到2分钟的生命周期，一直到10分钟的最长生命周期</p><p>　　<strong>静态ARP表项</strong></p><p>　　静态ARP表项通过手工配置和维护，不会被老化，不会被动态ARP表项覆盖。直到重新启动计算机为止。</p><p>　　一般情况下，ARP动态执行并自动寻求IP地址到以太网MAC地址的解析，无需管理员的介入。</p><p>　　当希望设备和指定用户只能使用某个固定的IP地址和MAC地址通信时，可以配置短静态ARP表项，当进一步希望限定这个用户只在某VLAN内的某个特定接口上连接时就可以配置长静态ARP表项。</p><h2 id="可靠传输-TCP"><a href="#可靠传输-TCP" class="headerlink" title="可靠传输-TCP"></a>可靠传输-TCP</h2><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-%E5%9F%BA%E7%A1%80/net-img-312sc434f3aebf2bc0a75d9845ef9654a195-20230811162623-nyla9mw.png"></p><p>　　<code>SYN</code> 是发起一个连接，<code>ACK</code> 是回复，<code>RST</code> 是重新连接，<code>FIN</code> 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</p><p>　　TCP有流量控制和拥塞控制</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h3><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-%E5%9F%BA%E7%A1%80/net-img-312sf0665a413d9f68fc2658dcdec7da6751-20230811162623-1al74lt.png"></p><p>　　TCP 的连接状态查看，在 Linux 可以通过 <code>netstat -napt</code> 命令查看。</p><h3 id="分割数据"><a href="#分割数据" class="headerlink" title="分割数据"></a><strong>分割数据</strong></h3><p>　　如果 HTTP 请求消息比较长，超过了 <code>MSS</code> 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。</p><p>　　数据会被以 <code>MSS</code> 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。</p><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-%E5%9F%BA%E7%A1%80/net-img-312s7b57f1fa7cb0f7ddd78c8442b85b300d-20230811162624-rm04mmo.png"></p><p>　　在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。</p><h2 id="远程定位-IP"><a href="#远程定位-IP" class="headerlink" title="远程定位-IP"></a>远程定位-IP</h2><p>　　在 IP 协议里面需要有<strong>源地址 IP</strong> 和 <strong>目标地址 IP</strong>：</p><ul><li>源地址IP，即是客户端输出的 IP 地址；</li><li>目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。</li></ul><p>　　当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。</p><p>　　这个时候就需要根据<strong>路由表</strong>规则，来判断哪一个网卡作为源地址 IP。 掩码与运算</p><p>　　<strong>有了MAC地址，为什么还要有IP地址？</strong></p><p>　　<a href="https://blog.csdn.net/qq_41549632/article/details/116711241?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-116711241-blog-86708609.235%5Ev32%5Epc_relevant_default_base3&spm=1001.2101.3001.4242.2&utm_relevant_index=4">有了MAC地址，为什么还要有IP地址？或者说有了 IP 地址，为什么还要用 MAC 地址？_有了mac地址为什么还需要ip地址呢_天亮i的博客-CSDN博客</a></p><p>　　<strong>有了IP为什么还要有MAC？</strong></p><p>　　<a href="https://zhuanlan.zhihu.com/p/571619940">有了IP地址，为何还要有MAC地址</a></p><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-%E5%9F%BA%E7%A1%80/net-img-312te761e0ff7ff08ae81cdcdb6469270de0-20230811162624-ivywvwi.png"></p><h2 id="两点运输-MAC"><a href="#两点运输-MAC" class="headerlink" title="两点运输-MAC"></a>两点运输-MAC</h2><p>　　在 MAC 包头里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>。</p><p>　　一般在 TCP&#x2F;IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p><ul><li><code>0800</code> ： IP 协议</li><li><code>0806</code> ： ARP 协议</li></ul><p>　　至此，网络包的报文如下图：</p><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-%E5%9F%BA%E7%A1%80/net-img-312s2303b48c6fd6aac3aa4378e3d53efe11-20230811162624-inaex91.png"></p><h2 id="出口-网卡"><a href="#出口-网卡" class="headerlink" title="出口-网卡"></a>出口-网卡</h2><p>　　网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p><p>　　负责执行这一操作的是<strong>网卡</strong>，要控制网卡还需要靠<strong>网卡驱动程序</strong>。</p><p>　　网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p><p>　　<img src="/2023/08/11/%E8%AE%A1%E7%BD%91-%E5%9F%BA%E7%A1%80/net-img-312s02172db0e647016b5f6b38af749caf8e-20230811162624-rvcq1g3.png"></p><h2 id="送别者-交换机"><a href="#送别者-交换机" class="headerlink" title="送别者-交换机"></a>送别者-交换机</h2><p>　　交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong></p><p>　　交换机的 MAC 地址表主要包含两个信息：</p><ul><li>一个是设备的 MAC 地址，</li><li>另一个是该设备连接在交换机的哪个端口上。</li></ul><p>　　<strong>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong></p><p>　　地址表中找不到指定的 MAC 地址，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。</p><p>　　此外，如果接收方 MAC 地址是一个<strong>广播地址</strong>，那么交换机会将包发送到除源端口之外的所有端口。</p><p>　　以下两个属于广播地址：</p><ul><li>MAC 地址中的 <code>FF:FF:FF:FF:FF:FF</code></li><li>IP 地址中的 <code>255.255.255.255</code></li></ul><h1 id="DNS出错，如何排查错误？"><a href="#DNS出错，如何排查错误？" class="headerlink" title="DNS出错，如何排查错误？"></a>DNS出错，如何排查错误？</h1><p>　　<a href="https://zhuanlan.zhihu.com/p/520785043">如何排查DNS解析出错？这四步轻松搞定 - 知乎 (zhihu.com)</a></p><p>　　1、通过whois查看域名状态</p><p>　　2、验证网络连接</p><p>　　3、ping主机</p><p>　　4、NSLookup</p><h1 id="客户端卡顿可能是什么问题-如何排查"><a href="#客户端卡顿可能是什么问题-如何排查" class="headerlink" title="客户端卡顿可能是什么问题? 如何排查?"></a>客户端卡顿可能是什么问题? 如何排查?</h1><p>　　<a href="https://zhuanlan.zhihu.com/p/266102548">面试题|排查网页打开慢的方法有多少种? 我总结了15个 - 知乎 (zhihu.com)</a></p><p>　　‍</p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity Shader入门</title>
    <link href="/2023/04/23/Unity-Shader%E5%85%A5%E9%97%A8/"/>
    <url>/2023/04/23/Unity-Shader%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>本篇介绍的是编写着色器的基础示例</p><span id="more"></span><h1 id="最简单的顶点-x2F-片元着色器"><a href="#最简单的顶点-x2F-片元着色器" class="headerlink" title="最简单的顶点&#x2F;片元着色器"></a>最简单的顶点&#x2F;片元着色器</h1><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs text">Shader &quot;Unlit/Chapter5-SimpleShader&quot;<br>&#123;<br>SubShader&#123;<br>pass&#123;<br>CGPROGRAM<br>//告诉Unity哪个函数包含了顶点着色器代码<br>#pragma vertex vert  <br>//告诉Unity哪个顶点包含了片元着色器代码<br>#pragma fragment frag<br>//逐顶点执行，通过POSITION语义指定了输入v包含了顶点的位置，语义告诉系统用户需要哪些输入值和用户的输出<br>//SV_POSITION告诉Unity，顶点着色器的输出时裁剪空间中的顶点坐标<br>float4 vert(float4 v:POSITION):SV_POSITION&#123;<br>return mul(UNITY_MATRIX_MVP,v);<br>&#125;<br>//SV_TARGET语义告诉渲染器把用户的输出颜色存储到一个渲染目标中<br>fixed4 frag():SV_TARGET&#123;<br>return fixed4(1.0,1.0,1.0,1.0);<br>&#125;<br>ENDCG<br>&#125;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="获取更多数据"><a href="#获取更多数据" class="headerlink" title="获取更多数据"></a>获取更多数据</h2><p>可以定义结构体，包含模型数据</p><p>格式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">struct StructName&#123;<br> Type Name: Semantic;<br> Type Name: Semantic;<br>......<br>&#125;;<br></code></pre></td></tr></table></figure><p>Unity支持的语义有：POSITION，TANGENT，NORMAL，TEXCOORD0，TEXCOORD1，TEXCOORD2，TEXCOORD3，COLOR等</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs text">Shader &quot;Unlit/Chapter5-SimpleShader&quot;<br>&#123;<br>SubShader&#123;<br>pass&#123;<br>CGPROGRAM<br>//告诉Unity哪个函数包含了顶点着色器代码<br>#pragma vertex vert  <br>//告诉Unity哪个顶点包含了片元着色器代码<br>#pragma fragment frag<br><br>struct a2v&#123;<br>//用模型空间的顶点填充vertex变量<br>float4 vertex:POSITION;<br>//用模型空间的法线方向填充normal变量<br>float3 normal:NORMAL;<br>//用模型的第一套纹理坐标填充texcoord变量<br>float4 texcoord:TEXCOORD0;<br>&#125;<br>//逐顶点执行<br>//SV_POSITION告诉Unity，顶点着色器的输出时裁剪空间中的顶点坐标<br>float4 vert(a2v v):SV_POSITION&#123;<br>return mul(UNITY_MATRIX_MVP,v.vertex);<br>&#125;<br>//SV_TARGET语义告诉渲染器把用户的输出颜色存储到一个渲染目标中<br>fixed4 frag():SV_TARGET&#123;<br>return fixed4(1.0,1.0,1.0,1.0);<br>&#125;<br>ENDCG<br>&#125;<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>数据来源：使用该材质的Mesh Render组件，在每帧调用Draw Call的时候，Mesh Render会把它负责渲染的模型数据发送给Unity Shader。一个模型通常包含了一组三角面片，每个三角面片由3个顶点组成，每个顶点包含了一些数据：顶点位置、法线、切线、纹理坐标、顶点颜色等。</p><h2 id="着色器通信"><a href="#着色器通信" class="headerlink" title="着色器通信"></a>着色器通信</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs text">Shader &quot;Unlit/Chapter5-SimpleShader&quot;<br>&#123;<br>SubShader&#123;<br>pass&#123;<br>CGPROGRAM<br>//告诉Unity哪个函数包含了顶点着色器代码<br>#pragma vertex vert  <br>//告诉Unity哪个顶点包含了片元着色器代码<br>#pragma fragment frag<br><br>struct a2v&#123;<br>//用模型空间的顶点填充vertex变量<br>float4 vertex:POSITION;<br>//用模型空间的法线方向填充normal变量<br>float3 normal:NORMAL;<br>//用模型的第一套纹理坐标填充texcoord变量<br>float4 texcoord:TEXCOORD0;<br>&#125;<br>;<br>struct v2f&#123;<br>//pos中包含了顶点在裁剪空间中的位置信息<br>float4 pos:SV_POSITION;<br>//COLOR0语义可以用于存储颜色信息<br>fixed3 color:COLOR0;<br>&#125;<br>;<br>//逐顶点执行<br>//SV_POSITION告诉Unity，顶点着色器的输出时裁剪空间中的顶点坐标<br>//顶点着色器的输出结构必须包含一个语义为SV_POSITION的变量，否则渲染器<br>//无法得到裁剪空间中的顶点坐标<br>v2f vert(a2v v)&#123;<br>v2f o; //声明输出结构<br>o.pos=mul(UNITY_MATRIX_MVP,v.vertex);<br>//v.normal包含了顶点的法线方向，分量范围在【-1，1】<br>//现映射到【0，1】<br>//存到o.color中传到片元着色器<br>o.color=v.normal*0.5+fixed3(0.5,0.5,0.5);<br>return o;<br>&#125;<br>//SV_TARGET语义告诉渲染器把用户的输出颜色存储到一个渲染目标中<br>fixed4 frag(v2f i):SV_TARGET&#123;<br>return fixed4(i.color,1.0);<br>&#125;<br>ENDCG<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用属性"><a href="#使用属性" class="headerlink" title="使用属性"></a>使用属性</h2><p>在材质面板上展示，方便调整</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs text">Shader &quot;Unlit/Chapter5-SimpleShader&quot;<br>&#123;<br>Properties&#123;<br>//声明一个Color类型的属性<br>_Color (&quot;Color Tint&quot;, Color)=(1.0,1.0,1.0,1.0)<br>&#125;<br>SubShader&#123;<br><br>pass&#123;<br>CGPROGRAM<br>//告诉Unity哪个函数包含了顶点着色器代码<br>#pragma vertex vert  <br>//告诉Unity哪个顶点包含了片元着色器代码<br>#pragma fragment frag<br><br>//在CG代码中，我们需要定义一个与属性名称和类型都匹配的变量<br>uniform fixed4 _Color;<br>struct a2v&#123;<br>//用模型空间的顶点填充vertex变量<br>float4 vertex:POSITION;<br>//用模型空间的法线方向填充normal变量<br>float3 normal:NORMAL;<br>//用模型的第一套纹理坐标填充texcoord变量<br>float4 texcoord:TEXCOORD0;<br>&#125;;<br>struct v2f&#123;<br>//pos中包含了顶点在裁剪空间中的位置信息<br>float4 pos:SV_POSITION;<br>//COLOR0语义可以用于存储颜色信息<br>fixed3 color:COLOR0;<br>&#125;;<br>//逐顶点执行<br>//SV_POSITION告诉Unity，顶点着色器的输出时裁剪空间中的顶点坐标<br>v2f vert(a2v v)&#123;<br>v2f o; //声明输出结构<br>o.pos=mul(UNITY_MATRIX_MVP,v.vertex);<br>//v.normal包含了顶点的法线方向，分量范围在【-1，1】<br>//现映射到【0，1】<br>//存到o.color中传到片元着色器<br>o.color=v.normal*0.5+fixed3(0.5,0.5,0.5);<br>return o;<br>&#125;<br>//SV_TARGET语义告诉渲染器把用户的输出颜色存储到一个渲染目标中<br>fixed4 frag(v2f i):SV_TARGET&#123;<br>fixed3 c=i.color;<br>//使用Color属性来控制输出颜色<br>c*=_Color.rgb;<br>return fixed4(c,1.0);<br>&#125;<br>ENDCG<br>&#125;<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><img src="/2023/04/23/Unity-Shader%E5%85%A5%E9%97%A8/1.png"></p><p>为了在CG代码中可以访问到定义的属性，必须在CG代码片段提前定义一个新的变量，这个变量的名称和类型必须与Properties语义块中的属性定义相匹配。</p><h3 id="匹配关系"><a href="#匹配关系" class="headerlink" title="匹配关系"></a>匹配关系</h3><p><img src="/2023/04/23/Unity-Shader%E5%85%A5%E9%97%A8/2.png"></p><p>uniform关键词时CG中修饰变量和参数的一种修饰词，仅仅提供一些关于该变量的初始值时如何指定和存储的相关信息。可以省略（仅限unity）</p><h1 id="Unity内置文件和变量"><a href="#Unity内置文件和变量" class="headerlink" title="Unity内置文件和变量"></a>Unity内置文件和变量</h1><p>Unity内置了提前定义的函数、变量和宏辅助编程</p><h2 id="内置的包含文件"><a href="#内置的包含文件" class="headerlink" title="内置的包含文件"></a>内置的包含文件</h2><p>#include   文件后缀是.cginc</p><p>CGincludes文件夹包含了所有的内置包含文件。</p><p>主要文件和用处：</p><p><img src="/2023/04/23/Unity-Shader%E5%85%A5%E9%97%A8/3.png"></p><p>UnityCG.cginc是最常接触的一个包含文件，可以使用其提供的结构体和函数为编写提供方便。</p><p><img src="/2023/04/23/Unity-Shader%E5%85%A5%E9%97%A8/4.png"></p><p><img src="/2023/04/23/Unity-Shader%E5%85%A5%E9%97%A8/5.png"></p><p>Unity还提供了用于访问时间、光照、雾效和环境光等目的的变量，这些变量大多位于UnityShaderVariables.cginc中，与光照有关的内置变量还会位于Lightning.cginc，AutoLight.cginc中</p><h1 id="Unity提供的CG-x2F-HLSL语义"><a href="#Unity提供的CG-x2F-HLSL语义" class="headerlink" title="Unity提供的CG&#x2F;HLSL语义"></a>Unity提供的CG&#x2F;HLSL语义</h1><p>语义：一个赋给Shader输入和输出的字符串，可以让Shader知道从哪里读取数据，并将数据输出到哪里</p><p>系统数值语义（system-value semantics）：以SV开头，带渲染流水线中有特殊的含义，不可以随便赋值</p><h2 id="Unity支持的语义"><a href="#Unity支持的语义" class="headerlink" title="Unity支持的语义"></a>Unity支持的语义</h2><p><img src="/2023/04/23/Unity-Shader%E5%85%A5%E9%97%A8/6.png"></p><p>一个语义可以使用的寄存器只能处理4个浮点值。</p><p>如果想定义矩阵变量就需要使用更多的空间。一种方法是拆分。</p><p>float4x4拆成4个float4类型的变量，每个变量存储了矩阵中的一行数据。</p><h1 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h1><p><img src="/2023/04/23/Unity-Shader%E5%85%A5%E9%97%A8/7.png"></p><p>注意语法差异：</p><ul><li><p>使用SV_POSITION来描述顶点着色器输出的顶点位置</p></li><li><p>使用SV_TARGET来描述片元着色器的输出颜色</p></li><li><p>尽量不要使用分支语句：</p></li><li><p>分支判断语句中使用的条件变量最好是常数，即在Shader运行过程中不会发生变换；</p></li><li><p>每个分支中包含的操作指令数尽可能少；</p></li><li><p>分支的嵌套层数尽可能少</p></li><li><p>不要除以0</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity Shader数学基础</title>
    <link href="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>本篇介绍的是坐标系及不同坐标系间通过矩阵进行转换</p><span id="more"></span><h1 id="坐标系和旋转正向"><a href="#坐标系和旋转正向" class="headerlink" title="坐标系和旋转正向"></a>坐标系和旋转正向</h1><p>左手坐标系和右手坐标系</p><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/1.png"></p><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/2.png"></p><p>Unity使用左手系，但是对于观察空间来说，Unity使用的是右手坐标系，摄像机的前向是z轴的负方向</p><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/3.png"></p><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p>转置矩阵性质：</p><ul><li><p>转置矩阵的转置等于原矩阵</p></li><li><p>矩阵串接的转置等于反向串接各个矩阵的转置</p></li></ul><p>逆矩阵性质：</p><ul><li><p>原矩阵乘转置矩阵为单位矩阵</p></li><li><p>逆矩阵的逆矩阵是原矩阵</p></li><li><p>单位矩阵的逆矩阵是本身</p></li><li><p>转置矩阵的逆矩阵是逆矩阵的转置</p></li></ul><p>判断可逆：矩阵的行列式不为0</p><p>正交矩阵性质：</p><ul><li><p>矩阵的每一行都是单位矢量</p></li><li><p>矩阵的每一行相互垂直</p></li><li><p>对列一样适用</p></li></ul><p>正交：矩阵乘转置矩阵是单位矩阵 也就是转置矩阵等于逆矩阵</p><p>一个正交矩阵的行和列之间分别构成了一组标准正交基，但如果使用一组正交基来构建一个矩阵的话，这个矩阵就不一定是正交矩阵</p><h1 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h1><p>包括平移，缩放，旋转等基础变换</p><p>复合变换，约定变换顺序：先缩放，再旋转，后平移</p><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/4.png"></p><h1 id="坐标系变换"><a href="#坐标系变换" class="headerlink" title="坐标系变换"></a>坐标系变换</h1><p>假设两个坐标空间A，B</p><p>从A空间变换到B空间的矩阵：就是A空间的X，Y，Z轴在父空间下的矢量表示  按列</p><p>B空间到A空间  就是按行</p><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/5.png"></p><h1 id="顶点的坐标空间变换过程"><a href="#顶点的坐标空间变换过程" class="headerlink" title="顶点的坐标空间变换过程"></a>顶点的坐标空间变换过程</h1><h2 id="模型空间"><a href="#模型空间" class="headerlink" title="模型空间"></a>模型空间</h2><p>每个物体自身的局部空间，Unity在模型空间是左手系，模型的顶点都是相对于模型空间的原点定义的</p><h2 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h2><h2 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h2><p>摄像机的本地空间，遵循右手系，符号OpenGL传统，摄像机的正前方指向的是-z轴方向。</p><p>观察空间是三维空间，屏幕空间是二维空间，通过投影变换进行转换</p><p>为了得到顶点在观察空间的位置，两种方法：</p><ol><li><p>计算观察空间3个坐标轴在世界空间下的表示，然后构建从观察空间变换到世界空间的变换矩阵，再对该矩阵进行求逆。</p></li><li><p>想象摄像机是从世界原点经过怎样的变换变换到现在的位置，然后用逆变换变换回去。</p></li></ol><h2 id="裁剪空间"><a href="#裁剪空间" class="headerlink" title="裁剪空间"></a>裁剪空间</h2><p>顶点接下来要从观察空间变换到裁剪空间，用于变换的矩阵为裁剪矩阵，也叫做投影矩阵</p><p>裁剪空间的目标是能够方便地对渲染图元进行裁剪，根据视锥体（view frustum）来决定裁剪范围。</p><p>视锥体由六个平面包围而成，是空间中的一块区域，决定了摄像机可以看到的空间。</p><p>其中有两种特殊的裁剪平面：近裁剪平面（near clip plane）和远裁剪平面（far clip plane）。</p><p>它们决定了摄像机可以看到的深度范围。</p><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/6.png"></p><p>投影矩阵有两个目的：</p><p>为投影做准备：真正的投影发生在后面的齐次除法中。经过投影变换后，顶点的w分量具有特殊的意义</p><p>对x，y，z分量进行缩放。经过投影矩阵的缩放后，可以直接使用w分量作为一个范围值，如果x，y，z分类都位于这个范围内，就说明顶点位于裁剪空间内。</p><p><a href="https://zhuanlan.zhihu.com/p/594103204">unity（shader入门精要）投影变换原理推导（保姆级）</a></p><h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p>通过Camera的Field of View（FOV）和Near，Far，Aspect（射线机的纵横比）决定</p><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/7.png"></p><p>得到的投影矩阵如下：</p><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/8.png"></p><p>这里的投影矩阵针对的是观察空间为右手坐标系，使用列矩阵在矩阵右侧相乘，且变换后z分量的范围在【-w，w】之间的情况。</p><p>本质上就是对x，y，z分量进行了不同程度的缩放，z分量进行了一个平移</p><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/9.png"></p><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/10.png"></p><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/11.png"></p><h3 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h3><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/12.png"></p><p>使用正交投影的投影矩阵对顶点进行变换后，w分量仍然为1。</p><p>本质是因为投影矩阵最后一行的不同，透视投影的投影矩阵的最后一行是 【0 0 -1 0】，正交投影的投影矩阵的最后一行是【0 0 0 1】</p><h2 id="屏幕空间"><a href="#屏幕空间" class="headerlink" title="屏幕空间"></a>屏幕空间</h2><p>经过投影矩阵变换后可以进行裁剪操作，裁剪后，需要进行真正的投影——把视锥体投影到屏幕空间&#x3D;&gt;得到真正的像素位置</p><h3 id="齐次除法（透视除法）"><a href="#齐次除法（透视除法）" class="headerlink" title="齐次除法（透视除法）"></a>齐次除法（透视除法）</h3><p>x，y，z都除w&#x3D;&gt;归一化的设备坐标NDC</p><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/13.png"></p><p>齐次除法后的立方体的x，y，z分量的范围都是【-1，1】 </p><p>DirectX中是【0，1】</p><h3 id="坐标映射"><a href="#坐标映射" class="headerlink" title="坐标映射"></a>坐标映射</h3><p>根据变换后的x，y坐标来映射窗口的像素坐标。</p><p>整体就是把【-1，-1】【0，0】分别映射到【0，0】【SCREENWIDTH，SCREENHEIGHT】</p><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/14.png"></p><p>z（clipz&#x2F;clipw）分量通常会被用于深度缓冲。</p><p>clipw作用：</p><ul><li><p>齐次除法的分母</p></li><li><p>透视校正插值</p></li></ul><h2 id="视口空间"><a href="#视口空间" class="headerlink" title="视口空间"></a>视口空间</h2><p>将【-1，1】的NDC映射到【0，1】的视口空间下</p><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/15.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/16.png"></p><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/17.png"></p><h1 id="法线变换"><a href="#法线变换" class="headerlink" title="法线变换"></a>法线变换</h1><p>使用顶点变换矩阵变换法线带来的问题：</p><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/18.png"></p><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/19.png"></p><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/20.png"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="Unity-Shader内置变量"><a href="#Unity-Shader内置变量" class="headerlink" title="Unity Shader内置变量"></a>Unity Shader内置变量</h1><p>内置的用于空间变换和摄像机以及屏幕参数的内置变量。可以在UnityShaderVariable.cginc文件中找到定义和说明。</p><h2 id="Unity内置的变换矩阵"><a href="#Unity内置的变换矩阵" class="headerlink" title="Unity内置的变换矩阵"></a>Unity内置的变换矩阵</h2><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/21.png"></p><p>Unity_MATRIX_T_MV：如果MV是正交矩阵&#x3D;&gt;逆矩阵&#x3D;转置矩阵&#x3D;&gt;MV矩阵的逆矩阵，将顶点和方向矢量从观察空间转换到模型空间</p><p>什么时候正交？</p><ul><li><p>只包含旋转</p></li><li><p>只包含旋转和缩放 缩放系数为k，则对应逆矩阵要乘以1&#x2F;k</p></li><li><p>只对方向矢量进行变换，忽略平移影响，只使用前三行和前3列来变换</p></li></ul><h2 id="摄像机和屏幕参数"><a href="#摄像机和屏幕参数" class="headerlink" title="摄像机和屏幕参数"></a>摄像机和屏幕参数</h2><p>Unity提供的访问当前正在渲染的摄像机的参数信息的内置变量：</p><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/22.png"></p><p><img src="/2023/04/23/Unity-Shader%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/23.png"></p><h1 id="CG语言中变量的一些注意点"><a href="#CG语言中变量的一些注意点" class="headerlink" title="CG语言中变量的一些注意点"></a>CG语言中变量的一些注意点</h1><p>通常右乘向量按照列矩阵进行乘法，Unity内置矩阵也都是按列存储的</p><p>CG矩阵初始化是按照行优先的顺序填充的，访问时也是按行索引</p><p>CG数据类型：向量float3、float4  矩阵类型：float3x3、float4x4等关键词进行声明和定义</p>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity Shader基础</title>
    <link href="/2023/04/23/Unity-Shader%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/04/23/Unity-Shader%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>本篇介绍的是ShaderLab文件的基础结构</p><span id="more"></span><h1 id="如何在编辑器使用？"><a href="#如何在编辑器使用？" class="headerlink" title="如何在编辑器使用？"></a>如何在编辑器使用？</h1><p>需要结合材质和unity shader来达到想要的效果。</p><ul><li><p>unity shader定义了渲染所需的各种代码（顶点着色器和片元着色器），属性（使用哪些纹理）和指令（渲染和标签设置）。</p></li><li><p>材质允许我们调节这些属性并赋给相应的模型</p></li></ul><p>Unity Shader模版：</p><ul><li><p>标准光照模型： Standard Surface Shader</p></li><li><p><strong>不包含光照（但包含雾效）：Unlit Shader  主要使用其作为练习</strong></p></li><li><p>实现屏幕后处理效果：Image Effect Shader</p></li><li><p>Compute Shader利用GPU的并行性来进行一些与常规渲染流水线无关的计算。</p></li></ul><p>如何使用？新建Unlit Shader：</p><p><img src="/2023/04/23/Unity-Shader%E5%9F%BA%E7%A1%80/1.png"></p><p>Default Maps：指定默认纹理，当任何材质第一次使用该Unity Shader时，纹理就会自动赋予到相应的属性上</p><h1 id="ShaderLab"><a href="#ShaderLab" class="headerlink" title="ShaderLab"></a>ShaderLab</h1><p>Unity为开发者提供的高层级的渲染抽象层</p><p><img src="/2023/04/23/Unity-Shader%E5%9F%BA%E7%A1%80/2.png"></p><p>使用ShaderLab，通过嵌套在花括号内部的语义（syntax）来描述Unity Shader文件的结构，这些结构包含了许多渲染所需的数据。不仅仅是着色器代码</p><h1 id="Unity-Shader结构"><a href="#Unity-Shader结构" class="headerlink" title="Unity Shader结构"></a>Unity Shader结构</h1><h2 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h2><p>Shader “Custom&#x2F;Myshader”{}</p><p>对应出现在材质面板中的位置是：Shader-&gt;Custom-&gt;MyShader</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>通过Properties定义的属性将会出现在材质面板中，可供调节</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">Properties&#123;<br>Name (&quot;display name&quot;, PropertyType) = DefaultValue<br>Name (&quot;display name&quot;, PropertyType) = DefaultValue<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>Name一般以 _XX 形式，方便编写代码调用  </p><p>display name 是实际面板上显示的名字</p><p>PropertyType指定属性类型</p><p><img src="/2023/04/23/Unity-Shader%E5%9F%BA%E7%A1%80/3.png"></p><h2 id="SubShader"><a href="#SubShader" class="headerlink" title="SubShader"></a>SubShader</h2><p>至少要有一个或多个SubShader语义块，会选择第一个能够在目标平台上运行的SubShader，若都不支持则使用Fallback语义指定的Unity Shader</p><p><strong>结构</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">SubShader&#123;<br>[Tags]<br>[RenderSetup]<br>Pass&#123;<br>&#125;<br>//other Passes<br>&#125;<br></code></pre></td></tr></table></figure><p>应尽量使用最小数目的Pass</p><p><strong>RederSetup选项</strong>：（可以单独写在Pass里进行不同设置）</p><p><img src="/2023/04/23/Unity-Shader%E5%9F%BA%E7%A1%80/4.png"></p><p><strong>Tags标签</strong>：</p><p>键值对，都是字符串类型，包括以下类型：</p><p><img src="/2023/04/23/Unity-Shader%E5%9F%BA%E7%A1%80/5.png"></p><p><strong>Pass语义块</strong>：</p><p>结构：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">Pass&#123;<br>[Name] //定义Pass名称 &quot;MyPassName&quot;<br>[Tages]<br>[RenderSetup]<br>//other code<br>&#125;<br></code></pre></td></tr></table></figure><p>定义名称后可以通过 UsePass “MyShader&#x2F;MYPASSNAME”来实现复用，使用其他Unity Shader中的Pass（自动转为大写）。</p><p>Pass中的Tages类型：</p><p><img src="/2023/04/23/Unity-Shader%E5%9F%BA%E7%A1%80/6.png"></p><p>其他的Pass:  UsePass（复用），GrabPass（抓取屏幕存在纹理中用于后续Pass处理）</p><h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><p>其他的SubShader都无法运行情况下使用</p><p>结构：</p><p>Fallback “names”</p><p>Fallback Off</p><h1 id="Unity-Shader着色器"><a href="#Unity-Shader着色器" class="headerlink" title="Unity Shader着色器"></a>Unity Shader着色器</h1><p>着色器代码可以写在SubShader语义块中（表面着色器做法），也可以写在Pass语义块中（顶点、片元着色器和固定函数着色器做法）</p><blockquote><p>《Shaders must die》是Unity的渲染工程师Aras所发表的博客，他认为顶点着色器和片元着色器是一种非常反人类的设计方式，虽然对硬件来说非常友好，但是不便于学习和理解。所以他设计了一种新的着色器结构，将原本的顶点着色器和片元着色器合并为同一个着色器，称之为表面着色器。</p></blockquote><blockquote><p>相比于顶点和片元着色器，表面着色器为着色器增加了一层新的抽象。相比于之前的顶点和片元着色器，表面着色器更为高级（这里的高级不是好与不好，类似于Python是一门高级语言而汇编是一门低级语言）</p></blockquote><p>表面着色器无需写在pass中，示例如下：</p><p><img src="/2023/04/23/Unity-Shader%E5%9F%BA%E7%A1%80/7.png"></p><p>顶点&#x2F;片元着色器也需要定义在CGPROGRAM和ENDCG直接，需要写在Pass语义块中，示例如下：</p><p><img src="/2023/04/23/Unity-Shader%E5%9F%BA%E7%A1%80/8.png"></p><p>Unity Shader是使用ShaderLab语言编写的，但是可以在ShaderLab内部嵌套CG&#x2F;HLSL代码来编写着色器代码</p><p>格式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">Pass &#123;<br>//Pass的标签和状态设置<br>CGPROGRAM<br>//编译指令，例如：<br>#pragma vertex vert<br>#pragma fragment frag<br>//CG代码<br>ENDCG<br>//其他的一些设置<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识Unity Shader</title>
    <link href="/2023/04/23/%E5%88%9D%E8%AF%86Unity-Shader/"/>
    <url>/2023/04/23/%E5%88%9D%E8%AF%86Unity-Shader/</url>
    
    <content type="html"><![CDATA[<p>本系列参考《Unity Shader入门精要》，记录学习笔记以备复习<br>本篇介绍的是渲染流水线各阶段的概念</p><span id="more"></span><h1 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h1><p><strong>输入是一个虚拟摄像机、一些光源、一些shader以及纹理</strong></p><p><strong>输出渲染一张二维纹理</strong></p><p>分为三个阶段：应用阶段(Application Stage)、几何阶段(Geometry Stage)、光栅化阶段(Rasterizer Stage)</p><p><img src="/2023/04/23/%E5%88%9D%E8%AF%86Unity-Shader/1.png"></p><ul><li><p>GPU流水线上一些可高度编程的阶段，而由着色器编译出来的最终代码是会在 GPU上运行的（对于固定管线的渲染来说，着色器有时等同于一些特定的渲染设置);</p></li><li><p>有一些特定类型的着色器，如顶点着色器、片元着色器等;</p></li><li><p>依靠着色器我们可以控制流水线中的渲染细节,例如用顶点着色器来进行顶点变换以及传递数据，用片元着色器来进行逐像素的渲染。</p></li></ul><h2 id="应用阶段"><a href="#应用阶段" class="headerlink" title="应用阶段"></a>应用阶段</h2><ol><li><p>准备好场景数据</p></li><li><p>粗粒度剔除(culling)工作，以把那些不可见的物体剔除出去</p></li><li><p>设置好每个模型的渲染状态。</p></li></ol><p>输*：渲染所需的几何信息，即**渲染图元（rendering primitives)**。通俗来讲，渲染图元可以是点、线、三角面等。这些渲染图元将会被传递给下一个阶段——几何阶段。</p><p>应用阶段大致可分为下面3个阶段:</p><ol><li><p>把数据加载到显存中。</p></li><li><p>设置渲染状态。</p></li><li><p>调用Draw Call</p></li></ol><h3 id="渲染状态"><a href="#渲染状态" class="headerlink" title="渲染状态"></a>渲染状态</h3><p>定义了场景中的网格是怎样被渲染的。例如，使用哪个顶点着色器（Vertex Shader)&#x2F;片元着色器(Fragment Shader)、光源属性、材质等。如果我们没有更改渲染状态，那么所有的网格都将使用同一种渲染状态。</p><h3 id="Draw-Call"><a href="#Draw-Call" class="headerlink" title="Draw Call"></a>Draw Call</h3><p>实际上，Draw Call就是一个命令，它的发起方是 CPU，接收方是GPU。这个命令仅仅会指向一个需要被渲染的图元(primitives)列表,而不会再包含任何材质信息——这是因为我们已经在上一个阶段中完成了</p><h2 id="几何阶段"><a href="#几何阶段" class="headerlink" title="几何阶段"></a>几何阶段</h2><ul><li><p>通常在GPU上进行</p></li><li><p>几何阶段负责和每个渲染图元打交道，进行逐顶点、逐多边形的操作</p></li><li><p>几何阶段的一个重要任务就是把顶点坐标变换到屏幕空间中，再交给光栅器进行处理</p></li></ul><p>输出：屏幕空间的二维顶点坐标、每个顶点对应的深度值、着色等相关信息，并传递给下一个阶段。</p><h2 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h2><ul><li><p>GPU 上运行</p></li><li><p>光栅化的任务主要是决定每个渲染图元中的哪些像素应该被绘制在屏幕上。</p></li><li><p>它需要对上一个阶段得到的逐顶点数据（例如纹理坐标、顶点颜色等)进行插值，然后再进行逐像素处理。</p></li></ul><h1 id="GPU流水线"><a href="#GPU流水线" class="headerlink" title="GPU流水线"></a>GPU流水线</h1><p><img src="/2023/04/23/%E5%88%9D%E8%AF%86Unity-Shader/2.png"></p><p>GPU的渲染流水线实现。颜色表示了不同阶段的可配置性或可编程性:绿色表示该流水线阶段是完全可编程控制的，黄色表示该流水线阶段可以配置但不是可编程的，蓝色表示该流水线阶段是由GPU固定实现的，开发者没有任何控制权。实线表示该Shader必须由开发者编程实现，虚线表示该Shader是可选的</p><h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><p>输入：来自cpu</p><p>处理单位：顶点</p><p>完成工作：坐标变换和逐顶点光照。</p><p>把顶点坐标从模型空间转换到齐次裁剪空间，然后由硬件做透视除法，得到归一化的设备坐标</p><h2 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h2><p>剔除不在视野内的物体，只需要将图元裁剪到单位立方体内</p><h2 id="屏幕映射"><a href="#屏幕映射" class="headerlink" title="屏幕映射"></a>屏幕映射</h2><p>任务：把每个图元的x和y坐标转换到屏幕坐标系下，一个缩放的过程。输入坐标范围是-1和1之间，对于输入的z坐标不做任何处理。</p><p>屏幕坐标系和z坐标一起构成了一个坐标系——窗口坐标系，这些值会一起传递到光栅化阶段。</p><p><strong>屏幕坐标系差异</strong>：opengl左下角作为最小坐标，directx定义左上角为最小坐标 （0,0）</p><p>下面开始进入光栅化阶段</p><p>输入：屏幕坐标系下的顶点位置以及额外信息：z，normal，viewdir etc.</p><p>光栅化目标：计算每个图元覆盖像素，计算颜色</p><h2 id="三角形设置"><a href="#三角形设置" class="headerlink" title="三角形设置"></a>三角形设置</h2><p>计算三角网格表示数据的过程，得到三角形边界的表示方式</p><h2 id="三角形遍历"><a href="#三角形遍历" class="headerlink" title="三角形遍历"></a>三角形遍历</h2><p>也称为扫描变换，检测每个像素是否被一个三角网格覆盖，如果被覆盖的话，生成一个片元。</p><p>片元中的状态是通过对三个顶点的信息进行插值得到的。</p><h2 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h2><p>directx中称为像素着色器。</p><p>输入：上一阶段对顶点信息插值的结果</p><p>输出：一个或者多个颜色值</p><p>仅可以影响单个片元</p><h2 id="逐片元操作"><a href="#逐片元操作" class="headerlink" title="逐片元操作"></a>逐片元操作</h2><p>directx中称为输出合并阶段。</p><p>任务：</p><p>决定每个片元的可见性，包括深度测试，模版测试 测试顺序不唯一，可以提前深度测试</p><p>片元通过测试后需要将其颜色与存储在颜色缓冲区中的颜色混合。</p><p>对于不透明物体可以关闭混合操作。对于半透明物体需要使用混合操作使其看起来是透明的。</p><p>当模型的图元通过上述计算和测试后就会显示在屏幕上。GPU使用双重缓冲技术，保证看到的图像是连续的。</p><h2 id="何为shader？"><a href="#何为shader？" class="headerlink" title="何为shader？"></a>何为shader？</h2><p>具体来说，shader就是：</p><ul><li><p>GPU上可高度编程的阶段</p></li><li><p>有一些特定类型的着色器</p></li><li><p>依靠着色器我们可以控制流水线中的渲染细节</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>光线追踪(三) 微平面理论</title>
    <link href="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/"/>
    <url>/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>基于物理的渲染：微平面理论（Cook-Torrance BRDF推导)</p><span id="more"></span><h1 id="辐射度量基础概念总结"><a href="#辐射度量基础概念总结" class="headerlink" title="辐射度量基础概念总结"></a>辐射度量基础概念总结</h1><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/1.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/2.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/3.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/4.png"></p><h1 id="微平面理论"><a href="#微平面理论" class="headerlink" title="微平面理论"></a>微平面理论</h1><p>微平面理论(Microfacets Theory)顾名思义，就是从微观的角度去分析，其认为任意物体的表面在到达微观的尺度之后，都是由许许多多的更小的<strong>镜面</strong>所组成的</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/5.png"></p><p>当这些微小的镜面的法线方向较为集中一致的时候，从宏观角度来看，物体的镜面反射会比较明显，反之，当这些微小镜面的法线方向较为杂乱，分布均匀的时候，物体表面则会相对粗糙。如下图所示：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/6.png"></p><p>（上方图中，微平面的镜面法线方向比较集中，下方图中微平面的镜面法线方向比较分散）</p><p>对于微观尺度的漫反射可以作如下解释，当光线照射到物体表面时，一部分光线会与表面的许许多多的微小镜面发生镜面反射，另一部分光线则会折射进入物体内部，如下图：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/7.png"></p><p>当光线折射进入内部的时候会与物体的微小粒子不断发生碰撞并散射到随机方向，同时在碰撞的过程中一部分光线的能量会被吸收转换为热能，有些光线在多次碰撞之后能量消耗殆尽，则表示该光线完全被物体吸收。还有一部分折射到物体内部的光线会因为散射方向的随机性重新离开表面，而这部分光线就形成了漫反射。 (tips:光线折射进入物体内部之后再被散射出来，离开表面的点可能并不是进入表面的点，但这里并不考虑这种情形，次表面散射(Subsurface Scattering)技术则将这种现象考虑了进去。)</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/8.png"></p><h1 id="Cook-Torrance-BRDF推导"><a href="#Cook-Torrance-BRDF推导" class="headerlink" title="Cook-Torrance BRDF推导"></a>Cook-Torrance BRDF推导</h1><h2 id="漫反射项推导"><a href="#漫反射项推导" class="headerlink" title="漫反射项推导"></a>漫反射项推导</h2><p>漫反射会均匀的向每个方向反射，因此，漫反射的BRDF一定是一个常数。假设入射光是均匀且遍布整个半球方向，可以得到如下方程：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/9.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/10.png"></p><h2 id="镜面反射项推导"><a href="#镜面反射项推导" class="headerlink" title="镜面反射项推导"></a>镜面反射项推导</h2><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/11.png"></p><p><strong>函数D：法线分布函数(Normal Distribution Function)，其代表了所有微观角度下微小镜面法线的分布情况，粗糙表面法线分布相对均匀，光滑表面法线分布相对集中 (这种解释可能会有些抽象，后面会给出更加直观的物理上的解释)</strong></p><p><strong>函数G：几何函数(Geometry Function)，描述了微平面自遮挡的属性。当一个平面相对比较粗糙的时候，平面表面上的微平面有可能挡住其他的微平面从而减少表面所反射的光线。</strong></p><p><strong>函数F：菲涅尔方程(Fresnel Rquation)，描述了物体表面在不同入射光角度下反射光线所占的比率</strong></p><p>可以看出无论是几何函数G，还是菲涅尔方程F，都是由于观察方向，入射方向的不同所导致的只有部分光线能够被反射</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/12.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/13.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/14.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/15.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/16.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/17.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/18.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/19.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/20.png"></p><h2 id="菲涅尔方程与几何函数的补充"><a href="#菲涅尔方程与几何函数的补充" class="headerlink" title="菲涅尔方程与几何函数的补充"></a>菲涅尔方程与几何函数的补充</h2><h3 id="菲涅尔方程"><a href="#菲涅尔方程" class="headerlink" title="菲涅尔方程"></a>菲涅尔方程</h3><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/21.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/22.png"></p><h3 id="几何函数"><a href="#几何函数" class="headerlink" title="几何函数"></a>几何函数</h3><p>几何函数G是为了表示微平面的自遮挡从而引起的光线损失，一般会出现如下两种的遮挡情况</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/23.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%89-%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA/24.png"></p>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>光线追踪</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>光线追踪(二) 辐射度量，BRDF，渲染方程，蒙特卡洛路径追踪</title>
    <link href="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/"/>
    <url>/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/</url>
    
    <content type="html"><![CDATA[<p>基于物理渲染的基础知识，包括辐射度量学，BRDF和渲染方程</p><span id="more"></span><h1 id="为什么需要辐射度量学"><a href="#为什么需要辐射度量学" class="headerlink" title="为什么需要辐射度量学"></a>为什么需要辐射度量学</h1><p>首先，想一想到目前为止我们对光线亮度的定义是什么？只是简单的用3维(R,G,B)向量来描述，但却没有任何的单位，如果想要一个完全正确的模型，这显然是不应该的，必须用合适的物理量来描述光线。</p><p>其次，考虑whited-style光线追踪模型，它真的是一个正确的模型吗？显然不是，原因如下：</p><p><strong>1 whited-style光线追踪并没有对漫反射的光线进行追踪，而是直接返回当前着色点颜色</strong></p><p><strong>2 在计算光源直接照射的贡献时，使用了Blinn-Phong模型，而Blinn-Phong模型本身就是一个不准确的经验模型，使用的这种模型的whited-style光线追踪自身自然也是不正确的</strong></p><h1 id="辐射度量学概念"><a href="#辐射度量学概念" class="headerlink" title="辐射度量学概念"></a>辐射度量学概念</h1><p>辐射度量学其实是对光照的一套测量系统和单位，它能够准确的描述光线的物理性质。</p><p>具体来说，我们需要明白的是其中的几个关于光线的概念，分别为： <strong>辐射能量(Radiant energy)，辐射通量(Radiant flux)，辐射强度(Radiant intensity)，irradiance，radiance</strong>，(对后两种概念没有合适的中文，所以就直接用英文了)，接下来就对这些概念进行具体解释。</p><h2 id="辐射能量-Radiant-energy-和辐射通量-Radiant-flux"><a href="#辐射能量-Radiant-energy-和辐射通量-Radiant-flux" class="headerlink" title="辐射能量(Radiant energy)和辐射通量(Radiant flux)"></a><strong>辐射能量(Radiant energy)和辐射通量(Radiant flux)</strong></h2><h3 id="辐射能量"><a href="#辐射能量" class="headerlink" title="辐射能量"></a>辐射能量</h3><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/1.png"></p><p>辐射能量其实非常直观，就是辐射出来的电磁能量，单位为焦耳。可以用物理当中的做功的大小来进行类比。</p><h3 id="辐射通量"><a href="#辐射通量" class="headerlink" title="辐射通量"></a>辐射通量</h3><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/2.png"></p><p>所谓辐射通量或者说辐射功率，其实就是在辐射能量的基础之上除以时间，也就是单位时间的能量。同样也可以用物理当中的功率来进行类比。</p><p>(tips: 具体来说一般偏向用radiant flux来衡量光线的亮度，因为我们更关心的是单位时间的效果，事实上也是这么做的，想想在说白炽灯泡的时候也是说60W亮度，80W亮度)</p><h2 id="辐射强度-Radiant-intensity"><a href="#辐射强度-Radiant-intensity" class="headerlink" title="辐射强度(Radiant intensity)"></a><strong>辐射强度(Radiant intensity)</strong></h2><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/3.png"></p><p><strong>1 Radiant itensity其实就是指从一个光源出发某一方向上的亮度</strong></p><p><strong>2 Irradiance指某一微小平面所接受到的光线亮度</strong></p><p><strong>3 radiance衡量的是一条传播光线所具有的亮度(不受传播方向影响而改变)</strong></p><h3 id="Radiant-itensity"><a href="#Radiant-itensity" class="headerlink" title="Radiant itensity"></a>Radiant itensity</h3><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/4.png"></p><p>Radiant intensity一句话来说就是从光源发出的<strong>每单位立体角上的功率</strong>，关于辐射功率的定义在上文已经解释，这里唯一还不知道的就是立体角(solid angle)了。</p><p>solid angle其实就是对应二维空间中圆的弧度在三维空间中球上的拓展。 首先看在二维计算弧度公式如下：</p><p>那么对应在三维上的球的弧度(立体角)，只需进行一个简单的扩展如下：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/5.png"></p><p>那么对于Radiant intensity的定义当中，微分立体角dw计算如下:<br>推导过程：[<a href="https://zhuanlan.zhihu.com/p/450731138]">https://zhuanlan.zhihu.com/p/450731138]</a></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/6.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/7.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/8.png"></p><h2 id="irradiance"><a href="#irradiance" class="headerlink" title="irradiance"></a>irradiance</h2><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/9.png"></p><p>irradiance是指每单位<strong>照射</strong>面积所接收到的power，单位如图中所示。 借助于irradiance，可以很轻松的解释在Blinn-Phong所提到的Lambert’s Law,即光线亮度在计算时需要乘上一个cos，如下图所示：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/10.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/11.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/12.png"></p><p>此外，回想一下也是在Blinn-Phong模型所提到的光线越远会越加衰减：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/13.png"></p><p>该现象也完全可以用irradiance解释，因为光的功率始终一致，离点光源所照射到的圆球面积也就越大，因此根据irradiance的式子，分母的面积值也就越大，irradiance也就越小。</p><h2 id="radiance"><a href="#radiance" class="headerlink" title="radiance"></a>radiance</h2><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/14.png"></p><p>用一句话概述的话，所谓radiance就是指<strong>每单位立体角，每单位垂直面积的功率</strong>，直观来看的话，很像是Intensity和irradiance的结合。<strong>它同时指定了光的方向与照射到的表面所接受到的亮度</strong>。</p><p>但这里有一个细微的区别，在irradiance中定义的<strong>每单位照射面积</strong>，而在radiance当中，为了更好的使其成为描述一条光线传播中的亮度，且在传播过程当中大小不随方向改变，所以在定义中关于接收面积的部分是<strong>每单位垂直面积</strong>，具体可以观察如下图：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/15.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/16.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/17.png"></p><p>&#x3D;&gt;</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/18.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/19.png"></p><h1 id="BRDF-双向反射分布函数）"><a href="#BRDF-双向反射分布函数）" class="headerlink" title="BRDF(双向反射分布函数）"></a>BRDF(双向反射分布函数）</h1><p>通过上述所有辐射度量学各种概念的定义之后，我们可以从这样一个角度理解光线的反射，如下图所示：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/20.png"></p><p><img src="/21.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/22.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/23.png"></p><h1 id="反射方程"><a href="#反射方程" class="headerlink" title="反射方程"></a>反射方程</h1><p>借助BRDF，可以得到反射方程如下：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/24.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/25.png"></p><p>到这里，通过辐射度量学，以及BRDF最终得到的反射方程正是一个<strong>完全正确的光线传播模型了</strong>，解决了在第一章提到的现有模型的所有缺点！（渲染方程只是在反射方程的基础之上加了一个自发光项）</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/26.png"></p><p>入射光线的radiance不仅仅是光源所引起的，还有可能是其他物体上着色点的反射光线的radiance，恰好反射到当前的着色点p(即间接光照)，同时其他物体上的反射光线的radiance依然也是由直接光照和间接光照构成，因此这与whitted-style当中的光线追踪过程十分类似，也是一个递归的过程。所以说想要解这样一个方程还是比较难的</p><h1 id="渲染方程及其物理含义解释"><a href="#渲染方程及其物理含义解释" class="headerlink" title="渲染方程及其物理含义解释"></a>渲染方程及其物理含义解释</h1><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/27.png"></p><p>不同情况：</p><p>一个点光源，单个物体：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/28.png"></p><p>(点光源对一个点来说自然只有一个方向有入射光，所以这里没有了积分)</p><p>多个点光源，单个物体</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/29.png"></p><p>将这些所有的点光源的贡献全部求和即可，那么如果点光源变成了面光源呢？如下图所示：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/30.png"></p><p>其实面光源就相当于无穷多个点光源的集合，只需要对 面光源所在的立体角范围进行积分，并且能够确定不同立体角方向的面光源的入射光radiance即可。</p><p>那么更进一步的，再在场景当中加入其它物体，使得物体之间发生光线交互之后是什么情况呢：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/31.png"></p><p>如上图所示，可以把其它物体同样考虑成面光源，对其所占立体角进行积分即可，只不过对其它物体的立体角积分不像是面光源所有入射方向都有radiance，物体的立体角可能只有个别几个方向有入射的radiance(即多次物体间光线反射之后恰好照射到着色点x)，其它方向没有，但本质上都可以视作是面光源。</p><p>这里就类似用了递归思想了</p><p>观察一下图中的渲染方程可以发现除了两个radiance，其它所有项都是知道的，可以将上式进一步写成如下图下方所示的式子：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/32.png"></p><p>其中各项与原渲染方程中一一对应，(这里其实是有数学严格推导的，不过我们只是为了接下来构建直观的物理解释，对于这些推导不必在意，默认成立即可)，再接着，可以把该式子离散化写为线性代数的形式：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/33.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/34.png"></p><p>仔细观察这个式子，注意E是光源所发出的光，K为反射算子，这样一个式子的物理含义如下图所示：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/35.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/36.png"></p><h1 id="蒙特卡洛路径追踪"><a href="#蒙特卡洛路径追踪" class="headerlink" title="蒙特卡洛路径追踪"></a>蒙特卡洛路径追踪</h1><p>如何解渲染方程？ 利用蒙特卡洛路径追踪来完成这个目标。</p><h2 id="蒙特卡洛积分"><a href="#蒙特卡洛积分" class="headerlink" title="蒙特卡洛积分"></a>蒙特卡洛积分</h2><p><strong>蒙特卡洛积分的目的：</strong> 当一个积分很难通过解析的方式得到答案的时候可以通过蒙特卡洛的方式近似得到积分结果，如下图所示：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/37.png"></p><p>显然对于这样一个函数，很难去用一个数学式子去表示，因此无法用一般解析的方法直接求得积分值，而这时候就可以采用蒙特卡洛的思想了。</p><p><strong>蒙特卡洛积分的原理及做法：</strong> 对函数值进行多次采样求均值作为积分值的近似</p><p>该做法十分容易理解，想象一下如果对上图这个函数值进行<strong>均匀采样</strong>的话，其实就相当于将整个积分面积切成了许许多多个长方形，然后将这些小长方形的面积全部加起来。没错，该做法其实就与黎曼积分的想法几乎一致。但蒙特卡洛积分更加的general，因为它可以指定一个分布来对被积分的值进行采样，定义如下：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/38.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/39.png"></p><p>但在本文中为了方便，所有的采样都使用均匀采样，因此很容易推出：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/40.png"></p><p>因此，<strong>蒙特卡洛在此来说就是一个帮助求得困难积分值的方法</strong>。</p><h2 id="蒙特卡洛路径追踪-1"><a href="#蒙特卡洛路径追踪-1" class="headerlink" title="蒙特卡洛路径追踪"></a>蒙特卡洛路径追踪</h2><p>在进入具体计算之前，对渲染方程做出一点小修改，即舍弃一下自发光项(因为除了光源其他物体不会发光), 以方便进行计算推导：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/41.png"></p><p>从具体例子出发，首先仅仅考虑直接光照：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/42.png"></p><p>再次观察该修改过之后的方程其实就只是一个单纯的积分计算</p><p>，其物理含义为着色点p到摄像机或人眼的Radiance值。</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/43.png"></p><p>此时的计算伪代码如下：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/44.png"></p><p>显而易见的，单独仅仅考虑直接光照自然是不够的，还需要间接光照，即当采样的wi方向碰撞到了别的物体，如下图所示：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/45.png"></p><p>此时采样的光线碰撞到了另一个物体的Q点，那么该条路径对着色点P的贡献是多少呢？自然是在点Q的直接光照再乘上反射到该方向上的百分比了！显然这是一个类似光线追踪的递归过程，不同在于该方法通过对光线方向的采样从而找出一条条可行的路径，这也正是为什么叫路径追踪的原因，伪代码如下：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/46.png"></p><p>至此，我们成功通过蒙特卡洛的方式解出了渲染方程的积分值，也通过考虑直接光照与间接光照解决了递归的问题。但该方法至此有一个非常致命的缺陷：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/47.png"></p><p>我们通过每次对光线方向的采样从而解出方程，假设每次采样100条，那么从人眼出发的第一次采样就是100条，在进行第二次反射之后就是10000条，依次类推，反射越多次光线数量便会爆炸增长，计算量会无法负担，那么如何才能使得光线数量不爆炸增长呢？<strong>唯有每次只采样一个方向！N&#x3D;1</strong></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/48.png"></p><p>每次如果只采样一个方向那么所带来的问题也是显而易见的，积分计算的结果会非常的noisy，虽然蒙特卡洛积分是无偏估计，但样本越少显然偏差越大。但该问题很好解决，如果每次只去寻找一条路径结果不好，那么重复多次寻找到多条路径，将多条路径的结果求得平均即可！如下图所示：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/49.png"></p><p>改良之后的Path Tracing伪代码如下：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/50.png"></p><p>通过对经过像素的光线重复采样，每次在反射的时候只按分布随机选取一个方向，解决了只对经过像素的光线采样一次，而对反射光线按分布采样多次所导致的光线爆炸问题。</p><p>那么现在所有的问题都解决了吗？还没有！因为shade函数的递归没有出口，永远不会停下。 但这里并不没有采用类似光线追踪当中设定反射深度显示的给出递归出口的方法，而是非常精妙的采用了**俄罗斯轮盘赌(Russian Roulette)**。</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/51.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/52.png"></p><p>shade函数的伪代码变更如下，使得可以停止递归了：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/53.png"></p><p>至此，我们的路径追踪算法已经完成大半，只差最后一个小问题！现在的路径追踪效率非常的低下，如图所示：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/54.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/55.png"></p><p>pdf：概率密度函数</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/56.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/57.png"></p><p>tips:计算直接光照的时候还需要判断光源与着色点之间是否有物体遮挡，该做法也很简单，只需从着色点x向光源采样点x’发出一条检测光线判断是否与光源之外的物体相交即可，如图所示:</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%BA%8C-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%EF%BC%8CBRDF%EF%BC%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%EF%BC%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/58.png"></p>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>光线追踪</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>光线追踪(一) Whitted-style Ray Tracing</title>
    <link href="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/"/>
    <url>/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/</url>
    
    <content type="html"><![CDATA[<p>Whitted-style Ray Tracing</p><span id="more"></span><p>主要参考链接：</p><p><a href="https://zhuanlan.zhihu.com/p/144403005">计算机图形学十二：Whitted-Style光线追踪原理详解及实现细节</a></p><p><a href="https://blog.csdn.net/weixin_45712636/article/details/123117170?spm=1001.2014.3001.5502">计算机图形学GAMES101（十四）光线追踪（辐射度量学、渲染方程与全局光照）_辐射度量学与图形学_momohola的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_45712636/article/details/123829907">计算机图形学GAMES101（十五）光线追踪（蒙特卡洛积分与路径追踪）_momohola的博客-CSDN博客</a></p><p>作业解析：</p><p><a href="https://blog.csdn.net/Q_pril/article/details/123825665">Games101：作业5解析-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/471277532">Games 101 | 作业5 + 光线追踪 Ray Tracing</a></p><h1 id="Whitted-Style-Ray-Tracing"><a href="#Whitted-Style-Ray-Tracing" class="headerlink" title="Whitted-Style Ray Tracing"></a>Whitted-Style Ray Tracing</h1><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么?"></a>为什么?</h2><ul><li><p><strong>光栅化很难处理全局光照</strong>（也有一些奇技淫巧，但是不能保证正确性）</p><ul><li><p>Soft Shadows</p></li><li><p>Glossy reflection</p></li><li><p>Indirect Illumination</p></li></ul></li><li><p>光栅化：快速近似、质量低</p></li><li><p>光线追踪：准确、非常慢</p><ul><li><p>offline渲染</p></li><li><p>实际生产中，渲染电影的一帧&#x3D;～10000CPU小时</p></li></ul></li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>首先对光线进行一些假设：</p><ul><li><p>光线一定沿着直线传播</p></li><li><p>光线之间无法碰撞</p></li><li><p>光线路径可逆，即从A发出的到B的光线，一定也可以从B发出到A（中途可发生反射和折射）</p></li></ul><p>考虑一下对光线的第三条假设：<strong>光路可逆</strong>，所有进入到人眼的光，都可从人眼发出光按照原路反方向返回，那么利用这种模拟从人眼发射光线的方法不就可以还原出所有的光路了呢？没错这就是光线追踪的核心想法，从光源出发难以模拟那就反着从摄像机发射光线！</p><h3 id="Ray-Casting"><a href="#Ray-Casting" class="headerlink" title="Ray Casting"></a>Ray Casting</h3><p>从人眼或摄像机向近投影平面上的每一个像素点发射一条光线，判断与场景物体的交点。当然一条光线自然可能会与不止一个物体相交，但是考虑遮挡关系，只去找最近的交点。接着连接该交点和光源，只要判断这条连线之间是否有物体存在就可以知道该交点是否在阴影之中。</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/1.png"></p><p>紧接着，自然可以利用Blinn-Phong模型对这个点进行局部光照模型计算，得到该像素的颜色，那么遍历所有近投影平面上的像素就能得到一张完整的图像。但如果光线追踪仅仅是在第一步Ray Casting就停止的话，那么它的效果与局部光照模型是一样的，因此我们需要第二步，真正的考虑全局效果</p><h3 id="Recursive-Whitted-Style-Ray-Tracing"><a href="#Recursive-Whitted-Style-Ray-Tracing" class="headerlink" title="Recursive (Whitted-Style) Ray Tracing"></a><strong>Recursive (Whitted-Style) Ray Tracing</strong></h3><p>考虑第一步中所做的Ray Casting，该条光线第一个与圆球物体相交，假设该圆球是一个玻璃球，那么便会发生镜面反射和折射。反射与折射出去的光线会可能与场景中的物体再次碰撞，发生第二次折射与反射。</p><p>光线弹射多次：Recursive (Whitted-Style) Ray Tracing</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/2.png"></p><p>从图中可以见到，不仅仅是与圆球相交的那一点可以贡献光到达眼睛，折射与反射之后再与物体相交的点也可以贡献光(<strong>光路可逆原理</strong>)。简而言之，除了直接从光源照射到圆球交点再沿着 eye rays(从眼睛发射的第一条光线)到眼睛中，也可能存在这样一种情形，有光照射到其他物体，再沿着eye rays的反射或折射的光线方向传回人眼！</p><p>因此<strong>每一个</strong>交点的颜色贡献来自这样种几类型 <strong>直接光照，反射方向间接光，折射方向间接光（如果有折射的话）</strong></p><p>下一步将这些所有交点与光源连接，称这些线为shadow rays（因为可以用来检测阴影），计算这些所有点的局部光照模型的结果，将其按照光线能量权重累加(该做法与递归过程等价)，最终得到近投影平面上该像素点的颜色！而这就是一个考虑全局效果的光照模型了，因为不仅仅考虑了直接光源的贡献，还考虑各种折射与反射光线的贡献。</p><p>以上就是光线追踪的整个过程了，还有额外几点要注意的 tips：</p><ol><li><p>整体过程是一个递归的过程，因此需要一定的递归终止条件，比如说允许的最大反射或折射次数为10。</p></li><li><p>光线在每次反射和折射之后都有能量损耗的，由系数决定，因此越往后的折射和反射光贡献的能量越小，这也是为什么在上文中提到根据光线能量权重求和。 e.g. 反射系数为0.7，那么第一次反射折损30%，第二次反射折损1-（70%x70%），依次类推。</p></li><li><p>如果反射或折射光线没有碰撞到物体，一般直接返回一个背景色</p></li></ol><p>参考伪代码如下：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/3.png"></p><h1 id="光线的表示方法"><a href="#光线的表示方法" class="headerlink" title="光线的表示方法"></a>光线的表示方法</h1><p>我们可以将每一条光线想象成一条射线，那么每一条光线都会由起点及方向这两个属性所固定，如下图所示：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/4.png"></p><p>起点o，方向d</p><h1 id="光线如何与物体求交"><a href="#光线如何与物体求交" class="headerlink" title="光线如何与物体求交"></a>光线如何与物体求交</h1><h2 id="隐式表面求交"><a href="#隐式表面求交" class="headerlink" title="隐式表面求交"></a>隐式表面求交</h2><p>首先介绍如何计算光线与隐式曲面的交点的方法，以一个球体为例，二者表示方程如下：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/5.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/6.png"></p><p>同样的根据b2-4ac 的正负关系，即可判断光线与球是一个交点还是两个交点又或是没有交点</p><p>进一步推广到隐式表面</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/7.png"></p><h2 id="显式表面求交"><a href="#显式表面求交" class="headerlink" title="显式表面求交"></a>显式表面求交</h2><p>真正在图形学中大量运用的其实是显示曲面，更具体来说就是许许多多个三角形，因此如何判断一条光线与显示曲面的交点，其实也就是计算光线与三角形面的交点。对于任意一个平面，可以用如下图中的式子表达：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/8.png"></p><p>图中对于平面方程的讲解已经很清楚。那么到这里其实已经成功把对显示曲面的求交又转化为了类似隐式曲面求交的方法，对于任意一个三角面来说，它一定处于一个平面之上，只需求出光线与平面的交点，再判断该交点是否在三角形内，就可以得到光线是否与三角形面相交的结果了！</p><p>首先给出如何计算光线与平面交点的过程：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/9.png"></p><p>得到参数 t 之后，自然可以计算出交点，并且再去计算出重心坐标就能判断该交点是否在三角形内了，但是这种方法略显繁琐，能不能一步就得到结果呢？当然可以！</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/10.png"></p><p>直接将点的形式用重心坐标的形式表示，随后利用克莱姆法则求解线性方程组即可！</p><p>判断合理：t为正</p><p>判断在三角形内：重心坐标三个系数均为正</p><p>推导过程：</p><p><a href="https://zhuanlan.zhihu.com/p/451582864">[数学] Möller–Trumbore 算法</a></p><h1 id="反射和折射"><a href="#反射和折射" class="headerlink" title="反射和折射"></a>反射和折射</h1><h2 id="反射方向计算"><a href="#反射方向计算" class="headerlink" title="反射方向计算"></a>反射方向计算</h2><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/11.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/12.png"></p><h2 id="折射方向计算"><a href="#折射方向计算" class="headerlink" title="折射方向计算"></a>折射方向计算</h2><p>折射方向的推导其实是由斯奈尔定理(Snell’s Law)得来的：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/13.png"></p><p>n，nt分别表示反射平面两边的反射率。</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/14.png"></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/15.png"></p><h2 id="菲涅尔反射"><a href="#菲涅尔反射" class="headerlink" title="菲涅尔反射"></a>菲涅尔反射</h2><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/16.png"></p><p>如果你垂直观察玻璃，你很容易看清玻璃外的东西(折射而来)，如果你视线玻璃近乎平行，此时你看到的大部分会是你自己(反射得到)，且视线越与玻璃平行，即与法线夹角越大，你的人像越加清晰，这种现象，就可以用菲涅尔反射来进行解释</p><p>简单来说，便是物体的反射率其实与你的观察角度即有关，对于绝缘体来说<strong>观察角度与法线夹角越大，反射的程度就越大</strong></p><p>金属反射率一直很大，所以很有光泽。</p><p>那么对于任意一个物体该去怎么计算出它的精确的反射率呢？计算公式如下：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/17.png"></p><p>当然这里考虑了两个极化，然后再求平均，我们不需要知道为什么要这么算，只要知道，<strong>物体的反射率和入射角度，和入射空间的折射率，和物体的折射率有关</strong>就可以了，然后套公式算就能得出正确的反射率了！那么对于精确的算法来说，可以看到计算量是非常大的，因此就有大佬提出了个简单的算法，近似得到结果，但计算量大大减小，如下：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/18.png"></p><h2 id="如何考虑漫反射"><a href="#如何考虑漫反射" class="headerlink" title="如何考虑漫反射"></a>如何考虑漫反射</h2><p>在Blin-Phong模型中层提到过，漫反射是光线照射到粗糙物体表面从而发生向周围均匀反射光线的一种现象，反射的光线可以说是无数的！</p><p>那么对于这种反射，在光线追踪该怎么处理呢？借鉴<a href="https://link.zhihu.com/?target=https://raytracing.github.io/books/RayTracingInOneWeekend.html"><strong>RayTracingInOneWeekend</strong></a> 里的做法，对于漫反射表面每次进行反射的时候，随机的选取物体表面向外半圆内的一个方向作为该次反射的方向，对其再像镜面反射及折射一样进行递归的光线追踪计算。</p><p><strong>但对每一个像素不仅仅只发出一条感知光线，利用多条光线RayTracing的结果求均值，最终作为该像素的颜色值</strong>。</p><p>比如说我每个像素sample 1000条光线，如果撞到漫反射表面那就是1000条随机方向的 RayTracing结果的均值，这样便能较为准确的模拟了漫反射表面的特性了。 (对一个像素进行多次sample，其实也就把抗锯齿也给做了)</p><p>(tips: 该方法其实更多算是path tracing，经典的whited-style光线追踪遇到漫反射表面会直接利用blinn-phong模型计算颜色值返回，而不再递归下去)</p><h1 id="Accelerating-Ray-Surface-Intersection"><a href="#Accelerating-Ray-Surface-Intersection" class="headerlink" title="Accelerating Ray-Surface Intersection"></a>Accelerating Ray-Surface Intersection</h1><h2 id="为什么-1"><a href="#为什么-1" class="headerlink" title="为什么"></a>为什么</h2><p>原始：每根光线和每个三角形求交（太慢！）</p><h2 id="轴对齐包围盒-Axis-Aligned-Bounding-Box-AABB"><a href="#轴对齐包围盒-Axis-Aligned-Bounding-Box-AABB" class="headerlink" title="**轴对齐包围盒 Axis-Aligned Bounding Box (AABB) **"></a>**轴对齐包围盒 Axis-Aligned Bounding Box (AABB) **</h2><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/19.png"></p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>当有的光线显然不会与一个物体相交的时候，那么自然也没有必要去遍历该物体的所有三角形面，因此利用一个包围盒包住该物体，在与该物体的三角面计算求交之前先判断光线是否与包围盒相交，倘若连包围盒都与光线没有交点的话，那么显然不会与物体的三角面有交点。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>以2D AABB为例子，因此只有x，y两对平面（二维应该其实是线，不过为了统一性这里依然称为平面，不影响理解），3D情况可类推：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/20.png"></p><p>首先如上图最左边所示，求出光线与一对x平面的交点，将先进入的交点(偏小的那个)记为 tmin, 后出去的交点(偏大的那个)记为 tmax，紧接着如中间图所示计算出光线与y平面的两个交点同样记为另外一组tmin, tmax，当然计算的过程中要注意如果任意的 t &lt; 0，那么这代表的是光线反向传播与对应平面的交点。</p><p><strong>1 只有当光线进入了所有的平面才算是真正进入了盒子中</strong></p><p><strong>2 只要当光线离开了任意平面就算是真正离开了盒子</strong></p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/21.png"></p><p>但光线一定会与包围盒有交点吗？显然不是，那么什么条件下才会有交点呢？ 我们说当tenter &lt; texit 的时候，光线<strong>所在直线</strong>一定在盒子中待过一段时间，也必然存在交点，但光线并不是直线，而是射线，除了保证了光线所在的直线在盒子里待过一段时间，还要考虑实际物理意义，具体如下：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/22.png"></p><p>带来效率提升</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/23.png"></p><p>r(t)&#x3D;o+td&#x3D;p&#x3D;p,</p><p>&#x3D;&gt;t</p><h2 id="均匀空间划分-Uniform-Spatial-Partitions-Grids"><a href="#均匀空间划分-Uniform-Spatial-Partitions-Grids" class="headerlink" title="**均匀空间划分 **Uniform Spatial Partitions(Grids)"></a>**均匀空间划分 **Uniform Spatial Partitions(Grids)</h2><h3 id="为什么-2"><a href="#为什么-2" class="headerlink" title="为什么"></a>为什么</h3><p>考虑以下情况：</p><ul><li><p>整个场景只有一个极其复杂的单一人物模型，那么只对这一个物体做包围盒的话，相当于对效率没有任何提升</p></li><li><p>整个场景充斥着大量的细小模型，如草，花之类的，每个模型可能只有很少的面，如果此时对每个物体求包围盒，得到的包围盒数量会相当之多，对于光线追踪效率来说效率提升有限</p></li></ul><p>基于以上两点考虑，AABB并不应只局限于以物体模型为单位，可以更加精细的考虑到以三角面为单位。另外对于场景的许许多多包围盒来说应该要有一种数据结构将其统领起来。 <strong>因此如何更好的划分场景形成不同的AABB，使得划分之后的AABB能够更好的加速光线追踪，这就是接下来要考虑的问题关键！</strong> (以下的划分形成的AABB更是一种general的概念，可能不会严格包围物体)</p><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p> 第一步对所要考虑的场景找一个包围盒：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/24.png"></p><p>第二步均匀划分这个大包围盒：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/25.png"></p><p>第三步在每个重叠小包围盒上存储物体模型信息</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/26.png"></p><p>紧接着，根据光线的方向与判断出所有相交的方格(这一步可以利用bresenham算法)，倘若方格中存储有物体，再进一步与方格中的物体模型或是三角形面求交。</p><p><a href="https://zhuanlan.zhihu.com/p/106155534">Bresenham 直线算法</a></p><p>简单来说就是将空间划分为多个均匀的小的AABB，再根据光线方向找出相交grid(这一步并不需要判断所有方格，正如上文提示，可以用brenham类似的方法来做)，再判断grid中是否存储了模型信息，若有则进一步求交。（这种划分方法假设了找出相交方格要比直接判断与物体求交相对容易，因此划分方格数的多少也是性能的关键，方格太少，没有加速效果，方格太多，判断与方格的求交可能会拖累效率）</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/27.png"></p><h2 id="KD-Tree空间划分"><a href="#KD-Tree空间划分" class="headerlink" title="KD-Tree空间划分"></a>KD-Tree空间划分</h2><p>在具体介绍KD-Tree空间划分的方法之前，首先来看看一些常用的空间划分方法：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/28.png"></p><p>第一种Oct-Tree，也就是八叉树，每次将空间分为8个相等的部分，再递归的对子空间进行划分，因为图中是2维例子，所以只划分了4部分。当划分的子空间足够小或是空间中三角形面的数量很少的时候会停止划分。这种方法的显著缺点是，随着维度的上升划分的空间数量会呈指数级增长。</p><p>第二种KD-Tree，也是本小节将要主要介绍的方法，其每次将空间划分为两部分，且划分依次沿着x-axis，y-axis，z-axis，即如图中所示，第一次横着将2维空间分为上下，第二次再竖着将上下两个子空间分别划分为左右部分，依次递归划分，终止条件与八叉树类似，细节问题之后按具体例子详解。</p><p>第三种BSP-Tree，其与KD-Tree类似，唯一不同的是划分不再沿着固定一轴，可以任意方向划分，缺点自然是划分的空间没有规则性，求交困难。</p><h3 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h3><p>第一步将空间分为两部分</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/29.png"></p><p>第二步对左右两个子空间换个方向再分为两部分(这里只画出了有半部分，其实左边也是一样)</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/30.png"></p><p>如此递归的划分下去，且在划分过程当中遵循这样几点：</p><p><strong>1 依次沿着x-axis,y-axis,z-axis划分，使得空间被划分的更加平衡</strong></p><p><strong>2 划分的位置由空间中三角面的分布决定，具体细节不展开</strong></p><p><strong>3 叶子节点存储对应空间的所有物体或三角面信息，中间节点仅存储指针指向两个子空间</strong></p><p><strong>4 当划分空间太小或是子空间内只有少量三角形则停止划分</strong></p><p>当KD-Tree建立完成之后，如何进行光线与物体求交判断呢？过程如下： </p><p>第一步判断光线是否与最外层的包围盒相交</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/31.png"></p><p>如果相交进一步判断是否与对应的两个子空间相交</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/32.png"></p><p>注意！因图中做了简化，最大包围盒的左半边并没继续进行划分(实际上应该要划分的)，所以左半部分对应的1号空间是叶子节点，如果光线与之相交，进一步判断与存储与叶子节点的物体信息求交。左半边判断完之后，接着判断右半部分。</p><p><strong>优点：</strong> 利用KD-Tree的结构来构建AABB的好处是倘若光线与哪一部分空间不相交，那么则可以省略该部分空间所有子空间的判断过程，在原始的纯粹的AABB之上更进一步提升了加速效率。</p><p><strong>缺点：</strong> 缺点是判断包围盒与三角面的是否相交较难，因此划分的过程不是那么想象的简单，其次同一个三角面可能被不同的包围盒同时占有，这两个不同包围盒内的叶节点会同时存储这一个三角形面</p><h2 id="BVH（Bounding-Volume-Hierarchy）"><a href="#BVH（Bounding-Volume-Hierarchy）" class="headerlink" title="BVH（Bounding Volume Hierarchy）"></a>BVH（<strong>Bounding Volume Hierarchy）</strong></h2><p>BVH与前几种方法最显著的区别就是，<strong>不再以空间作为划分依据，而是从对象的角度考虑，即三角形面</strong>，过程如下： 第一步同样找出场景的整体包围盒作为根节点</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/33.png"></p><p>第二步找到合适的划分点，将最大包围盒内的三角形面分为两部分，再分别重新就算新的包围盒</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/34.png"></p><p>注意到这里，<strong>包围盒会重叠，但一个三角形面只会被存储在唯一的包围盒内，而这也就解决了KD-Tree的缺点！</strong> 接下来与KD-Tree的建立类似，递归的对所有子空间重复该步骤</p><p>tips：</p><ol><li><p>每次划分一般选择最长的那一轴划分，假设是x轴，那么划分点选择所有三角面的重心坐标在x坐标上的中位数进行划分，如此便能保证划分的三角形左右两边三角形数量尽可能差不多，<strong>当然也就使得树形结构建立的更加平衡，深度更小，平均搜索次数更少，提高了效率</strong></p></li><li><p>与KD-Tree一样，中间节点不存储物体三角面信息，只在叶节点中存储，终止条件可设定为当前包围盒内三角形数量足够少 （e.g. 5个）</p></li></ol><p>伪代码：</p><p><img src="/2023/04/18/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%80-Whitted-style-Ray-Tracing/35.png"></p>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>光线追踪</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity简易解密游戏练习</title>
    <link href="/2023/03/25/Unity%E7%AE%80%E6%98%93%E8%A7%A3%E5%AF%86%E6%B8%B8%E6%88%8F%E7%BB%83%E4%B9%A0/"/>
    <url>/2023/03/25/Unity%E7%AE%80%E6%98%93%E8%A7%A3%E5%AF%86%E6%B8%B8%E6%88%8F%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>参考B站教程<a href="https://www.bilibili.com/video/BV19a411i7Tw/?spm_id_from=pageDriver&vd_source=71dde4a51421e8a6f41a13340e537c04">《迷失岛2》游戏框架开发</a>作为Unity日常练习</p><span id="more"></span>]]></content>
    
    
    
    <tags>
      
      <tag>游戏练习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity实现简易背包系统</title>
    <link href="/2023/03/25/Unity%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/03/25/Unity%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>Unity中使用ScriptableObject和UI实现背包系统</p><span id="more"></span><p>ScriptableObject：<br></p><ul><li>ScriptableObject 是 Unity 提供的一个数据配置存储基类，它是一个可以用来保存大量数据的数据容器，我们可以将它保存为自定义的数据资源文件。</li><li>ScriptableObject 是一个类似 MonoBehaviour 的基类，继承自 UnityEngine.Object 。要想使用它，需要我们写个脚本去继承 ScriptableObject 。需要注意的是，继承自 SctiptableObject 的脚本无法挂载到游戏物体上，毕竟它不是继承自 MonoBehaviour。</li><li>ScriptableObject 类的实例会被保存成资源文件（.asset文件），和预制体，材质球，音频文件等类似，都是一种资源文件，存放在 Assets 文件夹下，创建出来的实例也是唯一存在的</li><li>详细链接：<a href="https://blog.csdn.net/qq_46044366/article/details/124310241?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-124310241-blog-99649941.235%5Ev27%5Epc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-124310241-blog-99649941.235%5Ev27%5Epc_relevant_3mothn_strategy_recovery&utm_relevant_index=2">Unity进阶：ScriptableObject使用指南</a></li></ul><p>背包系统详细实现链接：<a href="https://blog.csdn.net/qq_42896549/article/details/105033887">背包系统制作</a></p><h1 id="背包功能实现"><a href="#背包功能实现" class="headerlink" title="背包功能实现"></a>背包功能实现</h1><p>核心代码和想法：<br><br>两个ScriptableObject: 分别代表物品和背包<br><br>Item.cs 物品</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">CreateAssetMenu(fileName =<span class="hljs-string">&quot;New Item&quot;</span>,menuName =<span class="hljs-string">&quot;Inventory/New Item&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Item</span> : <span class="hljs-title">ScriptableObject</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> itemName;  <span class="hljs-comment">//物品名称</span><br>    <span class="hljs-keyword">public</span> Sprite itemImage;    <span class="hljs-comment">//物品图片</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> itemHeld;    <span class="hljs-comment">//物品数量</span><br>    [<span class="hljs-meta">TextArea</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> itemInfo; <span class="hljs-comment">//物品信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> equip;  <span class="hljs-comment">//物品是否可装备</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>Inventory.cs 背包</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">CreateAssetMenu(fileName =<span class="hljs-string">&quot;New Inventory&quot;</span>,menuName =<span class="hljs-string">&quot;Inventory/New Inventory&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Inventory</span> : <span class="hljs-title">ScriptableObject</span><br>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;Item&gt; itemList=<span class="hljs-keyword">new</span> List&lt;Item&gt;(); <span class="hljs-comment">//存放物品</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>让我们按照事件触发的逻辑走起。<br><br>首先我们是要碰撞到世界中的一个物体，然后会调用背包管理脚本添加物品。<br></p><p>那么世界中的物体需要脚本来控制，在触发碰撞且碰撞对象为玩家（Player）时就要调用背包管理脚本添加物品，同时销毁自己。<br><br>当前物体在挂载脚本之后需要绑定两个object：Item和Inventory，表示是哪种类型的物体，该放在哪一个背包中。<br><br>让我们来看代码实现吧：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ItemOnWorld</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Item thisItem;<br>    <span class="hljs-keyword">public</span> Inventory playerInventory;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter2D</span>(<span class="hljs-params">Collider2D other</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(other.gameObject.CompareTag(<span class="hljs-string">&quot;Player&quot;</span>))<br>        &#123;<br>            AddNewItem();<br>            Destroy(gameObject);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddNewItem</span>()</span>&#123;<br>        <span class="hljs-comment">//判断是否在列表中，在 先加1</span><br>        <span class="hljs-keyword">if</span>(!playerInventory.itemList.Contains(thisItem))&#123;<br>            <span class="hljs-comment">// playerInventory.itemList.Add(thisItem);</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;playerInventory.itemList.Count;i++)&#123;<br>                <span class="hljs-keyword">if</span>(playerInventory.itemList[i]==<span class="hljs-literal">null</span>)&#123;<br>                    playerInventory.itemList[i]=thisItem;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            thisItem.itemHeld+=<span class="hljs-number">1</span>;<br>        &#125;<br>        InventoryManger.RefreshItem();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>先修改背包的数据，然后调用RefreshItem重新生成每一个背包槽</p><p>在一开始游戏初始化的时候，我们需要预先生成一些空槽位来填充grid panel，方便之后实现拖拽功能。空槽位的大小需要我们预先在Inventory对象中定义。修改myBag的itemList大小即可。<br><br>InventoryManger.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> TMPro;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InventoryManger</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">static</span> InventoryManger instance;<br>    <span class="hljs-keyword">public</span> Inventory myBag;<br>    <span class="hljs-keyword">public</span> GameObject slotGrid;<br>    <span class="hljs-comment">// public Slot slotPrefab;</span><br>    <span class="hljs-keyword">public</span> GameObject emptySlot;<br>    <span class="hljs-keyword">public</span> TMP_Text itemInformation;<br>    <span class="hljs-keyword">public</span> List&lt;GameObject&gt; slots=<span class="hljs-keyword">new</span> List&lt;GameObject&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">null</span>)<br>            Destroy(<span class="hljs-keyword">this</span>);<br>        instance = <span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span><br>    &#123;<br>        RefreshItem();<br>        itemInformation.text = <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateItemInformation</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> itemDescription</span>)</span><br>    &#123;<br>        instance.itemInformation.text = itemDescription;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RefreshItem</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; instance.slotGrid.transform.childCount; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (instance.slotGrid.transform.childCount == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            Destroy(instance.slotGrid.transform.GetChild(i).gameObject);<br>            instance.slots.Clear();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; instance.myBag.itemList.Count; i++)<br>        &#123;<br>            instance.slots.Add(Instantiate(instance.emptySlot));<br>            instance.slots[i].transform.SetParent(instance.slotGrid.transform);<br>            instance.slots[i].GetComponent&lt;Slot&gt;().slotID=i;<br>            instance.slots[i].GetComponent&lt;Slot&gt;().SetupSlot(instance.myBag.itemList[i]);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到这个背包管理脚本的核心就是控制销毁或实例化slot物体。<br>slot是什么呢？<br><br>Slot本身不再承载装备的素材图片，仅呈现出背包栏背景图片样式，实际的图片以及数字由Slot下的相关子物体承载。这样在没有物品时，只需将子物体的active属性设置为false即可正常显示背包栏背景，而对于物品的移动和交换，只需要将两个Slot下的子物体交换即可。<br><br>Slot.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.UI;<br><span class="hljs-keyword">using</span> TMPro;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Slot</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> slotID; <span class="hljs-comment">//空格ID=物体ID</span><br>    <span class="hljs-keyword">public</span> Item slotItem;<br>    <span class="hljs-keyword">public</span> Image slotImage;<br>    <span class="hljs-keyword">public</span> TMP_Text slotNum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> slotInfo;<br>    <span class="hljs-keyword">public</span> GameObject itemInSlot;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ItemOnClicked</span>()</span><br>    &#123;<br>        InventoryManger.UpdateItemInformation(slotInfo);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetupSlot</span>(<span class="hljs-params">Item item</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(item==<span class="hljs-literal">null</span>)&#123;<br>            itemInSlot.SetActive(<span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            slotImage.sprite=item.itemImage;<br>            slotNum.text=item.itemHeld.ToString();<br>            slotInfo=item.itemInfo;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里的绑定关系如图所示:</p><!-- ![](Unity实现简易背包系统/slot.png) --><p><img src="/2023/03/25/Unity%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F/slot.png"><br>当调用SetupSlot的时候就会显示当前类型物品的图片和数量，并更新描述信息。<br></p><p>实现拖拽功能，主要靠交换slot下的item来实现，因此需要创建ItemOnDrag脚本并赋给item对象。<br><br>注意点：</p><ol><li>拖拽的时候解除item和slot的父子关系，但是此时它还是位于Gird布局下，因此会“溢出”，所以要给item添加组件，忽略布局<img src="/2023/03/25/Unity%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F/ingorelayout.png"></li><li>如何判读拖拽后的位置可以放物体进去。使用UI射线检测，为了避免item挡住检测，要给它添加CanvasGroup组件，通过设置blocksRaycasts来控制是否阻止射线检测。</li><li>如果只是交换item的位置并不能实际改变数据，下次调用RefreshItem()又会重置会原来的样子，所以需要实际交换背包的itemList对应的内容才行。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.EventSystems;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ItemOnDrag</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IBeginDragHandler</span>, <span class="hljs-title">IDragHandler</span>, <span class="hljs-title">IEndDragHandler</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Transform originalParent;<br>    <span class="hljs-keyword">public</span> Inventory myBag;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> currentItemID; <span class="hljs-comment">//当前物品ID</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnBeginDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span><br>    &#123;<br>        originalParent=transform.parent;<br>        currentItemID=originalParent.GetComponent&lt;Slot&gt;().slotID;<br>        transform.SetParent(transform.parent.parent);<br>        transform.position=eventData.position;<br>        GetComponent&lt;CanvasGroup&gt;().blocksRaycasts=<span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span><br>    &#123;<br>        transform.position=eventData.position;<br>        Debug.Log(eventData.pointerCurrentRaycast.gameObject.name);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEndDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(eventData.pointerCurrentRaycast.gameObject!=<span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">if</span>(eventData.pointerCurrentRaycast.gameObject.name==<span class="hljs-string">&quot;ItemImage&quot;</span>)&#123;<br>                transform.SetParent(eventData.pointerCurrentRaycast.gameObject.transform.parent.parent);<br>                transform.position=eventData.pointerCurrentRaycast.gameObject.transform.parent.parent.position;<br><br>                <span class="hljs-comment">//实际数据改变</span><br>                <span class="hljs-keyword">var</span> tmp=myBag.itemList[currentItemID];<br>                myBag.itemList[currentItemID]=myBag.itemList[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID];<br>                myBag.itemList[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID]=tmp;<br><br><br>                eventData.pointerCurrentRaycast.gameObject.transform.parent.position=originalParent.position;<br>                eventData.pointerCurrentRaycast.gameObject.transform.parent.SetParent(originalParent);<br>                GetComponent&lt;CanvasGroup&gt;().blocksRaycasts=<span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(eventData.pointerCurrentRaycast.gameObject.name==<span class="hljs-string">&quot;slot(Clone)&quot;</span>)<br>            &#123;<br>                transform.SetParent(eventData.pointerCurrentRaycast.gameObject.transform);<br>                transform.position=eventData.pointerCurrentRaycast.gameObject.transform.position;<br>                myBag.itemList[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID]=myBag.itemList[currentItemID];<br>                <span class="hljs-keyword">if</span>(eventData.pointerCurrentRaycast.gameObject.GetComponent&lt;Slot&gt;().slotID!=currentItemID)<br>                    myBag.itemList[currentItemID]=<span class="hljs-literal">null</span>;<br>                GetComponent&lt;CanvasGroup&gt;().blocksRaycasts=<span class="hljs-literal">true</span>;    <br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        <span class="hljs-comment">//其他任何位置都归位</span><br>        transform.SetParent(originalParent);<br>        transform.position=originalParent.position;<br>        GetComponent&lt;CanvasGroup&gt;().blocksRaycasts=<span class="hljs-literal">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="移动背包"><a href="#移动背包" class="headerlink" title="移动背包"></a>移动背包</h1><p>最后需要做是移动背包整体界面的功能，通过在一个简单的脚本实现</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.EventSystems;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MoveBag</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IDragHandler</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Canvas canvas;<br>    RectTransform currentRect;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span><br>    &#123;<br>        currentRect = GetComponent&lt;RectTransform&gt;();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span><br>    &#123;<br>        currentRect.anchoredPosition+=eventData.delta;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="保存背包数据到本地，下次加载"><a href="#保存背包数据到本地，下次加载" class="headerlink" title="保存背包数据到本地，下次加载"></a>保存背包数据到本地，下次加载</h1><p>在场景中新建空物体，挂载GameSaveManger脚本，绑定想保存的背包</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">using</span> System.Runtime.Serialization.Formatters.Binary;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameSaveManger</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Inventory myInventory;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SaveGame</span>()</span>&#123;<br>        <span class="hljs-keyword">if</span>(!Directory.Exists(Application.persistentDataPath+<span class="hljs-string">&quot;/game_SaveData&quot;</span>))&#123;&#125;<br>            Directory.CreateDirectory(Application.persistentDataPath+<span class="hljs-string">&quot;/game_SaveData&quot;</span>);<br>        BinaryFormatter formatter=<span class="hljs-keyword">new</span> BinaryFormatter(); <span class="hljs-comment">//二进制转换</span><br>        FileStream file=File.Create(Application.persistentDataPath+<span class="hljs-string">&quot;/game_SaveData/inventory.txt&quot;</span>);<br>        <span class="hljs-keyword">var</span> json=JsonUtility.ToJson(myInventory);<br>        formatter.Serialize(file,json);<br>        file.Close();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadGame</span>()</span>&#123;<br>        BinaryFormatter binaryFormatter=<span class="hljs-keyword">new</span> BinaryFormatter();<br>        <span class="hljs-keyword">if</span>(File.Exists(Application.persistentDataPath+<span class="hljs-string">&quot;/game_SaveData/inventory.txt&quot;</span>))&#123;<br>            FileStream file=File.Open(Application.persistentDataPath+<span class="hljs-string">&quot;/game_SaveData/inventory.txt&quot;</span>,FileMode.Open);<br>            JsonUtility.FromJsonOverwrite((<span class="hljs-built_in">string</span>)binaryFormatter.Deserialize(file),myInventory);<br>            file.Close();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>背包系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chatglm_with_vits本地部署</title>
    <link href="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/"/>
    <url>/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>实现前端live2D交互对话，后端chatglm提供语言生成，vits模型onnx导出版实现文字转语音<br><br>项目地址：<a href="https://github.com/shanhainanhua/vits_with_chatgpt-gpt3">vits_with_chatgpt-gpt3</a></p><span id="more"></span><h1 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h1><h2 id="下载项目及相关模型"><a href="#下载项目及相关模型" class="headerlink" title="下载项目及相关模型"></a>下载项目及相关模型</h2><ol><li>首先从github仓库下载项目到本地，然后打开moe文件夹</li><li>下载语音模型<a href="https://huggingface.co/Mahiruoshi/vits_onnx_model/tree/main">vits_onnx_model</a>到moe文件夹中</li><li>下载开源<a href="https://github.com/THUDM/ChatGLM-6B">ChatGLM-6B模型</a>，注意下载完整的模型，然后之后会使用INT4量化等级来加载模型，最低GPU显存要求为6G。如果下载过慢可以在<a href="https://cloud.tsinghua.edu.cn/d/fb9f16d6dc8f482596c2/">这里</a>下载</li></ol><h2 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h2><ol><li>下载FFmpeg，按照<a href="https://zhuanlan.zhihu.com/p/572201206">教程</a>安装</li><li>确保cmake路径添加到系统变量中，比如用的vs2022下自带cmke<!-- ![](chatglm-with-vits本地部署/cmake.png) --><img src="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/cmake.png"></li><li>安装pyopenjtalk<!-- ![](chatglm-with-vits本地部署/pyopenjdk.png) --><img src="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/pyopenjdk.png"></li><li>项目运行需要gcc和openmp，因此需要安装TDM-GCC，这里按照网上教程按照并添加路径即可，初次安装点击create没有openmp选项，需要安装后再次运行exe文件，选择mange，双击目前安装的路径进行管理，额外安装<!-- ![](chatglm-with-vits本地部署/mange.png)![](chatglm-with-vits本地部署/mange2.png)![](chatglm-with-vits本地部署/mange3.png) --><img src="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/mange.png"><br><img src="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/mange2.png"><br><img src="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/mange3.png"></li><li>新建conda环境，python3.9，3.10都可以，然后安装符合自己电脑版本的torch-gpu</li><li>安装其他需要的包</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">aiofiles</span>==<span class="hljs-number">23</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">aiohttp</span>==<span class="hljs-number">3</span>.<span class="hljs-number">8</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">aiosignal</span>==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">altair</span>==<span class="hljs-number">4</span>.<span class="hljs-number">2</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">anyio</span>==<span class="hljs-number">3</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">appdirs</span>==<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">async</span>-timeout==<span class="hljs-number">4</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">attrs</span>==<span class="hljs-number">22</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">audioread</span>==<span class="hljs-number">3</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">certifi</span>==<span class="hljs-number">2022</span>.<span class="hljs-number">12</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">cffi</span>==<span class="hljs-number">1</span>.<span class="hljs-number">15</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">charset</span>-normalizer==<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">click</span>==<span class="hljs-number">8</span>.<span class="hljs-number">1</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">cn2an</span>==<span class="hljs-number">0</span>.<span class="hljs-number">5</span>.<span class="hljs-number">19</span><br><span class="hljs-attribute">colorama</span>==<span class="hljs-number">0</span>.<span class="hljs-number">4</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">coloredlogs</span>==<span class="hljs-number">15</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">contourpy</span>==<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">cpm</span>-kernels==<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">11</span><br><span class="hljs-attribute">cycler</span>==<span class="hljs-number">0</span>.<span class="hljs-number">11</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">Cython</span>==<span class="hljs-number">0</span>.<span class="hljs-number">29</span>.<span class="hljs-number">33</span><br><span class="hljs-attribute">decorator</span>==<span class="hljs-number">5</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">eng</span>-to-ipa==<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">entrypoints</span>==<span class="hljs-number">0</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">fastapi</span>==<span class="hljs-number">0</span>.<span class="hljs-number">95</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">ffmpy</span>==<span class="hljs-number">0</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">filelock</span>==<span class="hljs-number">3</span>.<span class="hljs-number">10</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">Flask</span>==<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">flatbuffers</span>==<span class="hljs-number">23</span>.<span class="hljs-number">3</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">fonttools</span>==<span class="hljs-number">4</span>.<span class="hljs-number">39</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">frozenlist</span>==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">fsspec</span>==<span class="hljs-number">2023</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">gradio</span>==<span class="hljs-number">3</span>.<span class="hljs-number">23</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">h11</span>==<span class="hljs-number">0</span>.<span class="hljs-number">14</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">httpcore</span>==<span class="hljs-number">0</span>.<span class="hljs-number">16</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">httpx</span>==<span class="hljs-number">0</span>.<span class="hljs-number">23</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">huggingface</span>-hub==<span class="hljs-number">0</span>.<span class="hljs-number">13</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">humanfriendly</span>==<span class="hljs-number">10</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">icetk</span>==<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">idna</span>==<span class="hljs-number">3</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">importlib</span>-metadata==<span class="hljs-number">6</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">importlib</span>-resources==<span class="hljs-number">5</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">inflect</span>==<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">itsdangerous</span>==<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">jamo</span>==<span class="hljs-number">0</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">jieba</span>==<span class="hljs-number">0</span>.<span class="hljs-number">42</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Jinja2</span>==<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">joblib</span>==<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">jsonschema</span>==<span class="hljs-number">4</span>.<span class="hljs-number">17</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">kiwisolver</span>==<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">lazy_loader</span>==<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">librosa</span>==<span class="hljs-number">0</span>.<span class="hljs-number">10</span>.<span class="hljs-number">0</span>.post2<br><span class="hljs-attribute">linkify</span>-it-py==<span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">llvmlite</span>==<span class="hljs-number">0</span>.<span class="hljs-number">39</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">markdown</span>-it-py==<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">MarkupSafe</span>==<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">matplotlib</span>==<span class="hljs-number">3</span>.<span class="hljs-number">7</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">mdit</span>-py-plugins==<span class="hljs-number">0</span>.<span class="hljs-number">3</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">mdurl</span>==<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">mpmath</span>==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">msgpack</span>==<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">multidict</span>==<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">networkx</span>==<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">numba</span>==<span class="hljs-number">0</span>.<span class="hljs-number">56</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">numpy</span>==<span class="hljs-number">1</span>.<span class="hljs-number">23</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">onnxruntime</span>==<span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">openai</span>==<span class="hljs-number">0</span>.<span class="hljs-number">27</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">orjson</span>==<span class="hljs-number">3</span>.<span class="hljs-number">8</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">packaging</span>==<span class="hljs-number">23</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">pandas</span>==<span class="hljs-number">1</span>.<span class="hljs-number">5</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">Pillow</span>==<span class="hljs-number">9</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">pooch</span>==<span class="hljs-number">1</span>.<span class="hljs-number">6</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">proces</span>==<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">protobuf</span>==<span class="hljs-number">3</span>.<span class="hljs-number">18</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">pycparser</span>==<span class="hljs-number">2</span>.<span class="hljs-number">21</span><br><span class="hljs-attribute">pydantic</span>==<span class="hljs-number">1</span>.<span class="hljs-number">10</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">pydub</span>==<span class="hljs-number">0</span>.<span class="hljs-number">25</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">pyopenjtalk</span>==<span class="hljs-number">0</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">pyparsing</span>==<span class="hljs-number">3</span>.<span class="hljs-number">0</span>.<span class="hljs-number">9</span><br><span class="hljs-attribute">pypinyin</span>==<span class="hljs-number">0</span>.<span class="hljs-number">48</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">pyreadline3</span>==<span class="hljs-number">3</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">pyrsistent</span>==<span class="hljs-number">0</span>.<span class="hljs-number">19</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">python</span>-dateutil==<span class="hljs-number">2</span>.<span class="hljs-number">8</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">python</span>-multipart==<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">pytz</span>==<span class="hljs-number">2022</span>.<span class="hljs-number">7</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">PyYAML</span>==<span class="hljs-number">6</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">regex</span>==<span class="hljs-number">2023</span>.<span class="hljs-number">3</span>.<span class="hljs-number">22</span><br><span class="hljs-attribute">requests</span>==<span class="hljs-number">2</span>.<span class="hljs-number">28</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">rfc3986</span>==<span class="hljs-number">1</span>.<span class="hljs-number">5</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">scikit</span>-learn==<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">scipy</span>==<span class="hljs-number">1</span>.<span class="hljs-number">10</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">semantic</span>-version==<span class="hljs-number">2</span>.<span class="hljs-number">10</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">sentencepiece</span>==<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">97</span><br><span class="hljs-attribute">six</span>==<span class="hljs-number">1</span>.<span class="hljs-number">16</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">sniffio</span>==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">soundfile</span>==<span class="hljs-number">0</span>.<span class="hljs-number">12</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">soxr</span>==<span class="hljs-number">0</span>.<span class="hljs-number">3</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">starlette</span>==<span class="hljs-number">0</span>.<span class="hljs-number">26</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">sympy</span>==<span class="hljs-number">1</span>.<span class="hljs-number">11</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">threadpoolctl</span>==<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">tokenizers</span>==<span class="hljs-number">0</span>.<span class="hljs-number">13</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">toolz</span>==<span class="hljs-number">0</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">torch</span>==<span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>+cu117<br><span class="hljs-attribute">torchaudio</span>==<span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>+cu117<br><span class="hljs-attribute">torchvision</span>==<span class="hljs-number">0</span>.<span class="hljs-number">15</span>.<span class="hljs-number">1</span>+cu117<br><span class="hljs-attribute">tqdm</span>==<span class="hljs-number">4</span>.<span class="hljs-number">65</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">transformers</span>==<span class="hljs-number">4</span>.<span class="hljs-number">26</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">typing_extensions</span>==<span class="hljs-number">4</span>.<span class="hljs-number">5</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">uc</span>-micro-py==<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Unidecode</span>==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">urllib3</span>==<span class="hljs-number">1</span>.<span class="hljs-number">26</span>.<span class="hljs-number">15</span><br><span class="hljs-attribute">uvicorn</span>==<span class="hljs-number">0</span>.<span class="hljs-number">21</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">websockets</span>==<span class="hljs-number">10</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">Werkzeug</span>==<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">yarl</span>==<span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">zipp</span>==<span class="hljs-number">3</span>.<span class="hljs-number">15</span>.<span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><p>可以复制进txt文件中批量安装，但是实际我用原项目中的requirement.txt的时候会出现错误，无法批量安装，手动安装后无问题。所以这里可以试试我的行不行，不行的话可以手动安装主要的包。记得transformers&#x3D;&#x3D;4.26.1,版本过过低都有可能出错。<br></p><ol start="7"><li>激活环境运行localchat.py<!-- ![](chatglm-with-vits本地部署/run1.png) --><img src="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/run1.png"><br>前面步骤没有问题的话，就可以运行文件，这里加载模型等待的时间会有些长<br><br>成功后，服务就运行在相应端口了。<!-- ![](chatglm-with-vits本地部署/run2.png) --><img src="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/run2.png"></li></ol><h2 id="部署前端"><a href="#部署前端" class="headerlink" title="部署前端"></a>部署前端</h2><p>下载<a href="https://github.com/Arkueid/Live2DMascot">Live2D项目</a><br>解压后，进入项目的x86文件夹下，修改config.json文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;ChatAPI&quot;</span> : <br>&#123;<br><span class="hljs-string">&quot;ChatSavePath&quot;</span> : <span class="hljs-string">&quot;chat&quot;</span>,  <span class="hljs-regexp">//</span>聊天音频和文本保存路径<br><span class="hljs-string">&quot;CustomChatServer&quot;</span> : <br>&#123;<br>        <span class="hljs-regexp">//</span>服务器地址，端口默认<span class="hljs-number">8080</span> 本地部署就是<span class="hljs-string">&quot;http://127.0.0.1:8080&quot;</span><br><span class="hljs-string">&quot;HostPort&quot;</span> : <span class="hljs-string">&quot;http://yourhost:8080&quot;</span>,  <br><span class="hljs-string">&quot;On&quot;</span> : true,  <span class="hljs-regexp">//</span>开启自定义聊天接口<br><span class="hljs-string">&quot;ReadTimeOut&quot;</span> : <span class="hljs-number">114</span>,  <span class="hljs-regexp">//</span>等待响应时间(s)<br><span class="hljs-string">&quot;Route&quot;</span> : <span class="hljs-string">&quot;/chat&quot;</span>  <span class="hljs-regexp">//</span>路径<br>&#125;,<br></code></pre></td></tr></table></figure><!-- ![](chatglm-with-vits本地部署/live2d.png) --><p><img src="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/live2d.png"></p><p>双击Live2D-x86.exe启动程序，然后桌面上就会显示人物了，通过任务栏中程序图标右击可以更改程序设置。</p><!-- ![](chatglm-with-vits本地部署/renwu.png) --><p><img src="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/renwu.png"></p><p>如何对话？<br>鼠标右键双击人物，会出现对话框，输入文字后回车等待回应即可。</p><!-- ![](chatglm-with-vits本地部署/renwu2.png) --><p><img src="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/renwu2.png"></p>]]></content>
    
    
    <categories>
      
      <category>chatgpt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chatgpt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ai绘画本地部署使用</title>
    <link href="/2023/03/23/Ai%E7%BB%98%E7%94%BB%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/03/23/Ai%E7%BB%98%E7%94%BB%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>本篇主要介绍stable_diffsion的本地部署过程以及有哪些坑。</p><span id="more"></span><p>AI部署参考的主要教程是<a href="https://space.bilibili.com/12566101?spm_id_from=333.337.0.0">B站秋葉aaaki</a><br><br>下载他的最终版整合包，然后自己配置环境，没有使用启动器<br><br>首先anaconda创建一个新的环境（推荐创建新的，免去包冲突的问题）<br></p><p><img src="/2023/03/23/Ai%E7%BB%98%E7%94%BB%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8/1.png"></p><p>然后进入解压后的项目目录下，激活创建的环境，使用pip命令安装依赖包</p><p><img src="/2023/03/23/Ai%E7%BB%98%E7%94%BB%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8/2.png"><br>注意：这里的requirements.txt文件可能会有冲突，因此我导出了我配置好环境的依赖文件，复制进去替换掉原来的内容，torch的版本需要根据自己显卡环境调整</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">absl</span>-py==<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">accelerate</span>==<span class="hljs-number">0</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">addict</span>==<span class="hljs-number">2</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">aenum</span>==<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">11</span><br><span class="hljs-attribute">aiofiles</span>==<span class="hljs-number">23</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">aiohttp</span>==<span class="hljs-number">3</span>.<span class="hljs-number">8</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">aiosignal</span>==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">altair</span>==<span class="hljs-number">4</span>.<span class="hljs-number">2</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">antlr4</span>-python3-runtime==<span class="hljs-number">4</span>.<span class="hljs-number">9</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">anyio</span>==<span class="hljs-number">3</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">async</span>-timeout==<span class="hljs-number">4</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">attrs</span>==<span class="hljs-number">22</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">basicsr</span>==<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">beautifulsoup4</span>==<span class="hljs-number">4</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">blendmodes</span>==<span class="hljs-number">2022</span><br><span class="hljs-attribute">boltons</span>==<span class="hljs-number">23</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">cachetools</span>==<span class="hljs-number">5</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">certifi</span>==<span class="hljs-number">2022</span>.<span class="hljs-number">12</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">chardet</span>==<span class="hljs-number">4</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">charset</span>-normalizer==<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">clean</span>-fid==<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">29</span><br><span class="hljs-attribute">click</span>==<span class="hljs-number">8</span>.<span class="hljs-number">1</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">clip</span> @ git+https://github.com/openai/clip.git@a9b1bf5920416aaeaec965c25dd9e8f98c864f16<br><span class="hljs-attribute">colorama</span>==<span class="hljs-number">0</span>.<span class="hljs-number">4</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">coloredlogs</span>==<span class="hljs-number">15</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">contourpy</span>==<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">cssselect2</span>==<span class="hljs-number">0</span>.<span class="hljs-number">7</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">cycler</span>==<span class="hljs-number">0</span>.<span class="hljs-number">11</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">deprecation</span>==<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">docopt</span>==<span class="hljs-number">0</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">einops</span>==<span class="hljs-number">0</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">entrypoints</span>==<span class="hljs-number">0</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">facexlib</span>==<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">fastapi</span>==<span class="hljs-number">0</span>.<span class="hljs-number">90</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">ffmpy</span>==<span class="hljs-number">0</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">filelock</span>==<span class="hljs-number">3</span>.<span class="hljs-number">10</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">filterpy</span>==<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">flatbuffers</span>==<span class="hljs-number">23</span>.<span class="hljs-number">3</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">font</span>-roboto==<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">fonts</span>==<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">fonttools</span>==<span class="hljs-number">4</span>.<span class="hljs-number">39</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">frozenlist</span>==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">fsspec</span>==<span class="hljs-number">2023</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">ftfy</span>==<span class="hljs-number">6</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">future</span>==<span class="hljs-number">0</span>.<span class="hljs-number">18</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">gdown</span>==<span class="hljs-number">4</span>.<span class="hljs-number">6</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">gfpgan</span>==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">gitdb</span>==<span class="hljs-number">4</span>.<span class="hljs-number">0</span>.<span class="hljs-number">10</span><br><span class="hljs-attribute">GitPython</span>==<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">27</span><br><span class="hljs-attribute">google</span>-auth==<span class="hljs-number">2</span>.<span class="hljs-number">16</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">google</span>-auth-oauthlib==<span class="hljs-number">0</span>.<span class="hljs-number">4</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">gradio</span>==<span class="hljs-number">3</span>.<span class="hljs-number">16</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">grpcio</span>==<span class="hljs-number">1</span>.<span class="hljs-number">51</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">h11</span>==<span class="hljs-number">0</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">httpcore</span>==<span class="hljs-number">0</span>.<span class="hljs-number">15</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">httpx</span>==<span class="hljs-number">0</span>.<span class="hljs-number">23</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">huggingface</span>-hub==<span class="hljs-number">0</span>.<span class="hljs-number">13</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">humanfriendly</span>==<span class="hljs-number">10</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">idna</span>==<span class="hljs-number">2</span>.<span class="hljs-number">10</span><br><span class="hljs-attribute">imageio</span>==<span class="hljs-number">2</span>.<span class="hljs-number">26</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">inflection</span>==<span class="hljs-number">0</span>.<span class="hljs-number">5</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">invisible</span>-watermark==<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">Jinja2</span>==<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">jsonmerge</span>==<span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">jsonschema</span>==<span class="hljs-number">4</span>.<span class="hljs-number">17</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">kiwisolver</span>==<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">kornia</span>==<span class="hljs-number">0</span>.<span class="hljs-number">6</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">lark</span>==<span class="hljs-number">1</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">lazy_loader</span>==<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">linkify</span>-it-py==<span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">llvmlite</span>==<span class="hljs-number">0</span>.<span class="hljs-number">39</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">lmdb</span>==<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">lpips</span>==<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">lxml</span>==<span class="hljs-number">4</span>.<span class="hljs-number">9</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">Markdown</span>==<span class="hljs-number">3</span>.<span class="hljs-number">4</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">markdown</span>-it-py==<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">MarkupSafe</span>==<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">matplotlib</span>==<span class="hljs-number">3</span>.<span class="hljs-number">7</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">mdit</span>-py-plugins==<span class="hljs-number">0</span>.<span class="hljs-number">3</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">mdurl</span>==<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">mpmath</span>==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">multidict</span>==<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">networkx</span>==<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">numba</span>==<span class="hljs-number">0</span>.<span class="hljs-number">56</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">numpy</span>==<span class="hljs-number">1</span>.<span class="hljs-number">23</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">oauthlib</span>==<span class="hljs-number">3</span>.<span class="hljs-number">2</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">omegaconf</span>==<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">onnx</span>==<span class="hljs-number">1</span>.<span class="hljs-number">13</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">onnxruntime</span>==<span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">open</span>-clip-torch @ git+https://gitee.com/ufhy/open_clip.git@bb6e834e9c70d9c27d0dc3ecedeebeaeb1ffad6b<br><span class="hljs-attribute">opencv</span>-contrib-python==<span class="hljs-number">4.7.0.72</span><br><span class="hljs-attribute">opencv</span>-python==<span class="hljs-number">4.7.0.72</span><br><span class="hljs-attribute">orjson</span>==<span class="hljs-number">3</span>.<span class="hljs-number">8</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">packaging</span>==<span class="hljs-number">23</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">pandas</span>==<span class="hljs-number">1</span>.<span class="hljs-number">5</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">piexif</span>==<span class="hljs-number">1</span>.<span class="hljs-number">1</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">Pillow</span>==<span class="hljs-number">9</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">pipreqs</span>==<span class="hljs-number">0</span>.<span class="hljs-number">4</span>.<span class="hljs-number">11</span><br><span class="hljs-attribute">protobuf</span>==<span class="hljs-number">3</span>.<span class="hljs-number">20</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">psutil</span>==<span class="hljs-number">5</span>.<span class="hljs-number">9</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">pyasn1</span>==<span class="hljs-number">0</span>.<span class="hljs-number">4</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">pyasn1</span>-modules==<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">pycryptodome</span>==<span class="hljs-number">3</span>.<span class="hljs-number">17</span><br><span class="hljs-attribute">pydantic</span>==<span class="hljs-number">1</span>.<span class="hljs-number">10</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">pyDeprecate</span>==<span class="hljs-number">0</span>.<span class="hljs-number">3</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">pydub</span>==<span class="hljs-number">0</span>.<span class="hljs-number">25</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">pyparsing</span>==<span class="hljs-number">3</span>.<span class="hljs-number">0</span>.<span class="hljs-number">9</span><br><span class="hljs-attribute">pyreadline3</span>==<span class="hljs-number">3</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">pyrsistent</span>==<span class="hljs-number">0</span>.<span class="hljs-number">19</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">PySocks</span>==<span class="hljs-number">1</span>.<span class="hljs-number">7</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">python</span>-dateutil==<span class="hljs-number">2</span>.<span class="hljs-number">8</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">python</span>-multipart==<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">pytorch</span>-lightning==<span class="hljs-number">1</span>.<span class="hljs-number">7</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">pytz</span>==<span class="hljs-number">2022</span>.<span class="hljs-number">7</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">PyWavelets</span>==<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">PyYAML</span>==<span class="hljs-number">6</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">realesrgan</span>==<span class="hljs-number">0</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">regex</span>==<span class="hljs-number">2023</span>.<span class="hljs-number">3</span>.<span class="hljs-number">22</span><br><span class="hljs-attribute">reportlab</span>==<span class="hljs-number">3</span>.<span class="hljs-number">6</span>.<span class="hljs-number">12</span><br><span class="hljs-attribute">requests</span>==<span class="hljs-number">2</span>.<span class="hljs-number">25</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">requests</span>-oauthlib==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">resize</span>-right==<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">rfc3986</span>==<span class="hljs-number">1</span>.<span class="hljs-number">5</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">rsa</span>==<span class="hljs-number">4</span>.<span class="hljs-number">9</span><br><span class="hljs-attribute">safetensors</span>==<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">scikit</span>-image==<span class="hljs-number">0</span>.<span class="hljs-number">19</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">scipy</span>==<span class="hljs-number">1</span>.<span class="hljs-number">10</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">sentencepiece</span>==<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">97</span><br><span class="hljs-attribute">six</span>==<span class="hljs-number">1</span>.<span class="hljs-number">16</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">smmap</span>==<span class="hljs-number">5</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">sniffio</span>==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">soupsieve</span>==<span class="hljs-number">2</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">starlette</span>==<span class="hljs-number">0</span>.<span class="hljs-number">23</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">svglib</span>==<span class="hljs-number">1</span>.<span class="hljs-number">5</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">sympy</span>==<span class="hljs-number">1</span>.<span class="hljs-number">11</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">tb</span>-nightly==<span class="hljs-number">2</span>.<span class="hljs-number">13</span>.<span class="hljs-number">0</span>a20230317<br><span class="hljs-attribute">tensorboard</span>==<span class="hljs-number">2</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">tensorboard</span>-data-server==<span class="hljs-number">0</span>.<span class="hljs-number">7</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">tensorboard</span>-plugin-wit==<span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">tifffile</span>==<span class="hljs-number">2023</span>.<span class="hljs-number">3</span>.<span class="hljs-number">21</span><br><span class="hljs-attribute">timm</span>==<span class="hljs-number">0</span>.<span class="hljs-number">6</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">tinycss2</span>==<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">tokenizers</span>==<span class="hljs-number">0</span>.<span class="hljs-number">13</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">toolz</span>==<span class="hljs-number">0</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">torch</span>==<span class="hljs-number">1</span>.<span class="hljs-number">13</span>.<span class="hljs-number">1</span>+cu117<br><span class="hljs-attribute">torchaudio</span>==<span class="hljs-number">0</span>.<span class="hljs-number">13</span>.<span class="hljs-number">1</span>+cu117<br><span class="hljs-attribute">torchdiffeq</span>==<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">torchmetrics</span>==<span class="hljs-number">0</span>.<span class="hljs-number">11</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">torchsde</span>==<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">torchvision</span>==<span class="hljs-number">0</span>.<span class="hljs-number">14</span>.<span class="hljs-number">1</span>+cu117<br><span class="hljs-attribute">tqdm</span>==<span class="hljs-number">4</span>.<span class="hljs-number">65</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">trampoline</span>==<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">transformers</span>==<span class="hljs-number">4</span>.<span class="hljs-number">25</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">typing_extensions</span>==<span class="hljs-number">4</span>.<span class="hljs-number">5</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">uc</span>-micro-py==<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">urllib3</span>==<span class="hljs-number">1</span>.<span class="hljs-number">26</span>.<span class="hljs-number">15</span><br><span class="hljs-attribute">uvicorn</span>==<span class="hljs-number">0</span>.<span class="hljs-number">21</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">wcwidth</span>==<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">webencodings</span>==<span class="hljs-number">0</span>.<span class="hljs-number">5</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">websockets</span>==<span class="hljs-number">10</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">Werkzeug</span>==<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">yapf</span>==<span class="hljs-number">0</span>.<span class="hljs-number">32</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">yarg</span>==<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">9</span><br><span class="hljs-attribute">yarl</span>==<span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>在配置好环境后需要启动launch.py文件</p><p><img src="/2023/03/23/Ai%E7%BB%98%E7%94%BB%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8/3.png"></p><p>启动时还可以配置参数：如python launch.py –no-half –no-half-vae –disable-nan-check</p><p>具体说明可以参见up主的教程和其他资料</p><p>下面是几张生成图的示例：</p><p>positive tags:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">(((masterpiece))),<span class="hljs-keyword">best </span>quality, illustration,(<span class="hljs-keyword">beautiful </span>detailed girl),<span class="hljs-keyword">beautiful </span>detailed glow,detailed ice,<span class="hljs-keyword">beautiful </span>detailed water,(<span class="hljs-keyword">beautiful </span>detailed eyes),expressionless,(floating palaces),azure hair,<span class="hljs-keyword">disheveled </span>hair,long <span class="hljs-keyword">bangs, </span>hairs <span class="hljs-keyword">between </span>eyes,(skyblue dress),<span class="hljs-keyword">black </span>ribbon,white <span class="hljs-keyword">bowties,midriff,&#123;&#123;&#123;half </span><span class="hljs-keyword">closed </span>eyes&#125;&#125;&#125;,<span class="hljs-keyword">big </span>forhead,<span class="hljs-keyword">blank </span>stare,flower,large top sleeves<br></code></pre></td></tr></table></figure><p>negative tags:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">owres,<span class="hljs-keyword">bad </span>anatomy,<span class="hljs-keyword">bad </span>hands,text,error,missing fingers,<span class="hljs-keyword">extra </span><span class="hljs-keyword">digit,fewer </span><span class="hljs-keyword">digits,cropped,worst </span>quality,low quality,<span class="hljs-keyword">normal </span>quality,<span class="hljs-keyword">jpeg </span>artifacts,signature,watermark,username,<span class="hljs-keyword">blurry,missing </span>fingers,<span class="hljs-keyword">bad </span>hands,missing arms,large <span class="hljs-keyword">breasts</span><br></code></pre></td></tr></table></figure><p><img src="/2023/03/23/Ai%E7%BB%98%E7%94%BB%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8/4.png"></p><p><img src="/2023/03/23/Ai%E7%BB%98%E7%94%BB%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8/6.png"></p><p><img src="/2023/03/23/Ai%E7%BB%98%E7%94%BB%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8/i5.png"></p><p><img src="/2023/03/23/Ai%E7%BB%98%E7%94%BB%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8/7.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI绘画</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stable_diffusion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shader基础</title>
    <link href="/2023/02/09/shader%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/02/09/shader%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>shader：着色器<br></p><ul><li>GPU流水线上一些可高度编程的阶段，而由着色器编译出来的最终代码是会在 GPU上运行的（对于固定管线的渲染来说，着色器有时等同于一些特定的渲染设置);</li><li>有一些特定类型的着色器，如顶点着色器、片元着色器等;</li><li>依靠着色器我们可以控制流水线中的渲染细节,例如用顶点着色器来进行顶点变换以及传递数据，用片元着色器来进行逐像素的渲染。</li></ul><h1 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线: "></a>渲染流水线: <br></h1><ul><li>输入是一个虚拟摄像机、一些光源、一些shader以及纹理</li><li>输出渲染一张二维纹理</li><li>分为三个阶段：<strong>应用阶段(Application Stage)<strong>、</strong>几何阶段(Geometry Stage)<strong>、</strong>光栅化阶段(Rasterizer Stage)</strong><!-- ![流水线]() --><img src="/2023/02/09/shader%E5%9F%BA%E7%A1%80/%E6%B5%81%E6%B0%B4%E7%BA%BF.png"></li></ul><p><strong>应用阶段</strong>：</p><ol><li>准备好场景数据</li><li>粗粒度剔除(culling)工作，以把那些不可见的物体剔除出去</li><li>设置好每个模型的渲染状态。<br><br><strong>输出</strong>：渲染所需的几何信息，即**渲染图元（rendering primitives)**。通俗来讲，渲染图元可以是点、线、三角面等。这些渲染图元将会被传递给下一个阶段——几何阶段。</li></ol><p>应用阶段大致可分为下面3个阶段:</p><ol><li>把数据加载到显存中。</li><li>设置渲染状态。</li><li>调用Draw Call</li></ol><p><strong>渲染状态</strong>：<br><br>定义了场景中的网格是怎样被渲染的。例如，使用哪个顶点着色器（Vertex Shader)&#x2F;片元着色器(Fragment Shader)、光源属性、材质等。如果我们没有更改渲染状态，那么所有的网格都将使用同一种渲染状态。</p><p><strong>Draw Call</strong>:<br><br>实际上，Draw Call就是一个命令，它的发起方是 CPU，接收方是GPU。这个命令仅仅会指向一个需要被渲染的图元(primitives)列表,而不会再包含任何材质信息——这是因为我们已经在上一个阶段中完成了</p><p><strong>几何阶段</strong></p><ul><li>通常在GPU上进行</li><li>几何阶段负责和每个渲染图元打交道，进行逐顶点、逐多边形的操作</li><li>几何阶段的一个重要任务就是把顶点坐标变换到屏幕空间中，再交给光栅器进行处理<br><strong>输出</strong>：屏幕空间的二维顶点坐标、每个顶点对应的深度值、着色等相关信息，并传递给下一个阶段。</li></ul><p><strong>光栅化阶段</strong></p><ul><li>GPU 上运行</li><li>光栅化的任务主要是决定每个渲染图元中的哪些像素应该被绘制在屏幕上。</li><li>它需要对上一个阶段得到的逐顶点数据（例如纹理坐标、顶点颜色等)进行插值，然后再进行逐像素处理。</li></ul><h1 id="GPU流水线"><a href="#GPU流水线" class="headerlink" title="GPU流水线"></a>GPU流水线</h1><p><img src="/2023/02/09/shader%E5%9F%BA%E7%A1%80/gpu%E6%B5%81%E6%B0%B4%E7%BA%BF.png"><br>GPU的渲染流水线实现。颜色表示了不同阶段的可配置性或可编程性:绿色表示该流水线阶段是完全可编程控制的，黄色表示该流水线阶段可以配置但不是可编程的，蓝色表示该流水线阶段是由GPU固定实现的，开发者没有任何控制权。实线表示该Shader必须由开发者编程实现，虚线表示该Shader是可选的</p>]]></content>
    
    
    
    <tags>
      
      <tag>shader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强化学习</title>
    <link href="/2021/03/12/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/03/12/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>记录相关文章链接</p><span id="more"></span><p><a href="https://blog.csdn.net/qq_34372112/article/details/100526785">强化学习系列之Policy Gradient</a></p>]]></content>
    
    
    <categories>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>动态规划</p><span id="more"></span><h1 id="递推求解"><a href="#递推求解" class="headerlink" title="递推求解"></a>递推求解</h1><h2 id="错排公式"><a href="#错排公式" class="headerlink" title="错排公式"></a>错排公式</h2><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%94%99%E6%8E%92.png"></p><p>我们按照 n 的取值顺序将所有的错装方式数量排 列为一个数列，同样用 F[n]表示数列里第 n 个数的取值，F[n]同时代表 n 个信封 的错装方式总数，我们确定该数列的递推关系。当 n 大于 3 时，我们考虑 n 封信 全部装错的情况。将信封按顺序由 1 到 n 编号。在任意一种错装方案中，假设 n 号信封里装的是 k 号信封的信，而 n 号信封里的信则装在 m 号信封里。按照k和m的等值与否将总的错误方式分为两类。</p><p>若 k 不等于m，交换 n 号信封和m号信封的信后，n 号信封里装的恰好是对<br>应的信，而 m 号信封中错装 k 号信封里的信，即除 n 号信封外其余 n-1 个信封 全部错装，其错装方式等于 F[n - 1]，又由于m的 n-1 个可能取值，这类错装方 式总数为（n - 1）* F[n - 1]。也可以理解为，在 n-1 个信封错装的 F[n - 1]种方式 的基础上，将 n 号信封所装的信与n - 1个信封中任意一个信封（共有 n-1 中选 择）所装的信做交换后，得到所有信封全部错装的方式数。 </p><p>另一种情况，若 k 等于m，交换 n 号信封和m号信封的信后，n 号信封和m 号信封里装的恰好是对应的信，这样除它们之外剩余的 n-2 个信封全部错装，其 错装方式为 F[n - 2]，又由于m的 n-1 个取值，这类错装方式总数为（n - 1）* F[n - 2]。也可以理解为，在 n - 2 个信封全部错装的基础上，交换最后两个信封中的 信(n 号信封和 1 到 n-1 号信封中任意一个，共有 n-1 种选择)，使所有的信封全部 错装的方式数。 </p><p>综上所述，F[n] &#x3D; (n - 1) * F[n - 1] + (n - 1) * F[n - 2]。这就是有名的错排公式</p><p>主要代码</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">F<span class="hljs-comment">[1]</span>=0;<br>F<span class="hljs-comment">[2]</span>=1;<br>for(int i=3;i&lt;=20;i++)<br>    F<span class="hljs-comment">[i]</span>=(i-1)*F<span class="hljs-comment">[i-1]</span>+(i-1)*F<span class="hljs-comment">[i-2]</span>;<br>    //递推求得数列的每一个数字<br></code></pre></td></tr></table></figure><h1 id="最长递增子序列-LIS"><a href="#最长递增子序列-LIS" class="headerlink" title="最长递增子序列 LIS"></a>最长递增子序列 LIS</h1><p>原理</p><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.png"></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AF%BC%E5%BC%B9.png"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;iostream&gt;</span><br><span class="hljs-comment">#include&lt;cmath&gt;</span><br>using namespace std;<br>int dp[26];<br>int a[26];<br>int main()<br>&#123;<br>    int k;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;k&amp;&amp;k)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;=k;i++)<br>        cin&gt;&gt;a[i];<br>        <br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;=k;i++)<br>        &#123;<br>            int <span class="hljs-attribute">tmax</span>=1;<br>            <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=1;j&lt;i;j++)<br>                <span class="hljs-keyword">if</span>(a[j]&gt;=a[i])<br>                    <span class="hljs-attribute">tmax</span>=max(tmax, dp[j]+1);<br>            dp[i]=tmax; <br>        &#125;<br><br>        int <span class="hljs-attribute">ans</span>=1;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;=k;i++)<br>        &#123;<br>            <span class="hljs-attribute">ans</span>=max(ans,dp[i]);<br>        &#125;<br>        cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%90%88%E5%94%B1%E9%98%9F%E5%BD%A2.png"></p><p>思路：<br><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%80%9D%E8%B7%AF.png"></p><p>代码</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include&lt;iostream&gt;</span><br><span class="hljs-meta">#include&lt;cmath&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br><span class="hljs-type">int</span> dp1[<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> dp2[<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> a[<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> main()<br>&#123;<br>    <span class="hljs-type">int</span> N;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;N)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)<br>            cin&gt;&gt;a[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)<br>        &#123;<br>            dp1[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(a[i]&gt;a[j])<br>                    dp1[i]=max(dp1[i],dp1[j]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=N;i&gt;=<span class="hljs-number">1</span>;i<span class="hljs-comment">--)</span><br>        &#123;<br>            dp2[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=N;j&gt;i;j<span class="hljs-comment">--)</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(a[i]&gt;a[j])<br>                   dp2[i]=max(dp2[i],dp2[j]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)<br>        &#123;<br>            ans=max(ans,dp1[i]+dp2[i]);<br>        &#125;<br>        cout&lt;&lt;N-ans+<span class="hljs-number">1</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(LCS)</h1><p>有两个字符串 S1 和 S2，求一个最长公共子串，即求字符串 S3，它同时为<br>S1 和 S2 的子串，且要求它的长度最长，并确定这个长度。这个问题被我们称为 最长公共子序列问题</p><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2.png"></p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<span class="hljs-comment">//dp[i][j]  i,j代表长度为i，j的字符串</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a,b;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;a&gt;&gt;b)<br>    &#123;<br>        <span class="hljs-type">int</span> lena=a.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> lenb=b.<span class="hljs-built_in">length</span>();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=lena;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=lenb;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>||j==<span class="hljs-number">0</span>) &#123;<br>                    dp[i][j]=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(a[i<span class="hljs-number">-1</span>]==b[j<span class="hljs-number">-1</span>]) dp[i][j]=dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> dp[i][j]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]);<br>               <br>            &#125;<br>        cout&lt;&lt;dp[lena][lenb]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="动态规划问题分析举例"><a href="#动态规划问题分析举例" class="headerlink" title="动态规划问题分析举例"></a>动态规划问题分析举例</h1><h2 id="搬寝室"><a href="#搬寝室" class="headerlink" title="搬寝室"></a>搬寝室</h2><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%90%AC%E5%AF%9D%E5%AE%A4.png"><br><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%90%AC%E5%AF%9D%E5%AE%A42.png"></p><p>示例代码</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br>const int INF = 0x7fffffff; //预定义最大的int取值为无穷<br>int list<span class="hljs-comment">[2001]</span>;             //保存每个物品重量<br>int dp<span class="hljs-comment">[1001]</span><span class="hljs-comment">[2001]</span>;         //保存每个状态<br>int main()<br>&#123;<br>    int n, k;<br>    while (cin &gt;&gt; n &gt;&gt; k &amp;&amp; n &amp;&amp; k)<br>    &#123;<br>        for (int i = 1; i &lt;= n; i++)<br>            cin &gt;&gt; list<span class="hljs-comment">[i]</span>;<br>        sort(list + 1, list + 1 + n); //使所有物品按照重量递增排序<br>        for (int i = 1; i &lt;= n; i++)<br>            dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span> = 0;<br>        for (int i = 1; i &lt;= k; i++)<br>        &#123;<br>            //递推求得每个状态<br>            for (int j = 2 * i; j &lt;= n; j++)<br>            &#123;<br>                if (j &gt; 2 * i)<br>                    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span>;<br>                //j&gt;2*i表明，最后两个物品可以不配对，即前j-1件物品足够配成i对<br>                //dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>可以由dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span>转移而来，其值先被设置为dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span><br>                else<br>                    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = INF;<br>                //若j==2*i，说明最后两件物品必须配对，否则前j件物品配不成i对，<br>                //所有其状态不能由dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>转移而来，dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>先设置为正无穷<br>                if(  dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>&gt; (dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-2]</span>+(list<span class="hljs-comment">[j]</span>-list<span class="hljs-comment">[j-1]</span>)*(list<span class="hljs-comment">[j]</span>-list<span class="hljs-comment">[j-1]</span>))  )<br>                &#123;<br>                    //若dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>从dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-2]</span>转移而来时，其值优于之前确定的正无穷<br>                    //或者由dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>转移而来的值时，更新该状态<br>                    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j - 2]</span> + (list<span class="hljs-comment">[j]</span> - list<span class="hljs-comment">[j - 1]</span>) * (list<span class="hljs-comment">[j]</span> - list<span class="hljs-comment">[j - 1]</span>); //更新<br>        <br>                &#125;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; dp<span class="hljs-comment">[k]</span><span class="hljs-comment">[n]</span> &lt;&lt; endl;<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p>主要讨论0-1背包，完全背包和多重背包三类问题</p><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p>采药<br><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%87%87%E8%8D%AF.png"></p><p>首先我们将这个问题抽象：有一个容量为 V 的背包，和一些物品。<br>这些物品分别有两个属性，体积w和价值 v，每种物品只有一个。<br>要求用这个背包装下价值尽可能多的物品，求该最大价值，背包可以不被装满。<br>因为最优解中，每个物品都有两种可能的情况，即在背包中或者不存在（背<br>包中有 0 个该物品或者 1 个），所以我们把这个问题称为 0-1 背包问题。在该例 中，背包的容积和物品的体积等效为总共可用的时间和采摘每个草药所需的时间。</p><p>在众多方案中求解最优解，是典型的动态规划问题。为了用动态规划来解决<br>该问题，我们用 dp[i][j]表示在总体积不超过 j 的情况下，前 i 个物品所能达到的 最大价值。</p><p>初始时，dp[0][j] (0&lt;&#x3D;j&lt;&#x3D;V)为 0。依据每种物品是否被放入背包，每个状态有两个状态转移的来源。</p><p>若物品 i 被放入背包，设其体积为w，价值为 v， 则 dp[i][j] &#x3D; dp[i - 1][j - w] + v。即在总体积不超过 j-w 时前 i-1 件物品可组成的最大价值的基础上再加上i物品的价值v；</p><p>若物品不加入背包，则dp[i][j] &#x3D; dp[i-1][j]， 即此时与总体积不超过 j 的前 i-1 件物品组成的价值最大值等价。</p><p>选择它们之中 较大的值成为状态 dp[i][j]的值。</p><p>综上所述，0-1 背包的状态转移方程为：<br><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%87%87%E8%8D%AF%E6%96%B9%E7%A8%8B.png"></p><p>代码</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#include&lt;iostream&gt;<br>#include&lt;cmath&gt;<br>using namespace std;<br>struct Node&#123;<br>    int w;<br>    int v;<br>&#125;a<span class="hljs-comment">[101]</span>;<br>int dp<span class="hljs-comment">[101]</span><span class="hljs-comment">[1001]</span>;//dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>表示前i个物品组成的总体积不大于j的最大价值和<br>int main()<br>&#123;<br>    int V,M;<br>    while(cin&gt;&gt;V&gt;&gt;M)<br>    &#123;<br>        for(int i=1;i&lt;=M;i++)<br>            cin&gt;&gt;a<span class="hljs-comment">[i]</span>.v&gt;&gt;a<span class="hljs-comment">[i]</span>.w;<br>        for(int i=1;i&lt;=V;i++) //初始化<br>            dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span>=0;<br>        for(int i=1;i&lt;=M;i++) //循环遍历每个物品<br>        &#123;<br>            for(int j=V;j&gt;=a<span class="hljs-comment">[i]</span>.v;j--)<br>            &#123;<br>                dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>,dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-a<span class="hljs-comment">[i]</span>.v]</span>+a<span class="hljs-comment">[i]</span>.w);<br>            &#125;<br>            for(int j=a<span class="hljs-comment">[i]</span>.v-1;j&gt;=0;j--)<br>                dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>;<br>        &#125;<br>        cout&lt;&lt;dp<span class="hljs-comment">[M]</span><span class="hljs-comment">[V]</span>&lt;&lt;endl;<br>    &#125;<br>    return 0;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%87%87%E8%8D%AF%E4%BC%98%E5%8C%96.png"></p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b?a:b;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">E</span>&#123;<br>    <span class="hljs-type">int</span> w;<span class="hljs-comment">//物品的体积</span><br>    <span class="hljs-type">int</span> v;<span class="hljs-comment">//物品的总价值</span><br>&#125;list[<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1001</span>];<span class="hljs-comment">//dp[i][j]表示前i个物品组成的总体积不大于j的最大价值和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> s,n;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;s&gt;&gt;n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>          cin&gt;&gt;list[i].w&gt;&gt;list[i].v;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=s;i++)&#123;<br>            dp[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始化状态</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-comment">//循环每一个物品</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=s;j&gt;=list[i].w;j--)&#123;<br>                <span class="hljs-comment">//对s到list[i].w的每个j，状态转移来源为dp[i-1][j]</span><br>                <span class="hljs-comment">//或dp[i-1][j-list[i].w]+list[i].v,选择其中较大的值</span><br>                dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-list[i].w]+list[i].v);<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;dp[s]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E5%8F%98%E5%8C%96.png"></p><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.png"></p><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%A4%BA%E4%BE%8B.png"></p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x7fffffff</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">E</span>&#123;<span class="hljs-comment">//钱币结构体</span><br>    <span class="hljs-type">int</span> w;<span class="hljs-comment">//重量</span><br>    <span class="hljs-type">int</span> v;<span class="hljs-comment">//价值</span><br>&#125;list[<span class="hljs-number">501</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">10001</span>];<span class="hljs-comment">//状态</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin&gt;&gt;T;<span class="hljs-comment">//输入测试数据组数</span><br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-comment">//T次循环，处理T组数据</span><br>        <span class="hljs-type">int</span> s,tmp;<br>        cin&gt;&gt;tmp&gt;&gt;s;<span class="hljs-comment">//输入空储蓄罐重量和装满钱币的储蓄罐重量</span><br>        s-=tmp;<span class="hljs-comment">//计算钱币所占重量</span><br>        <span class="hljs-type">int</span> n;<br>        cin&gt;&gt;n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            cin&gt;&gt;list[i].v&gt;&gt;list[i].w;<span class="hljs-comment">//输入不同种类钱币的价值和重量</span><br>        &#125;<br>        <span class="hljs-comment">//因为是要求正好相等  所以初始时，除dp[0]外，其余dp[j]设置初始值为无穷或不存在</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=s;i++)<br>            dp[i]=INF;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//遍历所有物品</span><br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=list[i].w;j&lt;=s;j++)&#123;<br>               <span class="hljs-comment">//完全背包，顺序遍历所有可能转移的状态</span><br>               <span class="hljs-keyword">if</span>(dp[j-list[i].w]!=INF) <span class="hljs-comment">//若不为无穷，就可以由此状态转移而来</span><br>                   dp[j]=<span class="hljs-built_in">min</span>(dp[j],dp[j-list[i].w]+list[i].v);<span class="hljs-comment">//取转移值和原值的较小值</span><br>           &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(dp[s]!=INF) <span class="hljs-comment">//若存在一种方案使背包恰好装满，输出其最小值</span><br>            cout&lt;&lt;dp[s]&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span><br>            cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B9%B0%E5%A4%A7%E7%B1%B3.png"><br>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">2</span> <br><span class="hljs-symbol">2 </span><span class="hljs-number">100</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">100</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">400<br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">E</span>&#123;<span class="hljs-comment">//大米</span><br>   <span class="hljs-type">int</span> w;<span class="hljs-comment">//价格</span><br>   <span class="hljs-type">int</span> v;<span class="hljs-comment">//重量</span><br>&#125;list[<span class="hljs-number">2001</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">101</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--) <span class="hljs-comment">//T组测试用例</span><br>    &#123;<br>        <span class="hljs-type">int</span> s,n;   <span class="hljs-comment">//经费和大米种类</span><br>        cin&gt;&gt;s&gt;&gt;n;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> v,w,k;<span class="hljs-comment">//价格，重量，袋数</span><br>            cin&gt;&gt;v&gt;&gt;w&gt;&gt;k;<br>            <span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(k-c&gt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//对输入的数字k，拆分成1,2,4，..k-2^c+1,其中c为使最后一项大于0的最大整数</span><br>                k-=c;<br>                list[++cnt].w=c*w;<br>                list[cnt].v=c*v;<span class="hljs-comment">//拆分后的大米重量和价格均为组成该物品的大米的重量价格和</span><br>                c*=<span class="hljs-number">2</span>;<br>            &#125;<br>            list[++cnt].w=w*k;<br>            list[cnt].v=v*k;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=s;i++) dp[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)&#123;<br>            <span class="hljs-comment">//对拆分后的所有物品进行0-1背包</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=s;j&gt;=list[i].v;j--)&#123;<br>                dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-list[i].v]+list[i].w);<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;dp[s]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%A4%9A%E9%87%8D.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索</title>
    <link href="/2021/03/08/%E6%90%9C%E7%B4%A2/"/>
    <url>/2021/03/08/%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p>总结算法常见问题中关于搜索的相关方法和注意要点</p><span id="more"></span><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>找准条件即可</p><h1 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h1><p>主要完成状态的转移，不断拓展状态</p><h2 id="基础模版例题"><a href="#基础模版例题" class="headerlink" title="基础模版例题"></a>基础模版例题</h2><p><img src="/2021/03/08/%E6%90%9C%E7%B4%A2/%E8%83%9C%E5%88%A9%E9%80%83%E4%BA%A1.png"><br><img src="/2021/03/08/%E6%90%9C%E7%B4%A2/%E8%83%9C%E5%88%A9%E9%80%83%E4%BA%A1%E8%BE%93%E5%85%A5.png"><br><img src="/2021/03/08/%E6%90%9C%E7%B4%A2/%E8%83%9C%E5%88%A9%E9%80%83%E4%BA%A1%E8%BE%93%E5%87%BA.png"></p><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">bool</span> mark[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>][<span class="hljs-number">50</span>];<span class="hljs-comment">//标记数组</span><br><span class="hljs-type">int</span> maze[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>][<span class="hljs-number">50</span>];<span class="hljs-comment">//保存立方体信息</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">N</span>&#123;<br>    <span class="hljs-type">int</span> x,y,z;<span class="hljs-comment">//位置坐标</span><br>    <span class="hljs-type">int</span> t;<span class="hljs-comment">//所需时间</span><br>&#125;;<br>queue&lt;N&gt; Q; <span class="hljs-comment">//队列，队列中的元素为状态</span><br><span class="hljs-type">int</span> go[][<span class="hljs-number">3</span>]=&#123;<br>    <span class="hljs-comment">//用于坐标变换，六个方向</span><br>    <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<br>    <span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<br>    <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())&#123;<br>      N now=Q.<span class="hljs-built_in">front</span>();<br>      Q.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;<br>        <span class="hljs-comment">//依次扩展其六个相邻结点</span><br>        <span class="hljs-type">int</span> nx=now.x+go[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ny=now.y+go[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> nz=now.z+go[i][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span>(nx&lt;<span class="hljs-number">0</span>||nx&gt;=a||ny&lt;<span class="hljs-number">0</span>||ny&gt;=b||nz&lt;<span class="hljs-number">0</span>||nz&gt;=c)  <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//若新坐标在立方体外，则丢弃该坐标</span><br>        <span class="hljs-keyword">if</span>(maze[nx][ny][nz]==<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//若该位置为墙，则丢弃该坐标</span><br>        <span class="hljs-keyword">if</span>(mark[nx][ny][nz]==<span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//已经标记过，丢弃该坐标</span><br>        <span class="hljs-comment">//队列中放入新结点</span><br>        N tmp;<br>        tmp.x=nx;<br>        tmp.y=ny;<br>        tmp.z=nz;<br>        tmp.t=now.t+<span class="hljs-number">1</span>;<span class="hljs-comment">//耗时</span><br>        Q.<span class="hljs-built_in">push</span>(tmp);<br>        mark[nx][ny][nz]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//标记该结点</span><br>        <span class="hljs-keyword">if</span>(nx==a<span class="hljs-number">-1</span>&amp;&amp;ny==b<span class="hljs-number">-1</span>&amp;&amp;nz==c<span class="hljs-number">-1</span>)<br>           <span class="hljs-keyword">return</span> tmp.t;<br>        <span class="hljs-comment">//若该坐标即为终点，可直接返回其耗时</span><br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//若所有状态查找完后，仍得不到所需坐标，则返回-1</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)&#123;<br>        <span class="hljs-type">int</span> a,b,c,t;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;t;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;b;j++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;c;k++)&#123;<br>            cin&gt;&gt;maze[i][j][k];<span class="hljs-comment">//输入立方体信息</span><br>            mark[i][j][k]=<span class="hljs-literal">false</span>;<span class="hljs-comment">//初始化标记数组</span><br>        &#125;<br>        <span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())  Q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//清空队列</span><br>        mark[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//标记起点</span><br>        N tmp;<br>        tmp.t=tmp.x=tmp.y=tmp.z=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始状态</span><br>        Q.<span class="hljs-built_in">push</span>(tmp);<span class="hljs-comment">//将初始状态放入队列</span><br>        <span class="hljs-type">int</span> res=<span class="hljs-built_in">BFS</span>(a,b,c);<span class="hljs-comment">//广度优先搜索</span><br>        <span class="hljs-keyword">if</span>(res&lt;=t)  cout&lt;&lt;res;<span class="hljs-comment">//若所需时间符合条件，则输出</span><br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;-1&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例题2，注重状态转移<br><img src="/2021/03/08/%E6%90%9C%E7%B4%A2/%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90.png"></p><p>示例代码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#include&lt;iostream&gt;</span><br><span class="hljs-comment">#include &lt;queue&gt;</span><br>using namespace std;<br>struct N&#123;<br>    int a,b,c;<span class="hljs-regexp">//</span>每个杯子中可乐的体积<br>    int t;<span class="hljs-regexp">//</span>得到该体积组倾倒次数<br>&#125;;<br>queue&lt;N&gt; Q;<span class="hljs-regexp">//</span>队列<br>bool mark[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<br>void AtoB(int &amp;a,int sa,int &amp;b,int sb)<br>&#123;<br>    <span class="hljs-regexp">//</span>倾倒函数，由容积为sa的杯子倒往容积为sb的杯子<br>    <span class="hljs-regexp">//</span>a，b，初始时为原始杯子中可乐的体积，<br>    <span class="hljs-regexp">//</span>函数调用完毕后，为各自杯子中可乐的新体积<br>    <span class="hljs-keyword">if</span>(sb-b&gt;=a) <br>    &#123;<br>        <span class="hljs-regexp">//</span>若a可以全部倒到b中<br>        b+=a;<br>        a=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        a-=sb-b;<br>        b=sb;<br>    &#125;<br>&#125;<br><br>int BFS(int s,int n,int m)<br>&#123;<br>    <span class="hljs-keyword">while</span>(!Q.empty())<br>    &#123;<br>        N now=Q.front();<span class="hljs-regexp">//</span>拿出队头状态<br>        Q.pop();<br>        int a,b,c;<span class="hljs-regexp">//</span>a,b,c临时保存三个杯子中可乐体积<br><br><br>        <span class="hljs-regexp">//</span>可能的状态 a-&gt;b<br>        a=now.a;<br>        b=now.b;<br>        c=now.c;<br>        AtoB(a,s,b,n);<span class="hljs-regexp">//</span>由a倾倒向b<br>        <span class="hljs-keyword">if</span>(mark[a][b][c]==false)<br>        &#123;<br>            <span class="hljs-regexp">//</span>若该体积组尚未出现<br>            mark[a][b][c]=true;<span class="hljs-regexp">//</span>标记该体积组<br>            N tmp;<br>            tmp.a=a;<br>            tmp.b=b;<br>            tmp.c=c;<br>            tmp.t=now.t+<span class="hljs-number">1</span>;<span class="hljs-regexp">//</span>生成新的状态<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(c==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;c==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-regexp">//</span>若该状态已经为平分状态，则直接返回该状态的耗时<br>            Q.push(tmp);<span class="hljs-regexp">//</span>否则放入队列<br>        &#125;<br><br><br>        <span class="hljs-regexp">//</span>可能的状态b-&gt;a<br>        a=now.a;<br>        b=now.b;<br>        c=now.c;<br>        AtoB(b,n,a,s);<span class="hljs-regexp">//</span>由b倾倒向a<br>        <span class="hljs-keyword">if</span>(mark[a][b][c]==false)<br>        &#123;<br>            <span class="hljs-regexp">//</span>若该体积组尚未出现<br>            mark[a][b][c]=true;<span class="hljs-regexp">//</span>标记该体积组<br>            N tmp;<br>            tmp.a=a;<br>            tmp.b=b;<br>            tmp.c=c;<br>            tmp.t=now.t+<span class="hljs-number">1</span>;<span class="hljs-regexp">//</span>生成新的状态<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(c==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;c==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-regexp">//</span>若该状态已经为平分状态，则直接返回该状态的耗时<br>            Q.push(tmp);<span class="hljs-regexp">//</span>否则放入队列<br>        &#125;<br><br><br>        <span class="hljs-regexp">//</span>可能的状态a-&gt;c<br>        a=now.a;<br>        b=now.b;<br>        c=now.c;<br>        AtoB(a,s,c,m);<span class="hljs-regexp">//</span>由a倾倒向c<br>        <span class="hljs-keyword">if</span>(mark[a][b][c]==false)<br>        &#123;<br>            <span class="hljs-regexp">//</span>若该体积组尚未出现<br>            mark[a][b][c]=true;<span class="hljs-regexp">//</span>标记该体积组<br>            N tmp;<br>            tmp.a=a;<br>            tmp.b=b;<br>            tmp.c=c;<br>            tmp.t=now.t+<span class="hljs-number">1</span>;<span class="hljs-regexp">//</span>生成新的状态<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(c==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;c==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-regexp">//</span>若该状态已经为平分状态，则直接返回该状态的耗时<br>            Q.push(tmp);<span class="hljs-regexp">//</span>否则放入队列<br>        &#125;<br><br><br>        <span class="hljs-regexp">//</span>可能的状态 c-&gt;a<br>        a=now.a;<br>        b=now.b;<br>        c=now.c;<br>        AtoB(c,m,a,s);<span class="hljs-regexp">//</span>由c倾倒向a<br>        <span class="hljs-keyword">if</span>(mark[a][b][c]==false)<br>        &#123;<br>            <span class="hljs-regexp">//</span>若该体积组尚未出现<br>            mark[a][b][c]=true;<span class="hljs-regexp">//</span>标记该体积组<br>            N tmp;<br>            tmp.a=a;<br>            tmp.b=b;<br>            tmp.c=c;<br>            tmp.t=now.t+<span class="hljs-number">1</span>;<span class="hljs-regexp">//</span>生成新的状态<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(c==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;c==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-regexp">//</span>若该状态已经为平分状态，则直接返回该状态的耗时<br>            Q.push(tmp);<span class="hljs-regexp">//</span>否则放入队列<br>        &#125;<br><br><br>        <span class="hljs-regexp">//</span>可能的状态 b-&gt;c<br>        a=now.a;<br>        b=now.b;<br>        c=now.c;<br>        AtoB(b,n,c,m);<span class="hljs-regexp">//</span>由b倾倒向c<br>        <span class="hljs-keyword">if</span>(mark[a][b][c]==false)<br>        &#123;<br>            <span class="hljs-regexp">//</span>若该体积组尚未出现<br>            mark[a][b][c]=true;<span class="hljs-regexp">//</span>标记该体积组<br>            N tmp;<br>            tmp.a=a;<br>            tmp.b=b;<br>            tmp.c=c;<br>            tmp.t=now.t+<span class="hljs-number">1</span>;<span class="hljs-regexp">//</span>生成新的状态<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(c==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;c==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-regexp">//</span>若该状态已经为平分状态，则直接返回该状态的耗时<br>            Q.push(tmp);<span class="hljs-regexp">//</span>否则放入队列<br>        &#125;<br><br><br>        <span class="hljs-regexp">//</span>可能的状态c-&gt;b<br>        a=now.a;<br>        b=now.b;<br>        c=now.c;<br>        AtoB(c,m,b,n);<span class="hljs-regexp">//</span>由c倾倒向b<br>        <span class="hljs-keyword">if</span>(mark[a][b][c]==false)<br>        &#123;<br>            <span class="hljs-regexp">//</span>若该体积组尚未出现<br>            mark[a][b][c]=true;<span class="hljs-regexp">//</span>标记该体积组<br>            N tmp;<br>            tmp.a=a;<br>            tmp.b=b;<br>            tmp.c=c;<br>            tmp.t=now.t+<span class="hljs-number">1</span>;<span class="hljs-regexp">//</span>生成新的状态<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(c==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;c==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-regexp">//</span>若该状态已经为平分状态，则直接返回该状态的耗时<br>            Q.push(tmp);<span class="hljs-regexp">//</span>否则放入队列<br>        &#125;<br>    &#125;<br>    return -<span class="hljs-number">1</span>;<br>&#125;<br><br>int main()<br>&#123;<br>    int s,n,m;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;s&gt;&gt;n&gt;&gt;m&amp;&amp;s&amp;&amp;n&amp;&amp;m)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(s%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-regexp">//</span>若s为奇数不可能平分，直接输出NO<br>            cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;=s;i++)<br>         <span class="hljs-keyword">for</span>(int j=<span class="hljs-number">0</span>;j&lt;=n;j++)<br>          <span class="hljs-keyword">for</span>(int k=<span class="hljs-number">0</span>;k&lt;=m;k++)<br>             mark[i][j][k]=false;<br>             <span class="hljs-regexp">//</span>初始化状态<br>        N tmp;<br>        tmp.a=s;<br>        tmp.b=<span class="hljs-number">0</span>;<br>        tmp.c=<span class="hljs-number">0</span>;<br>        tmp.t=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!Q.empty()) Q.pop();<br>        Q.push(tmp);<span class="hljs-regexp">//</span>将初始状态放入队列<br>        mark[s][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=true;<span class="hljs-regexp">//</span>标记初始状态<br>        int rec=BFS(s,n,m);<span class="hljs-regexp">//</span>广度优先搜索<br>        <span class="hljs-keyword">if</span>(rec==-<span class="hljs-number">1</span>) cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;rec&lt;&lt;endl;<br>    &#125;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归是一种十分常用的编码技巧，所谓即递归即函数调用<br>函数本身，调用的方式按照问题的不同人为定义，这种调用方式被称为递归方式。<br>同时，为了不使这样的递归无限的发生，我们必须设定递归的出口，即当函数到达某种条件时停止递归。</p><h2 id="模版例题："><a href="#模版例题：" class="headerlink" title="模版例题："></a>模版例题：</h2><p><img src="/2021/03/08/%E6%90%9C%E7%B4%A2/%E6%B1%89%E8%AF%BA%E5%A1%94.png"><br><img src="/2021/03/08/%E6%90%9C%E7%B4%A2/han.png"><br>主要代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart">Long Long F(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span>)&#123;<br>   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">num</span>==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>*F(<span class="hljs-built_in">num</span><span class="hljs-number">-1</span>)+<span class="hljs-number">2</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="示例1：素数环"><a href="#示例1：素数环" class="headerlink" title="示例1：素数环"></a>示例1：素数环</h2><p>题目大意为由给定的 1 到 n 数字中，将数字依次填入环中，使得环中任意两 个相邻的数字间的和为素数。</p><p>对于给定的 n，按字典序由小到大输出所有符合条 件的解（第一个数恒定为 1）<br><img src="/2021/03/08/%E6%90%9C%E7%B4%A2/%E7%B4%A0%E8%BE%93.png"></p><p>为了解决该问题，我们可以采用回溯法枚举每一个值。当第一个数位为 1<br>确定时，我们尝试放入第二个数，使其和 1 的和为素数，放入后再尝试放入第三 个数，使其与第二个数的和为素数，直到所有的数全部被放入环中，且最后一个 数与 1 的和也是素数，那么这个方案即为答案，输出；若在尝试放数的过程中， 发现当前位置无论放置任何之前未被使用的数均不可能满足条件，那么我们回溯 改变其上一个数，直到产生我们所需要的答案，或者确实不再存在更多的解。 为了实现这一回溯枚举的过程，我们采用递归的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> ans[<span class="hljs-number">22</span>];<span class="hljs-comment">//保存环中每一个被放入的数</span><br><span class="hljs-type">bool</span> hashnum[<span class="hljs-number">22</span>];<span class="hljs-comment">//标记之前已经被放入环中的数</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> prime[]=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">17</span>,<span class="hljs-number">19</span>,<span class="hljs-number">23</span>,<span class="hljs-number">29</span>,<span class="hljs-number">31</span>,<span class="hljs-number">37</span>,<span class="hljs-number">41</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//判断是否是素数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">13</span>;i++)<br>      <span class="hljs-keyword">if</span>(prime[i]==x) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//检查输出由回溯枚举得到的解</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(ans[n]+ans[<span class="hljs-number">1</span>])==<span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//判读最后一个数和第一个数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">1</span>) cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        cout&lt;&lt;ans[i];<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//递归枚举，num为当前已经放入环中的数字</span><br>    <span class="hljs-keyword">if</span>(num&gt;<span class="hljs-number">1</span>) <span class="hljs-comment">//当放入的数字大于一个时</span><br>      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(ans[num]+ans[num<span class="hljs-number">-1</span>])==<span class="hljs-literal">false</span>)<br>         <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//判断最后两个数字的和是否为素数，若不是则返回枚举第num个数</span><br>    <span class="hljs-keyword">if</span>(num==n)&#123;<br>        <span class="hljs-comment">//若已经放入了n个数</span><br>        <span class="hljs-built_in">check</span>();<span class="hljs-comment">//检查输出</span><br>        <span class="hljs-keyword">return</span>;<span class="hljs-comment">//返回，继续枚举下一组解</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-comment">//放入一个数</span><br>        <span class="hljs-keyword">if</span>(hashnum[i]==<span class="hljs-literal">false</span>)&#123;<br>            hashnum[i]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//标记i为已使用</span><br>            ans[num+<span class="hljs-number">1</span>]=i;<span class="hljs-comment">//将这个数字放入ans数组中</span><br>            <span class="hljs-built_in">DFS</span>(num+<span class="hljs-number">1</span>);<span class="hljs-comment">//继续尝试放入下一个数</span><br>            hashnum[i]=<span class="hljs-literal">false</span>;<span class="hljs-comment">//当回溯回枚举该位数字时，将i标记为未使用</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cas=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录Case数</span><br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&amp;&amp;n)<br>    &#123;<br>        cas++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">22</span>;i++)<br>           hashnum[i]=<span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//初始化</span><br>        ans[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//第一个数字恒定为1</span><br>        cout&lt;&lt;cas&lt;&lt;endl;<br>        hashnum[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//标记1被使用</span><br>        <span class="hljs-built_in">DFS</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//继续尝试放入下一个数字</span><br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="示例2-洪泛-遍历图"><a href="#示例2-洪泛-遍历图" class="headerlink" title="示例2  洪泛 遍历图"></a>示例2  洪泛 遍历图</h2><p>题目大意：在给定的 n*m 图中，确定有几个@的块。块符合以下条件，其<br>中的任意对@均互相直接或间接连通，两个@直接相邻或者对角相邻即被视为连通。<br>计算最后总共有几个连通块</p><p>输入</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mel">The input <span class="hljs-keyword">file</span> contains one or more grids. Each <span class="hljs-keyword">grid</span> begins with a line containing<br>m and n, the number of rows and columns <span class="hljs-keyword">in</span> the <span class="hljs-keyword">grid</span>, separated by a single space. If m = <span class="hljs-number">0</span> it signals the end of the input; otherwise <span class="hljs-number">1</span> &lt;= m &lt;= <span class="hljs-number">100</span> and <span class="hljs-number">1</span> &lt;= n &lt;= <span class="hljs-number">100.</span> Following this are m lines of n characters each (not counting the end-of-line characters). Each <span class="hljs-keyword">character</span> corresponds to one plot, and is either <span class="hljs-string">`*&#x27;, representing the absence of oil, or `</span>@&#x27;, representing an oil pocket.<br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <br>*<br><span class="hljs-number">3</span> <span class="hljs-number">5</span><br>*@*@* <br>**@** <br>*@*@* <br><span class="hljs-number">1</span> <span class="hljs-number">8</span><br>@@****@* <br><span class="hljs-number">5</span> <span class="hljs-number">5</span><br>****@ <br>*@@*@ <br>*@**@ <br>@@@*@ <br>@@**@ <br><span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">For <span class="hljs-keyword">each</span> grid, output <span class="hljs-keyword">the</span> <span class="hljs-built_in">number</span> <span class="hljs-keyword">of</span> distinct oil deposits. Two different pockets are part <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> same oil deposit <span class="hljs-keyword">if</span> they are adjacent horizontally, vertically, <span class="hljs-keyword">or</span> diagonally. An oil deposit will <span class="hljs-keyword">not</span> contain more than <span class="hljs-number">100</span> pockets.For <span class="hljs-keyword">each</span> grid, output <span class="hljs-keyword">the</span> <span class="hljs-built_in">number</span> <span class="hljs-keyword">of</span> distinct oil deposits. Two different pockets are part <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> same oil deposit <span class="hljs-keyword">if</span> they are adjacent horizontally, vertically, <span class="hljs-keyword">or</span> diagonally. An oil deposit will <span class="hljs-keyword">not</span> contain more than <span class="hljs-number">100</span> pockets.<br><span class="hljs-number">0</span> <br><span class="hljs-number">1</span> <br><span class="hljs-number">2</span> <br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br>char a[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<br>bool mark[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<br>int n, m;<br>void init()<br>&#123;<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">101</span>; i++)<br>        <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">101</span>; j++)<br>        &#123;<br>            a[i][j] = <span class="hljs-number">0</span>;<br>            mark[i][j] = <span class="hljs-literal">false</span>;<br>        &#125;<br>&#125;<br>void DFS(int h, int l)<br>&#123;<br>    <span class="hljs-keyword">if</span> (h &gt; n || l &gt; m)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">-1</span>; i &lt;= <span class="hljs-number">1</span>; i++)<br>        <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">-1</span>; j &lt;= <span class="hljs-number">1</span>; j++)<br>        &#123;<br><br>            int <span class="hljs-keyword">new</span><span class="hljs-type">h</span> = h + i;<br>            int <span class="hljs-keyword">new</span><span class="hljs-type">l</span> = l + j;<br>    <br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">h</span> &lt; <span class="hljs-number">1</span> || <span class="hljs-keyword">new</span><span class="hljs-type">h</span> &gt; n || <span class="hljs-keyword">new</span><span class="hljs-type">l</span> &lt; <span class="hljs-number">1</span> || <span class="hljs-keyword">new</span><span class="hljs-type">l</span> &gt; m || mark[<span class="hljs-keyword">new</span><span class="hljs-type">h</span>][<span class="hljs-keyword">new</span><span class="hljs-type">l</span>] == <span class="hljs-literal">true</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (a[<span class="hljs-keyword">new</span><span class="hljs-type">h</span>][<span class="hljs-keyword">new</span><span class="hljs-type">l</span>] == <span class="hljs-string">&#x27;*&#x27;</span>)<br>                <span class="hljs-keyword">continue</span>;<br><br>            mark[<span class="hljs-keyword">new</span><span class="hljs-type">h</span>][<span class="hljs-keyword">new</span><span class="hljs-type">l</span>] = <span class="hljs-literal">true</span>;<br>            DFS(<span class="hljs-keyword">new</span><span class="hljs-type">h</span>, <span class="hljs-keyword">new</span><span class="hljs-type">l</span>);<br>        &#125;<br>&#125;<br><br>int main()<br>&#123;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &amp;&amp; n)<br>    &#123;<br>        cin &gt;&gt; m;<br>        init();<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>                cin &gt;&gt; a[i][j];<br>        int ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (!mark[i][j] &amp;&amp; a[i][j] == <span class="hljs-string">&#x27;@&#x27;</span>)<br>                &#123;<br>                    mark[i][j] = <span class="hljs-literal">true</span>;<br>                    DFS(i, j);<br>                    ans++;<br>                &#125;<br>            &#125;<br><br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h1><p>首先回顾之前已经介绍过的广度优先搜索。在由状态的转移和扩展构成的解答树中，<br>广度优先搜索按照层次遍历所有的状态，直到找到我们需要的状态。 与其相对的，假如我们改变对解答树的遍历方式，改为优先遍历层次更深的状态，直到遇到一个状态结点，其不再拥有子树，则返回上一层，<br>访问其未被访 问过的子树，直至解答树中所有的状态都被遍历完毕。<br>这个过程，类似于树的前序遍历。<br><br>由于其缺少了广度搜索中按层次递增顺序遍历的特性。<br>所以当深度优先搜索 搜索到我们需要的状态时，其不再具有某种最优的特性。<br>所以，在使用深度优先 搜索时，我们更多的求解有或者没有的问题，即对解答树是否有我们需要的答案 进行判定，<br>而一般不使用深度优先搜索求解最优解问题</p><h2 id="示例-迷宫-经典问题"><a href="#示例-迷宫-经典问题" class="headerlink" title="示例  迷宫 经典问题"></a>示例  迷宫 经典问题</h2><p>题目大意：有一个 N*M 的迷宫，包括起点 S，终点 D，墙 X，和地面，0<br>秒时主人公从 S 出发，每秒能走到四个与其相邻的位置中的一个，且每个位置被 行走之后都不能再次走入，问是否存在这样一条路径使主人公在 T 秒时刚好走 到D。</p><p>样例输入输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus">第一行代表N，M，T，接下来N行M列就是数组，也就是此题迷宫的地图<br><br><span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <br>S<span class="hljs-selector-class">.X</span>. <br>.<span class="hljs-selector-class">.X</span>. <br>.<span class="hljs-selector-class">.XD</span> <br>....<br><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <br>S<span class="hljs-selector-class">.X</span>. <br>.<span class="hljs-selector-class">.X</span>. <br>..<span class="hljs-selector-class">.D</span> <br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><br>输出：<br>NO <br>YES<br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br>int N, M, T;<br>char a[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>];<br>int dir[][<span class="hljs-number">2</span>] = &#123;<br>    <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<br>    <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>bool mark[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>];<br>bool flag;<br>void DFS(int x, int y, int t)<br>&#123;<br>    <span class="hljs-keyword">if</span> (a[x][y] == <span class="hljs-string">&#x27;D&#x27;</span>)<br>    &#123;<br>        flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t &gt; T)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        &#123;<br>            int <span class="hljs-keyword">new</span><span class="hljs-type">x</span> = x + dir[i][<span class="hljs-number">0</span>];<br>            int <span class="hljs-keyword">new</span><span class="hljs-type">y</span> = y + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">x</span> &lt; <span class="hljs-number">1</span> || <span class="hljs-keyword">new</span><span class="hljs-type">x</span> &gt; N || <span class="hljs-keyword">new</span><span class="hljs-type">y</span> &lt; <span class="hljs-number">1</span> || <span class="hljs-keyword">new</span><span class="hljs-type">y</span> &gt; M)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (a[<span class="hljs-keyword">new</span><span class="hljs-type">x</span>][<span class="hljs-keyword">new</span><span class="hljs-type">y</span>] == <span class="hljs-string">&#x27;X&#x27;</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (!mark[<span class="hljs-keyword">new</span><span class="hljs-type">x</span>][<span class="hljs-keyword">new</span><span class="hljs-type">y</span>])<br>            &#123;<br>                mark[<span class="hljs-keyword">new</span><span class="hljs-type">x</span>][<span class="hljs-keyword">new</span><span class="hljs-type">y</span>] = <span class="hljs-literal">true</span>;<br>                DFS(<span class="hljs-keyword">new</span><span class="hljs-type">x</span>, <span class="hljs-keyword">new</span><span class="hljs-type">y</span>, t + <span class="hljs-number">1</span>);<br>                mark[<span class="hljs-keyword">new</span><span class="hljs-type">x</span>][<span class="hljs-keyword">new</span><span class="hljs-type">y</span>] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br>int main()<br>&#123;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; N &gt;&gt; M &gt;&gt; T &amp;&amp; N &amp;&amp; M &amp;&amp; T)<br>    &#123;<br>        flag = <span class="hljs-literal">false</span>;<br>        int marki, markj;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>            <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">1</span>; j &lt;= M; j++)<br>            &#123;<br>                mark[i][j] = <span class="hljs-literal">false</span>;<br>                cin &gt;&gt; a[i][j];<br>                <span class="hljs-keyword">if</span> (a[i][j] == <span class="hljs-string">&#x27;S&#x27;</span>)<br>                &#123;<br>                    marki = i;<br>                    markj = j;<br>                &#125;<br>            &#125;<br>        mark[marki][markj] = <span class="hljs-literal">true</span>;<br>        DFS(marki, markj, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">if</span> (flag)<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p>八皇后</p><p><img src="/2021/03/08/%E6%90%9C%E7%B4%A2/%E5%85%AB%E7%9A%87%E5%90%8E.png"></p><p>主要在于判断对角线是否相同</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/*非常朴素的八皇后问题，问题规模也已经框定好了，只要把每次得到的列号转化成要比较的十进制数字即可*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; solut;            <span class="hljs-comment">//用来放最终的结果</span><br><span class="hljs-type">int</span> position[<span class="hljs-number">9</span>];            <span class="hljs-comment">//行号从1开始，其中下标代表行号，其中存放的内容代表列号</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">DFS</span>(<span class="hljs-number">1</span>);                    <span class="hljs-comment">//直接从第一行开始放</span><br>    <span class="hljs-built_in">sort</span>(solut.<span class="hljs-built_in">begin</span>(), solut.<span class="hljs-built_in">end</span>());    <span class="hljs-comment">//这里应该不用sort因为得到的solution应该都是从小到大</span><br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n) != EOF)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, solut[n - <span class="hljs-number">1</span>]);    <span class="hljs-comment">//因为vector是从0开始的    </span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span>            <span class="hljs-comment">//row代表要放入的行号,逐行放入，因为要用的是列号，而且按照习惯都是一列一列计算的</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (row == <span class="hljs-number">9</span>)            <span class="hljs-comment">//row==9意味着从1~8行全都放入,已完成解</span><br>    &#123;<br>        <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">8</span>; i++)<br>        &#123;<br>            temp += position[i] * <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-number">8</span> - i);    <br>        &#125;<br>        solut.<span class="hljs-built_in">push_back</span>(temp);                        <span class="hljs-comment">//把得到的solution放进vector</span><br>    &#125;<br><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">8</span>; i++)<br>        &#123;<br>            position[row] = i;        <span class="hljs-comment">//i在这里代表列号</span><br>            <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;        <span class="hljs-comment">//用一个标志位来标记，是否冲突</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;  row; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (position[row] == position[j] || row - position[row] == j - position[j] || row + position[row] == j + position[j])<br>                &#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;        <span class="hljs-comment">//这里的判断条件j - position[j]会把同一主对角线标记为同一个数字，与row - position[row]同时计算就能判断是否冲突</span><br>            &#125;<span class="hljs-comment">//for</span><br>            <span class="hljs-keyword">if</span> (flag)<br>                <span class="hljs-built_in">DFS</span>(row + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<span class="hljs-comment">//endif</span><br>&#125;<span class="hljs-comment">//DFS</span><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法之数学问题</title>
    <link href="/2021/03/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>涉及机试中涉及的一系列数学问题，包括数位拆解、分解素因数等高频知识点，以及最小公倍数，最大公约数的基本方法，高精度整数运算的实现。</p><span id="more"></span><h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><p><img src="/2021/03/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include &lt;bits/stdc++.h&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> a,b;<br>    <span class="hljs-built_in">string</span> n;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;a&gt;&gt;n&gt;&gt;b)<br>    &#123;<br>        <span class="hljs-built_in">long</span> num=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">string</span> result=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(n[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>            n=n.substr(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">int</span> k=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=n.length()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(n[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;n[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>                num+=(n[i]-<span class="hljs-string">&#x27;0&#x27;</span>)*k;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n[i]&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;n[i]&lt;=<span class="hljs-string">&#x27;z&#x27;</span>)<br>                num+=(n[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">10</span>)*k;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n[i]&gt;=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;n[i]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)<br>                num+=(n[i]-<span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-number">10</span>)*k;<br>            k*=a;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(num%b&lt;=<span class="hljs-number">9</span>)<br>                result=to_string(num%b)+result;<br>            <span class="hljs-keyword">else</span><br>                result=<span class="hljs-built_in">string</span>(<span class="hljs-number">1</span>,num%b<span class="hljs-number">-10</span>+<span class="hljs-string">&#x27;A&#x27;</span>)+result;<br>            num/=b;<br>        &#125;<br>        cout&lt;&lt;result&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最大公约数-GCD"><a href="#最大公约数-GCD" class="headerlink" title="最大公约数 GCD"></a>最大公约数 GCD</h1><p>求a,b的最大公约数：</p><ol><li>如果a,b全为0，则它们的最大公约数不存在</li><li>若a,b其中之一为零，它们的最大公约数为a,b中非0的那个</li><li>若a,b都不为0  则使a&#x3D;b;b&#x3D;a%b;  然后重复该过程</li></ol><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">else</span> <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">gcd</span><span class="hljs-params">(b,a%b)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最小公倍数-LCM"><a href="#最小公倍数-LCM" class="headerlink" title="最小公倍数 LCM"></a>最小公倍数 LCM</h1><p>a,b两数的最小公倍数为两数的乘积除以它们的最大公约数</p><h1 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h1><p>合数是指在大于1的整数中除了能被1和本身整除外，还能被其他数（0除外）整除的数。与之相对的是质数（素数），而1既不属于质数也不属于合数。最小的合数是4。其中，完全数与相亲数是以它为基础的。</p><h2 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h2><p>若一个数不是素数，则必存在一个小于它的素数为其的因数。在我们获得一个素数时，将它的所有倍数均标记为非素数，这样当我们遍历到一个数时，它没有被任何小于它的素数标记为非素数，则确定其为素数。</p><p><img src="/2021/03/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/%E7%B4%A0%E6%95%B0%E7%AD%9B.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-meta">#include&lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-built_in">int</span> prime[<span class="hljs-number">10000</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">int</span> primesize=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">bool</span> mark[<span class="hljs-number">10001</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span>()</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">10001</span>;i++)<br>        mark[i]=<span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">10000</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(mark[i]==<span class="hljs-literal">true</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        prime[primesize++]=i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=i*i;j&lt;=<span class="hljs-number">10000</span>;j+=i)<br>            mark[j]=<span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-keyword">init</span>();<br>    <span class="hljs-built_in">int</span> n;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n)<br>    &#123;<br>        <span class="hljs-built_in">bool</span> flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;primesize;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(prime[i]&lt;n&amp;&amp;prime[i]%<span class="hljs-number">10</span>==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(flag==<span class="hljs-literal">false</span>)<br>                &#123;<br>                    flag=<span class="hljs-literal">true</span>;<br>                    cout&lt;&lt;prime[i];<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;prime[i];<br>                &#125;<br>            &#125; <br>        &#125;<br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="分解素因数"><a href="#分解素因数" class="headerlink" title="分解素因数"></a>分解素因数</h2><p><img src="/2021/03/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/%E5%88%86%E8%A7%A3%E7%B4%A0%E5%9B%A0%E6%95%B0.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include&lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-built_in">int</span> prime[<span class="hljs-number">100000</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">int</span> primesize;<br><span class="hljs-built_in">bool</span> mark[<span class="hljs-number">100001</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span>()</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100001</span>;i++)<br>        mark[i]=<span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">100000</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(mark[i])<br>            <span class="hljs-keyword">continue</span>;<br>        prime[primesize++]=i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=i*i;j&lt;=<span class="hljs-number">100000</span>;j+=i)<br>            mark[j]=<span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-keyword">init</span>();<br>    <span class="hljs-built_in">int</span> N;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;N)<br>    &#123;<br>         <span class="hljs-built_in">int</span> ansPrime[<span class="hljs-number">30</span>];<span class="hljs-comment">//按顺序保存分解出的素因数</span><br>         <span class="hljs-built_in">int</span> ansSize=<span class="hljs-number">0</span>;<span class="hljs-comment">//分解出素因数的个数</span><br>         <span class="hljs-built_in">int</span> ansNum[<span class="hljs-number">30</span>]; <span class="hljs-comment">//保存分解出的素因数对应的幂指数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;primesize;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(N%prime[i]==<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//若该素数能整除分解数</span><br>                ansPrime[ansSize]=prime[i];<span class="hljs-comment">//则该素数为其素因数</span><br>                ansNum[ansSize]=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始化幂指数为0</span><br>                <span class="hljs-keyword">while</span>(N%prime[i]==<span class="hljs-number">0</span>)<br>                &#123;<br>                    ansNum[ansSize]++;<br>                    N/=prime[i];<br>                &#125;<br>                ansSize++;<br>                <span class="hljs-keyword">if</span>(N==<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(N!=<span class="hljs-number">1</span>)&#123;<br>            ansPrime[ansSize]=N;<span class="hljs-comment">//若测试所有素因数，n仍未被分解至1，则剩余的因数一定是N一个大于100000的素因数</span><br>            ansNum[ansSize++]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;ansSize;i++)&#123;<br>            ans+=ansNum[i]; <br>        &#125;<br>        cout&lt;&lt;ans&lt;&lt;endl;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="阶乘的素因数分解"><a href="#阶乘的素因数分解" class="headerlink" title="阶乘的素因数分解"></a>阶乘的素因数分解</h2><p><img src="/2021/03/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/%E6%95%B4%E9%99%A4%E9%97%AE%E9%A2%98.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a,n;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;a)!=EOF)&#123;<br>        <span class="hljs-type">int</span> count1[<span class="hljs-number">1010</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> count2[<span class="hljs-number">1010</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> t=n;<br>            <span class="hljs-keyword">while</span>(t)&#123;<br>                count1[i]+=t/i;<br>                t=t/i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">233333333</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=a;i++)&#123;<br>            <span class="hljs-keyword">while</span>(a%i==<span class="hljs-number">0</span>)&#123;<br>                count2[i]++;<br>                a/=i;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count2[i]==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(count1[i]/count2[i]&lt;ans)<br>                ans=count1[i]/count2[i];<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><br></code></pre></td></tr></table></figure><p>使用素数筛</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1010</span><br><span class="hljs-type">int</span> prime[N];<br><span class="hljs-type">int</span> primesize;<br><span class="hljs-type">bool</span> mark[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)<br>        mark[i]=<span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;N;i++)&#123;<br>        <span class="hljs-keyword">if</span>(mark[i]==<span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            prime[primesize++]=i;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i*i;j&lt;N;j+=i)<br>                mark[j]=<span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> a,n;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;a)!=EOF)&#123;<br>        <span class="hljs-type">int</span> count1[N]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> count2[N]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;primesize;i++)&#123;<br>            <span class="hljs-type">int</span> t=n;<br>            <span class="hljs-keyword">while</span>(t)&#123;<br>                count1[i]+=t/prime[i];<br>                t/=prime[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">233333333</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;primesize;i++)&#123;<br>            <span class="hljs-keyword">while</span>(a%prime[i]==<span class="hljs-number">0</span>)&#123;<br>                count2[i]++;<br>                a/=prime[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count2[i]==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(count1[i]/count2[i]&lt;ans)<br>                ans=count1[i]/count2[i];<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="二分求幂"><a href="#二分求幂" class="headerlink" title="二分求幂"></a>二分求幂</h1><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p><a href="https://blog.csdn.net/harington/article/details/87602682">csdn相关介绍博客</a></p><p><img src="/2021/03/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/%E5%BF%AB%E9%80%9F%E5%B9%82.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binaryPow</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)  <span class="hljs-comment">//对应二进制位为1  可以写成b&amp;1 取二进制最后一位</span><br>           ans*=a;  <span class="hljs-comment">//累乘至结果</span><br>        a*=a;       <span class="hljs-comment">//准备</span><br>        b/=<span class="hljs-number">2</span>;       <span class="hljs-comment">//可以写成b&gt;&gt;1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a,b;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;a&gt;&gt;b)<br>    &#123;<br>       cout&lt;&lt;<span class="hljs-built_in">binaryPow</span>(a,b)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> N=<span class="hljs-number">10</span>;<br><span class="hljs-built_in">int</span> tmp[N][N];<br><span class="hljs-built_in">void</span> multi(<span class="hljs-built_in">int</span> a[][N],<span class="hljs-built_in">int</span> b[][N],<span class="hljs-built_in">int</span> n)<br>&#123;<br>    memset(tmp,<span class="hljs-number">0</span>,sizeof tmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)<br>        tmp[i][j]+=a[i][k]*b[k][j];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>        a[i][j]=tmp[i][j];<br>&#125;<br><span class="hljs-built_in">int</span> res[N][N];<br><span class="hljs-built_in">void</span> Pow(<span class="hljs-built_in">int</span> a[][N],<span class="hljs-built_in">int</span> n)<br>&#123;<br>    memset(res,<span class="hljs-number">0</span>,sizeof res);<span class="hljs-comment">//n是幂，N是矩阵大小</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++) res[i][i]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(n)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>)<br>            multi(res,a,N);<span class="hljs-comment">//res=res*a;复制直接在multi里面实现了；</span><br>        multi(a,a,N);<span class="hljs-comment">//a=a*a</span><br>        n&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br><br>————————————————<br>版权声明：本文为CSDN博主「wust_wenhao」的原创文章，遵循CC <span class="hljs-number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：https:<span class="hljs-comment">//blog.csdn.net/wust_zzwh/article/details/52058209</span><br><br></code></pre></td></tr></table></figure><h1 id="高精度整数"><a href="#高精度整数" class="headerlink" title="高精度整数"></a>高精度整数</h1><p>计算n的阶乘</p><p><img src="/2021/03/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/n%E7%9A%84%E9%98%B6%E4%B9%98.png"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> res[<span class="hljs-number">3000</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> N;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;N)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3000</span>;i++) res[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> size=<span class="hljs-number">0</span>;res[size++]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=N;i++)<br>        &#123;<br>            <span class="hljs-type">int</span> jinwei=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;size;j++)<br>            &#123;<br>                res[j]=(res[j]*i+jinwei);<br>                <span class="hljs-keyword">if</span>(res[j]&gt;<span class="hljs-number">9</span>)<br>                &#123;<br>                    jinwei=res[j]/<span class="hljs-number">10</span>;<br>                    res[j]%=<span class="hljs-number">10</span>;<br>                &#125;     <br>                <span class="hljs-keyword">else</span> jinwei=<span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(jinwei)&#123;<br>                res[size++]=jinwei%<span class="hljs-number">10</span>;<br>                jinwei/=<span class="hljs-number">10</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=size<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>            cout&lt;&lt;res[i];<br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构相关算法</title>
    <link href="/2021/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
    <url>/2021/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>包含树，图，bfs，dfs，最短路径，最小生成树等常用模版代码</p><span id="more"></span><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="题目1：遍历二叉树"><a href="#题目1：遍历二叉树" class="headerlink" title="题目1：遍历二叉树"></a>题目1：遍历二叉树</h2><p><img src="/2021/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E5%8D%95.png"></p><ol><li>利用结论：二叉树的先序遍历入栈，那么出栈顺序就是他的中序遍历</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string pre;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; pre)<br>    &#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : pre)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (it != <span class="hljs-string">&#x27;#&#x27;</span>)<br>                s.<span class="hljs-built_in">push</span>(it);<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (!s.<span class="hljs-built_in">empty</span>())<br>                &#123;<br>                    cout &lt;&lt; s.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>                    s.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>使用数组模拟二叉树</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N1=<span class="hljs-number">1e8</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N2=<span class="hljs-number">1e2</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> pos,len,t;<br><span class="hljs-type">char</span> tree[N1];<br><span class="hljs-type">char</span> str[N2];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span><span class="hljs-comment">//建立二叉树</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> c = str[t++];<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;#&#x27;</span>)<span class="hljs-comment">//若是‘#’，说明该节点为空返回上一级节点</span><br>        <span class="hljs-keyword">return</span>;<br>    tree[pos] = c;<span class="hljs-comment">//若不是‘#’，为本节点赋值</span><br>    <span class="hljs-built_in">create</span>(pos*<span class="hljs-number">2</span>);<span class="hljs-comment">//递归创建左子树</span><br>    <span class="hljs-built_in">create</span>(pos*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);<span class="hljs-comment">//递归创建右子树</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span><span class="hljs-comment">//中序遍历二叉树</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(tree[root]==<span class="hljs-number">0</span>)<span class="hljs-comment">//如果该节点为0，说明该节点为空，返回上一级</span><br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traverse</span>(<span class="hljs-number">2</span>*root);<span class="hljs-comment">//先遍历左子树</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>,tree[root]);<span class="hljs-comment">//遍历完左子树后，访问本节点</span><br>    <span class="hljs-built_in">traverse</span>(<span class="hljs-number">2</span>*root+<span class="hljs-number">1</span>);<span class="hljs-comment">//再遍历右子树</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str)!=EOF)<br>    &#123;<br>        t=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">create</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">traverse</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>通过指针创建二叉树</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 101</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    Node *lchild;<br>    Node *rchild;<br>    <span class="hljs-type">char</span> c;<br>&#125;;<br><br><span class="hljs-function">Node *<span class="hljs-title">CreateNode</span><span class="hljs-params">()</span><span class="hljs-comment">//创建新节点，返回结点指针</span></span><br><span class="hljs-function"></span>&#123;<br>    Node *ret=(Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Node));<br>    ret-&gt;lchild=<span class="hljs-literal">NULL</span>;<br>    ret-&gt;rchild=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">(Node *T)</span><span class="hljs-comment">//中序遍历</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T-&gt;lchild!=<span class="hljs-literal">NULL</span>) <span class="hljs-built_in">InOrder</span>(T-&gt;lchild);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, T-&gt;c);<br>    <span class="hljs-keyword">if</span>(T-&gt;rchild!=<span class="hljs-literal">NULL</span>) <span class="hljs-built_in">InOrder</span>(T-&gt;rchild);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Del</span><span class="hljs-params">(Node *T)</span><span class="hljs-comment">//删除树</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T-&gt;lchild!=<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//删除左子树</span><br>    &#123;<br>        <span class="hljs-built_in">Del</span>(T-&gt;lchild);<br>        T-&gt;lchild=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(T-&gt;rchild!=<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//删除右子树</span><br>    &#123;<br>        <span class="hljs-built_in">Del</span>(T-&gt;rchild);<br>        T-&gt;rchild=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(T);<span class="hljs-comment">//删除根节点</span><br>&#125;<br><br><span class="hljs-type">unsigned</span> pos;<span class="hljs-comment">//标记字符串处理到哪了</span><br><span class="hljs-type">char</span> str[N];<span class="hljs-comment">//读取的字符串</span><br><br><span class="hljs-function">Node *<span class="hljs-title">BuildTree</span><span class="hljs-params">()</span><span class="hljs-comment">//根据字符串创立二叉树，并返回根节点指针</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(pos&gt;=<span class="hljs-built_in">strlen</span>(str)) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//字符串处理完了就歇着吧</span><br>    <span class="hljs-keyword">if</span>(str[pos]==<span class="hljs-string">&#x27;#&#x27;</span>)<span class="hljs-comment">//创建空树，即返回空指针</span><br>    &#123;<br>        pos++;<span class="hljs-comment">//准备处理下一个字符</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    Node *p=<span class="hljs-built_in">CreateNode</span>();<span class="hljs-comment">//创建一个空节点</span><br>    p-&gt;c=str[pos++];<span class="hljs-comment">//先序，先获取根节点的字符信息</span><br>    p-&gt;lchild=<span class="hljs-built_in">BuildTree</span>();<span class="hljs-comment">//创建左子树</span><br>    p-&gt;rchild=<span class="hljs-built_in">BuildTree</span>();<span class="hljs-comment">//创建右子树</span><br>    <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//完事，返回根节点指针</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">gets</span>(str))<br>    &#123;<br>        pos=<span class="hljs-number">0</span>;<span class="hljs-comment">//标记字符串处理到哪了</span><br>        Node *T=<span class="hljs-built_in">BuildTree</span>();<span class="hljs-comment">//根据字符串构建整棵树</span><br>        <span class="hljs-built_in">InOrder</span>(T);<span class="hljs-comment">//中序遍历并输出</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-built_in">Del</span>(T);<span class="hljs-comment">//贴心的删除树，释放内存空间</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题目二：给定先序中序求后序"><a href="#题目二：给定先序中序求后序" class="headerlink" title="题目二：给定先序中序求后序"></a>题目二：给定先序中序求后序</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span>&lt;iostream&gt;<br>#<span class="hljs-keyword">include</span>&lt;algorithm&gt;<br>using namespace std;<br>void <span class="hljs-constructor">Post(<span class="hljs-params">string</span> <span class="hljs-params">str1</span>,<span class="hljs-params">string</span> <span class="hljs-params">str2</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(str1.length<span class="hljs-literal">()</span>==<span class="hljs-number">0</span>)    return;<br>    <span class="hljs-built_in">int</span> root=str2.find(str1<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>);<br>    <span class="hljs-constructor">Post(<span class="hljs-params">str1</span>.<span class="hljs-params">substr</span>(1,<span class="hljs-params">root</span>)</span>,str2.substr(<span class="hljs-number">0</span>,root));<br>    <span class="hljs-constructor">Post(<span class="hljs-params">str1</span>.<span class="hljs-params">substr</span>(<span class="hljs-params">root</span>+1)</span>,str2.substr(root+<span class="hljs-number">1</span>));<br>    cout&lt;&lt;str1<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;<br>&#125;<br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span><br>&#123;<br>    <span class="hljs-built_in">string</span> str1,str2;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;str1&gt;&gt;str2)<br>    &#123;<br>        <span class="hljs-constructor">Post(<span class="hljs-params">str1</span>,<span class="hljs-params">str2</span>)</span>;<br>        cout&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>代码二</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;                <span class="hljs-comment">//树结点结构体</span><br>   Node *lchild; <span class="hljs-comment">//左儿子指针</span><br>   Node *rchild; <span class="hljs-comment">//右儿子指针</span><br>   <span class="hljs-type">char</span> c;       <span class="hljs-comment">//结点字符信息</span><br>&#125; Tree[<span class="hljs-number">50</span>];      <span class="hljs-comment">//静态内存分配数组</span><br><span class="hljs-type">int</span> loc;         <span class="hljs-comment">//静态数组中已经分配的结点个数</span><br><span class="hljs-function">Node *<span class="hljs-title">creat</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-comment">//申请一个结点空间,返回指向其的指针</span><br>   Tree[loc].lchild = Tree[loc].rchild = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//初始化左右儿子为空</span><br>   <span class="hljs-keyword">return</span> &amp;Tree[loc++];                        <span class="hljs-comment">//返回指针,且loc累加</span><br>&#125;<br><span class="hljs-type">char</span> str1[<span class="hljs-number">30</span>], str2[<span class="hljs-number">30</span>]; <span class="hljs-comment">//保存前序和中序遍历结果字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(Node *T)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">//后序遍历</span><br>   <span class="hljs-keyword">if</span> (T-&gt;lchild != <span class="hljs-literal">NULL</span>)<br>   &#123;                        <span class="hljs-comment">//若左子树不为空</span><br>      <span class="hljs-built_in">postOrder</span>(T-&gt;lchild); <span class="hljs-comment">//递归遍历其左子树</span><br>   &#125;<br>   <span class="hljs-keyword">if</span> (T-&gt;rchild != <span class="hljs-literal">NULL</span>)<br>   &#123;                        <span class="hljs-comment">//若右子树不为空</span><br>      <span class="hljs-built_in">postOrder</span>(T-&gt;rchild); <span class="hljs-comment">//递归遍历其右子树</span><br>   &#125;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, T-&gt;c); <span class="hljs-comment">//遍历该结点,输出其字符信息</span><br>&#125;<br><span class="hljs-function">Node *<span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> s1, <span class="hljs-type">int</span> e1, <span class="hljs-type">int</span> s2, <span class="hljs-type">int</span> e2)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-comment">//由字符串的前序遍历和中序遍历还原树, 并返回其根节点, </span><br>   <span class="hljs-comment">//其中前序遍历结果为由str1[s1] 到str2[e1] ，中序遍历结果为str2[s2] 到str2[e2]</span><br>   Node *ret = <span class="hljs-built_in">creat</span>(); <span class="hljs-comment">//为该树根节点申请空间</span><br>   ret-&gt;c = str1[s1];   <span class="hljs-comment">//该结点字符为前序遍历中第一个字符</span><br>   <span class="hljs-type">int</span> rootIdx;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s2; i &lt;= e2; i++)<br>   &#123; <span class="hljs-comment">//查找该根节点字符在中序遍历中的位置</span><br>      <span class="hljs-keyword">if</span> (str2[i] == str1[s1])<br>      &#123;<br>         rootIdx = i;<br>         <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (rootIdx != s2)<br>   &#123;  <span class="hljs-comment">//若左子树不为空,递归还原其左子树</span><br>      ret-&gt;lchild = <span class="hljs-built_in">build</span>(s1 + <span class="hljs-number">1</span>, s1 + (rootIdx - s2), s2, rootIdx - <span class="hljs-number">1</span>); <br>   &#125;<br>   <span class="hljs-keyword">if</span> (rootIdx != e2)<br>   &#123;  <span class="hljs-comment">//若右子树不为空,递归还原其右子树</span><br>      ret-&gt;rchild = <span class="hljs-built_in">build</span>(s1 + (rootIdx - s2) + <span class="hljs-number">1</span>, e1, rootIdx + <span class="hljs-number">1</span>, e2); <br>   &#125;<br>   <span class="hljs-keyword">return</span> ret; <span class="hljs-comment">//返回根节点指针</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str1) != EOF)<br>   &#123;<br>      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str2); <span class="hljs-comment">//输入</span><br>      loc = <span class="hljs-number">0</span>;    <span class="hljs-comment">//初始化静态内存空间中已经使用结点个数为0</span><br>      <span class="hljs-type">int</span> L1 = <span class="hljs-built_in">strlen</span>(str1);<br>      <span class="hljs-type">int</span> L2 = <span class="hljs-built_in">strlen</span>(str2);          <span class="hljs-comment">//计算两个字符串长度</span><br>      Node *T = <span class="hljs-built_in">build</span>(<span class="hljs-number">0</span>, L1 - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, L2 - <span class="hljs-number">1</span>); <span class="hljs-comment">//还原整棵树,其根结点指针保存在T中</span><br>      <span class="hljs-built_in">postOrder</span>(T);                   <span class="hljs-comment">//后序遍历</span><br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);                   <span class="hljs-comment">//输出换行</span><br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="vector在邻接链表中的应用"><a href="#vector在邻接链表中的应用" class="headerlink" title="vector在邻接链表中的应用"></a>vector在邻接链表中的应用</h2><p>首先定义一个结构体</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> Struct Edge&#123;<br>    <span class="hljs-built_in">int</span> nextNode;<span class="hljs-comment">//下一个结点编号</span><br>    <span class="hljs-built_in">int</span> cost;<span class="hljs-comment">//该边的权重</span><br>&#125;Edge;<br></code></pre></td></tr></table></figure><p>为每一个结点建立一个单链表来保存与其相邻的边权值和结点的信息。使用vector来模拟这些单链表。结点数量为N</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;Edge&gt; edge[N];<br></code></pre></td></tr></table></figure><p>利用</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">for</span>(int i=<span class="hljs-number">0</span>;i&lt;N;i++)  &#123;<br>    edge<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.clear</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>来实现对这些单链表的初始化<br><br><br>要添加信息时使用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Edge tmp<span class="hljs-comment">;//准备一个Edge结构体</span><br>tmp.nextNode<span class="hljs-operator">=</span><span class="hljs-number">3</span><span class="hljs-comment">;//下一结点编号为3</span><br>tmp.cost<span class="hljs-operator">=</span><span class="hljs-number">38</span><span class="hljs-comment">;</span><br>edge[<span class="hljs-number">1</span>].push_back(tmp)<span class="hljs-comment">;//将该边加入结点1的单链表中</span><br></code></pre></td></tr></table></figure><p>当需要查询某个结点的所有邻接信息时，对vector进行遍历</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-keyword">edge</span>[<span class="hljs-number">2</span>]<span class="hljs-variable">.size</span>();i++)&#123;<br>    <span class="hljs-keyword">int</span> nextNode=<span class="hljs-keyword">edge</span>[<span class="hljs-number">2</span>][i]<span class="hljs-variable">.nextNode</span>;  <span class="hljs-comment">//读出邻接结点</span><br>    <span class="hljs-keyword">int</span> cost=<span class="hljs-keyword">edge</span>[<span class="hljs-number">2</span>][i]<span class="hljs-variable">.cost</span>;  <span class="hljs-comment">//读出权值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当需要删除某个单链表中的某些边信息时，调用vector::erase<br><br>例如，删除结点1的单链表中edge[1][i]所对应的边信息时，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">edge<span class="hljs-selector-attr">[1]</span><span class="hljs-selector-class">.erase</span>(edge<span class="hljs-selector-attr">[1]</span><span class="hljs-selector-class">.begin</span>()+<span class="hljs-selector-tag">i</span>,edge<span class="hljs-selector-attr">[1]</span><span class="hljs-selector-class">.begin</span>())+<span class="hljs-selector-tag">i</span>+<span class="hljs-number">1</span>);<br>//即vector<span class="hljs-selector-class">.erase</span>(vector<span class="hljs-selector-class">.begin</span>()+第一个要删除的元素编号，vector<span class="hljs-selector-class">.begin</span>()+最后一个要删除元素的编号+<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>首先，定义一个数组，用双亲表示法来表示各棵树（所有的集合元素个数总和为N）：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> Tree[<span class="hljs-built_in">N</span>];<br></code></pre></td></tr></table></figure><p>用Tree[i]来表示结点i的双亲结点，若Tree[i]为 <strong>-1</strong> 则表示该结点不存在双亲结点，即结点i为其所在树的根节点.<br><br><br>为了查找结点x所在树的根节点，定义以下函数</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRoot</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(Tree[x]==<span class="hljs-number">-1</span>)  <span class="hljs-keyword">return</span> x;<span class="hljs-comment">//若当前结点为根节点则返回该结点号</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">findRoot</span><span class="hljs-params">(Tree[x])</span></span>; <span class="hljs-comment">//否则递归查找其双钱结点的根节点</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>为了优化路径压缩</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> find<span class="hljs-constructor">Root(<span class="hljs-params">int</span> <span class="hljs-params">x</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(Tree<span class="hljs-literal">[<span class="hljs-identifier">x</span>]</span>==-<span class="hljs-number">1</span>)  return x;<span class="hljs-comment">//若当前结点为根节点则返回该结点号</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">int</span> tmp=find<span class="hljs-constructor">Root(Tree[<span class="hljs-params">x</span>])</span>;<br>        Tree<span class="hljs-literal">[<span class="hljs-identifier">x</span>]</span>=tmp; <span class="hljs-comment">//将当前结点的双亲设置为查找返回的根节点编号</span><br>        return tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例1-畅通工程-求解图上连通分量个数"><a href="#例1-畅通工程-求解图上连通分量个数" class="headerlink" title="例1 畅通工程 求解图上连通分量个数"></a>例1 畅通工程 求解图上连通分量个数</h3><p><img src="/2021/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include&lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-built_in">int</span> Tree[<span class="hljs-number">1010</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span>()</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1010</span>;i++)<br>        Tree[i]=<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">findRoot</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(Tree[x]==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> tmp=findRoot(Tree[x]);<br>        Tree[x]=tmp;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> N,M;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;N&amp;&amp;N)<br>    &#123;<br>        cin&gt;&gt;M;<br>        <span class="hljs-keyword">init</span>();<br>        <span class="hljs-keyword">while</span>(M--)<br>        &#123;<br>            <span class="hljs-built_in">int</span> a,b;<br>            cin&gt;&gt;a&gt;&gt;b;<br>            <br>            <span class="hljs-built_in">int</span> roota=findRoot(a);<br>            <span class="hljs-built_in">int</span> rootb=findRoot(b);<br>            <span class="hljs-keyword">if</span>(roota!=rootb)<br>                Tree[roota]=rootb;<br>        &#125;<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(Tree[i]==<span class="hljs-number">-1</span>)  ans++;<br>        &#125;<br>        cout&lt;&lt;ans<span class="hljs-number">-1</span>&lt;&lt;endl; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例2-More-is-better"><a href="#例2-More-is-better" class="headerlink" title="例2 More is better"></a>例2 More is better</h3><p>题目大意：有10000000个人，其中有n个好朋友，朋友关系具有传递性，找出最大的集合，集合中都是朋友关系或者只有一个人，输出集合中最多少人。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> N = <span class="hljs-number">10000001</span>;<br><span class="hljs-built_in">int</span> Tree[N] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">int</span> Sum[N] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span>()</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    &#123;<br>        Tree[i] = <span class="hljs-number">-1</span>;<br>        Sum[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getRoot</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (Tree[x] == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> tmp = getRoot(Tree[x]);<br>        Tree[x] = tmp;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> n;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &amp;&amp; n)<br>    &#123;<br>        <span class="hljs-built_in">int</span> a, b;<br>        <span class="hljs-keyword">init</span>();<br>        <span class="hljs-keyword">while</span> (n--)<br>        &#123;<br>            cin &gt;&gt; a &gt;&gt; b;<br>            a=getRoot(a);<br>            b=getRoot(b);<br>            <span class="hljs-keyword">if</span> (a!=b)<br>            &#123;<br>                Tree[a] = b;<br>                Sum[b] += Sum[a];<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (Tree[i] == <span class="hljs-number">-1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (Sum[i] &gt; ans)<br>                &#123;<br>                    ans = Sum[i];<br>                &#125;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以用来判断连通图</p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>定义：在一个无向连通图中，如果存在一个连通子图包含原图中所有的结点合萼部分边，且这个子图中不存在回路，那么我们称这个子图为原图的一颗生成树。在带权图中，所有的生成树中边权的和最小的那颗（或几颗）被称为最小生成树。</p><h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>原理：</p><ol><li>初始时所有结点属于孤立的集合</li><li>按照边权递增顺序遍历所有的边，若遍历到的边两个顶点仍分属不同的集合（该边即为连通这两个集合的边中权值最小的那条）则确定该边为最小生成树上的一条边，并将这两个顶点分属的集合合并。</li><li>遍历完所有边后，原图上所有结点属于同一个集合则被选取的边和原图中所有结点构成最小生成树；否则原图不连通，最小生成树不存在。。</li></ol><p>例题1  还是畅通工程，利用并查集<br><img src="/2021/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/%E8%BF%98%E6%98%AF%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-type">int</span> cost;<br>&#125;;<span class="hljs-comment">//定义边数据结构</span><br>Edge edge[<span class="hljs-number">5000</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> Tree[<span class="hljs-number">101</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">101</span>;i++)<br>        Tree[i]=<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFather</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(Tree[x]==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> tmp=<span class="hljs-built_in">findFather</span>(Tree[x]);<br>        Tree[x]=tmp;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Edge x,Edge y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x.cost&lt;y.cost;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> N;<span class="hljs-comment">//村庄数目 &lt;100;</span><br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;N&amp;&amp;N)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5000</span>;i++)<br>            edge[i].a=edge[i].b=edge[i].cost=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> M=N*(N<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<span class="hljs-comment">//边的数量;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;M;i++)<br>           cin&gt;&gt;edge[i].a&gt;&gt;edge[i].b&gt;&gt;edge[i].cost;<br>        <span class="hljs-built_in">sort</span>(edge,edge+M,cmp);<span class="hljs-comment">//按边排好序后，选边加入</span><br>        <span class="hljs-built_in">init</span>();<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录总长度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;M;i++)<br>        &#123;<br>            <span class="hljs-type">int</span> a=<span class="hljs-built_in">findFather</span>(edge[i].a);<br>            <span class="hljs-type">int</span> b=<span class="hljs-built_in">findFather</span>(edge[i].b);<br>            <span class="hljs-keyword">if</span>(a!=b)  <span class="hljs-comment">//不属于一个集合</span><br>            &#123;<br>                Tree[a]=b;<br>                ans+=edge[i].cost;<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最短路径-自己到自己设为0-其他一开始设为-1-不可达"><a href="#最短路径-自己到自己设为0-其他一开始设为-1-不可达" class="headerlink" title="最短路径  自己到自己设为0  其他一开始设为-1  不可达"></a>最短路径  自己到自己设为0  其他一开始设为-1  不可达</h2><h3 id="Floyd-弗洛伊德算法"><a href="#Floyd-弗洛伊德算法" class="headerlink" title="Floyd 弗洛伊德算法"></a>Floyd 弗洛伊德算法</h3><p>全源最短路   三重循环</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">for(int k=1;k&lt;=n;k++) //k从1到N循环，依次代表允许经过的中间结点编号小于等于k<br>for(int i=1;i&lt;=n;i++)<br>    for(int j=1;j&lt;=n;j++)&#123;<br>        if(ans<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span>==-1||ans<span class="hljs-comment">[k]</span><span class="hljs-comment">[j]</span>==-1)  continue;<br>        if(ans<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>==-1||ans<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span>+ans<span class="hljs-comment">[k]</span><span class="hljs-comment">[j]</span>&lt;ans<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>)<br>            ans<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=ans<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span>+ans<span class="hljs-comment">[k]</span><span class="hljs-comment">[j]</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>算法特点：最好图的大小不超过200个结点，当两个结点间有多余一条边时，选择长度最小的边权值存入邻接矩阵。</p><h3 id="Dijkstra-迪杰斯特拉算法"><a href="#Dijkstra-迪杰斯特拉算法" class="headerlink" title="Dijkstra 迪杰斯特拉算法"></a>Dijkstra 迪杰斯特拉算法</h3><p>单源最短路</p><p>算法流程：</p><ol><li>初始化，集合K中加入结点1，结点1到结点1最短距离为0，到其他结点为无穷（或不确定）</li><li>遍历与集合K中结点直接相邻的边（U，V，C），其中U属于集合K，V不属于集合K，计算由结点1出发按照已经得到的最短路径到达U，再由U经过该边到达V时的路径长度。比较所有与集合K中结点直接相邻的非集合K结点该路径长度，其中路径长度最小的结点被确定为下一个最短路径确定的结点，其最短路径长度即为这个路径长度，最后将该结点加入集合K</li><li>若集合K中已经包含所有的点，算法结束；否则重复步骤2</li></ol><p>例题<br>采用vector模拟链表</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">E</span>&#123;<br>    <span class="hljs-type">int</span> next;  <span class="hljs-comment">//代表直接相邻的结点</span><br>    <span class="hljs-type">int</span> c;     <span class="hljs-comment">//代表该边的权值</span><br>&#125;;<br>vector&lt;E&gt; edge[<span class="hljs-number">101</span>];<span class="hljs-comment">//邻接链表</span><br><span class="hljs-type">bool</span> mark[<span class="hljs-number">101</span>];<span class="hljs-comment">//标记是否得到最短路径</span><br><span class="hljs-type">int</span> Dis[<span class="hljs-number">101</span>];<span class="hljs-comment">//标记开始点距离各个结点距离</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n&amp;&amp;m)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)  <br>            edge[i].<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">//初始化邻接链表</span><br>        <span class="hljs-keyword">while</span>(m--)<br>        &#123;<br>            <span class="hljs-type">int</span> a,b,c;<br>            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>            E tmp;<br>            tmp.c=c;<br>            tmp.next=b;<br>            edge[a].<span class="hljs-built_in">push_back</span>(tmp);<br>            tmp.next=a;<br>            edge[b].<span class="hljs-built_in">push_back</span>(tmp);<br>            <span class="hljs-comment">//将邻接信息加入邻接链表，无向图 两遍</span><br>        &#125;<br>        <span class="hljs-comment">//初始化mark和dis数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            Dis[i]=<span class="hljs-number">-1</span>;<span class="hljs-comment">//代表不可达</span><br>            mark[i]=<span class="hljs-literal">false</span>;<span class="hljs-comment">//所有结点不属于集合K</span><br>        &#125;<br>        Dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>; <span class="hljs-comment">//得到最近的结点为自己 结点1，长度为0</span><br>        mark[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//将结点1加入集合K</span><br>        <span class="hljs-type">int</span> newP=<span class="hljs-number">1</span>;<span class="hljs-comment">//集合中新加入的点为结点1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<span class="hljs-comment">//循环n-1次</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;edge[newP].<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-type">int</span> t=edge[newP][j].next;<br>                <span class="hljs-type">int</span> c=edge[newP][j].c;<br>                <span class="hljs-comment">//看是否可通过newP这个点 缩短相关结点的最短距离</span><br>                <span class="hljs-keyword">if</span>(mark[t]==<span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(Dis[t]==<span class="hljs-number">-1</span>||Dis[t]&gt;Dis[newP]+c)<br>                &#123;<br>                    Dis[t]=Dis[newP]+c;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//找下一个最小点   之前的标记为true</span><br>            <span class="hljs-type">int</span> min=<span class="hljs-number">123123123</span>;<span class="hljs-comment">//最小值初始化为一个大整数，为找最小值作准备</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(mark[j]==<span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(Dis[j]==<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(Dis[j]&lt;min)&#123;<br>                    min=Dis[j]; <span class="hljs-comment">//更新其为最小值</span><br>                    newP=j; <span class="hljs-comment">//以此为中介 更新</span><br>                &#125;<br>            &#125;<br>            mark[newP]=<span class="hljs-literal">true</span>;<br>        &#125;<br>        cout&lt;&lt;Dis[n]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>采用矩阵</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs stata">需要一个辅助数组<span class="hljs-keyword">dis</span>来存储起点到其他所有点的距离<br>将<span class="hljs-keyword">dis</span>数组中的值称为最短路程的<span class="hljs-string">&quot;估计值&quot;</span><br>核心思想:通过边来松弛起点到其他各个点的距离<br>代码;<br><span class="hljs-comment">//初始化dis数组</span><br> <span class="hljs-keyword">for</span>(int i=1;i&lt;=<span class="hljs-keyword">n</span>;i++)<br>  <span class="hljs-keyword">dis</span>[i]=a[1][i](假设起点为1)<br><span class="hljs-comment">//标记数组初始化visted</span><br> <span class="hljs-keyword">for</span>(int i=1;i&lt;=<span class="hljs-keyword">n</span>;i++)<br>   visted[i]=0;<br> visted[1]=1;<br><span class="hljs-comment">//接下来重复过程</span><br>在<span class="hljs-keyword">dis</span>数组中找当前离起点最近的点<br>然后访问这个点的所有边看是否能通过<span class="hljs-keyword">dis</span>数组更新起点到那些边的距离<br>能的话就更新<br>代码:(部分是伪代码)<br> int min=<span class="hljs-keyword">Inf</span>;<br> <span class="hljs-keyword">for</span>(int i=1;i&lt;=<span class="hljs-keyword">dis</span>.size();i++)<br>  &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">dis</span>[i]&lt;min)<br>     &#123;<br>        min=<span class="hljs-keyword">dis</span>[i];<br>        <span class="hljs-keyword">mark</span>=i  ;<span class="hljs-comment">//mark用来记录这一点</span><br>     &#125; <br>&#125;<br>然后更新：<br> <span class="hljs-keyword">for</span>(int v=1；v&lt;=<span class="hljs-keyword">n</span>;v++)<br>   &#123;<br>      <span class="hljs-keyword">if</span>(a[<span class="hljs-keyword">mark</span>][v]&lt;<span class="hljs-keyword">inf</span>)<br>        &#123;<br>             <span class="hljs-keyword">if</span>(<span class="hljs-keyword">dis</span>[v]&gt;<span class="hljs-keyword">dis</span>[<span class="hljs-keyword">mark</span>]+a[<span class="hljs-keyword">mark</span>][v])<br>                <span class="hljs-keyword">dis</span>[v]=<span class="hljs-keyword">dis</span>[<span class="hljs-keyword">mark</span>]+a[<span class="hljs-keyword">mark</span>][v];<br>        &#125;<br>   &#125;<br><br>这个过程持续<span class="hljs-keyword">n</span>-1所以最外层还要加上循环<br> <span class="hljs-keyword">for</span>(int k=1;k&lt;=<span class="hljs-keyword">n</span>-1;k++)<br>&#123;<br> ….<br>&#125;<br><br>时间复杂度O(<span class="hljs-keyword">n</span>^2)<br><br><br></code></pre></td></tr></table></figure><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>使用标准模版：std：：queue</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">queue&lt;<span class="hljs-type">int</span>&gt; Q;<br></code></pre></td></tr></table></figure><p>Q.push(x);将元素x放入队尾</p><p>x&#x3D;Q.front();&#x2F;&#x2F;读取队头元素，将其值赋值给x</p><p>Q.pop();&#x2F;&#x2F;弹出队头元素</p><p>Q.empty();&#x2F;&#x2F;判断队列是否为空，若返回值为true代表队列为空</p><p>为了保存在拓扑排序中不断出现的和之前已经出现的入度为 0 的结点，我们 使用一个队列。每当出现一个入度为 0 的结点，我们将其放入队列；若需要找到 一个入度为 0 的结点，就从队头取出。</p><p>示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 在一个 qq 群里有着许多师徒关系，如 A 是 B 的师父，同时 B<br><span class="hljs-regexp">//</span> 是A的徒弟，一个师父可能有许多徒弟，一个徒弟也可能会有许多不同的师父。 <br><span class="hljs-regexp">//</span> 输入给出该群里所有的师徒关系，问是否存在这样一种非法的情况：<br><span class="hljs-regexp">//</span> 以三个人为 例，即A是B的师父，B是C 的师父，C又反过来是A的师父。<br><span class="hljs-regexp">//</span> 若我们将该群 里的所有人都抽象成图上的结点，将所有的师徒关系都抽象成有向边（由师父指 向徒弟），<br><span class="hljs-regexp">//</span> 该实际问题就转化 图是否为有向无环图。为一个数学问题——该图上是否存在一个环，<br><span class="hljs-regexp">//</span> 即判断是否属于有向无环图时。若一个图，存在符合拓扑次序的结点序列，则该图为有向无环图<br><span class="hljs-comment">#include&lt;iostream&gt;</span><br><span class="hljs-comment">#include&lt;vector&gt;</span><br><span class="hljs-comment">#include&lt;queue&gt;</span><br>using namespace std;<br>vector&lt;int&gt; edge[<span class="hljs-number">501</span>];<span class="hljs-regexp">//</span>邻接链表，此边无权值，只需保存编号<br>queue&lt;int&gt; Q;<span class="hljs-regexp">//</span>保存入度为<span class="hljs-number">0</span>的结点的队列<br>int main()<br>&#123;<br>    int inDegree[<span class="hljs-number">501</span>];<span class="hljs-regexp">//</span>统计每个结点的入度<br>    int n,m;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n&amp;&amp;m)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-regexp">//</span>初始化所有结点，编号<span class="hljs-number">0</span>~n-<span class="hljs-number">1</span><br>        &#123;<br>            inDegree[i]=<span class="hljs-number">0</span>; <span class="hljs-regexp">//</span>初始化入度信息，所有结点入度均为<span class="hljs-number">0</span><br>            edge[i].clear();<span class="hljs-regexp">//</span>清空邻接链表<br>        &#125;<br>        <span class="hljs-keyword">while</span> (m--)<br>        &#123;<br>            int a,b;<br>            cin&gt;&gt;a&gt;&gt;b;<span class="hljs-regexp">//</span>读入一条由a指向b的有向边<br>            inDegree[b]++;<br>            edge[a].push_back(b);<span class="hljs-regexp">//</span>将b加入a的邻接链表<br>        &#125;<br>        <span class="hljs-keyword">while</span>(Q.empty()==false) Q.pop();<span class="hljs-regexp">//</span>清空队列<br>        <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(inDegree[i]==<span class="hljs-number">0</span>)<br>            Q.push(i);<span class="hljs-regexp">//</span>若结点入度为<span class="hljs-number">0</span>，则将其放入队列<br>        &#125;<br>        int cnt=<span class="hljs-number">0</span>;<span class="hljs-regexp">//</span>累加已经确定拓扑序列的结点个数<br>        <span class="hljs-keyword">while</span>(Q.empty()==false)&#123;<br>            int nowP=Q.front();<span class="hljs-regexp">//</span>取出队头结点编号<br>            Q.pop();<span class="hljs-regexp">//</span>弹出队头元素<br>            cnt++;<br>            <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;edge[nowP].size();i++)&#123;<br>                <span class="hljs-regexp">//</span>将该结点以及以其为弧尾的所有边去除<br>                inDegree[edge[nowP][i]]--;<br>                <span class="hljs-regexp">//</span>去除某条边后，该边所指后继结点入度减一<br>                <span class="hljs-keyword">if</span>(inDegree[edge[nowP][i]]==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-regexp">//</span>若该结点入度变为<span class="hljs-number">0</span><br>                Q.push(edge[nowP][i]);<span class="hljs-regexp">//</span>将其放到队列中<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-regexp">//</span>若所有结点都能被确定拓扑序列，则原图为有向无环图<br>        <span class="hljs-regexp">//</span>否则，原图为非有向无环图<br>        <span class="hljs-keyword">if</span>(cnt==n) cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>;<br>        cout&lt;&lt;endl;<br>    &#125;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mlagent学习记录</title>
    <link href="/2021/02/23/mlagent%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/02/23/mlagent%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>记录mlagent相关知识</p><!---more--><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>ML-Agents Academy类按如下方式安排代理模拟循环：</p><p>1.调用学院的<code>OnEnvironmentReset</code>委托。<br>2.为场景中的每个Agent调用<code>OnEpisodeBegin()</code>函数。<br>3.为场景中的每个Agent调用 <code>CollectObservations(VectorSensor sensor)</code>函数。<br>4.使用每个Agent的策略来决定Agent的下一个动作。<br>5.为场景中的每个Agent调用<code>OnActionReceived()</code>函数，并传入代理商策略选择的操作。<br>6.如果代理已达到其 <code>MaxStep</code> ，则调用代理的<code>OnEpisodeBegin()</code>函数。</p><h2 id="命令行相关"><a href="#命令行相关" class="headerlink" title="命令行相关"></a>命令行相关</h2><p>使用mlagents-learn进行训练<br><br>相应参数：<br><img src="/2021/02/23/mlagent%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E5%91%BD%E4%BB%A41.png"><br><img src="/2021/02/23/mlagent%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E5%91%BD%E4%BB%A42.png"><br><img src="/2021/02/23/mlagent%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E5%91%BD%E4%BB%A43.png"></p><h2 id="设计Agent"><a href="#设计Agent" class="headerlink" title="设计Agent"></a>设计Agent</h2><h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h3><p>代理扮演这观察周围环境，并决定最好的使用这些观察的行动方针的角色。通过在unity中继承Agent类来创建Agent。创建Agent的关键是你根据Agent完成任务并给予的奖励。<br><br>一个Agent将它观察到的信息传给它的Policy。之后，Policy会做出决定并且反馈相应的动作给Agent。你的Agent代码必须执行这个动作并对每个动作评估奖励值，奖励值用来探索最优的决策。<br><br>Policy从代理本身抽象出决策逻辑，因此您可以在多个代理中使用相同的策略。政策如何制定决策取决于它是什么样的政策。您可以更改策略<br>通过更改其”行为参数(Behavior Parameters)”来代理。如果您将”行为类型(Behavior Type)”设置为”仅限启发式(Heuristic Only)”，代理将使用其”启发式”方法做出决策它可以允许您手动控制代理或编写自己的策略。如果代理有一个”模型(Model)”文件，它的政策将使用神经网络”模型”作出决定。</p><h3 id="Decisons"><a href="#Decisons" class="headerlink" title="Decisons"></a>Decisons</h3><p>每次代理请求时，观察-决策-行动-奖励周期都会重复一个决定。当”Agent.RequestDecision()”被调用时，代理将请求决策。如果您需要代理定期请求自行决策，添加代理游戏对象的”Decision Requester”组件。定期决策<br>间隔通常最适合基于物理的模拟。例如，机器人模拟器中的代理，必须提供关节扭矩的精细控制应该在模拟的每一步都做出决定。另一方面，一个代理，只需要作出决定时，某些游戏或模拟事件发生，应手动调用”Agent.RequestDecision()”。</p><h3 id="Observations"><a href="#Observations" class="headerlink" title="Observations"></a>Observations</h3><p>要做出决策，代理必须观察其环境才能推断世界的状态。状态观察可以采取以下形式：<br></p><ul><li>Vector Observation :  由浮点数组成的数组</li><li>Visual Observation :  一个或多个摄像机图像或者渲染纹理</li></ul><p>当你使用vector Observation时，要继承<code>Agent.CollectObservations(VectorSensor sensor)</code>方法来创建功能矢量<br><br>当你使用visual Observation时，你只需要确定哪些Unity的相机对象或渲染将提供图像，基础代理类将处理剩下的东西。你不需要使用<code>CollectObservations(VectorSensor sensor)</code>方法，除非你也同时使用了vector observation。</p><h4 id="Vector-Observation-Space-Feature-Vectors"><a href="#Vector-Observation-Space-Feature-Vectors" class="headerlink" title="Vector Observation Space: Feature Vectors"></a>Vector Observation Space: Feature Vectors</h4><p>使用<code>CollectObservations(VectorSensor sensor)</code>方法来收集信息在这个函数里面使用<code>VectorSensor.AddObservation</code> 来手动添加信息。<br>例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> GameObject ball;<br><br><span class="hljs-keyword">private</span> List&lt;<span class="hljs-built_in">float</span>&gt; state = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">float</span>&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CollectObservations</span>(<span class="hljs-params">VectorSensor sensor</span>)</span><br>&#123;<br>    sensor.AddObservation(gameObject.transform.rotation.z);<br>    sensor.AddObservation(gameObject.transform.rotation.x);<br>    sensor.AddObservation((ball.transform.position.x - gameObject.transform.position.x));<br>    sensor.AddObservation((ball.transform.position.y - gameObject.transform.position.y));<br>    sensor.AddObservation((ball.transform.position.z - gameObject.transform.position.z));<br>    sensor.AddObservation(ball.transform.GetComponent&lt;Rigidbody&gt;().velocity.x);<br>    sensor.AddObservation(ball.transform.GetComponent&lt;Rigidbody&gt;().velocity.y);<br>    sensor.AddObservation(ball.transform.GetComponent&lt;Rigidbody&gt;().velocity.z);<br>&#125;<br></code></pre></td></tr></table></figure><p>当设置Agent的<code>Behavior Parameters</code>时，可以设置下面这些属性：</p><ul><li>Space Size： 状态大小必须匹配你之前添加信息构成的功能矢量的长度，<br>观测特征向量是浮点数列表，这意味着<br>您必须将任何其他数据类型转换为浮点数或浮点数列表。<br><br><code>VectorSensor.AddObservation</code>方法提供许多通用类型的数据载入，你可以添加整数和布尔类型的数据，也可以添加unity中的数据类型<code>Vector2</code>,<br><code>Vector3</code>, and <code>Quaternion</code>.<br></li></ul><p>类型列举应以_one hot_样式进行编码。即，添加一个每个列举元素的功能载体的元素，设置将观察到的成员代表为一个的元素，并将其余部分设置为零。</p><h5 id="Normalization"><a href="#Normalization" class="headerlink" title="Normalization"></a>Normalization</h5><p>为了在培训时取得最佳效果，您应该使培训的组件规范化。<br>功能矢量的范围[-1，+1]或[0，1]。当您使值规范化时，PPO神经网络通常可以更快地融合到解决方案。请注意，并不一定总是要的归一画到这些推荐的范围，但它是在使用神经网络时被认为是最佳实践。在您的观察组件之间的范围内变化越大，培训将更有可能受到影响。<br>为了归一化数值到值[o,1]，可以使用下面的公式</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">normalizedValue = (currentValue - minValue)/(maxValue - minValue)<br></code></pre></td></tr></table></figure><p>旋转和角度也同样要归一化，当角度位于0到360度之间时，可以使用下面的公式</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Quaternion rotation = transform.rotation;<br>Vector3 normalized = rotation.eulerAngles / <span class="hljs-number">180.0f</span> - Vector3.one;  <span class="hljs-comment">// [-1,1]</span><br>Vector3 normalized = rotation.eulerAngles / <span class="hljs-number">360.0f</span>;  <span class="hljs-comment">// [0,1]</span><br></code></pre></td></tr></table></figure><p>对于可能超出[0,360]范围的角度，您可以减小角度，或者，如果转数很大，则增加最大值(maximum value).</p><h4 id="Multiple-Visual-Observations"><a href="#Multiple-Visual-Observations" class="headerlink" title="Multiple Visual Observations"></a>Multiple Visual Observations</h4><p>视觉观察直接或从一个或多个中使用渲染的纹理场景中的摄影机。 该策略将纹理矢量化为3D张量可以馈入卷积神经网络（CNN）。可以将视觉观察与辅助向量观察一起使用。使用视觉观察的代理可以捕获任意复杂度的状态，并且当状态难以用数字描述时，此功能很有用。 但是，他们通常也效率较低，训练较慢，有时甚至不<br>完全成功。<br><br>视觉观察结果可以从场景中的Cameras或RenderTextures中获取。要将视觉观察添加到代理，请添加“摄像机传感器”组件或将RenderTextures传感器组件添加到代理。<br>然后拖动相机或渲染要添加到<code>Camera</code>或<code>RenderTexture</code>字段的纹理。您可以拥有多个摄像头或渲染纹理，甚至可以结合使用都附加到代理。 对于每个视觉观察，设置宽度和高度<br>图像的像素数（以像素为单位）以及观察结果是彩色还是灰度。<br><br>使用相同策略的每个代理程序必须具有相同数量的视觉观察结果，并且它们都必须具有相同的分辨率（包括它们是否为灰度）。此外，代理上的每个传感器组件都必须具有唯一的名称，以便它们可以确定性地排序（该名称对于该Agent必须是唯一的，但是多个Agent可以<br>具有相同名称的传感器组件）。<br><br>当使用<code>RenderTexture</code>视觉观察时，方便的调试功能是<br>添加一个“画布”，然后添加一个“原始图像”，并将其纹理设置为代理的<br><code>RenderTexture</code>。 这将在游戏屏幕上呈现Agent观察图像。<br><br>可以参考 <strong>GridWord</strong> 项目使用情况(官方案例)，目的是到达指定地点同时避免碰撞。</p><h4 id="Raycast-Observations"><a href="#Raycast-Observations" class="headerlink" title="Raycast Observations"></a>Raycast Observations</h4><p>只需添加一个RayPerceptionSensorComponent3D（RayPerceptionSensorComponent2D）在观察过程中，几条光线（或球体，取决于设置）被投射到物理世界，被击中的物体决定了生成的观察向量。<br><br>Both sensor components have several settings:</p><ul><li><em>Detectable Tags</em>  对应于代理应该能够区分的对象类型的字符串列表。 例如，在WallJump示例中，我们使用“墙”，“目标”和“块”作为要检测的对象列表。</li><li><em>Rays Per Direction</em> 确定投射的光线数。一缕是总是向前投射，多的光线向左右投射。</li><li><em>Max Ray Degrees</em> 最外面的光线的角度（以度为单位）。 90度对应代理的左侧和右侧。.</li><li><em>Sphere Cast Radius</em> 用于球体铸造的球体的大小。 如果设置到0，将使用射线代替球体。 光线可能更有效，特别是在复杂的场景中。</li><li><em>Ray Length</em> 射线长度</li><li><em>Observation Stacks</em>  要与转换结果“堆叠”的先前结果数。 请注意，这可以独立于“行为参数”中的“堆叠矢量”设置。</li><li><em>Start Vertical Offset</em> (3D only) 射线起点的垂直偏移。</li><li><em>End Vertical Offset</em> (3D only) 射线终点的垂直偏移.<br> 创建的观测值的总大小为</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">（观测堆栈）*（<span class="hljs-number">1</span> + <span class="hljs-number">2</span> *每个方向的光线）*（可检测的标签数量+ <span class="hljs-number">2</span>）<br><span class="hljs-comment">(Observation Stacks)</span> * <span class="hljs-comment">(1 + 2 * Rays Per Direction)</span> * <span class="hljs-comment">(Num Detectable Tags + 2)</span><br><br></code></pre></td></tr></table></figure><p>因此，应尽量减少射线和标签的数量，以减少使用的数据量。 请注意，这与在<br><code>Behavior Parameters</code>中状态大小无关。</p><h3 id="Vector-Actions"><a href="#Vector-Actions" class="headerlink" title="Vector Actions"></a>Vector Actions</h3><p>动作是代理执行的来自策略的指令。 当学院调用时，会将操作作为参数传递给代理。使用OnActionReceived()。当您指定矢量动作空间时<br>是 <strong>Continuous</strong>，则传递给Agent的action参数是一个数组<br>长度等于<code>Vector Action Space Size</code>属性的控制信号。当您指定<strong>Discrete</strong>向量动作空间类型时，该动作参数是包含整数的数组。 每个整数都是列表或表的索引<br>命令。<br>在<strong>Discrete</strong>向量动作空间类型中，动作参数是一个索引数组。 数组中的索引数由<br>在<code>Branches Size</code>属性中定义的数决定。每个分支对应于一个动作表，您可以通过指定每个表的大小修改<code>Branches</code>属性。<br>Policy和培训算法都不知道有关该采取的行动本身的意思。训练算法只是尝试<br>动作列表中不同的值并观察随着时间的推移这些值对累积奖励的影响。因此，为Agent定义的唯一位置动作是在OnActionReceived()函数中。<br><br>例如，如果您设计了一个可以在两个维度上移动的代理，则可以使用连续或离散矢量动作。 在连续的情况下，您会将向量动作大小设置为2（每个维度一个），并且代理的策略将创建一个具有两个浮点值的操作。在离散情况下，您将使用一个大小为4的分支（每个分支一个）<br>方向），该策略将创建一个包含单个值范围从零到三的元素。 或者，您可以创建大小为2的两个分支（一个用于水平移动，一个用于垂直移动），并且该策略将创建一个包含两个元素的操作数组,值范围从零到一。<br><br>请注意，在为代理编程操作时，通常有助于使用代理的<code>Heuristic()</code>方法测试您的操作逻辑，让您映射键盘行动命令。<br>The 3DBall and Area  example environments are set up to use either the continuous or the discrete vector action spaces.</p><h4 id="Continuous-Action-Space"><a href="#Continuous-Action-Space" class="headerlink" title="Continuous Action Space"></a>Continuous Action Space</h4><p>当代理使用设置为“连续”向量操作空间的策略时，传递给代理的OnActionReceived（）函数的操作参数是一个数组长度等于“矢量操作空间大小”属性值。数组中的各个值具有您赋予的任何含义.<br><br>默认情况下，我们提供的PPO算法的输出会预先钳制<code>vectorAction</code>进入[-1，1]范围。 最佳做法是手动剪辑如果您打算在您的环境中使用第三方算法，则也需要这些。</p><h4 id="Discrete-Action-Space"><a href="#Discrete-Action-Space" class="headerlink" title="Discrete Action Space"></a>Discrete Action Space</h4><p>如果Agent使用 <strong>Discrete</strong>向量操作空间，则传递给代理的OnActionReceived()函数的操作参数是一个包含索引的数组。在离散向量作用空间中，<code>Branches</code>是一个<br>整数数组，每个值对应于每个分支。<br>例如，如果我们想要一个可以在平台上移动并跳跃的Agent，我们可以<br>定义两个分支（一个代表运动，一个代表跳跃），因为我们想要<br>代理能够同时移动 <strong>和</strong> 跳。 我们定义第一个分支有5种可能的动作（不要移动，左移，右移，后退，前进），第二个动作有2种可能的动作（不要跳，跳）。 这<br>OnActionReceived（）方法类似于：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Get the action index for movement</span><br><span class="hljs-built_in">int</span> movement = Mathf.FloorToInt(act[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">// Get the action index for jumping</span><br><span class="hljs-built_in">int</span> jump = Mathf.FloorToInt(act[<span class="hljs-number">1</span>]);<br><br><span class="hljs-comment">// Look up the index in the movement action list:</span><br><span class="hljs-keyword">if</span> (movement == <span class="hljs-number">1</span>) &#123; directionX = <span class="hljs-number">-1</span>; &#125;<br><span class="hljs-keyword">if</span> (movement == <span class="hljs-number">2</span>) &#123; directionX = <span class="hljs-number">1</span>; &#125;<br><span class="hljs-keyword">if</span> (movement == <span class="hljs-number">3</span>) &#123; directionZ = <span class="hljs-number">-1</span>; &#125;<br><span class="hljs-keyword">if</span> (movement == <span class="hljs-number">4</span>) &#123; directionZ = <span class="hljs-number">1</span>; &#125;<br><span class="hljs-comment">// Look up the index in the jump action list:</span><br><span class="hljs-keyword">if</span> (jump == <span class="hljs-number">1</span> &amp;&amp; IsGrounded()) &#123; directionY = <span class="hljs-number">1</span>; &#125;<br><br><span class="hljs-comment">// Apply the action results to move the Agent</span><br>gameObject.GetComponent&lt;Rigidbody&gt;().AddForce(<br>    <span class="hljs-keyword">new</span> Vector3(<br>        directionX * <span class="hljs-number">40f</span>, directionY * <span class="hljs-number">300f</span>, directionZ * <span class="hljs-number">40f</span>));<br></code></pre></td></tr></table></figure><p>以上代码示例是AreaAgent的简化摘录类，离散量和连续动作空间都有。</p><h5 id="Masking-Discrete-Actions"><a href="#Masking-Discrete-Actions" class="headerlink" title="Masking Discrete Actions"></a>Masking Discrete Actions</h5><p>使用离散动作时，可以指定某些动作为下一个决定是不可能采用的。 当代理受<br>神经网络控制时，代理将无法执行指定的操作。 注意当代理受Heuristic启发式控制时，代理将仍然能够决定执行屏蔽操作。 为了掩盖动作，请覆盖<code>Agent.CollectDiscreteActionMasks（）</code>虚拟方法，并在其中调用<code>DiscreteActionMasker.SetMask（）</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CollectDiscreteActionMasks</span>(<span class="hljs-params">DiscreteActionMasker actionMasker</span>)</span>&#123;<br>    actionMasker.SetMask(branch, actionIndices)<br>&#125;<br></code></pre></td></tr></table></figure><p>Where:</p><ul><li><code>branch</code> is the index (starting at 0) of the branch on which you want to mask the action</li><li><code>actionIndices</code> is a list of <code>int</code> corresponding to the<br>indices of the actions that the Agent cannot perform.</li></ul><p>例如，如果您有一个具有2个分支的代理，并且在第一个分支<br>（分支0）有4种可能的操作：_“什么都不做” _，_“跳转” _，_“拍摄” _<br>和_“更换武器” _。 然后使用下面的代码，代理将_“ do<br>对于他的下一个决定，无“ _”或“更换武器” _（因为动作索引1和2<br>被遮罩）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">SetMask(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">2</span>]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;)<br></code></pre></td></tr></table></figure><p>注意:</p><ul><li>You can call <code>SetMask</code> multiple times if you want to put masks on<br>multiple branches.</li><li>You cannot mask all the actions of a branch.</li><li>You cannot mask actions in continuous control.</li></ul><h3 id="Rewards"><a href="#Rewards" class="headerlink" title="Rewards"></a>Rewards</h3><p>在强化学习中，奖励是Agent做正确事情的信号。 PPO强化学习算法通过优化代理做出的选择来工作，以使代理随时间获得最高的累积奖励。 您的奖励机制越好，您的代理商将学得越好。<br><br><strong>注意:</strong><br>奖励在Agent使用经过训练的模型进行推理时不会使用，在模仿学习中也不会使用。<br>也许最好的建议是从简单开始，仅在需要时增加复杂性。 通常，您应该奖励结果，而不是您认为会导致期望结果的行动。 为了帮助您获得奖励，您可以使用Monitor类显示代理收到的累积奖励。 您甚至可以在观察代理如何累积奖励的同时，使用代理的启发式方法来控制代理。<br><br>通过调用OnActionReceived（）函数中的AddReward（）方法向代理分配奖励。 每个决策之间分配的奖励应在[-1,1]范围内。 超出此范围的值可能导致训练不稳定。 当Agent收到新决定时，<code>reward</code>值将重置为零。 如果对一个代理决策有多个对<code>AddReward（）</code>的调用，则将这些奖励加起来以评估前一个决策的质量。 有一种名为<code>SetReward()</code> ”的方法，该方法将覆盖自上一个决定以来给予代理的所有先前奖励。</p><h3 id="Agent-Properties"><a href="#Agent-Properties" class="headerlink" title="Agent Properties"></a>Agent Properties</h3><ul><li><code>Behavior Parameters</code> - The parameters dictating what Policy the Agent will<br>receive.<ul><li><code>Behavior Name</code> - 行为的标识符。 具有相同行为名称的代理将学习相同的政策. </li><li><code>Vector Observation</code><ul><li><code>Space Size</code> - Agent的向量观测值的长度。</li><li><code>Stacked Vectors</code> - 将被堆叠并一起用于决策的先前矢量观测的数量。 这导致矢量观察的有效大小被传递给策略为：<em>Space Size</em> x _Stacked Vectors_。</li></ul></li><li><code>Vector Action</code><ul><li><code>Space Type</code> - 对应于动作矢量是否包含单个整数（离散）或一系列实值浮点（连续）.</li><li><code>Space Size</code> (Continuous) - 动作向量的长度.</li><li><code>Branches</code> (Discrete) - 整数数组，定义多个并发的离散操作。 “分支”数组中的值对应于每个操作分支的可能离散值的数量。</li></ul></li><li><code>Model</code> - 用于推理的神经网络模型（训练后获得）</li><li><code>Inference Device</code> - 在推理期间使用CPU还是GPU运行模型</li><li><code>Behavior Type</code> - Determines whether the Agent will do training, inference, or use its<br>Heuristic() method:<ul><li><code>Default</code> - the Agent will train if they connect to a python trainer, otherwise they will perform inference.</li><li><code>Heuristic Only</code> - the Agent will always use the <code>Heuristic()</code> method.</li><li><code>Inference Only</code> - the Agent will always perform inference.</li></ul></li><li><code>Team ID</code> - Used to define the team for <a href="Training-Self-Play.md">self-play</a></li><li><code>Use Child Sensors</code> - Whether to use all Sensor components attached to child GameObjects of this Agent.</li></ul></li><li><code>Max Step</code> - 每个代理的最大步骤数。 一旦这个数字到达后，代理将被重置.</li></ul><h2 id="训练-Agent"><a href="#训练-Agent" class="headerlink" title="训练 Agent"></a>训练 Agent</h2><p>训练过程的输出是一个包含优化后的模型文件政策。 该模型文件是TensorFlow数据图，其中包含数学训练过程中选择的最佳操作和最佳权重。 使用命令<code>mlagents-learn</code> 来训练您的代理。 此命令已安装在<code>mlagents</code>软件包。可在以下位置找到ml-agents &#x2F; mlagents &#x2F; trainers &#x2F; learn.py。<br>可以像<code>config / trainer_config.yaml</code>这样编辑配置文件指定训练期间使用的超参数。您可以使用文本编辑器编辑此文件，以添加特定的配置<br>每个行为。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mlagents-learn &lt;trainer-config-file&gt; --<span class="hljs-built_in">env</span>=&lt;env_name&gt; --run-id=&lt;run-identifier&gt; --train<br></code></pre></td></tr></table></figure><p>在训练过程中，训练程序会定期间隔（由<code>summary_freq</code>选项指定）打印和保存更新。 保存的信息按<code>run-id</code>值分组，因此您应该为每个ID分配一个唯一的ID。<br><br>您可以在训练期间或之后通过运行以下命令使用TensorBoard查看这些统计信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tensorboard --logdir=summaries --port 6006<br></code></pre></td></tr></table></figure><p>之后本地浏览器打开 <code>http://localhost:6006</code>.<br><strong>注意：</strong><br>TensorBoard使用的默认端口是6006。如果存在现有会话在端口6006上运行，可以使用–port在开放的端口上启动新会话选项。<br><br>训练结束后，您可以在<code>models</code> 文件夹中在指定的运行ID下找到保存的模型</p><h3 id="Training-Config-File"><a href="#Training-Config-File" class="headerlink" title="Training Config File"></a>Training Config File</h3><table><thead><tr><th align="left"><strong>Setting</strong></th><th align="left"><strong>Description</strong></th><th align="left"><strong>Applies To Trainer*</strong></th></tr></thead><tbody><tr><td align="left">batch_size</td><td align="left">The number of experiences in each iteration of gradient descent.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">batches_per_epoch</td><td align="left">In imitation learning, the number of batches of training examples to collect before training the model.</td><td align="left"></td></tr><tr><td align="left">beta</td><td align="left">The strength of entropy regularization.</td><td align="left">PPO</td></tr><tr><td align="left">buffer_size</td><td align="left">The number of experiences to collect before updating the policy model. In SAC, the max size of the experience buffer.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">buffer_init_steps</td><td align="left">The number of experiences to collect into the buffer before updating the policy model.</td><td align="left">SAC</td></tr><tr><td align="left">epsilon</td><td align="left">Influences how rapidly the policy can evolve during training.</td><td align="left">PPO</td></tr><tr><td align="left">hidden_units</td><td align="left">The number of units in the hidden layers of the neural network.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">init_entcoef</td><td align="left">How much the agent should explore in the beginning of training.</td><td align="left">SAC</td></tr><tr><td align="left">lambd</td><td align="left">The regularization parameter.</td><td align="left">PPO</td></tr><tr><td align="left">learning_rate</td><td align="left">The initial learning rate for gradient descent.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">learning_rate_schedule</td><td align="left">Determines how learning rate changes over time.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">max_steps</td><td align="left">The maximum number of simulation steps to run during a training session.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">memory_size</td><td align="left">The size of the memory an agent must keep. Used for training with a recurrent neural network. See <a href="Feature-Memory.md">Using Recurrent Neural Networks</a>.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">normalize</td><td align="left">Whether to automatically normalize observations.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">num_epoch</td><td align="left">The number of passes to make through the experience buffer when performing gradient descent optimization.</td><td align="left">PPO</td></tr><tr><td align="left">num_layers</td><td align="left">The number of hidden layers in the neural network.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">behavioral_cloning</td><td align="left">Use demonstrations to bootstrap the policy neural network. See <a href="Training-PPO.md#optional-behavioral-cloning-using-demonstrations">Pretraining Using Demonstrations</a>.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">reward_signals</td><td align="left">The reward signals used to train the policy. Enable Curiosity and GAIL here. See <a href="Reward-Signals.md">Reward Signals</a> for configuration options.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">save_replay_buffer</td><td align="left">Saves the replay buffer when exiting training, and loads it on resume.</td><td align="left">SAC</td></tr><tr><td align="left">sequence_length</td><td align="left">Defines how long the sequences of experiences must be while training. Only used for training with a recurrent neural network. See <a href="Feature-Memory.md">Using Recurrent Neural Networks</a>.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">summary_freq</td><td align="left">How often, in steps, to save training statistics. This determines the number of data points shown by TensorBoard.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">tau</td><td align="left">How aggressively to update the target network used for bootstrapping value estimation in SAC.</td><td align="left">SAC</td></tr><tr><td align="left">time_horizon</td><td align="left">How many steps of experience to collect per-agent before adding it to the experience buffer.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">trainer</td><td align="left">The type of training to perform: “ppo”, “sac”, “offline_bc” or “online_bc”.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">train_interval</td><td align="left">How often to update the agent.</td><td align="left">SAC</td></tr><tr><td align="left">num_update</td><td align="left">Number of mini-batches to update the agent with during each update.</td><td align="left">SAC</td></tr><tr><td align="left">use_recurrent</td><td align="left">Train using a recurrent neural network. See <a href="Feature-Memory.md">Using Recurrent Neural Networks</a>.</td><td align="left">PPO, SAC</td></tr></tbody></table><h2 id="Training-with-Proximal-Policy-Optimization"><a href="#Training-with-Proximal-Policy-Optimization" class="headerlink" title="Training with Proximal Policy Optimization"></a>Training with Proximal Policy Optimization</h2><p>ML-Agents提供一种称为近端策略优化（PPO）的强化学习算法的实现。 PPO使用神经网络来逼近理想功能，该理想功能将代理的观察结果映射到代理在给定状态下可以采取的最佳操作。 ML-Agents PPO算法在TensorFlow中实现，并在单独的Python进程中运行（通过套接字与正在运行的Unity应用程序进行通信）。成功训练强化学习模型通常涉及调整训练超参数。 本指南包含一些最佳实践，用于在默认参数似乎无法达到您想要的性能水平时调整培训过程。</p><h3 id="Hyperparameters"><a href="#Hyperparameters" class="headerlink" title="Hyperparameters"></a>Hyperparameters</h3><h4 id="Reward-Signals"><a href="#Reward-Signals" class="headerlink" title="Reward Signals"></a>Reward Signals</h4><p>在强化学习中，目标是学习使奖励最大化的策略。在基础级别上，奖励是由环境给予的。 但是，我们可以想象奖励代理商各种不同的行为。 例如，我们可以奖励代理商探索新状态，而不仅仅是给出明确的奖励。 此外，我们可以混合奖励信号来帮助学习过程。<br>ML-Agents工具箱默认提供三个奖励信号：外部（环境）奖励信号，好奇心奖励信号（可用于鼓励在稀疏外部奖励环境中进行探索）和GAIL奖励信号。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">reward_signals:</span><br>    <span class="hljs-attr">extrinsic:</span><br>        <span class="hljs-attr">strength:</span> <span class="hljs-number">1.0</span><br>        <span class="hljs-attr">gamma:</span> <span class="hljs-number">0.99</span><br>    <span class="hljs-attr">curiosity:</span><br>        <span class="hljs-attr">strength:</span> <span class="hljs-number">0.02</span><br>        <span class="hljs-attr">gamma:</span> <span class="hljs-number">0.99</span><br>        <span class="hljs-attr">encoding_size:</span> <span class="hljs-number">256</span><br>    <span class="hljs-attr">gail:</span><br>        <span class="hljs-attr">strength:</span> <span class="hljs-number">0.01</span><br>        <span class="hljs-attr">gamma:</span> <span class="hljs-number">0.99</span><br>        <span class="hljs-attr">encoding_size:</span> <span class="hljs-number">128</span><br>        <span class="hljs-attr">demo_path:</span> <span class="hljs-string">Project/Assets/ML-Agents/Examples/Pyramids/Demos/ExpertPyramid.demo</span><br></code></pre></td></tr></table></figure><p>除了任何特定于类的超参数之外，每个奖励信号还应至少定义两个参数“ strength”和“ gamma”。 请注意，要删除奖励信号，您应该从“ reward_signals”中完全删除其条目。 任何时候都应至少定义一个奖励信号。</p><ul><li><p>Reward Signal Types: <br><br>  Strength：Typical Range: <code>1.0</code><br><br>  Gamma：   Typical Range: <code>0.8</code> - <code>0.995</code></p></li><li><p>Curiosity Reward Signal: <br><br>  Strength：Typical Range: <code>0.001</code> - <code>0.1</code><br><br>  Gamma：   Typical Range: <code>0.8</code> - <code>0.995</code><br>  encoding_size:  <code>encoding_size</code>对应于固有好奇心模型使用的编码大小。此值应足够小以鼓励ICM压缩原始观察结果，但也不能太小以防止其学习区分已演示和实际行为。Default Value: <code>64</code>   。Typical Range: <code>64</code> - <code>256</code></p></li><li><p>GAIL Reward Signal: <br><br>  Strength：Typical Range: <code>0.01</code> - <code>1.0</code><br><br>  Gamma：   Typical Range: <code>0.8</code> - <code>0.9</code><br>  demo_path:   <code>demo_path</code>是您的.demo文件或.demo文件目录的路径。<br>  encoding_size:encoding_size对应于鉴别器使用的隐藏层的大小，该值应足够小以鼓励鉴别器压缩原始观测值，但也不能太小以防止其学习区分已证明的行为和实际行为。 大幅增加此大小也会对训练时间产生负面影响。 Default Value: <code>64</code>     Typical Range: <code>64</code> - <code>256</code></p></li></ul><h4 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h4><p><code>lambd</code>对应于计算通用优势估算值（[GAE]（<a href="https://arxiv.org/abs/1506.02438%EF%BC%89%EF%BC%89%E6%97%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E2%80%9C">https://arxiv.org/abs/1506.02438））时使用的“</a> lambda”参数。 这可以认为代理在计算更新的价值估算时多少依赖于其当前价值估算。 低值对应于更多地依赖于当前值估计（可能是高偏差），而高值对应于更多地依赖于在环境中接收到的实际奖励（可能是高方差）。 参数提供了两者之间的折衷，正确的值可以导致更稳定的训练过程。</p><p>Typical Range: <code>0.9</code> - <code>0.95</code></p><h4 id="Buffer-Size"><a href="#Buffer-Size" class="headerlink" title="Buffer Size"></a>Buffer Size</h4><p><code>buffer_size</code>对应于我们进行任何模型学习或更新之前应收集的经验（代理商的观察，行动和获得的奖励）的数量。 **这应该是<code>batch_size</code>**的倍数。 通常，较大的<code>buffer_size</code>对应于更稳定的训练更新。</p><p>Typical Range: <code>2048</code> - <code>409600</code></p><h4 id="Batch-Size"><a href="#Batch-Size" class="headerlink" title="Batch Size"></a>Batch Size</h4><p><code>batch_size</code>是用于梯度下降更新的一次迭代的经验数量。 **这应该始终是<code>buffer_size</code>**的一小部分。 如果您使用的是连续动作空间，则该值应较大（大约1000s）。 如果您使用的是离散操作空间，则该值应较小（约10s）。</p><p>Typical Range (Continuous): <code>512</code> - <code>5120</code></p><p>Typical Range (Discrete): <code>32</code> - <code>512</code></p><h4 id="Number-of-Epochs"><a href="#Number-of-Epochs" class="headerlink" title="Number of Epochs"></a>Number of Epochs</h4><p>num_epoch是梯度下降过程中通过experience buffer的次数。 <code>batch_size</code>越大，可以接受的越大。 减少此设置将确保更新更稳定，但会降低学习速度。</p><p>Typical Range: <code>3</code> - <code>10</code></p><h4 id="Learning-Rate"><a href="#Learning-Rate" class="headerlink" title="Learning Rate"></a>Learning Rate</h4><p><code>learning_rate</code>对应于每个梯度下降更新步骤的强度。 如果训练不稳定，则通常应减少该奖励，并且奖励不能持续增加。</p><p>Typical Range: <code>1e-5</code> - <code>1e-3</code></p><h4 id="Optional-Learning-Rate-Schedule"><a href="#Optional-Learning-Rate-Schedule" class="headerlink" title="(Optional) Learning Rate Schedule"></a>(Optional) Learning Rate Schedule</h4><p>learning_rate_schedule对应于学习率随时间的变化。对于PPO，我们建议递减学习率直到max_steps以便学习更稳定地收敛。 但是，在某些情况下（例如，训练时间未知），可以禁用此功能。</p><p>Options:</p><ul><li><code>linear</code> (default): 线性衰减<code>learning_rate</code>，在<code>max_steps</code>处达到0。</li><li><code>constant</code>: 在整个训练过程中保持学习率恒定.</li></ul><p>Options: <code>linear</code>, <code>constant</code></p><h4 id="Time-Horizon"><a href="#Time-Horizon" class="headerlink" title="Time Horizon"></a>Time Horizon</h4><p><code>time_horizon</code>对应于将每个代理添加到体验缓冲区之前收集多少个体验步骤。 在episode结束之前达到此限制时，将使用价值估算值来预测业务代表当前状态的总体预期回报。 因此，此参数在偏见程度较小但方差估计较高（较长时间范围）与偏倚较大但变化较少的估计值（较短时间范围）之间进行权衡。 如果情节中频繁获得奖励，或者情节过长，<br>数字越小越理想。 此数字应足够大，以捕获代理程序动作序列中的所有重要行为。</p><p>Typical Range: <code>32</code> - <code>2048</code></p><h4 id="Max-Steps"><a href="#Max-Steps" class="headerlink" title="Max Steps"></a>Max Steps</h4><p><code>max_steps</code>对应于训练过程中运行了多少步仿真（乘以跳帧）。 对于更复杂的问题，应该增加该值。</p><p>Typical Range: <code>5e5</code> - <code>1e7</code></p><h4 id="Beta"><a href="#Beta" class="headerlink" title="Beta"></a>Beta</h4><p><code>beta</code>对应于熵正则化的强度，这使策略“更加随机”。 这样可以确保座席在训练过程中正确探索动作空间。 增加此数量将确保采取更多随机动作。 应当对此进行调整，以使熵（可从TensorBoard测量）随着奖励的增加而缓慢减小。 如果熵下降太快，则增加<code>beta</code>。 如果熵下降太慢，则降低<code>beta</code>。.</p><p>Typical Range: <code>1e-4</code> - <code>1e-2</code></p><h4 id="Epsilon"><a href="#Epsilon" class="headerlink" title="Epsilon"></a>Epsilon</h4><p><code>epsilon</code> 对应于梯度下降更新期间新旧策略之间可接受的差异阈值。 将此值设置得较小将导致更稳定的更新，但也会减慢训练过程。</p><p>Typical Range: <code>0.1</code> - <code>0.3</code></p><h4 id="Normalize"><a href="#Normalize" class="headerlink" title="Normalize"></a>Normalize</h4><p><code>normalize</code> 对应于是否对矢量观测输入应用了归一化。 该归一化基于矢量观测值的移动平均值和方差。 规范化对于复杂的连续控制问题很有用，但对于较简单的离散控制问题则可能有害。</p><h4 id="Number-of-Layers"><a href="#Number-of-Layers" class="headerlink" title="Number of Layers"></a>Number of Layers</h4><p><code>num_layers</code>对应于观察输入之后或视觉观察的CNN编码之后存在多少个隐藏层。 对于简单的问题，较少的层可能会更快更有效地进行训练。 对于更复杂的控制问题，可能需要更多的层。</p><h4 id="Hidden-Units"><a href="#Hidden-Units" class="headerlink" title="Hidden Units"></a>Hidden Units</h4><p><code>hidden_units</code> 对应于神经网络的每个完全连接层中有多少个单元。 对于简单的问题，其中正确的操作是观察输入的直接组合，这应该很小。 对于动作是观察变量之间非常复杂的相互作用的问题，此值应该更大。</p><p>Typical Range: <code>32</code> - <code>512</code></p><h4 id="Optional-Visual-Encoder-Type"><a href="#Optional-Visual-Encoder-Type" class="headerlink" title="(Optional) Visual Encoder Type"></a>(Optional) Visual Encoder Type</h4><p><code>vis_encode_type</code>对应于用于对视觉观察进行编码的编码器类型。<br>有效选项包括：</p><ul><li><code>simple</code>（默认）：一个简单的编码器，由两个卷积层组成</li><li><code>nature_cnn</code>：[Mnih等人提出的CNN实现]（<a href="https://www.nature.com/articles/nature14236%EF%BC%89%EF%BC%8C">https://www.nature.com/articles/nature14236），</a><br>由三个卷积层组成</li><li><code>resnet</code>：[IMPALA Resnet实施]（<a href="https://arxiv.org/abs/1802.01561%EF%BC%89%EF%BC%8C">https://arxiv.org/abs/1802.01561），</a><br>由三层堆叠的层组成，每层有两个残余块，<br>比其他两个更大的网络。</li></ul><p>选项：<code>simple</code>，<code>nature_cnn</code>，<code>resnet</code></p><h3 id="Optional-Recurrent-Neural-Network-Hyperparameters"><a href="#Optional-Recurrent-Neural-Network-Hyperparameters" class="headerlink" title="(Optional) Recurrent Neural Network Hyperparameters"></a>(Optional) Recurrent Neural Network Hyperparameters</h3><p>以下超参数仅在<code>use_recurrent</code>设置为true时使用</p><h4 id="Sequence-Length"><a href="#Sequence-Length" class="headerlink" title="Sequence Length"></a>Sequence Length</h4><p><code>sequence_length</code> 对应于训练期间通过网络传递的经验序列的长度。 该时间应足够长，以捕获代理随时间推移可能需要记住的任何信息。 例如，如果您的Agent需要记住物体的速度，则此值可能很小。 如果您的经纪人只需要记住一集开始时只给出一次的信息，则该值应该更大。</p><p>Typical Range: <code>4</code> - <code>128</code></p><h4 id="Memory-Size"><a href="#Memory-Size" class="headerlink" title="Memory Size"></a>Memory Size</h4><p><code>memory_size</code>对应于用于存储策略循环神经网络隐藏状态的浮点数数组的大小。 该值必须是2的倍数，并且应该与您期望代理成功完成任务所需记住的信息量成比例。</p><p>Typical Range: <code>32</code> - <code>256</code></p><h3 id="Optional-Behavioral-Cloning-Using-Demonstrations"><a href="#Optional-Behavioral-Cloning-Using-Demonstrations" class="headerlink" title="(Optional) Behavioral Cloning Using Demonstrations"></a>(Optional) Behavioral Cloning Using Demonstrations</h3><p>在某些情况下，您可能想使用播放器记录的行为来引导代理策略。 这可以帮助指导代理商获得奖励。 行为克隆（BC）增加了模仿示范的训练操作，而不是试图使报酬最大化。<br>要使用BC，请在trainer_config中添加一个“ behavioral_cloning”部分。 例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">behavioral_cloning:<br>    demo_path: .<span class="hljs-regexp">/Project/</span>Assets<span class="hljs-regexp">/ML-Agents/</span>Examples<span class="hljs-regexp">/Pyramids/</span>Demos/ExpertPyramid.demo<br>    strength: <span class="hljs-number">0.5</span><br>    steps: <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><p>以下是BC可用的超参数。</p><h4 id="Strength"><a href="#Strength" class="headerlink" title="Strength"></a>Strength</h4><p><code>strength</code>对应于模仿的学习率相对于PPO的学习率，大致对应于我们允许BC影响政策的强度。</p><p>Typical Range: <code>0.1</code> - <code>0.5</code></p><h4 id="Demo-Path"><a href="#Demo-Path" class="headerlink" title="Demo Path"></a>Demo Path</h4><p><code>demo_path</code>是您的.demo文件或.demo文件目录的路径。 有关<code>.demo</code>文件的更多信息，请参见Training-Imitation-Learning.md（官方文档）。</p><h4 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h4><p>在BC期间，通常希望代理在“看到”奖励后停止使用演示，并允许其优化过去的可用演示和&#x2F;或泛化所提供的演示之外的内容。<br> <code>steps</code>对应于BC有效的训练步骤。 BC的学习率将逐步逐步提高。 将步骤设置为0，以在整个训练过程中持续模仿。</p><h4 id="Optional-Batch-Size"><a href="#Optional-Batch-Size" class="headerlink" title="(Optional) Batch Size"></a>(Optional) Batch Size</h4><p><code>batch_size</code>是用于梯度下降更新的一次迭代的演示经验的数量。 如果未指定，则默认为为PPO定义的<code>batch_size</code>。</p><p>Typical Range (Continuous): <code>512</code> - <code>5120</code></p><p>Typical Range (Discrete): <code>32</code> - <code>512</code></p><h4 id="Optional-Number-of-Epochs"><a href="#Optional-Number-of-Epochs" class="headerlink" title="(Optional) Number of Epochs"></a>(Optional) Number of Epochs</h4><p><code>num_epoch</code>是梯度下降过程中通过体验缓冲区的次数。 如果未指定，则默认为PPO设置的时期数。</p><p>Typical Range: <code>3</code> - <code>10</code></p><h4 id="Optional-Samples-Per-Update"><a href="#Optional-Samples-Per-Update" class="headerlink" title="(Optional) Samples Per Update"></a>(Optional) Samples Per Update</h4><p><code>samples_per_update</code> 是最大样本数<br>在每次模仿更新期间使用。 如果您的演示数据集非常大，则可能需要降低此值，以避免过分适合演示策略。 设置为0可在每个更新步骤训练所有演示。</p><p>Default Value: <code>0</code> (all)</p><p>Typical Range: Approximately equal to PPO’s <code>buffer_size</code></p><h3 id="Training-Statistics"><a href="#Training-Statistics" class="headerlink" title="Training Statistics"></a>Training Statistics</h3><p>要查看训练统计信息，请使用TensorBoard。 </p><h4 id="Cumulative-Reward"><a href="#Cumulative-Reward" class="headerlink" title="Cumulative Reward"></a>Cumulative Reward</h4><p>随着时间的流逝，奖励的总体趋势应持续增加。 预计会有小起起落。 根据任务的复杂性，奖励可能不会显着增加，直到进入培训过程的数百万步为止。</p><h4 id="Entropy"><a href="#Entropy" class="headerlink" title="Entropy"></a>Entropy</h4><p>这对应于决策的随机性。 在训练期间，这应该持续减少。 如果它减小得太快或根本没有减小，则应调整<code>beta</code>（使用离散动作空间时）。</p><h4 id="Learning-Rate-1"><a href="#Learning-Rate-1" class="headerlink" title="Learning Rate"></a>Learning Rate</h4><p>默认情况下，这会随着时间的流逝而减少，除非将<code>learning_rate_schedule</code>设置为<code>constant</code>。</p><h4 id="Policy-Loss"><a href="#Policy-Loss" class="headerlink" title="Policy Loss"></a>Policy Loss</h4><p>这些值会在训练过程中振荡。 通常，它们应小于1.0。</p><h4 id="Value-Estimate"><a href="#Value-Estimate" class="headerlink" title="Value Estimate"></a>Value Estimate</h4><p>这些值应随着累积奖励的增加而增加。 它们对应于Agent预测自己在任何给定时间点会收到多少奖励。</p><h4 id="Value-Loss"><a href="#Value-Loss" class="headerlink" title="Value Loss"></a>Value Loss</h4><p>这些价值将随着奖励的增加而增加，一旦奖励稳定就应减少。</p><h2 id="实例-Gridworld"><a href="#实例-Gridworld" class="headerlink" title="实例 Gridworld"></a>实例 Gridworld</h2><p><a href="https://youtu.be/gu8HE9WKEVI">GridWorld</a></p><p><img src="/2021/02/23/mlagent%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/gridworld.png"></p><ul><li>设置：经典网格世界任务的版本。场景包含代理商，目标，<br>和障碍。</li><li>目标：代理商必须在网格上导航至目标，同时避免<br>障碍。</li><li>代理：环境包含九个具有相同行为参数的代理。</li><li>Agent奖励功能：<ul><li>-0.01每一步。</li><li>+1.0，如果座席导航到网格的目标位置（情节结束）。</li><li>-1.0，如果特工导航到障碍物（情节结束）。</li></ul></li><li>行为参数：<ul><li>向量观察空间：无</li><li>向量动作空间：（离散）大小为4，对应于运动<br>基本方向。请注意，对于这种环境，<br>[动作遮罩]（Learning-Environment-Design-Agents.md＃masking-discrete-actions）<br>默认情况下处于打开状态（此选项可以切换<br>使用“ trueAgent” GameObject中的“屏蔽动作”复选框。<br>提供的经过训练的模型文件是在启用操作屏蔽的情况下生成的。</li><li>视觉观察：对应于GridWorld的自顶向下视图。</li></ul></li><li>浮动属性：三个，分别对应于网格大小，障碍物数量和<br>目标数。</li><li>基准平均奖励：0.8</li></ul>]]></content>
    
    
    <categories>
      
      <category>mlagent</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp常用函数</title>
    <link href="/2021/02/08/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <url>/2021/02/08/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>本篇旨在记录算法学习过程中所遇所用到的c&#x2F;c++函数及技巧 以备复习</p><!---more--><h2 id="C-String类"><a href="#C-String类" class="headerlink" title="C++ String类"></a>C++ String类</h2><h3 id="常见函数："><a href="#常见函数：" class="headerlink" title="常见函数："></a>常见函数：</h3><ul><li><p>插入： insert(位置，待插入字符串)</p></li><li><p>删除： erase(pos , len) pos  <br>表示要删除的子字符串的起始下标，len 表示要删除子字符串的长度。如果不指明 len 的话，那么直接删除从 pos 到字符串结束处的所有字符（此时 len &#x3D; str.length - pos）。</p></li><li><p>提取字符串：string substr (size_t pos &#x3D; 0, size_t len &#x3D; npos) const; <br><br>pos 为要提取的子字符串的起始下标，len 为要提取的子字符串的长度。</p></li><li><p>字符串查找<br></p><ol><li>find()：第一个参数为待查找的子字符串，它可以是 string 字符串，也可以是C风格的字符串。第二个参数为开始查找的位置（下标）；如果不指明，则从第0个字符开始查找。</li><li>rfind()：rfind() 和 find() 很类似，同样是在字符串中查找子字符串，不同的是 find() 函数从第二个参数开始往后查找，而 rfind() 函数则最多查找到第二个参数处，如果到了第二个参数所指定的下标还没有找到子字符串，则返回一个无穷大值4294967295。</li><li>find_first_of():find_first_of() 函数用于查找子字符串和字符串共同具有的字符在字符串中首次出现的位置<br><br>例:<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">string <span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;first second second third&quot;</span>;<br>string <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;asecond&quot;</span>;<br>int index = <span class="hljs-built_in">s1</span>.find_first_of(<span class="hljs-built_in">s2</span>);<br><br>运行结果：<br>Found <span class="hljs-built_in">at</span> index : <span class="hljs-number">3</span><br>本例中 <span class="hljs-built_in">s1</span> 和 <span class="hljs-built_in">s2</span> 共同具有的字符是 ’s’，该字符在 <span class="hljs-built_in">s1</span> 中首次出现的下标是<span class="hljs-number">3</span>，故查找结果返回<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p>数值转换 <a href="https://blog.csdn.net/tengfei461807914/article/details/52203202">链接</a></p></li><li><p>其他用法 <a href="https://blog.csdn.net/fdqw_sph/article/details/54233971">链接</a></p></li></ul><p>string数值转换<br><img src="/2021/02/08/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2.png"><br>char转string<br><img src="/2021/02/08/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/char%E8%BD%ACstring.png"></p><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><p>格式字符有d,o,x,u,c,s,f,e,g等。 </p><ul><li><p>%d：就是普通的输出</p></li><li><p>%2d：是将数字按宽度为2，采用右对齐方式输出，若数据位数不到2位，则左边补空格</p></li><li><p>%02d：和%2d差不多，只不过左边补0</p></li><li><p>％d: 整型输出，％ld长整型输出，</p></li><li><p>％o: 以八进制数形式输出整数，</p></li><li><p>％x: 以十六进制数形式输出整数，或输出字符串的地址。</p></li><li><p>％u: 以十进制数输出unsigned型数据(无符号数)。注意：%d与%u有无符号的数值范围，也就是极限的值，不然数值打印出来会有误。</p></li><li><p>％c: 用来输出一个字符，</p></li><li><p>％s: 用来输出一个字符串，</p></li><li><p>％f: 用来输出实数，以小数形式输出，默认情况下保留小数点6位。</p></li><li><p>%.100f: 用来输出实数，保留小数点100位。</p></li><li><p>％e:以指数形式输出实数，</p></li><li><p>％g:根据大小自动选f格式或e格式，且不输出无意义的零</p></li></ul><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="判断素数"><a href="#判断素数" class="headerlink" title="判断素数"></a>判断素数</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs abnf">bool IsPrime(int n)<br>&#123;<br>if(n &lt;<span class="hljs-operator">=</span> <span class="hljs-number">1</span>)&#123;<br>cout&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot;不是素数&quot;</span>&lt;&lt;endl<span class="hljs-comment">; </span><br>return false<span class="hljs-comment">;</span><br>&#125;<br>    for (int i <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">; i &lt; n; i++)</span><br>    &#123;<br>        if ((n % i) <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span>)&#123;<br>            cout&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot;不是素数&quot;</span>&lt;&lt;endl<span class="hljs-comment">;</span><br>            return false<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>    cout&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot;是素数&quot;</span>&lt;&lt;endl<span class="hljs-comment">;</span><br>    return true<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断闰年"><a href="#判断闰年" class="headerlink" title="判断闰年"></a>判断闰年</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">int</span> isRunyear(<span class="hljs-keyword">int</span> x)<br>&#123;<br>    <span class="hljs-keyword">if</span>(x%100!=<span class="hljs-number">0</span>&amp;&amp;x%4==<span class="hljs-number">0</span>||x%400==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="日期模版"><a href="#日期模版" class="headerlink" title="日期模版"></a>日期模版</h3><p>题目描述：有两个日期，求两个日期之间的天数，如果两个日期是连续的我们规定他们之间的天数为两天</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isRunyear</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span>&amp;&amp;x%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>||x%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//0代表不是闰年 28天  1   29天 </span><br><span class="hljs-type">int</span> month[<span class="hljs-number">2</span>][<span class="hljs-number">13</span>]=&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;,<br>                  &#123;<span class="hljs-number">0</span>,<span class="hljs-number">31</span>,<span class="hljs-number">29</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Date</span>&#123;<br>    <span class="hljs-type">int</span> Day;<br>    <span class="hljs-type">int</span> Month;<br>    <span class="hljs-type">int</span> Year;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nextDay</span><span class="hljs-params">()</span></span>&#123;<br>        Day++;<br>        <span class="hljs-type">int</span> isrun=<span class="hljs-built_in">isRunyear</span>(Year);<br>        <span class="hljs-keyword">if</span>(Day&gt;month[isrun][Month])<br>        &#123;<br>            Day=<span class="hljs-number">1</span>;<br>            Month++;<br>            <span class="hljs-keyword">if</span>(Month&gt;<span class="hljs-number">12</span>)<br>            &#123;<br>               Month=<span class="hljs-number">1</span>;<br>               Year++;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>&#125;;<br><span class="hljs-type">int</span> buf[<span class="hljs-number">5001</span>][<span class="hljs-number">13</span>][<span class="hljs-number">32</span>]; <span class="hljs-comment">//保存预处理的天数</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Date tmp;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录天数插值</span><br>    tmp.Year=<span class="hljs-number">0</span>;<br>    tmp.Month=<span class="hljs-number">1</span>;<br>    tmp.Day=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(tmp.Year!=<span class="hljs-number">5000</span>)<br>    &#123;<br>        buf[tmp.Year][tmp.Month][tmp.Day]=cnt;<br>        tmp.<span class="hljs-built_in">nextDay</span>();<br>        cnt++;<br>    &#125;<br>    <span class="hljs-type">int</span> Y1,M1,D1;<br>    <span class="hljs-type">int</span> Y2,M2,D2;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%4d%2d%2d&quot;</span>,&amp;Y1,&amp;M1,&amp;D1)!=EOF)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%4d%2d%2d&quot;</span>,&amp;Y2,&amp;M2,&amp;D2);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">abs</span>(buf[Y2][M2][D2]-buf[Y1][M1][D1])+<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断星期几"><a href="#判断星期几" class="headerlink" title="判断星期几"></a>判断星期几</h3><p>利用基姆拉尔森计算日期公式  w&#x3D;(d+2<em>m+3</em>(m+1)&#x2F;5+y+y&#x2F;4-y&#x2F;100+y&#x2F;400)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">getWeekdayByYearday</span><span class="hljs-params">(<span class="hljs-type">int</span> iY, <span class="hljs-type">int</span> iM, <span class="hljs-type">int</span> iD)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> iWeekDay = <span class="hljs-number">-1</span>; <br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == iM || <span class="hljs-number">2</span> == iM) <br>    &#123;   <br>        iM += <span class="hljs-number">12</span>; <br>        iY--;<br>    &#125;   <br>    iWeekDay = (iD + <span class="hljs-number">1</span> + <span class="hljs-number">2</span> * iM + <span class="hljs-number">3</span> * (iM + <span class="hljs-number">1</span>) / <span class="hljs-number">5</span> + iY + iY / <span class="hljs-number">4</span> - iY / <span class="hljs-number">100</span> + iY / <span class="hljs-number">400</span>) % <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">switch</span>(iWeekDay)<br>    &#123;   <br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> : <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Sunday&quot;</span>; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> : <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Monday&quot;</span>; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> : <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Tuesday&quot;</span>; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span> : <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Wednesday&quot;</span>; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span> : <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Thursday&quot;</span>; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span> : <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Friday&quot;</span>; <span class="hljs-keyword">break</span>;                                                             <br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span> : <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Saturday&quot;</span>; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span> : <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-keyword">break</span>;<br>    &#125;   <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> year,month,day;<br>    <span class="hljs-type">char</span> ch=<span class="hljs-string">&#x27;1&#x27;</span>;<br>    <span class="hljs-keyword">while</span>(ch != <span class="hljs-string">&#x27;\033&#x27;</span>)<br>    &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n请输入日期：\n格式为：1900,1,1\n&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d,%d,%d&quot;</span>,&amp;year,&amp;month,&amp;day);<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> * p = <span class="hljs-built_in">getWeekdayByYearday</span>(year, month, day);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WeekDay : %s\n&quot;</span>, p);<br>        ch = <span class="hljs-built_in">getchar</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Repeater"><a href="#Repeater" class="headerlink" title="Repeater"></a>Repeater</h3><p><img src="/2021/02/08/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/Repeater1.png"><br><img src="/2021/02/08/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/%E8%BE%93%E5%85%A5.png"><br><img src="/2021/02/08/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/%E8%BE%93%E5%87%BA.png"></p><p>代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">char</span> map[<span class="hljs-number">3003</span>][<span class="hljs-number">3003</span>];<br><span class="hljs-type">char</span> str[<span class="hljs-number">6</span>][<span class="hljs-number">6</span>];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)<br>                map[x + i][y + j] = str[i][j];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> size = (<span class="hljs-type">int</span>)<span class="hljs-built_in">pow</span>(n*<span class="hljs-number">1.0</span>, m - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>            <span class="hljs-keyword">if</span> (str[i][j] != <span class="hljs-string">&#x27; &#x27;</span>)<br>                <span class="hljs-built_in">dfs</span>(m - <span class="hljs-number">1</span>, x + i*size, y + j*size);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    n = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n)&#123;<br>        cin &gt;&gt; n;<br>        <span class="hljs-built_in">getchar</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            cin.<span class="hljs-built_in">getline</span>(str[i],<span class="hljs-number">6</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> m;<br>        cin &gt;&gt; m;<br>        <span class="hljs-type">int</span> size = (<span class="hljs-type">int</span>)<span class="hljs-built_in">pow</span>(n*<span class="hljs-number">1.0</span>, m);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;size; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;size; j++)<br>                map[i][j] = <span class="hljs-string">&#x27; &#x27;</span>;<br>            map[i][size] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(m, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;size; i++)<br>            cout&lt;&lt;map[i]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><br></code></pre></td></tr></table></figure><h3 id="二分搜索模版"><a href="#二分搜索模版" class="headerlink" title="二分搜索模版"></a>二分搜索模版</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">while</span>(base&lt;=<span class="hljs-built_in">top</span>)<br>&#123;<br>    int <span class="hljs-built_in">mid</span>=(base+<span class="hljs-built_in">top</span>)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(a[<span class="hljs-built_in">mid</span>].xuehao==x)<br>    &#123;<br>        flag=<span class="hljs-number">1</span>;<br>        cout&lt;&lt;a[<span class="hljs-built_in">mid</span>].xuehao&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;a[<span class="hljs-built_in">mid</span>].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;a[<span class="hljs-built_in">mid</span>].xingbie&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;a[<span class="hljs-built_in">mid</span>].age&lt;&lt;endl;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(a[<span class="hljs-built_in">mid</span>].xuehao&gt;x)<br>        &#123;<br>            <span class="hljs-built_in">top</span>=<span class="hljs-built_in">mid</span><span class="hljs-number">-1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            base=<span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="矩阵旋转"><a href="#矩阵旋转" class="headerlink" title="矩阵旋转"></a>矩阵旋转</h3><p><img src="/2021/02/08/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/%E7%9F%A9%E9%98%B5%E6%97%8B%E8%BD%AC.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span><br>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> *a;<br>    *a = *b;<br>    *b = t;<br>&#125;<br><br><span class="hljs-comment">// 逆时针旋转</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">transpose</span><span class="hljs-params">(<span class="hljs-type">int</span> a[][<span class="hljs-number">4</span>], <span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; j &lt; n; j++)<br>            swap(a[i][j], a[j][i]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)<br>            swap(a[i][j], a[n - <span class="hljs-number">1</span> - i][j]);<br>&#125;<br><br><span class="hljs-comment">// 顺时针旋转</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">clockwise</span><span class="hljs-params">(<span class="hljs-type">int</span> a[][<span class="hljs-number">4</span>], <span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n - i; j++)<br>            swap(a[i][j], a[n - <span class="hljs-number">1</span> - j][n - <span class="hljs-number">1</span> - i]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)<br>            swap(a[i][j], a[n - <span class="hljs-number">1</span> - i][j]);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL常见用法总结</title>
    <link href="/2021/02/07/STL%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2021/02/07/STL%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>本篇旨在记载STL一些常见函数及用法以备记忆</p><span id="more"></span><h1 id="栈容器-stack"><a href="#栈容器-stack" class="headerlink" title="栈容器 stack"></a>栈容器 stack</h1><p>用法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">头文件：<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>empty() 堆栈为空则返回真</li><li>pop() 移除栈顶元素</li><li>push() 在栈顶增加元素</li><li>size() 返回栈中元素数目</li><li>top() 返回栈顶元素</li></ul><p>初始化：    <code>stack&lt;int&gt;  s</code></p><p>示例：简单计算器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>stack&lt;<span class="hljs-type">char</span>&gt; op; <span class="hljs-comment">//符号栈</span><br>stack&lt;<span class="hljs-type">float</span>&gt; num; <span class="hljs-comment">//数字栈</span><br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-type">float</span> num1, <span class="hljs-type">float</span> num2, <span class="hljs-type">char</span> op)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span>)<br>        <span class="hljs-keyword">return</span> num1 + num2;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;-&#x27;</span>)<br>        <span class="hljs-keyword">return</span> num2 - num1;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span>)<br>        <span class="hljs-keyword">return</span> num2 * num1;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;/&#x27;</span>)<br>        <span class="hljs-keyword">return</span> num2 / num1;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; s &amp;&amp; s != <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">//读入一行表达式</span><br>    &#123;<br>        <span class="hljs-comment">//cout&lt;&lt;&quot;开始处理&quot;&lt;&lt;endl;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">float</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;+&#x27;</span> || s[i] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>            &#123;<br>                <span class="hljs-comment">// cout&lt;&lt;s[i]&lt;&lt;endl;</span><br>                <span class="hljs-keyword">while</span> (!op.<span class="hljs-built_in">empty</span>())<br>                &#123;<br>                    <span class="hljs-type">char</span> tmpop = op.<span class="hljs-built_in">top</span>();<br>                    op.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-type">float</span> num1 = num.<span class="hljs-built_in">top</span>();<br>                    num.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-type">float</span> num2 = num.<span class="hljs-built_in">top</span>();<br>                    num.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-type">float</span> calnum = <span class="hljs-built_in">cal</span>(num1, num2, tmpop);<br>                    num.<span class="hljs-built_in">push</span>(calnum);<br>                &#125;<br><br>                op.<span class="hljs-built_in">push</span>(s[i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;*&#x27;</span> || s[i] == <span class="hljs-string">&#x27;/&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (!op.<span class="hljs-built_in">empty</span>())<br>                &#123;<br>                    <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;+&#x27;</span> &amp;&amp; op.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;-&#x27;</span>)<br>                    &#123;<br>                        <span class="hljs-type">char</span> tmpop = op.<span class="hljs-built_in">top</span>();<br>                        op.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-type">float</span> num1 = num.<span class="hljs-built_in">top</span>();<br>                        num.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-type">float</span> num2 = num.<span class="hljs-built_in">top</span>();<br>                        num.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-type">float</span> calnum = <span class="hljs-built_in">cal</span>(num1, num2, tmpop);<br>                        num.<span class="hljs-built_in">push</span>(calnum);<br>                    &#125;<br>                &#125;<br><br>                op.<span class="hljs-built_in">push</span>(s[i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// cout&lt;&lt;&quot;处理数字&quot;&lt;&lt;s[i]&lt;&lt;endl;</span><br>                <span class="hljs-comment">//输入字符  转数字</span><br><br>                <span class="hljs-type">float</span> sum = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (s[i] != <span class="hljs-string">&#x27;+&#x27;</span> &amp;&amp; s[i] != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; s[i] != <span class="hljs-string">&#x27;*&#x27;</span> &amp;&amp; s[i] != <span class="hljs-string">&#x27;/&#x27;</span> &amp;&amp; i &lt; s.<span class="hljs-built_in">length</span>())<br>                &#123;<br>                    sum = sum * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                    <span class="hljs-comment">//  cout&lt;&lt;sum&lt;&lt;endl;</span><br>                    i++;<br>                &#125;<br>                i--;<br>                <span class="hljs-comment">//cout &lt;&lt; &quot;sum=&quot; &lt;&lt; sum &lt;&lt; &quot; &quot;&lt;&lt;endl;</span><br>                num.<span class="hljs-built_in">push</span>(sum); <span class="hljs-comment">//存数字</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// cout&lt;&lt;&quot;op栈大小&quot;&lt;&lt;op.size()&lt;&lt;endl;</span><br>        <span class="hljs-comment">//根据op栈处理num栈</span><br>        <span class="hljs-keyword">while</span> (!op.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">char</span> tmpop = op.<span class="hljs-built_in">top</span>();<br>            op.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">float</span> num1 = num.<span class="hljs-built_in">top</span>(); cout&lt;&lt;<span class="hljs-string">&quot;num1=&quot;</span>&lt;&lt;num1&lt;&lt;endl;<br>            num.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">float</span> num2 = num.<span class="hljs-built_in">top</span>(); cout&lt;&lt;<span class="hljs-string">&quot;num2=&quot;</span>&lt;&lt;num2&lt;&lt;endl;<br>            num.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">float</span> calnum = <span class="hljs-built_in">cal</span>(num1, num2, tmpop);<br>            num.<span class="hljs-built_in">push</span>(calnum);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2f\n&quot;</span>,num.<span class="hljs-built_in">top</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="优先队列-实现堆-（应用：哈夫曼树）"><a href="#优先队列-实现堆-（应用：哈夫曼树）" class="headerlink" title="优先队列-实现堆 （应用：哈夫曼树）"></a>优先队列-实现堆 （应用：哈夫曼树）</h1><p>使用之前的预处理：<br><code>include&lt;queue&gt;</code></p><p>利用语句：<code>priority_queue&lt;int&gt; Q; </code>   建立一个保存元素为int的堆Q，默认为大根堆</p><p>利用语句：<code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; Q; </code>定义小根堆</p><p>关于堆的操作如下：</p><p><code>Q.push(x); </code> 将元素x放入堆Q中</p><p><code>Q.top(); </code> 取出堆顶元素</p><p><code>Q.pop(); </code> 弹出堆顶元素，取出后堆会自动调整为一个新的小顶堆</p><p>例：<br><img src="/2021/02/07/STL%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt; &gt; Q;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>())<br>            Q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> a;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            cin &gt;&gt; a;<br>            Q.<span class="hljs-built_in">push</span>(a);<br>        &#125;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(Q.<span class="hljs-built_in">size</span>() &gt;<span class="hljs-number">1</span>)  <span class="hljs-comment">//不算入根节点，最后一个节点为根节点</span><br>        &#123;<br>            <span class="hljs-type">int</span> a1=Q.<span class="hljs-built_in">top</span>();<br>            Q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> a2=Q.<span class="hljs-built_in">top</span>();<br>            Q.<span class="hljs-built_in">pop</span>();<br>            ans+=a1+a2;<br>            Q.<span class="hljs-built_in">push</span>(a1+a2);<br>        &#125;<br>        cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">map</span>&lt;string,<span class="hljs-keyword">int</span>&gt; M;<span class="hljs-regexp">//</span>定义一个完成从string到<span class="hljs-keyword">int</span>映射的<span class="hljs-keyword">map</span><br>M.clear();<span class="hljs-regexp">//</span>清空一个<span class="hljs-keyword">map</span><br>M.find(b);<span class="hljs-regexp">//</span>确定<span class="hljs-keyword">map</span>中是否保存string对象b的映射，若没有函数返回M.end()<br>M[b]=idx;<span class="hljs-regexp">//</span>若<span class="hljs-keyword">map</span>中不存在string对象b的映射，则定义其映射为b映射为idx<br>idxb=M[b];<span class="hljs-regexp">//</span>若<span class="hljs-keyword">map</span>中存在string对象b的映射，则读出该映射<br></code></pre></td></tr></table></figure><p><img src="/2021/02/07/STL%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/%E6%98%A0%E5%B0%84.png"></p><p>样例输入</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">3</span><br>Alice Bob Smith John Alice Smith<br><span class="hljs-number">5</span><br><span class="hljs-selector-tag">a</span> c c d d e <span class="hljs-selector-tag">b</span> e <span class="hljs-selector-tag">a</span> d <br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">Yes</span> <br><span class="hljs-keyword">No</span><br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>map&lt;string, <span class="hljs-type">int</span>&gt; arr;<br><span class="hljs-type">int</span> in[<span class="hljs-number">2002</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &amp;&amp; n)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n; i++) <span class="hljs-comment">//n组胜负关系，至多存在n个队伍</span><br>            in[i] = <span class="hljs-number">0</span>;<br>        string a, b;<br>        arr.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//对map中的映射关系清空</span><br>        <span class="hljs-type">int</span> idx=<span class="hljs-number">0</span>;<span class="hljs-comment">//下一个被映射的数字</span><br>        <span class="hljs-keyword">while</span> (n--)<br>        &#123;<br>            cin &gt;&gt; a &gt;&gt; b;<br>            <span class="hljs-type">int</span> idxa,idxb;<br>            <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">find</span>(a) == arr.<span class="hljs-built_in">end</span>())<span class="hljs-comment">//若尚无对a的映射</span><br>            &#123;<br>               idxa=idx;<br>               arr[a]=idx++;<span class="hljs-comment">//设定其映射为idx，并递增idx</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> idxa=arr[a];<span class="hljs-comment">//否则直接读出该映射</span><br>            <span class="hljs-keyword">if</span>(arr.<span class="hljs-built_in">find</span>(b)==arr.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                idxb=idx;<br>                arr[b]=idx++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> idxb=arr[b];<br>            in[idxb]++;<span class="hljs-comment">//b的入度递增</span><br>        &#125;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;idx;i++)<br>        &#123;<br>            <span class="hljs-comment">//确定所有映射数字的入度，统计入度为0的个数</span><br>            <span class="hljs-keyword">if</span>(in[i]==<span class="hljs-number">0</span>)<br>              cnt++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">1</span>) cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关联规则挖掘系统</title>
    <link href="/2020/01/13/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/01/13/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>这学期的大数据课设由三部分组成，记录自己负责的关联规则挖掘系统部分内容。<br><br>环境：代码由python实现，版本为3.7版本，界面设计采用tkinter，采用两种算法：Apriori和fpgrowth<br></p><span id="more"></span><p>Apriori算法使用python的模块<strong>efficient-apriori</strong>，<br><img src="/Apriori.png"><br>fpgrowth算法采用<strong>orange-associate</strong>模块，其实fpgrowth算法在python中有更好地封装：pyfpgrowth<br><img src="/2020/01/13/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98%E7%B3%BB%E7%BB%9F/pyfpgrowth.png"><br>系统的主界面如下图：<br><img src="/2020/01/13/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98%E7%B3%BB%E7%BB%9F/%E4%B8%BB%E7%95%8C%E9%9D%A2.png"></p><p>在做课设的时候，有一个要求的画出fp树，查阅网上资料后发现并没有好的实现方法，至少我试过了没有得到理想的效果<br><br>但是在github上找到一个html+js编写的画fptree的网页,<a href="https://github.com/janithl/FPTreeSimulator/blob/master/index.html">点此跳转</a></p><p>于是就想着将这个网页嵌入python中，如果是pyqt实现的页面的话是比较好解决的，但是tkinter的话，最后找到唯一的一个方法就是使用cefpython3模块，可以内嵌浏览器。<br><br>此系统读入数据可放入txt文件中，格式如下:<br><img src="/2020/01/13/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE.png" alt="读入数据格式"><br><br>数据可以是汉字，字母，数字。</p><p>本系统所有代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Created on Thu Dec 19 22:15:06 2019</span><br><span class="hljs-string"></span><br><span class="hljs-string">@author: shanhainanhua</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> filedialog<br><span class="hljs-comment">#from fptree import *</span><br><span class="hljs-comment">#from pymining import itemmining,assocrules</span><br><span class="hljs-keyword">from</span> orangecontrib.associate.fpgrowth <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> efficient_apriori <span class="hljs-keyword">import</span> apriori<br><span class="hljs-keyword">from</span> orangecontrib.associate.fpgrowth <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> functools<br><br><br><span class="hljs-keyword">global</span> minsupport<br><span class="hljs-keyword">global</span> minconfidence<br><br>data=[]<br><span class="hljs-comment">#事件函数</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">LoadData</span>():<br>    <span class="hljs-keyword">global</span> data<br>    data=[]<br>    file_path=filedialog.askopenfilename(title=<span class="hljs-string">&#x27;打开单个文件&#x27;</span>,<br>    filetypes=[(<span class="hljs-string">&#x27;All Files&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>),(<span class="hljs-string">&quot;文本文件&quot;</span>, <span class="hljs-string">&#x27;*.txt&#x27;</span>)], <span class="hljs-comment"># 只处理的文件类型</span><br>    initialdir=<span class="hljs-string">&#x27;g:/&#x27;</span>) <span class="hljs-comment"># 初始目录</span><br>    <span class="hljs-built_in">print</span>(file_path)<br>    e1_value=file_path<br>    <span class="hljs-comment">#e1.delete(1,END)</span><br>    e1.insert(END,e1_value)<br>    e1.grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">1</span>,pady=<span class="hljs-number">18</span>,padx=<span class="hljs-number">10</span>)<br>    f=<span class="hljs-built_in">open</span>(file_path,<span class="hljs-string">&#x27;rb&#x27;</span>).readlines()<br>   <br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>        <span class="hljs-comment">#line = line.decode(&#x27;gbk&#x27;).strip()</span><br>        line = line.decode(<span class="hljs-string">&#x27;UTF-8&#x27;</span>).strip()<br>        tmp=[]<br>        <span class="hljs-comment">#line=line.split(&quot;,&quot;)</span><br>        line=line.split(<span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> line:<br>            tmp.append(<span class="hljs-built_in">str</span>(item))<br>        data.append(tmp)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入的数据为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(data))<br><br>   <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Start</span>():<br>    <span class="hljs-comment">#先获取组件的值</span><br>    <span class="hljs-keyword">global</span> minsupport<br>    <span class="hljs-keyword">global</span> minconfidence<br>    minsupport=<span class="hljs-built_in">float</span>(e2.get())<br>    minconfidence=<span class="hljs-built_in">float</span>(e3.get())<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;minsupport=&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(minsupport))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;minconfidence=&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(minconfidence))<br>    choice=<span class="hljs-built_in">int</span>(r.get())<br>    <span class="hljs-keyword">if</span> choice==<span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;选择了Apriori算法&quot;</span>)<br>        DoApriori()<br>        <br>    <span class="hljs-keyword">if</span> choice==<span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;选择了fp-growth算法&quot;</span>)<br>        DoFpGrowth()<br>    <br>    <br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">DoApriori</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    datalen=len(data)</span><br><span class="hljs-string">    thisminsupport=minsupport/datalen</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    itemsets, rules = apriori(data, minsupport,  minconfidence)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;频繁项集为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(itemsets))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;关联规则为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(rules))<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> itemsets:<br>        <span class="hljs-built_in">print</span>(item)<br>    <span class="hljs-keyword">for</span> rule <span class="hljs-keyword">in</span> rules:<br>        <span class="hljs-built_in">print</span>(rule)<br>    text_result.insert(END,<span class="hljs-string">&quot;使用Apriori算法生成频繁项集和关联规则\n&quot;</span>)<br>    text_result.insert(END,(<span class="hljs-string">&quot;频繁项集为：\n&quot;</span>+<span class="hljs-built_in">str</span>(itemsets)+<span class="hljs-string">&quot;\n&quot;</span>))<br>    text_result.insert(END,(<span class="hljs-string">&quot;关联规则为：\n&quot;</span>+<span class="hljs-built_in">str</span>(rules)+<span class="hljs-string">&quot;\n&quot;</span>))<br>   <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">DoFpGrowth</span>():<br>    strSet = <span class="hljs-built_in">set</span>(functools.reduce(<span class="hljs-keyword">lambda</span> a,b:a+b, data))<br>    strEncode = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(strSet,<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(strSet)))) <span class="hljs-comment">#编码字典，即:&#123;&#x27;ArticleTag_BS&#x27;: 6,&#x27;Country_Argentina&#x27;: 53,etc...&#125;</span><br>    strDecode = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(strEncode.values(), strEncode.keys()))  <span class="hljs-comment">#解码字典，即:&#123;6:&#x27;ArticleTag_BS&#x27;,53:&#x27;Country_Argentina&#x27;,etc...&#125;</span><br>    data_int = [<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> item:strEncode[item],row)) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> data]   <span class="hljs-comment">#编码后的输入数据       </span><br>    itemsets=frequent_itemsets(data_int,<span class="hljs-number">.4</span>)<br>    itemsets=<span class="hljs-built_in">dict</span>(itemsets)<br>    <span class="hljs-comment">#print(itemsets)</span><br>    rules = association_rules(itemsets, <span class="hljs-number">.5</span>)   <span class="hljs-comment">#这里设置置信度</span><br>    rules = <span class="hljs-built_in">list</span>(rules)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;关联规则\n&quot;</span>)<br>    <span class="hljs-built_in">print</span>(rules)<br>    start=<span class="hljs-number">0</span><br>    tmpitem=[]<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> itemsets:<br>        tmpj=[]<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> item:<br>          j=strDecode[j]<br>          tmpj.append(j)<br>        tmpitem.append(<span class="hljs-built_in">set</span>(tmpj))<br>    tmprules=[]<br>    <span class="hljs-keyword">for</span> rule <span class="hljs-keyword">in</span> rules:<br>        tmpj=[]<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> rule[:-<span class="hljs-number">2</span>]:<br>           j=strDecode[<span class="hljs-built_in">list</span>(j)[<span class="hljs-number">0</span>]]<br>           tmpj.append(j)<br>        tmprules.append(tmpj)<br>    text_result.insert(END,<span class="hljs-string">&quot;使用fp-growth算法生成频繁项集和关联规则\n&quot;</span>)<br>    text_result.insert(END,(<span class="hljs-string">&quot;频繁项集为：\n&quot;</span>+<span class="hljs-built_in">str</span>(tmpitem)+<span class="hljs-string">&quot;\n&quot;</span>))<br>    text_result.insert(END,(<span class="hljs-string">&quot;关联规则为：\n&quot;</span>+<span class="hljs-built_in">str</span>(tmprules)+<span class="hljs-string">&quot;\n&quot;</span>))<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Clear</span>():<br>    text_result.delete(<span class="hljs-number">1.0</span>,<span class="hljs-string">&#x27;end&#x27;</span>)<br>    e1.delete(<span class="hljs-number">2.0</span>,END)<br>    e2.delete(<span class="hljs-number">0</span>, END)<br>    e3.delete(<span class="hljs-number">0</span>, END)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Close</span>():<br>    root.quit()<br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">showtree</span>():<br>    root.deiconify()<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">save_file</span>():<br>  file_path = filedialog.asksaveasfilename(title=<span class="hljs-string">u&#x27;保存文件&#x27;</span>)<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;保存文件：&#x27;</span>, file_path)<br>  file_text = text_result.get(<span class="hljs-string">&#x27;1.0&#x27;</span>,END)<br>  <span class="hljs-keyword">if</span> file_path <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file=file_path, mode=<span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>      file.write(file_text)<br>    dialog.Dialog(<span class="hljs-literal">None</span>, &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;File Modified&#x27;</span>, <span class="hljs-string">&#x27;text&#x27;</span>: <span class="hljs-string">&#x27;保存完成&#x27;</span>, <span class="hljs-string">&#x27;bitmap&#x27;</span>: <span class="hljs-string">&#x27;warning&#x27;</span>, <span class="hljs-string">&#x27;default&#x27;</span>: <span class="hljs-number">0</span>,<br>               <span class="hljs-string">&#x27;strings&#x27;</span>: (<span class="hljs-string">&#x27;OK&#x27;</span>, <span class="hljs-string">&#x27;Cancle&#x27;</span>)&#125;)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;保存完成&#x27;</span>)<br><br><span class="hljs-comment">#创建界面，进行事件绑定</span><br>root1 = Tk()<br>root1.geometry(<span class="hljs-string">&quot;850x450&quot;</span>)<br>root1.title(<span class="hljs-string">&quot;关联规则挖掘系统&quot;</span>)<br>root1.resizable=(<span class="hljs-literal">False</span>,<span class="hljs-literal">False</span>)<br>root1[<span class="hljs-string">&quot;background&quot;</span>] = <span class="hljs-string">&quot;SkyBlue&quot;</span><br>root1.attributes(<span class="hljs-string">&quot;-alpha&quot;</span>, <span class="hljs-number">0.9</span>)<br><br> <br><span class="hljs-comment"># Thinker总共提供了三种布局组件的方法：pack(),grid()和place()</span><br><span class="hljs-comment"># grid()方法允许你用表格的形式来管理组件的位置</span><br><span class="hljs-comment"># row选项代表行，column选项代表列</span><br><span class="hljs-comment"># 例如row=1，column=2表示第二行第三列(0表示第一行)</span><br><br>fram1=Frame(root1)<br>Label(fram1,text=<span class="hljs-string">&quot;频繁项集和关联规则&quot;</span>,font=(<span class="hljs-string">&quot;华文行楷&quot;</span>, <span class="hljs-number">20</span>), fg=<span class="hljs-string">&quot;green&quot;</span>).grid(row=<span class="hljs-number">0</span>,column=<span class="hljs-number">0</span>)<br>text_result=Text(fram1)<br>text_result.grid(row=<span class="hljs-number">2</span>,column=<span class="hljs-number">0</span>)<br>fram1.grid(row=<span class="hljs-number">0</span>,rowspan=<span class="hljs-number">4</span>,column=<span class="hljs-number">4</span>)<br><br>fram2=Frame(root1,width=<span class="hljs-number">300</span>,height=<span class="hljs-number">500</span>)<br><br>btnloaddata=Button(fram2, text=<span class="hljs-string">&quot;导入数据&quot;</span>,command=LoadData)<br>btnloaddata.grid(row=<span class="hljs-number">0</span>,column=<span class="hljs-number">0</span>,pady=<span class="hljs-number">18</span>)<br>Label(fram2, text=<span class="hljs-string">&quot;最小支持度&quot;</span>).grid(row=<span class="hljs-number">1</span>,column=<span class="hljs-number">0</span>,pady=<span class="hljs-number">18</span>)<br>Label(fram2, text=<span class="hljs-string">&quot;最小置信度&quot;</span>).grid(row=<span class="hljs-number">2</span>,column=<span class="hljs-number">0</span>,pady=<span class="hljs-number">18</span>)<br><br>e1_value=<span class="hljs-string">&quot;导入文件的路径:\n&quot;</span><br>e1 = Text(fram2,width=<span class="hljs-number">20</span>,height=<span class="hljs-number">3</span>)<br>e1.insert(<span class="hljs-number">1.0</span>,e1_value)<br><br><br>e2 = Entry(fram2)<br>e3 = Entry(fram2)<br><br><br>e1.grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">1</span>,pady=<span class="hljs-number">18</span>,padx=<span class="hljs-number">10</span>)<br>e2.grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">1</span>,pady=<span class="hljs-number">18</span>,padx=<span class="hljs-number">10</span>)<br>e3.grid(row=<span class="hljs-number">2</span>, column=<span class="hljs-number">1</span>,pady=<span class="hljs-number">18</span>,padx=<span class="hljs-number">10</span>)<br><br>fram2.grid(row=<span class="hljs-number">0</span>,column=<span class="hljs-number">0</span>,rowspan=<span class="hljs-number">4</span>,columnspan=<span class="hljs-number">3</span>,pady=<span class="hljs-number">18</span>)<br><br><span class="hljs-comment"># 创建单选项</span><br>r = IntVar()<br>male_select = Radiobutton(root1,text=<span class="hljs-string">&quot;Apriori&quot;</span>,value=<span class="hljs-number">1</span>,variable=r)<br>male_select.grid(row=<span class="hljs-number">3</span>,column=<span class="hljs-number">0</span>)<br>female_select = Radiobutton(root1,text=<span class="hljs-string">&quot;Fp-growth&quot;</span>,value=<span class="hljs-number">2</span>,variable=r)<br>female_select.grid(row=<span class="hljs-number">3</span>,column=<span class="hljs-number">1</span>)<br><br>fram3=Frame(root1,width=<span class="hljs-number">100</span>,height=<span class="hljs-number">10</span>)<br><br>btnstart=Button(fram3,text=<span class="hljs-string">&quot;开始&quot;</span>,command=Start)<br>btnclear=Button(fram3,text=<span class="hljs-string">&quot;清空&quot;</span>,command=Clear)<br>btnshowtree=Button(fram3,text=<span class="hljs-string">&quot;显示Fptree&quot;</span>,command=showtree)<br>btnsave=Button(fram3,text=<span class="hljs-string">&quot;保存结果&quot;</span>,command=save_file)<br><span class="hljs-comment">#btnclose=Button(fram3,text=&quot;结束&quot;,command=&quot;&quot;)</span><br>btnstart.grid(row=<span class="hljs-number">0</span>,column=<span class="hljs-number">0</span>,padx=<span class="hljs-number">10</span>,pady=<span class="hljs-number">10</span>)<br>btnclear.grid(row=<span class="hljs-number">0</span>,column=<span class="hljs-number">1</span>,padx=<span class="hljs-number">10</span>,pady=<span class="hljs-number">10</span>)<br>btnshowtree.grid(row=<span class="hljs-number">0</span>,column=<span class="hljs-number">2</span>,padx=<span class="hljs-number">10</span>,pady=<span class="hljs-number">10</span>)<br>btnsave.grid(row=<span class="hljs-number">0</span>,column=<span class="hljs-number">3</span>,padx=<span class="hljs-number">10</span>,pady=<span class="hljs-number">10</span>)<br><span class="hljs-comment">#btnclose.grid(row=0,column=2,padx=10,pady=10)</span><br><br>fram3.grid(row=<span class="hljs-number">4</span>,column=<span class="hljs-number">0</span>,columnspan=<span class="hljs-number">3</span>)<br><br>fram1[<span class="hljs-string">&quot;background&quot;</span>] = <span class="hljs-string">&quot;white&quot;</span><br>fram2[<span class="hljs-string">&quot;background&quot;</span>] = <span class="hljs-string">&quot;SkyBlue&quot;</span><br>fram3[<span class="hljs-string">&quot;background&quot;</span>] = <span class="hljs-string">&quot;SkyBlue&quot;</span><br><br><br><span class="hljs-comment">######################################################################################</span><br><span class="hljs-comment"># Example of embedding CEF Python browser using Tkinter toolkit.</span><br><span class="hljs-comment"># This example has two widgets: a navigation bar and a browser.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> This example often crashes on Mac (Python 2.7, Tk 8.5/8.6)</span><br><span class="hljs-comment">#       during initial app loading with such message:</span><br><span class="hljs-comment">#       &quot;Segmentation fault: 11&quot;. Reported as Issue #309.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Tested configurations:</span><br><span class="hljs-comment"># - Tk 8.5 on Windows/Mac</span><br><span class="hljs-comment"># - Tk 8.6 on Linux</span><br><span class="hljs-comment"># - CEF Python v55.3+</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Known issue on Linux: When typing url, mouse must be over url</span><br><span class="hljs-comment"># entry widget otherwise keyboard focus is lost (Issue #255</span><br><span class="hljs-comment"># and Issue #284).</span><br><br><span class="hljs-comment">#以下代码为了嵌入html页面，具体代码没有仔细研究过，只是为了应用，只要修改embed_browser的url路径即可</span><br><span class="hljs-keyword">from</span> cefpython3 <span class="hljs-keyword">import</span> cefpython <span class="hljs-keyword">as</span> cef<br><span class="hljs-keyword">import</span> ctypes<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk<br><span class="hljs-keyword">except</span> ImportError:<br>    <span class="hljs-keyword">import</span> Tkinter <span class="hljs-keyword">as</span> tk<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> platform<br><span class="hljs-keyword">import</span> logging <span class="hljs-keyword">as</span> _logging<br><br><span class="hljs-keyword">global</span> root<br>root = tk.Tk()<br><br><span class="hljs-comment"># Fix for PyCharm hints warnings</span><br>WindowUtils = cef.WindowUtils()<br><br><span class="hljs-comment"># Platforms</span><br>WINDOWS = (platform.system() == <span class="hljs-string">&quot;Windows&quot;</span>)<br>LINUX = (platform.system() == <span class="hljs-string">&quot;Linux&quot;</span>)<br>MAC = (platform.system() == <span class="hljs-string">&quot;Darwin&quot;</span>)<br><br><span class="hljs-comment"># Globals</span><br>logger = _logging.getLogger(<span class="hljs-string">&quot;tkinter_.py&quot;</span>)<br><br><span class="hljs-comment"># Constants</span><br><span class="hljs-comment"># Tk 8.5 doesn&#x27;t support png images</span><br>IMAGE_EXT = <span class="hljs-string">&quot;.png&quot;</span> <span class="hljs-keyword">if</span> tk.TkVersion &gt; <span class="hljs-number">8.5</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;.gif&quot;</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainFrame</span>(tk.Frame):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, root</span>):<br>        self.browser_frame = <span class="hljs-literal">None</span><br>        self.navigation_bar = <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># Root</span><br>        root.geometry(<span class="hljs-string">&quot;900x640+300+200&quot;</span>)<br>        tk.Grid.rowconfigure(root, <span class="hljs-number">0</span>, weight=<span class="hljs-number">1</span>)<br>        tk.Grid.columnconfigure(root, <span class="hljs-number">0</span>, weight=<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># MainFrame</span><br>        tk.Frame.__init__(self, root)<br>        self.master.title(<span class="hljs-string">&quot;FpTree&quot;</span>)<br>        self.master.protocol(<span class="hljs-string">&quot;WM_DELETE_WINDOW&quot;</span>, self.on_close)<br>        self.master.bind(<span class="hljs-string">&quot;&lt;Configure&gt;&quot;</span>, self.on_root_configure)<br>        self.setup_icon()<br>        self.bind(<span class="hljs-string">&quot;&lt;Configure&gt;&quot;</span>, self.on_configure)<br>        self.bind(<span class="hljs-string">&quot;&lt;FocusIn&gt;&quot;</span>, self.on_focus_in)<br>        self.bind(<span class="hljs-string">&quot;&lt;FocusOut&gt;&quot;</span>, self.on_focus_out)<br><br>        <span class="hljs-comment"># NavigationBar</span><br>        self.navigation_bar = NavigationBar(self)<br>        self.navigation_bar.grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">0</span>,<br>                                 sticky=(tk.N + tk.S + tk.E + tk.W))<br>        tk.Grid.rowconfigure(self, <span class="hljs-number">0</span>, weight=<span class="hljs-number">0</span>)<br>        tk.Grid.columnconfigure(self, <span class="hljs-number">0</span>, weight=<span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># BrowserFrame</span><br>        self.browser_frame = BrowserFrame(self, self.navigation_bar)<br>        self.browser_frame.grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">0</span>,<br>                                sticky=(tk.N + tk.S + tk.E + tk.W))<br>        tk.Grid.rowconfigure(self, <span class="hljs-number">1</span>, weight=<span class="hljs-number">1</span>)<br>        tk.Grid.columnconfigure(self, <span class="hljs-number">0</span>, weight=<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># Pack MainFrame</span><br>        self.pack(fill=tk.BOTH, expand=tk.YES)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_root_configure</span>(<span class="hljs-params">self, _</span>):<br>        logger.debug(<span class="hljs-string">&quot;MainFrame.on_root_configure&quot;</span>)<br>        <span class="hljs-keyword">if</span> self.browser_frame:<br>            self.browser_frame.on_root_configure()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_configure</span>(<span class="hljs-params">self, event</span>):<br>        logger.debug(<span class="hljs-string">&quot;MainFrame.on_configure&quot;</span>)<br>        <span class="hljs-keyword">if</span> self.browser_frame:<br>            width = event.width<br>            height = event.height<br>            <span class="hljs-keyword">if</span> self.navigation_bar:<br>                height = height - self.navigation_bar.winfo_height()<br>            self.browser_frame.on_mainframe_configure(width, height)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_focus_in</span>(<span class="hljs-params">self, _</span>):<br>        logger.debug(<span class="hljs-string">&quot;MainFrame.on_focus_in&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_focus_out</span>(<span class="hljs-params">self, _</span>):<br>        logger.debug(<span class="hljs-string">&quot;MainFrame.on_focus_out&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_close</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.browser_frame:<br>            self.browser_frame.on_root_close()<br>        self.master.destroy()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_browser</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.browser_frame:<br>            <span class="hljs-keyword">return</span> self.browser_frame.browser<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_browser_frame</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.browser_frame:<br>            <span class="hljs-keyword">return</span> self.browser_frame<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setup_icon</span>(<span class="hljs-params">self</span>):<br>        resources = os.path.join(os.path.dirname(__file__), <span class="hljs-string">&quot;resources&quot;</span>)<br>        icon_path = os.path.join(resources, <span class="hljs-string">&quot;tkinter&quot;</span>+IMAGE_EXT)<br>        <span class="hljs-keyword">if</span> os.path.exists(icon_path):<br>            self.icon = tk.PhotoImage(file=icon_path)<br>            <span class="hljs-comment"># noinspection PyProtectedMember</span><br>            self.master.call(<span class="hljs-string">&quot;wm&quot;</span>, <span class="hljs-string">&quot;iconphoto&quot;</span>, self.master._w, self.icon)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BrowserFrame</span>(tk.Frame):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, master, navigation_bar=<span class="hljs-literal">None</span></span>):<br>        self.navigation_bar = navigation_bar<br>        self.closing = <span class="hljs-literal">False</span><br>        self.browser = <span class="hljs-literal">None</span><br>        tk.Frame.__init__(self, master)<br>        self.bind(<span class="hljs-string">&quot;&lt;FocusIn&gt;&quot;</span>, self.on_focus_in)<br>        self.bind(<span class="hljs-string">&quot;&lt;FocusOut&gt;&quot;</span>, self.on_focus_out)<br>        self.bind(<span class="hljs-string">&quot;&lt;Configure&gt;&quot;</span>, self.on_configure)<br>        self.focus_set()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">embed_browser</span>(<span class="hljs-params">self</span>):<br>        window_info = cef.WindowInfo()<br>        rect = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, self.winfo_width(), self.winfo_height()]<br>        window_info.SetAsChild(self.get_window_handle(), rect)<br>        self.browser = cef.CreateBrowserSync(window_info,<br>                                             url=<span class="hljs-string">&quot;file:///fptree.html&quot;</span>) <span class="hljs-comment">#todo  </span><br>        <span class="hljs-comment">#只需要修改url中的内容，嵌入本地html</span><br>        <span class="hljs-keyword">assert</span> self.browser<br>        self.browser.SetClientHandler(LoadHandler(self))<br>        self.browser.SetClientHandler(FocusHandler(self))<br>        self.message_loop_work()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_window_handle</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.winfo_id() &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> self.winfo_id()<br>        <span class="hljs-keyword">elif</span> MAC:<br>            <span class="hljs-comment"># On Mac window id is an invalid negative value (Issue #308).</span><br>            <span class="hljs-comment"># This is kind of a dirty hack to get window handle using</span><br>            <span class="hljs-comment"># PyObjC package. If you change structure of windows then you</span><br>            <span class="hljs-comment"># need to do modifications here as well.</span><br>            <span class="hljs-comment"># noinspection PyUnresolvedReferences</span><br>            <span class="hljs-keyword">from</span> AppKit <span class="hljs-keyword">import</span> NSApp<br>            <span class="hljs-comment"># noinspection PyUnresolvedReferences</span><br>            <span class="hljs-keyword">import</span> objc<br>            <span class="hljs-comment"># Sometimes there is more than one window, when application</span><br>            <span class="hljs-comment"># didn&#x27;t close cleanly last time Python displays an NSAlert</span><br>            <span class="hljs-comment"># window asking whether to Reopen that window.</span><br>            <span class="hljs-comment"># noinspection PyUnresolvedReferences</span><br>            <span class="hljs-keyword">return</span> objc.pyobjc_id(NSApp.windows()[-<span class="hljs-number">1</span>].contentView())<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;Couldn&#x27;t obtain window handle&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">message_loop_work</span>(<span class="hljs-params">self</span>):<br>        cef.MessageLoopWork()<br>        self.after(<span class="hljs-number">10</span>, self.message_loop_work)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_configure</span>(<span class="hljs-params">self, _</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.browser:<br>            self.embed_browser()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_root_configure</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># Root &lt;Configure&gt; event will be called when top window is moved</span><br>        <span class="hljs-keyword">if</span> self.browser:<br>            self.browser.NotifyMoveOrResizeStarted()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_mainframe_configure</span>(<span class="hljs-params">self, width, height</span>):<br>        <span class="hljs-keyword">if</span> self.browser:<br>            <span class="hljs-keyword">if</span> WINDOWS:<br>                ctypes.windll.user32.SetWindowPos(<br>                    self.browser.GetWindowHandle(), <span class="hljs-number">0</span>,<br>                    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height, <span class="hljs-number">0x0002</span>)<br>            <span class="hljs-keyword">elif</span> LINUX:<br>                self.browser.SetBounds(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height)<br>            self.browser.NotifyMoveOrResizeStarted()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_focus_in</span>(<span class="hljs-params">self, _</span>):<br>        logger.debug(<span class="hljs-string">&quot;BrowserFrame.on_focus_in&quot;</span>)<br>        <span class="hljs-keyword">if</span> self.browser:<br>            self.browser.SetFocus(<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_focus_out</span>(<span class="hljs-params">self, _</span>):<br>        logger.debug(<span class="hljs-string">&quot;BrowserFrame.on_focus_out&quot;</span>)<br>        <span class="hljs-keyword">if</span> self.browser:<br>            self.browser.SetFocus(<span class="hljs-literal">False</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_root_close</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.browser:<br>            self.browser.CloseBrowser(<span class="hljs-literal">True</span>)<br>            self.clear_browser_references()<br>        self.destroy()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clear_browser_references</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># Clear browser references that you keep anywhere in your</span><br>        <span class="hljs-comment"># code. All references must be cleared for CEF to shutdown cleanly.</span><br>        self.browser = <span class="hljs-literal">None</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoadHandler</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, browser_frame</span>):<br>        self.browser_frame = browser_frame<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">OnLoadStart</span>(<span class="hljs-params">self, browser, **_</span>):<br>        <span class="hljs-keyword">if</span> self.browser_frame.master.navigation_bar:<br>            self.browser_frame.master.navigation_bar.set_url(browser.GetUrl())<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FocusHandler</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, browser_frame</span>):<br>        self.browser_frame = browser_frame<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">OnTakeFocus</span>(<span class="hljs-params">self, next_component, **_</span>):<br>        logger.debug(<span class="hljs-string">&quot;FocusHandler.OnTakeFocus, next=&#123;next&#125;&quot;</span><br>                     .<span class="hljs-built_in">format</span>(<span class="hljs-built_in">next</span>=next_component))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">OnSetFocus</span>(<span class="hljs-params">self, source, **_</span>):<br>        logger.debug(<span class="hljs-string">&quot;FocusHandler.OnSetFocus, source=&#123;source&#125;&quot;</span><br>                     .<span class="hljs-built_in">format</span>(source=source))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">OnGotFocus</span>(<span class="hljs-params">self, **_</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Fix CEF focus issues (#255). Call browser frame&#x27;s focus_set</span><br><span class="hljs-string">           to get rid of type cursor in url entry widget.&quot;&quot;&quot;</span><br>        logger.debug(<span class="hljs-string">&quot;FocusHandler.OnGotFocus&quot;</span>)<br>        self.browser_frame.focus_set()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NavigationBar</span>(tk.Frame):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, master</span>):<br>        self.back_state = tk.NONE<br>        self.forward_state = tk.NONE<br>        self.back_image = <span class="hljs-literal">None</span><br>        self.forward_image = <span class="hljs-literal">None</span><br>        self.reload_image = <span class="hljs-literal">None</span><br><br>        tk.Frame.__init__(self, master)<br>        resources = os.path.join(os.path.dirname(__file__), <span class="hljs-string">&quot;resources&quot;</span>)<br><br>        <span class="hljs-comment"># Back button</span><br>        back_png = os.path.join(resources, <span class="hljs-string">&quot;back&quot;</span>+IMAGE_EXT)<br>        <span class="hljs-keyword">if</span> os.path.exists(back_png):<br>            self.back_image = tk.PhotoImage(file=back_png)<br>        self.back_button = tk.Button(self, image=self.back_image,<br>                                     command=self.go_back)<br>        self.back_button.grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># Forward button</span><br>        forward_png = os.path.join(resources, <span class="hljs-string">&quot;forward&quot;</span>+IMAGE_EXT)<br>        <span class="hljs-keyword">if</span> os.path.exists(forward_png):<br>            self.forward_image = tk.PhotoImage(file=forward_png)<br>        self.forward_button = tk.Button(self, image=self.forward_image,<br>                                        command=self.go_forward)<br>        self.forward_button.grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># Reload button</span><br>        reload_png = os.path.join(resources, <span class="hljs-string">&quot;reload&quot;</span>+IMAGE_EXT)<br>        <span class="hljs-keyword">if</span> os.path.exists(reload_png):<br>            self.reload_image = tk.PhotoImage(file=reload_png)<br>        self.reload_button = tk.Button(self, image=self.reload_image,<br>                                       command=self.reload)<br>        self.reload_button.grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">2</span>)<br><br>        <span class="hljs-comment"># Url entry</span><br>        self.url_entry = tk.Entry(self)<br>        self.url_entry.bind(<span class="hljs-string">&quot;&lt;FocusIn&gt;&quot;</span>, self.on_url_focus_in)<br>        self.url_entry.bind(<span class="hljs-string">&quot;&lt;FocusOut&gt;&quot;</span>, self.on_url_focus_out)<br>        self.url_entry.bind(<span class="hljs-string">&quot;&lt;Return&gt;&quot;</span>, self.on_load_url)<br>        self.url_entry.bind(<span class="hljs-string">&quot;&lt;Button-1&gt;&quot;</span>, self.on_button1)<br>        self.url_entry.grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">3</span>,<br>                            sticky=(tk.N + tk.S + tk.E + tk.W))<br>        tk.Grid.rowconfigure(self, <span class="hljs-number">0</span>, weight=<span class="hljs-number">100</span>)<br>        tk.Grid.columnconfigure(self, <span class="hljs-number">3</span>, weight=<span class="hljs-number">100</span>)<br><br>        <span class="hljs-comment"># Update state of buttons</span><br>        self.update_state()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">go_back</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.master.get_browser():<br>            self.master.get_browser().GoBack()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">go_forward</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.master.get_browser():<br>            self.master.get_browser().GoForward()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reload</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.master.get_browser():<br>            self.master.get_browser().Reload()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_url</span>(<span class="hljs-params">self, url</span>):<br>        self.url_entry.delete(<span class="hljs-number">0</span>, tk.END)<br>        self.url_entry.insert(<span class="hljs-number">0</span>, url)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_url_focus_in</span>(<span class="hljs-params">self, _</span>):<br>        logger.debug(<span class="hljs-string">&quot;NavigationBar.on_url_focus_in&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_url_focus_out</span>(<span class="hljs-params">self, _</span>):<br>        logger.debug(<span class="hljs-string">&quot;NavigationBar.on_url_focus_out&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_load_url</span>(<span class="hljs-params">self, _</span>):<br>        <span class="hljs-keyword">if</span> self.master.get_browser():<br>            self.master.get_browser().StopLoad()<br>            self.master.get_browser().LoadUrl(self.url_entry.get())<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_button1</span>(<span class="hljs-params">self, _</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Fix CEF focus issues (#255). See also FocusHandler.OnGotFocus.&quot;&quot;&quot;</span><br>        logger.debug(<span class="hljs-string">&quot;NavigationBar.on_button1&quot;</span>)<br>        self.master.master.focus_force()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_state</span>(<span class="hljs-params">self</span>):<br>        browser = self.master.get_browser()<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> browser:<br>            <span class="hljs-keyword">if</span> self.back_state != tk.DISABLED:<br>                self.back_button.config(state=tk.DISABLED)<br>                self.back_state = tk.DISABLED<br>            <span class="hljs-keyword">if</span> self.forward_state != tk.DISABLED:<br>                self.forward_button.config(state=tk.DISABLED)<br>                self.forward_state = tk.DISABLED<br>            self.after(<span class="hljs-number">100</span>, self.update_state)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> browser.CanGoBack():<br>            <span class="hljs-keyword">if</span> self.back_state != tk.NORMAL:<br>                self.back_button.config(state=tk.NORMAL)<br>                self.back_state = tk.NORMAL<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> self.back_state != tk.DISABLED:<br>                self.back_button.config(state=tk.DISABLED)<br>                self.back_state = tk.DISABLED<br>        <span class="hljs-keyword">if</span> browser.CanGoForward():<br>            <span class="hljs-keyword">if</span> self.forward_state != tk.NORMAL:<br>                self.forward_button.config(state=tk.NORMAL)<br>                self.forward_state = tk.NORMAL<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> self.forward_state != tk.DISABLED:<br>                self.forward_button.config(state=tk.DISABLED)<br>                self.forward_state = tk.DISABLED<br>        self.after(<span class="hljs-number">100</span>, self.update_state)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Click1</span>():<br>    root.deiconify()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    logger.setLevel(_logging.INFO)<br>    stream_handler = _logging.StreamHandler()<br>    formatter = _logging.Formatter(<span class="hljs-string">&quot;[%(filename)s] %(message)s&quot;</span>)<br>    stream_handler.setFormatter(formatter)<br>    logger.addHandler(stream_handler)<br>    logger.info(<span class="hljs-string">&quot;CEF Python &#123;ver&#125;&quot;</span>.<span class="hljs-built_in">format</span>(ver=cef.__version__))<br>    logger.info(<span class="hljs-string">&quot;Python &#123;ver&#125; &#123;arch&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>            ver=platform.python_version(), arch=platform.architecture()[<span class="hljs-number">0</span>]))<br>    logger.info(<span class="hljs-string">&quot;Tk &#123;ver&#125;&quot;</span>.<span class="hljs-built_in">format</span>(ver=tk.Tcl().<span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;info patchlevel&#x27;</span>)))<br>    <span class="hljs-keyword">assert</span> cef.__version__ &gt;= <span class="hljs-string">&quot;55.3&quot;</span>, <span class="hljs-string">&quot;CEF Python v55.3+ required to run this&quot;</span><br>    sys.excepthook = cef.ExceptHook  <span class="hljs-comment"># To shutdown all CEF processes on error</span><br>    root.withdraw()<br>    <span class="hljs-comment">#root = tk.Tk()</span><br>   <br>    app = MainFrame(root)<br>    <span class="hljs-comment"># Tk must be initialized before CEF otherwise fatal error (Issue #306)</span><br>    cef.Initialize()<br>    root1.mainloop()<br>    app.mainloop()<br>    cef.Shutdown()<br>    <br><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据挖掘及应用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计组上机总结</title>
    <link href="/2019/11/03/%E8%AE%A1%E7%BB%84%E4%B8%8A%E6%9C%BA%E6%80%BB%E7%BB%93/"/>
    <url>/2019/11/03/%E8%AE%A1%E7%BB%84%E4%B8%8A%E6%9C%BA%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>记录计组的一次上机实验，内容是存储器设计方面，考试设计题</p><span id="more"></span>  <h1 id="实验名称：模型机的总体设计-存储器设计"><a href="#实验名称：模型机的总体设计-存储器设计" class="headerlink" title="实验名称：模型机的总体设计-存储器设计"></a>实验名称：模型机的总体设计-存储器设计</h1><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>熟练掌握存储器的设计<br></p><h2 id="二、实验要求"><a href="#二、实验要求" class="headerlink" title="二、实验要求"></a>二、实验要求</h2><p>某机器中，已知ROM区域的地址空间起始地址为4000H开始，地址空间为8K * 16位（用8K * 8位的ROM芯片构成）。RAM采用最后地址8K*16位空间（用8K *8位的RAM芯片构成）。CPU采用8086、地址锁存器采用8282，数据缓冲器采用8286，译码器采用74ALS138。进行设计并用网络标签法完成要求：</p><ol><li>画出地址译码方案 </li><li>画出存储器与CPU等元件的连接图</li></ol><h2 id="三、实习步骤"><a href="#三、实习步骤" class="headerlink" title="三、实习步骤"></a>三、实习步骤</h2><p>首先分析题目所给的电路，题目中给的ROM地址空间起始地址为4000H，地址空间为8K<em>16为，8k即2^13，即A0~A12<br><br>再分析RAM，由于RAM采用的是最后地址8K</em>16为空间，因此同样是A0<del>A12<br><br>题目中给定使用8086CPU，8086是16位微处理器芯片，相关信号如下：<br><br><strong>CPU相关信号:</strong><br><br>ALE：ALE 地址锁存允许信号（输出），高电平有效，不能被浮空。<br>一般用它来控制地址锁存器，它在下降沿会把地址锁存器的输入信号锁定，然后地址锁存器的输出用于提供地址。<br><br>一般在T1时刻出现ALE有效的信号，将地址送人地址锁存器。<br><br>RD 读信号引脚（输出），执行一个对内存货I&#x2F;O端口的读操作，到底是读取内存中的单元数据还是I&#x2F;O端口中的数据，取决于M&#x2F;IO信号。<br><br>WR写信号（输出），低电平有效，对存储器或I&#x2F;O写操作，具体哪种操作取决于M&#x2F;IO信号。<br>M&#x2F;IO存储器&#x2F;输入&#x2F;输出控制信号（输出）若此信号为高电平，表示CPU和存储器之间进行数据传输；<br><br>若为低电平，表示CPU和输入输出设备之间进行数据传输。<br><br>DEN信号：8086 CPU中，控制信号DEN的作用是.CPU发出的数据传输有效控制信号<br><br>DT&#x2F;R信号：用来控制数据传送方向，在8086系统中，通常采用8286或8287作为数据总线的驱动器，用DT&#x2F;R* 信号来控制数据驱动器的数据传送方向，当DT&#x2F;R* &#x3D;1时，数据驱动器进行数据发送；DT&#x2F;R*&#x3D;0时，数据驱动器进行数据接收。<br><br>因为是16位，所以地址为A0</del>A15,因此可以先画出地址译码方案<br><img src="/2019/11/03/%E8%AE%A1%E7%BB%84%E4%B8%8A%E6%9C%BA%E6%80%BB%E7%BB%93/%E5%9C%B0%E5%9D%80%E8%AF%91%E7%A0%81%E6%96%B9%E6%A1%88.png"></p><!-- <img src="计组上机总结/地址译码方案.png"> --><p>A0<del>A12为真正的地址，而A15</del>A13对应于译码器的A，B，C</p><p>由于ROM地址空间为8k * 16位，所以依据题意需要采用2片8k * 8为的ROM芯片构成，在此选用两片2764芯片，基本参数如下：<br><br>A0到A12为13条地址信号输入线，说明芯片容量为2的13次方，即8K<br><br>D0到D7为数据线，表示芯片的每个存储单元存放一个字节（8位二进制数）。对芯片读数时，作为输出线，对芯片编程时，作为输入线。<br><br>CE为输入信号，低电平有效。（有称作片选信号）<br><br>OE为输出允许信号，低电平有效<br><br><img src="/2019/11/03/%E8%AE%A1%E7%BB%84%E4%B8%8A%E6%9C%BA%E6%80%BB%E7%BB%93/%E5%9C%B0%E5%9D%80%E8%AF%91%E7%A0%81%E6%96%B9%E6%A1%88.png"></p><!-- <img src="计组上机总结/地址译码方案.png"> --><p>接着分析RAM芯片，同样是采用两个芯片进行片选，选择的芯片为SRAM6164芯片：<br>为8K×8bit的CMOSRAM芯片。<br><br>WE为写信号，CS为片选信号，OE为输出允许信号，D0<del>D7为8位数据线，A0</del>A12为13根地址线<br><img src="/2019/11/03/%E8%AE%A1%E7%BB%84%E4%B8%8A%E6%9C%BA%E6%80%BB%E7%BB%93/RAM%E8%8A%AF%E7%89%87.png"></p><!-- <img src="计组上机总结/RAM芯片.png"> --><p>之后按照题目说的地址锁存器采用8282，关于地址锁存器相关概念不是很清楚，查阅后发现基本概念如下：<br><br>地址锁存器是一个暂存器，它根据控制信号的状态，将总线上地址代码暂存起来。8086&#x2F;8088数据和地址总线采用分时复用操作方法，即用同一总线既传输数据又传输地址。当微处理器与存储器交换信号时，首先由CPU发出存储器地址，同时发出允许锁存信号ALE给锁存器，当锁存器接到该信号后将地址&#x2F;数据总线上的地址锁存在总线上，随后才能传输数据。</p><!-- <img src="计组上机总结/地址锁存器.png"> --><p><img src="/2019/11/03/%E8%AE%A1%E7%BB%84%E4%B8%8A%E6%9C%BA%E6%80%BB%E7%BB%93/%E5%9C%B0%E5%9D%80%E9%94%81%E5%AD%98%E5%99%A8.png"></p><p>数据缓冲器采用8286，数据缓冲器相关概念如下：<br><br>数据缓冲器是一款具有不同传输能力元件之间通过时用来暂存这些数据的存储器。<br></p><!-- <img src="计组上机总结/数据缓冲器.png"> --><p><img src="/2019/11/03/%E8%AE%A1%E7%BB%84%E4%B8%8A%E6%9C%BA%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BC%93%E5%86%B2%E5%99%A8.png"></p><p>译码器采用74ALS138，根据输入的数字量在多个输出端中选一个有效，由之前的地址译码方案可知的当Y15，Y14，Y13分别为0, 1，0时，对应ROM地址，此时译码器的Y2端有效<br>同理RAM对应111，即Y7端有效</p><!-- <img src="计组上机总结/译码器.png"> --><p> <img src="/2019/11/03/%E8%AE%A1%E7%BB%84%E4%B8%8A%E6%9C%BA%E6%80%BB%E7%BB%93/%E8%AF%91%E7%A0%81%E5%99%A8.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ID3实现决策树</title>
    <link href="/2019/10/23/ID3%E5%AE%9E%E7%8E%B0%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2019/10/23/ID3%E5%AE%9E%E7%8E%B0%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>总结课上讲的决策树基本概念以及采用ID3算法实现决策树</p><span id="more"></span><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>决策树是一种类似于流程图的数结构，其中每个内部节点表示在一个属性上的测试，每个分支代表该测试的一个输出，每一个叶节点存放一个类标号，最顶层是根节点。</p><h2 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h2><p><a href="https://blog.csdn.net/qq_39521554/article/details/80559531">此段原文链接</a></p><blockquote><p>事实上，熵的英文原文为entropy，最初由德国物理学家鲁道夫·克劳修斯提出，其表达式为：entropy,它表示一个系系统在不受外部干扰时，其内部最稳定的状态。后来一中国学者翻译entropy时，考虑到entropy是能量Q跟温度T的商，且跟火有关，便把entropy形象的翻译成“熵”。我们知道，任何粒子的常态都是随机运动，也就是”无序运动”，如果让粒子呈现”有序化”，必须耗费能量。所以，温度（热能）可以被看作”有序化”的一种度量，而”熵”可以看作是”无序化”的度量。如果没有外部能量输入，封闭系统趋向越来越混乱（熵越来越大）。比如，如果房间无人打扫，不可能越来越干净（有序化），只可能越来越乱（无序化）。而要让一个系统变得更有序，必须有外部能量的输入。1948年，香农Claude E. Shannon引入信息（熵），将其定义为离散随机事件的出现概率。一个系统越是有序，信息熵就越低；反之，一个系统越是混乱，信息熵就越高。所以说，信息熵可以被认为是系统有序化程度的一个度量。</p></blockquote><p>熵越大，就意味着混杂度越大，越难以区分，因此决策树要选取熵小的作为根节点</p><p>公式：<br>entropy(S)&#x3D;$\sum_{i&#x3D;0}^N {Pi*\log_2 Pi}$<br><br><br>Pi为概率</p><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>用来衡量熵的期望减少值<br>分类前的信息熵减去分类后的信息熵<br><br>公式：gain(S,A)&#x3D;entropy(S)-entropy(S,A)<br><br>信息增益越大，熵的减小量越大，节点更纯</p><p>entropy(S,A)含义：<br><br>设属性A将S划分为m份，根据A划分的子集的熵或期望信息<br><br>entropy(S,A)&#x3D;$\sum_{i&#x3D;0}^m {|Si| \over |S|}*entropy(Si)$ <br><br>(Si表示根据属性A划分的S的第i个字集,|S|和|Si|分别表示S中，Si中的样本数目)</p><h1 id="构建决策树"><a href="#构建决策树" class="headerlink" title="构建决策树"></a>构建决策树</h1><p>代码实现(<a href="https://blog.csdn.net/leaf_zizi/article/details/82848682">原文链接</a>)</p><p><img src="/2019/10/23/ID3%E5%AE%9E%E7%8E%B0%E5%86%B3%E7%AD%96%E6%A0%91/%E5%86%B3%E7%AD%96%E6%A0%91.png"></p><p>建树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> log<br><span class="hljs-keyword">import</span> operator<br> <br><span class="hljs-comment"># 计算信息熵</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calcShannonEnt</span>(<span class="hljs-params">dataSet</span>):<br>    numEntries = <span class="hljs-built_in">len</span>(dataSet)  <span class="hljs-comment"># 样本数</span><br>    labelCounts = &#123;&#125;<br>    <span class="hljs-keyword">for</span> featVec <span class="hljs-keyword">in</span> dataSet:  <span class="hljs-comment"># 遍历每个样本</span><br>        currentLabel = featVec[-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 当前样本的类别</span><br>        <span class="hljs-keyword">if</span> currentLabel <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> labelCounts.keys():  <span class="hljs-comment"># 生成类别字典</span><br>            labelCounts[currentLabel] = <span class="hljs-number">0</span><br>        labelCounts[currentLabel] += <span class="hljs-number">1</span><br>    shannonEnt = <span class="hljs-number">0.0</span><br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> labelCounts:  <span class="hljs-comment"># 计算信息熵</span><br>        prob = <span class="hljs-built_in">float</span>(labelCounts[key]) / numEntries<br>        shannonEnt = shannonEnt - prob * log(prob, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> shannonEnt<br> <br> <br><span class="hljs-comment"># 划分数据集，axis:按第几个属性划分，value:要返回的子集对应的属性值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">splitDataSet</span>(<span class="hljs-params">dataSet, axis, value</span>):<br>    retDataSet = []<br>    featVec = []<br>    <span class="hljs-keyword">for</span> featVec <span class="hljs-keyword">in</span> dataSet:<br>        <span class="hljs-keyword">if</span> featVec[axis] == value:<br>            reducedFeatVec = featVec[:axis]<br>            reducedFeatVec.extend(featVec[axis + <span class="hljs-number">1</span>:])<br>            retDataSet.append(reducedFeatVec)<br>    <span class="hljs-keyword">return</span> retDataSet<br> <br> <br><span class="hljs-comment"># 选择最好的数据集划分方式</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">chooseBestFeatureToSplit</span>(<span class="hljs-params">dataSet</span>):<br>    numFeatures = <span class="hljs-built_in">len</span>(dataSet[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>  <span class="hljs-comment"># 属性的个数</span><br>    baseEntropy = calcShannonEnt(dataSet)<br>    bestInfoGain = <span class="hljs-number">0.0</span><br>    bestFeature = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numFeatures):  <span class="hljs-comment"># 对每个属性技术信息增益</span><br>        featList = [example[i] <span class="hljs-keyword">for</span> example <span class="hljs-keyword">in</span> dataSet]<br>        uniqueVals = <span class="hljs-built_in">set</span>(featList)  <span class="hljs-comment"># 该属性的取值集合</span><br>        newEntropy = <span class="hljs-number">0.0</span><br>        <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> uniqueVals: <span class="hljs-comment"># 对每一种取值计算信息增益</span><br>            subDataSet = splitDataSet(dataSet, i, value)<br>            prob = <span class="hljs-built_in">len</span>(subDataSet) / <span class="hljs-built_in">float</span>(<span class="hljs-built_in">len</span>(dataSet))<br>            newEntropy += prob * calcShannonEnt(subDataSet)<br>        infoGain = baseEntropy - newEntropy<br>        <span class="hljs-keyword">if</span> (infoGain &gt; bestInfoGain):  <span class="hljs-comment"># 选择信息增益最大的属性</span><br>            bestInfoGain = infoGain<br>            bestFeature = i<br>    <span class="hljs-keyword">return</span> bestFeature<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">majorityCnt</span>(<span class="hljs-params">classList</span>):<br>    classCount = &#123;&#125;<br>    <span class="hljs-keyword">for</span> vote <span class="hljs-keyword">in</span> classList:<br>        <span class="hljs-keyword">if</span> vote <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> classCount.keys(): classCount[vote] = <span class="hljs-number">0</span><br>        classCount[vote] += <span class="hljs-number">1</span><br>    sortedClassCount = <span class="hljs-built_in">sorted</span>(classCount.iteritems(),<br>                              key=operator.itemgetter(<span class="hljs-number">1</span>), reverse=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> sortedClassCount[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br> <br> <br><span class="hljs-comment"># 递归构建决策树</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">createTree</span>(<span class="hljs-params">dataSet, labels</span>):<br>    classList = [example[-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> example <span class="hljs-keyword">in</span> dataSet]  <span class="hljs-comment"># 类别向量</span><br>    <span class="hljs-keyword">if</span> classList.count(classList[<span class="hljs-number">0</span>]) == <span class="hljs-built_in">len</span>(classList):  <span class="hljs-comment"># 如果只有一个类别，返回</span><br>        <span class="hljs-keyword">return</span> classList[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(dataSet[<span class="hljs-number">0</span>]) == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 如果所有特征都被遍历完了，返回出现次数最多的类别</span><br>        <span class="hljs-keyword">return</span> majorityCnt(classList)<br>    bestFeat = chooseBestFeatureToSplit(dataSet)  <span class="hljs-comment"># 最优划分属性的索引</span><br>    bestFeatLabel = labels[bestFeat]  <span class="hljs-comment"># 最优划分属性的标签</span><br>    myTree = &#123;bestFeatLabel: &#123;&#125;&#125;<br>    <span class="hljs-keyword">del</span> (labels[bestFeat])  <span class="hljs-comment"># 已经选择的特征不再参与分类</span><br>    featValues = [example[bestFeat] <span class="hljs-keyword">for</span> example <span class="hljs-keyword">in</span> dataSet]<br>    uniqueValue = <span class="hljs-built_in">set</span>(featValues)  <span class="hljs-comment"># 该属性所有可能取值，也就是节点的分支</span><br>    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> uniqueValue:  <span class="hljs-comment"># 对每个分支，递归构建树</span><br>        subLabels = labels[:]<br>        myTree[bestFeatLabel][value] = createTree(<br>            splitDataSet(dataSet, bestFeat, value), subLabels)<br>    <span class="hljs-keyword">return</span> myTree<br></code></pre></td></tr></table></figure><p>画图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 定义文本框和箭头格式</span><br>decisionNode = <span class="hljs-built_in">dict</span>(boxstyle=<span class="hljs-string">&quot;round4&quot;</span>, color=<span class="hljs-string">&#x27;#3366FF&#x27;</span>)  <span class="hljs-comment">#定义判断结点形态</span><br>leafNode = <span class="hljs-built_in">dict</span>(boxstyle=<span class="hljs-string">&quot;circle&quot;</span>, color=<span class="hljs-string">&#x27;#FF6633&#x27;</span>)  <span class="hljs-comment">#定义叶结点形态</span><br>arrow_args = <span class="hljs-built_in">dict</span>(arrowstyle=<span class="hljs-string">&quot;&lt;-&quot;</span>, color=<span class="hljs-string">&#x27;g&#x27;</span>)  <span class="hljs-comment">#定义箭头</span><br><br><span class="hljs-comment">#绘制带箭头的注释</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plotNode</span>(<span class="hljs-params">nodeTxt, centerPt, parentPt, nodeType</span>):<br>    createPlot.ax1.annotate(nodeTxt, xy=parentPt, xycoords=<span class="hljs-string">&#x27;axes fraction&#x27;</span>,<br>                            xytext=centerPt, textcoords=<span class="hljs-string">&#x27;axes fraction&#x27;</span>,<br>                            va=<span class="hljs-string">&quot;center&quot;</span>, ha=<span class="hljs-string">&quot;center&quot;</span>, bbox=nodeType, arrowprops=arrow_args)<br><br><br><span class="hljs-comment">#计算叶结点数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getNumLeafs</span>(<span class="hljs-params">myTree</span>):<br>    numLeafs = <span class="hljs-number">0</span><br>    firstStr = <span class="hljs-built_in">list</span>(myTree.keys())[<span class="hljs-number">0</span>]<br>    secondDict = myTree[firstStr]<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> secondDict.keys():<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(secondDict[key]).__name__ == <span class="hljs-string">&#x27;dict&#x27;</span>:<br>            numLeafs += getNumLeafs(secondDict[key])<br>        <span class="hljs-keyword">else</span>:<br>            numLeafs += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> numLeafs<br><br><br><span class="hljs-comment">#计算树的层数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getTreeDepth</span>(<span class="hljs-params">myTree</span>):<br>    maxDepth = <span class="hljs-number">0</span><br>    firstStr = <span class="hljs-built_in">list</span>(myTree.keys())[<span class="hljs-number">0</span>]<br>    secondDict = myTree[firstStr]<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> secondDict.keys():<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(secondDict[key]).__name__ == <span class="hljs-string">&#x27;dict&#x27;</span>:<br>            thisDepth = <span class="hljs-number">1</span> + getTreeDepth(secondDict[key])<br>        <span class="hljs-keyword">else</span>:<br>            thisDepth = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> thisDepth &gt; maxDepth:<br>            maxDepth = thisDepth<br>    <span class="hljs-keyword">return</span> maxDepth<br><br><br><span class="hljs-comment">#在父子结点间填充文本信息</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plotMidText</span>(<span class="hljs-params">cntrPt, parentPt, txtString</span>):<br>    xMid = (parentPt[<span class="hljs-number">0</span>] - cntrPt[<span class="hljs-number">0</span>]) / <span class="hljs-number">2.0</span> + cntrPt[<span class="hljs-number">0</span>]<br>    yMid = (parentPt[<span class="hljs-number">1</span>] - cntrPt[<span class="hljs-number">1</span>]) / <span class="hljs-number">2.0</span> + cntrPt[<span class="hljs-number">1</span>]<br>    createPlot.ax1.text(xMid, yMid, txtString, va=<span class="hljs-string">&quot;center&quot;</span>, ha=<span class="hljs-string">&quot;center&quot;</span>, rotation=<span class="hljs-number">30</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plotTree</span>(<span class="hljs-params">myTree, parentPt, nodeTxt</span>):<br>    numLeafs = getNumLeafs(myTree)<br>    depth = getTreeDepth(myTree)<br>    firstStr = <span class="hljs-built_in">list</span>(myTree.keys())[<span class="hljs-number">0</span>]<br>    cntrPt = (plotTree.xOff + (<span class="hljs-number">1.0</span> + <span class="hljs-built_in">float</span>(numLeafs)) / <span class="hljs-number">2.0</span> / plotTree.totalW, plotTree.yOff)<br>    plotMidText(cntrPt, parentPt, nodeTxt)  <span class="hljs-comment">#在父子结点间填充文本信息</span><br>    plotNode(firstStr, cntrPt, parentPt, decisionNode)  <span class="hljs-comment">#绘制带箭头的注释</span><br>    secondDict = myTree[firstStr]<br>    plotTree.yOff = plotTree.yOff - <span class="hljs-number">1.0</span> / plotTree.totalD<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> secondDict.keys():<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(secondDict[key]).__name__ == <span class="hljs-string">&#x27;dict&#x27;</span>:<br>            plotTree(secondDict[key], cntrPt, <span class="hljs-built_in">str</span>(key))<br>        <span class="hljs-keyword">else</span>:<br>            plotTree.xOff = plotTree.xOff + <span class="hljs-number">1.0</span> / plotTree.totalW<br>            plotNode(secondDict[key], (plotTree.xOff, plotTree.yOff), cntrPt, leafNode)<br>            plotMidText((plotTree.xOff, plotTree.yOff), cntrPt, <span class="hljs-built_in">str</span>(key))<br>    plotTree.yOff = plotTree.yOff + <span class="hljs-number">1.0</span> / plotTree.totalD<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">createPlot</span>(<span class="hljs-params">inTree</span>):<br>    fig = plt.figure(<span class="hljs-number">1</span>, facecolor=<span class="hljs-string">&#x27;white&#x27;</span>)<br>    fig.clf()<br>    axprops = <span class="hljs-built_in">dict</span>(xticks=[], yticks=[])<br>    createPlot.ax1 = plt.subplot(<span class="hljs-number">111</span>, frameon=<span class="hljs-literal">False</span>, **axprops)<br>    plotTree.totalW = <span class="hljs-built_in">float</span>(getNumLeafs(inTree))<br>    plotTree.totalD = <span class="hljs-built_in">float</span>(getTreeDepth(inTree))<br>    plotTree.xOff = -<span class="hljs-number">0.5</span> / plotTree.totalW;<br>    plotTree.yOff = <span class="hljs-number">1.0</span>;<br>    plotTree(inTree, (<span class="hljs-number">0.5</span>, <span class="hljs-number">1.0</span>), <span class="hljs-string">&#x27;&#x27;</span>)<br>    plt.show()<br><br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">classify</span>(<span class="hljs-params">inputTree, featLabels, testVec</span>):<br>    firstStr = <span class="hljs-built_in">list</span>(inputTree.keys())[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 根节点</span><br>    secondDict = inputTree[firstStr]<br>    featIndex = featLabels.index(firstStr)  <span class="hljs-comment"># 跟节点对应的属性</span><br>    classLabel = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> secondDict.keys():  <span class="hljs-comment"># 对每个分支循环</span><br>        <span class="hljs-keyword">if</span> testVec[featIndex] == key:  <span class="hljs-comment"># 测试样本进入某个分支</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(secondDict[key]).__name__ == <span class="hljs-string">&#x27;dict&#x27;</span>:  <span class="hljs-comment"># 该分支不是叶子节点，递归</span><br>                classLabel = classify(secondDict[key], featLabels, testVec)<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 如果是叶子， 返回结果</span><br>                classLabel = secondDict[key]<br>    <span class="hljs-keyword">return</span> classLabel<br></code></pre></td></tr></table></figure><p>主函数执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> csv<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data</span>(<span class="hljs-params">filename</span>):<br>    lines = csv.reader(<span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&quot;rt&quot;</span>,encoding=<span class="hljs-string">&#x27;utf-8-sig&#x27;</span>))<br>    dataset = <span class="hljs-built_in">list</span>(lines)<br>    <span class="hljs-keyword">return</span> dataset<br><br>filename=<span class="hljs-string">&quot;G:/学习/课程相关/大三/大数据挖掘/上机/4/thisdata.csv&quot;</span> <br>listWm = load_data(filename)<br>labels = [<span class="hljs-string">&#x27;Outlook&#x27;</span>, <span class="hljs-string">&#x27;Temperature&#x27;</span>, <span class="hljs-string">&#x27;Humidity&#x27;</span>, <span class="hljs-string">&#x27;Windy&#x27;</span>]<br>Trees = createTree(listWm, labels)<br>createPlot(Trees)<br>labels = [<span class="hljs-string">&#x27;Outlook&#x27;</span>, <span class="hljs-string">&#x27;Temperature&#x27;</span>, <span class="hljs-string">&#x27;Humidity&#x27;</span>, <span class="hljs-string">&#x27;Windy&#x27;</span>]<br>testData = [<span class="hljs-string">&#x27;Rain&#x27;</span>, <span class="hljs-string">&#x27;Cool&#x27;</span>, <span class="hljs-string">&#x27;High&#x27;</span>, <span class="hljs-string">&#x27;Not&#x27;</span>]<br>testClass = classify(Trees, labels, testData)<br><span class="hljs-built_in">print</span>(testClass)<br><br></code></pre></td></tr></table></figure><p><img src="/2019/10/23/ID3%E5%AE%9E%E7%8E%B0%E5%86%B3%E7%AD%96%E6%A0%91/output.png"><br>输出结果:No</p>]]></content>
    
    
    <categories>
      
      <category>大数据挖掘及应用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python日常问题总结</title>
    <link href="/2019/10/23/Python%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2019/10/23/Python%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>总结平时学习遇到的python使用中出现的问题以及python的一些用法，注意事项</p><span id="more"></span><h1 id="使用问题"><a href="#使用问题" class="headerlink" title="使用问题"></a>使用问题</h1><h2 id="python读取csv文件出现’-ufeff’乱码的解决方法"><a href="#python读取csv文件出现’-ufeff’乱码的解决方法" class="headerlink" title="python读取csv文件出现’\ufeff’乱码的解决方法"></a>python读取csv文件出现’\ufeff’乱码的解决方法</h2><p><a href="https://www.jianshu.com/p/4eef0b44da58">原文链接</a><br><br>使用python中的csv模块读取文件的时候使用encoding&#x3D;’utf-8’解码，会在读取了列表的一个位出现‘‘\ufeff’’，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">csv_reader</span>():<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;2.csv&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        reader=csv.reader(f)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(reader)<br><br>list1=csv_reader()<br><span class="hljs-built_in">print</span>(list1)<br></code></pre></td></tr></table></figure><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#输出结果<br>[[<span class="hljs-string">&#x27;\ufeff2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>], [<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>], [<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>], [<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>], [<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>], [<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>], [<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>], <br>[<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;10&#x27;</span>],[<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-string">&#x27;11&#x27;</span>], [<span class="hljs-string">&#x27;11&#x27;</span>, <span class="hljs-string">&#x27;12&#x27;</span>], [<span class="hljs-string">&#x27;12&#x27;</span>, <span class="hljs-string">&#x27;13&#x27;</span>], [<span class="hljs-string">&#x27;13&#x27;</span>, <span class="hljs-string">&#x27;14&#x27;</span>], [<span class="hljs-string">&#x27;14&#x27;</span>, <span class="hljs-string">&#x27;15&#x27;</span>]]<br></code></pre></td></tr></table></figure><p>要去掉这个字符，只需要在读取的时候使用encoding&#x3D;’utf-8-sig’格式就好,代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">csv_reader</span>():<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;2.csv&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8-sig&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        reader=csv.reader(f)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(reader)<br><br>list1=csv_reader()<br><span class="hljs-built_in">print</span>(list1)<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">#输出结果<br><span class="hljs-selector-attr">[[<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>]</span>, <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>]</span>, <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>]</span>, <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>]</span>, <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>]</span>, <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>]</span>, <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>]</span>, <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;10&#x27;</span>]</span>, <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;1</span></span><br></code></pre></td></tr></table></figure><h2 id="在java中调用cmd-运行python程序，其实是通过cmd调用，本代码是在网上找到的代码修改而来，忘记具体地址了，抱歉。"><a href="#在java中调用cmd-运行python程序，其实是通过cmd调用，本代码是在网上找到的代码修改而来，忘记具体地址了，抱歉。" class="headerlink" title="在java中调用cmd,运行python程序，其实是通过cmd调用，本代码是在网上找到的代码修改而来，忘记具体地址了，抱歉。"></a>在java中调用cmd,运行python程序，其实是通过cmd调用，本代码是在网上找到的代码修改而来，忘记具体地址了，抱歉。</h2><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">doimagecaption</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//System.out.print(&quot;开始运行&quot;);</span><br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D://temp.tmp&quot;</span>);<span class="hljs-comment">//新建一个用来存储结果的缓存文件</span><br><span class="hljs-keyword">if</span>(!file.exists()) &#123;<br>file.createNewFile();<br>System.out.print(<span class="hljs-string">&quot;创建文件&quot;</span>);<br><span class="hljs-type">ProcessBuilder</span> <span class="hljs-variable">pb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessBuilder</span>().command(<span class="hljs-string">&quot;cmd.exe&quot;</span>, <span class="hljs-string">&quot;/c&quot;</span>, <span class="hljs-string">&quot;g:&amp;cd imgcp&amp;activate&amp;python main.py --phase=test --model_file=\&quot;./models/289999.npy\&quot; --beam_size=3&quot;</span>).inheritIO();<br>    <span class="hljs-comment">//ProcessBuilder pb = new ProcessBuilder().command(&quot;cmd.exe&quot;, &quot;/c&quot;, &quot;ipconfig&quot;).inheritIO();</span><br>System.out.print(<span class="hljs-string">&quot;创建pb&quot;</span>);<br>pb.redirectErrorStream(<span class="hljs-literal">true</span>);<span class="hljs-comment">//这里是把控制台中的红字变成了黑字，用通常的方法其实获取不到，控制台的结果是pb.start()方法内部输出的</span><br>pb.redirectOutput(file);<span class="hljs-comment">//把执行结果输出。</span><br>pb.start().waitFor();<span class="hljs-comment">//等待语句执行完成，否则可能会读不到结果。</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>br= <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(in));<br><span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">while</span>((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>System.out.println(line);<br>&#125;<br>br.close();<br>br = <span class="hljs-literal">null</span>;<br>file.delete();<br>&#125;  <br><span class="hljs-keyword">if</span>(br != <span class="hljs-literal">null</span>) <br>br.close();<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>如果使用的话只需要按如下示意修改即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">command(<span class="hljs-string">&quot;cmd.exe&quot;</span>, <span class="hljs-string">&quot;/c&quot;</span>, <span class="hljs-string">&quot;填入本应在cmd里输入的内容，多条语句可以使用&amp;拼接&quot;</span>).inheritIO();<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单个神经元</title>
    <link href="/2019/10/20/%E5%8D%95%E4%B8%AA%E7%A5%9E%E7%BB%8F%E5%85%83/"/>
    <url>/2019/10/20/%E5%8D%95%E4%B8%AA%E7%A5%9E%E7%BB%8F%E5%85%83/</url>
    
    <content type="html"><![CDATA[<ul><li>单个神经元</li><li>激活函数</li><li>损失函数</li><li>优化器</li><li>Maxout<span id="more"></span></li></ul><h1 id="单个神经元"><a href="#单个神经元" class="headerlink" title="单个神经元"></a>单个神经元</h1><p>一个神经元由以下几个关键知识点组成：</p><ul><li>激活函数</li><li>损失函数</li><li>梯度下降</li></ul><p>将所有输入的信号经过w变换后，再添加一个额外的偏执量b，把它们加载一起求和，然后在选择一个模拟细胞体处理的函数来实现整个过程的仿真。这个函数称为激活函数。<br><br>把w和b赋予合适的值时，配合合适的激活函数，就会发现可以产生很好的拟合效果，这个过程叫做正向传播<br><br>实际过程中无法得知w和b的值具体是多少才是正常的，因此加入训练过程来让模型自动修正，最终产生一个合适的权重,这叫做反向传播<br><br>而如何将输出的误差转化为权重的误差，使用BP算法(误差反向传播算法)<br></p><p>激活函数主要作用是用来加入非线性因素的，以解决线性模型表达能力不足的缺陷<br><br>神经网络里常用的激活函数有Sigmoid，Tanh和Relu等<br><br>Sigmoid函数：把输入的值压缩到0到1之间，TensorFlow中对应函数为tf.nn.sigmoid(x,name&#x3D;None)<br><br>Tanh函数：将值域扩展到-1到1之间，TensorFlow对应函数tf.nn.tanh(x,name&#x3D;None)<br><br>ReLU函数(也称为Rectifier)，max(0,x) ，仅在正向传播方面在信号响应上有优势，<br>TensorFlow中对应函数：</p><ul><li>tf.nn.relu(features,name&#x3D;None)：一般的ReLU函数，max(features,0)</li><li>tf.nn.relu6(features,name&#x3D;None):是以6位阈值的ReLU函数，即min(max(features,0),6)</li></ul><p>relu6存在的原因是防止梯度爆炸， 当节点和层数特别多<br>而且输出都为正时， 它们的加和会是一个很大的值， 尤其在经历几层变<br>换之后， 最终的值可能会离目标值相差太远。 误差太大， 会导致对参数<br>调整修正值过大， 这会导致网络抖动得较厉害， 最终很难收敛。</p><p>其他变种：</p><ul><li>tf.nn.softplus(features,name&#x3D;None)</li><li>tf.nn.elu(features,name&#x3D;None)</li><li>tf.maximum(x,leak*x,name&#x3D;name) #leak为传入的参数，可以设为0.01等</li></ul><p>还可以手动封装Swish函数，要优于ReLU函数<br></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Swish</span>(<span class="hljs-params">x,beta=<span class="hljs-number">1</span></span>):<br><span class="hljs-keyword">return</span> x*tf.nn.sigmoid(x*beta)<br></code></pre></td></tr></table></figure><p>softmax算法-处理分类问题<br><br>tf.nn.softmax(logits,name&#x3D;None) 计算softmax<br><br>tf.nn.log_softmax(logits,name&#x3D;None) 对softmax取对数<br><br>实际使用中，softmax伴随的分类标签都为one_hot编码，在softmax时，需要将目标分成几类，就在最后这层放几个节点</p><p>损失函数<br><br>两种比较常见的损失函数:</p><ul><li>均值平方差</li><li>交叉熵</li></ul><p>损失函数的选取取决于输入标签数据的类型<br><br>如果输入的是实数、无界的值，损失函数使用平方差<br><br>如果输入的标签是位矢量(分类标志)，使用交叉熵会更合适<br></p><p>TensorFlow中的梯度下降函数<br><br>在TensorFlow中是通过一个叫做Optimizer的优化器类进行训练优化的，对于不同算法的优化器，在TensorFlow中有不同的类<br><br>在训练过程中，先实例化一个优化函数如tf.train.GradientDescentOptimizer,并基于一定的学习率进行梯度优化训练</p><p>optimizer&#x3D;tf.train.GradentDescentOptimizer(learning_rate)<br><br>接着使用一个minimize()的操作，里面传入损失值节点loss，再启动一个外层的循环，优化器就会按照循环的次数一次次沿着loss最小值的方向优化参数<br><br>目前比较常用的优化器为Adam优化器</p><p>每个优化器的第一个参数learning_rate代表学习率，设置学习率的方法：退化学习率，又叫学习率衰减<br><br>例如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">learning_rate</span>=tf.train.exponential_decay(starter_learning_rate,global_step,<span class="hljs-number">100000</span>,<span class="hljs-number">0</span>.<span class="hljs-number">96</span>)<br></code></pre></td></tr></table></figure><p>这种方式定义的学习率就是退化学习率，它的意思是当前迭代到global_step步，学习率每一步都按照每10万步缩小到0.96%的速度衰退<br><br>通过增大批次处理样本的数量也可以起到退化学习率的效果。但是这种方法要求训练时的最小批次要与实际应用中的最小批次一致</p><h1 id="单个神经元的扩展——Maxout网络"><a href="#单个神经元的扩展——Maxout网络" class="headerlink" title="单个神经元的扩展——Maxout网络"></a>单个神经元的扩展——Maxout网络</h1><p>将激活函数变成一个网络选择器，原理就是将多个神经元并列地放在一起，从它们的输出结果找到最大的那个，代表对特征响应最敏感，然后取这个神尽管的结果参与后面的运算。这样的网络会有更好的拟合效果<br><br>Maxout的拟合功能很强大，但是也有节点过多，参数过多，训练过慢的缺点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tensorflow.examples.tutorials.mnist <span class="hljs-keyword">import</span> input_data<br>mnist = input_data.read_data_sets(<span class="hljs-string">&quot;MNIST_data/&quot;</span>)<br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf <span class="hljs-comment">#导入tensorflow库</span><br><br>tf.reset_default_graph()<br><span class="hljs-comment"># tf Graph Input</span><br>x = tf.placeholder(tf.float32, [<span class="hljs-literal">None</span>, <span class="hljs-number">784</span>]) <span class="hljs-comment"># mnist data维度 28*28=784</span><br>y = tf.placeholder(tf.int32, [<span class="hljs-literal">None</span>]) <span class="hljs-comment"># 0-9 数字=&gt; 10 classes</span><br><br><span class="hljs-comment"># Set model weights</span><br>W = tf.Variable(tf.random_normal([<span class="hljs-number">784</span>, <span class="hljs-number">10</span>]))<br>b = tf.Variable(tf.zeros([<span class="hljs-number">10</span>]))<br><br><br>z= tf.matmul(x, W) + b<br><br><br>maxout = tf.reduce_max(z,axis= <span class="hljs-number">1</span>,keep_dims=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># Set model weights</span><br>W2 = tf.Variable(tf.truncated_normal([<span class="hljs-number">1</span>, <span class="hljs-number">10</span>], stddev=<span class="hljs-number">0.1</span>))<br>b2 = tf.Variable(tf.zeros([<span class="hljs-number">1</span>]))<br><span class="hljs-comment"># 构建模型</span><br>pred = tf.nn.softmax(tf.matmul(maxout, W2) + b2)<br><br><span class="hljs-comment"># 构建模型</span><br><span class="hljs-comment">#pred = tf.nn.softmax(z) # Softmax分类</span><br><br><span class="hljs-comment"># Minimize error using cross entropy</span><br><span class="hljs-comment">#cost = tf.reduce_mean(-tf.reduce_sum(y*tf.log(pred), reduction_indices=1))</span><br>cost = tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y, logits=z))<br><span class="hljs-comment">#参数设置</span><br>learning_rate = <span class="hljs-number">0.04</span><br><span class="hljs-comment"># 使用梯度下降优化器</span><br>optimizer = tf.train.GradientDescentOptimizer(learning_rate).minimize(cost)<br><br>training_epochs = <span class="hljs-number">200</span><br>batch_size = <span class="hljs-number">100</span><br>display_step = <span class="hljs-number">1</span><br><br><br><span class="hljs-comment"># 启动session</span><br><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:<br>    sess.run(tf.global_variables_initializer())<span class="hljs-comment"># Initializing OP</span><br><br>    <span class="hljs-comment"># 启动循环开始训练</span><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(training_epochs):<br>        avg_cost = <span class="hljs-number">0.</span><br>        total_batch = <span class="hljs-built_in">int</span>(mnist.train.num_examples/batch_size)<br>        <span class="hljs-comment"># 遍历全部数据集</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(total_batch):<br>            batch_xs, batch_ys = mnist.train.next_batch(batch_size)<br>            <span class="hljs-comment"># Run optimization op (backprop) and cost op (to get loss value)</span><br>            _, c = sess.run([optimizer, cost], feed_dict=&#123;x: batch_xs,<br>                                                          y: batch_ys&#125;)<br>            <span class="hljs-comment"># Compute average loss</span><br>            avg_cost += c / total_batch<br>        <span class="hljs-comment"># 显示训练中的详细信息</span><br>        <span class="hljs-keyword">if</span> (epoch+<span class="hljs-number">1</span>) % display_step == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;Epoch:&quot;</span>, <span class="hljs-string">&#x27;%04d&#x27;</span> % (epoch+<span class="hljs-number">1</span>), <span class="hljs-string">&quot;cost=&quot;</span>, <span class="hljs-string">&quot;&#123;:.9f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(avg_cost))<br><br>    <span class="hljs-built_in">print</span>( <span class="hljs-string">&quot; Finished!&quot;</span>)<br><br><br></code></pre></td></tr></table></figure><pre><code class="hljs">Epoch: 0001 cost= 4.593184041Epoch: 0002 cost= 1.818854022Epoch: 0003 cost= 1.314909137、、、Epoch: 0197 cost= 0.289531484Epoch: 0198 cost= 0.289406507Epoch: 0199 cost= 0.289030269Epoch: 0200 cost= 0.288644536 Finished!</code></pre><br>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基础练习-mnist手写数据集识别</title>
    <link href="/2019/10/20/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-mnist%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%86%E5%88%AB/"/>
    <url>/2019/10/20/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-mnist%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>照着书实现了一下mnist手写数据集识别这个深度学习中的”hello,world”</p><span id="more"></span><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>第一层接收输入信号，最后一层返回输出信号，这些网络通常都是前馈神经网络<br><br>传递函数：最常用的一种传递函数就是sigmoid函数，值域为(0,1）<br><br>一般情况下，前馈神经网络的最后一层会采用一个softmax函数，这样可以方便地用后验概率解释网络的输出</p><h1 id="MNIST手写数字数据集"><a href="#MNIST手写数字数据集" class="headerlink" title="MNIST手写数字数据集"></a>MNIST手写数字数据集</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> tensorflow.examples.tutorials.mnist <span class="hljs-keyword">import</span> input_data<br>%matplotlib inline<br>mnist_data=input_data.read_data_sets(<span class="hljs-string">&quot;Data/data&quot;</span>,one_hot=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;输入数据:&#x27;</span>,mnist_data.train.images)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;输入数据的shape&#x27;</span>,mnist_data.train.images.shape)<br><span class="hljs-keyword">import</span> pylab<br>im=mnist_data.train.images[<span class="hljs-number">1</span>]<br>im=im.reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">28</span>)<br>pylab.imshow(im)<br>pylab.show()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Extracting Data/data\train-images-idx3-ubyte.gzExtracting Data/data\train-labels-idx1-ubyte.gzExtracting Data/data\t10k-images-idx3-ubyte.gzExtracting Data/data\t10k-labels-idx1-ubyte.gz输入数据: [[0. 0. 0. ... 0. 0. 0.] [0. 0. 0. ... 0. 0. 0.] [0. 0. 0. ... 0. 0. 0.] ... [0. 0. 0. ... 0. 0. 0.] [0. 0. 0. ... 0. 0. 0.] [0. 0. 0. ... 0. 0. 0.]]输入数据的shape (55000, 784)</code></pre><p><img src="/2019/10/20/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-mnist%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%86%E5%88%AB/output_3_1.png" alt="png"></p><p>mnist数据集 输入图片是个550000x784的矩阵，第一个维度代表图片索引，第二个<br>维度代表图像像素，28x28像素的图片，共有10个类别<br><br>所以先创建一个[None,784]的占位符x和一个[None,10]的占位符y</p><p>交叉熵可在神经网络(机器学习)中作为损失函数，p表示真实标记的分布，q则为训练后的模型的预测标记分布，交叉熵损失函数可以衡量p与q的相似性。交叉熵作为损失函数还有一个好处是使用sigmoid函数在梯度下降时能避免均方误差损失函数学习速率降低的问题，因为学习速率可以被输出的误差所控制。 [</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">from</span> tensorflow.examples.tutorials.mnist <span class="hljs-keyword">import</span> input_data<br>mnist=input_data.read_data_sets(<span class="hljs-string">&quot;Data/data/&quot;</span>,one_hot=<span class="hljs-literal">True</span>)<br><span class="hljs-keyword">import</span> pylab<br>tf.reset_default_graph()<br>x=tf.placeholder(tf.float32,[<span class="hljs-literal">None</span>,<span class="hljs-number">784</span>])<br>y=tf.placeholder(tf.float32,[<span class="hljs-literal">None</span>,<span class="hljs-number">10</span>])<br><span class="hljs-comment">#定义学习参数</span><br>W=tf.Variable(tf.random_normal([<span class="hljs-number">784</span>,<span class="hljs-number">10</span>])) <span class="hljs-comment">#W设为随机值</span><br>b=tf.Variable(tf.zeros([<span class="hljs-number">10</span>]))<span class="hljs-comment">#b设为0</span><br><span class="hljs-comment">#构建模型</span><br>pred=tf.nn.softmax(tf.matmul(x,W)+b)<span class="hljs-comment">#softmax分类</span><br><span class="hljs-comment">#定义反向传播结构，进行优化</span><br><span class="hljs-comment">#损失函数</span><br>cost=tf.reduce_mean(-tf.reduce_sum(y*tf.log(pred),reduction_indices=<span class="hljs-number">1</span>))<br><span class="hljs-comment">#定义参数</span><br>learning_rate=<span class="hljs-number">0.01</span><br><span class="hljs-comment">#使用梯度下降优化器</span><br>optimizer=tf.train.GradientDescentOptimizer(learning_rate).minimize(cost)<br><span class="hljs-comment">#开始训练模型</span><br><span class="hljs-comment">#定义训练迭代次数</span><br>training_epochs=<span class="hljs-number">25</span><br><span class="hljs-comment">#定义在训练过程中一次取100条数据进行训练</span><br>batch_size=<span class="hljs-number">100</span><br><span class="hljs-comment">#显示训练中间状态的间隔</span><br>display_step=<span class="hljs-number">1</span><br><br><span class="hljs-comment">#保存模型</span><br>saver=tf.train.Saver()<br>model_path=<span class="hljs-string">&quot;log/521model.ckpt&quot;</span><br><br><span class="hljs-comment">#启动session</span><br><span class="hljs-keyword">with</span> tf.Session(config=tf.ConfigProto(log_device_placement=<span class="hljs-literal">True</span>)) <span class="hljs-keyword">as</span> sess:<br>        sess.run(tf.global_variables_initializer())<br>        <span class="hljs-comment">#启动循环开始训练</span><br>        <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(training_epochs):<br>            avg_cost=<span class="hljs-number">0.0</span><br>            total_batch=<span class="hljs-built_in">int</span>(mnist.train.num_examples/batch_size)<br>            <span class="hljs-comment">#循环所有数据集</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(total_batch):<br>                batch_xs,batch_ys=mnist.train.next_batch(batch_size)<br>                <span class="hljs-comment">#运行优化器</span><br>                [opti,c]=sess.run([optimizer,cost],feed_dict=&#123;x:batch_xs,y:batch_ys&#125;)<br>                <span class="hljs-comment">#计算平均loss值</span><br>                avg_cost+=c/total_batch<br>                <span class="hljs-comment">#显示训练中的详细信息</span><br>            <span class="hljs-keyword">if</span> (epoch+<span class="hljs-number">1</span>)%display_step==<span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Epoch:&quot;</span>,<span class="hljs-string">&quot;%04d&quot;</span> % (epoch+<span class="hljs-number">1</span>),<span class="hljs-string">&quot;cost=&quot;</span>,<span class="hljs-string">&quot;&#123;:.9f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(avg_cost))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Finshed!&quot;</span>)<br>        <span class="hljs-comment">#保存模型</span><br>        save_path=saver.save(sess,model_path)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Model saved in file:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(save_path))<br><span class="hljs-keyword">if</span> tf.test.gpu_device_name():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Default GPU Device:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(tf.test.gpu_device_name()))<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Please install GPU version or TF&#x27;</span>)<br><br><span class="hljs-comment">#读取模型并将两张图片放进去让模型预测结果</span><br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Starting 2nd session...&quot;</span>)<br><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:<br>    <span class="hljs-comment">#初始化变量</span><br>    sess.run(tf.global_variables_initializer())<br>    <span class="hljs-comment">#恢复模型变量</span><br>    saver.restore(sess,model_path)<br>    <span class="hljs-comment">#测试 model</span><br>    correct_prediction=tf.equal(tf.arg_max(pred,<span class="hljs-number">1</span>),tf.arg_max(y,<span class="hljs-number">1</span>))<br>    <span class="hljs-comment">#计算准确率</span><br>    accuracy=tf.reduce_mean(tf.cast(correct_prediction,tf.float32))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy:&quot;</span>,accuracy.<span class="hljs-built_in">eval</span>(&#123;x:mnist.test.images,y:mnist.test.labels&#125;))<br>    output=tf.arg_max(pred,<span class="hljs-number">1</span>)<br>    output = tf.argmax(pred, <span class="hljs-number">1</span>)<br>    batch_xs, batch_ys = mnist.train.next_batch(<span class="hljs-number">2</span>)<br>    outputval,predv = sess.run([output,pred], feed_dict=&#123;x: batch_xs&#125;)<br>    <span class="hljs-built_in">print</span>(outputval,predv,batch_ys)<br>    im = batch_xs[<span class="hljs-number">0</span>]<br>    im = im.reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">28</span>)<br>    pylab.imshow(im)<br>    pylab.show()<br>    im = batch_xs[<span class="hljs-number">1</span>]<br>    im = im.reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">28</span>)<br>    pylab.imshow(im)<br>    pylab.show()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Extracting Data/data/train-images-idx3-ubyte.gzExtracting Data/data/train-labels-idx1-ubyte.gzExtracting Data/data/t10k-images-idx3-ubyte.gzExtracting Data/data/t10k-labels-idx1-ubyte.gzEpoch: 0001 cost= 8.901484704Epoch: 0002 cost= 4.491928911Epoch: 0003 cost= 3.105935341Epoch: 0004 cost= 2.460903181Epoch: 0005 cost= 2.088093793Epoch: 0006 cost= 1.843727299Epoch: 0007 cost= 1.670136872Epoch: 0008 cost= 1.539499564Epoch: 0009 cost= 1.437489002Epoch: 0010 cost= 1.355080850Epoch: 0011 cost= 1.287055298Epoch: 0012 cost= 1.229517875Epoch: 0013 cost= 1.180266858Epoch: 0014 cost= 1.137388955Epoch: 0015 cost= 1.099723647Epoch: 0016 cost= 1.066415745Epoch: 0017 cost= 1.036452132Epoch: 0018 cost= 1.009471819Epoch: 0019 cost= 0.985050059Epoch: 0020 cost= 0.962679997Epoch: 0021 cost= 0.942112822Epoch: 0022 cost= 0.923188624Epoch: 0023 cost= 0.905731321Epoch: 0024 cost= 0.889469135Epoch: 0025 cost= 0.874153477Finshed!Model saved in file:log/521model.ckptDefault GPU Device:/device:GPU:0Starting 2nd session...INFO:tensorflow:Restoring parameters from log/521model.ckptAccuracy: 0.8259[2 8] [[5.4470024e-06 1.0342207e-14 9.9999440e-01 8.0820775e-12 4.5177516e-12  3.1603236e-16 6.3706992e-08 3.8312063e-15 7.3337933e-11 3.1762011e-18] [2.8309601e-04 9.6081327e-05 1.4640624e-03 3.5183481e-10 1.6233769e-03  3.4435538e-03 1.4779908e-02 9.2782180e-08 9.7314465e-01 5.1651290e-03]] [[0. 0. 1. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 1. 0.]]</code></pre><p><img src="/2019/10/20/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-mnist%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%86%E5%88%AB/output_6_1.png" alt="png"></p><p><img src="/2019/10/20/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-mnist%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%86%E5%88%AB/output_6_2.png" alt="png"></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TensorFlow编程基础</title>
    <link href="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>TensorFlow编程相关基础知识，会逐渐补充，以备复习</p><span id="more"></span><h1 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h1><p>一个TensorFlow程序的执行过程一般分为3个阶段：</p><ul><li>创建计算图</li><li>运行一个会话，以完成计算图中定义的操作</li><li>输出数据集合和分析</li></ul><p>用placeholder函数定义一个数据或张量需要3个参数。第一个是数据类型。第二个是占位<br>符 的形状,本例中为一个一维张量,含有一个条目,第三个是变量名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> session:  <span class="hljs-comment">#创建一个对象包含计算图</span><br>    x = tf.placeholder(tf.float32, [<span class="hljs-number">1</span>], name=<span class="hljs-string">&quot;x&quot;</span>) <span class="hljs-comment">#利用占位符概念定义变量</span><br>    y = tf.placeholder(tf.float32, [<span class="hljs-number">1</span>], name=<span class="hljs-string">&quot;y&quot;</span>)<br>    z = tf.constant(<span class="hljs-number">2.0</span>)<br>    y = x * z<br>    x_in = [<span class="hljs-number">100</span>]<span class="hljs-comment">#该程序可以处理非常大、非常复杂的x值，所以可以创建x_in列表，并使其指向占位符x。</span><br>    y_output = session.run(y, &#123;x: x_in&#125;) <span class="hljs-comment">#只有执行session.run()时，程序才会开始处理已定义的图元素</span><br>    <span class="hljs-built_in">print</span>(y_output)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[200.]</code></pre><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><p>TensorFlow的数据模型由张量表示。忽略那些复杂的数学定义，可以说（ TensorFlow中的）<br>“张量”指的是一个多维数值阵列。<br>这种数据结构由3个参数描述——阶（ rank）、 形状（ shape） 和数据类型（ type）</p><h2 id="阶"><a href="#阶" class="headerlink" title="阶"></a>阶</h2><p>每个张量的维度单位用阶来描述。它定义了张量的维数，因此，也被称为一个张量的量级或<br>张量的n个维。零阶张量是一个标量，一阶张量是一个向量，二阶张量是一个矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#定义TensorFlow中的标量，向量，矩阵，立方阵</span><br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br>scalar=tf.constant(<span class="hljs-number">100</span>)<br>vector=tf.constant([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br>matrix=tf.constant([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br>cube_matrix=tf.constant([[[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>]],[[<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>],[<span class="hljs-number">6</span>]],[[<span class="hljs-number">7</span>],[<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>]]])<br><span class="hljs-built_in">print</span>(scalar.get_shape())<br><span class="hljs-built_in">print</span>(vector.get_shape())<br><span class="hljs-built_in">print</span>(matrix.get_shape())<br><span class="hljs-built_in">print</span>(cube_matrix.get_shape())<br></code></pre></td></tr></table></figure><pre><code class="hljs">()(5,)(2, 3)(3, 3, 1)</code></pre><h2 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h2><p>张量的形状指的是其行数和列数<br>使用get_shape()函数</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>TensorFlow中数据的传递需要通过其API与NumPy数组的交互来完成<br><br>tf.constant()  定义常量<br><br>tf.variable()  定义变量</p><h2 id="取回"><a href="#取回" class="headerlink" title="取回"></a>取回</h2><p>同时取回多个操作的输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br>constant_A=tf.constant([<span class="hljs-number">100.0</span>])<br>constant_B=tf.constant([<span class="hljs-number">300.0</span>])<br>constant_C=tf.constant([<span class="hljs-number">3.0</span>])<br>sum_=tf.add(constant_A,constant_B)<br>mul_=tf.multiply(constant_A,constant_C)<br><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:<br>    result=sess.run([sum_,mul_])<br>    <span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[array([400.], dtype=float32), array([300.], dtype=float32)]</code></pre><h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p>注入机制将张量插入图节点，它用一个张量值暂时替代操作的输出。注入机制只用于在调用<br>run函数时，通过feed_dict传递参数。最常见的用法是使用tf.placeholder()创建feed操作，<br>并继承其他特定操作作为注入操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a=<span class="hljs-number">3</span><br>b=<span class="hljs-number">2</span><br>x=tf.placeholder(tf.float32,shape=(a,b))<br>y=tf.add(x,x)<br>data=np.random.rand(a,b)<br>sess=tf.Session()<br><span class="hljs-built_in">print</span>(sess.run(y,feed_dict=&#123;x:data&#125;))<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[1.1956241  0.17609641] [1.9851147  1.7567049 ] [0.4986568  0.8624873 ]]</code></pre><h1 id="TensorBoard"><a href="#TensorBoard" class="headerlink" title="TensorBoard"></a>TensorBoard</h1><p>训练神经网络时，有时会需要监控网络的参数，一般是节点的输入和输出。这样即可在每次<br>训练迭代后检查误差函数是否最小化，从而了解你的模型是否正确学习。<br><br>TensorFlow提供了TensorBoard框架，用于分析和调试神经网络模型。<br><br>TensorBoard采用所谓的汇总来查看模型的参数；一旦TensorFlow代码执行，我们就可以调用TensorBoard的图形用户界面来查看汇总数据。<br><br>此外， TensorBoard还可以显示并学习TensorFlow的计算图。一个深度神经网络模型的计算图<br>往往会非常复杂<br><br>工作流程如下：</p><ul><li>编译你的计算图&#x2F;代码；</li><li>添加汇总op到你需要分析的节点上；</li><li>照常运行你的计算图；</li><li>同时附带运行汇总op；</li><li>代码运行完成后， 启动TensorBoard；</li><li>可视化汇总输出。</li></ul><p>实例：实现一个单输入神经元<br><br>损失函数采用结果与期望值的差的平方，越小越好<br><br>优化函数采用梯度下降法<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br>input_value=tf.constant(<span class="hljs-number">0.5</span>,name=<span class="hljs-string">&quot;input_value&quot;</span>)  <span class="hljs-comment">#输入值，不变</span><br>weight=tf.Variable(<span class="hljs-number">1.0</span>,name=<span class="hljs-string">&quot;weight&quot;</span>)  <span class="hljs-comment">#权值，会更新</span><br>expected_output=tf.constant(<span class="hljs-number">0.0</span>,name=<span class="hljs-string">&quot;expected_output&quot;</span>) <span class="hljs-comment">#期望输出</span><br>model=tf.multiply(input_value,weight,<span class="hljs-string">&quot;model&quot;</span>) <span class="hljs-comment">#操作，模型</span><br>loss_function=tf.<span class="hljs-built_in">pow</span>(expected_output-model,<span class="hljs-number">2</span>) <span class="hljs-comment">#损失函数</span><br>optimizer=tf.train.GradientDescentOptimizer(<span class="hljs-number">0.025</span>).minimize(loss_function) <span class="hljs-comment">#优化函数</span><br><br><span class="hljs-comment">#接下来 tensorboard</span><br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> [input_value,weight,expected_output,model,loss_function]:<br>    tf.summary.scalar(value.op.name,value)<br>summaries=tf.summary.merge_all()  <span class="hljs-comment">#为每个运行的结点添加分析，然后总结</span><br>sess=tf.Session()<br>log_path=<span class="hljs-string">&quot;../Tensorboardlog\og_simple_stats&quot;</span><br>summary_writer=tf.summary.FileWriter(log_path,sess.graph) <span class="hljs-comment">#声明路径</span><br>sess.run(tf.global_variables_initializer())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    summary_writer.add_summary(sess.run(summaries),i) <span class="hljs-comment">#写入信息</span><br>    sess.run(optimizer)<br><br></code></pre></td></tr></table></figure><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>实例1：从一组看似混乱的数据中找出y&#x3D;2x的规律</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>%matplotlib inline<br>train_X=np.linspace(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)<br>train_Y=<span class="hljs-number">2</span>*train_X+np.random.randn(<span class="hljs-number">100</span>)*<span class="hljs-number">0.3</span><br><span class="hljs-comment">#显示模拟数据点</span><br>plt.plot(train_X,train_Y,<span class="hljs-string">&#x27;ro&#x27;</span>,label=<span class="hljs-string">&#x27;Original data&#x27;</span>)<br>plt.legend()<br>plt.show()<br><br></code></pre></td></tr></table></figure><p><img src="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/output_2_0.png" alt="png"></p><p>接下来进行模型搭建，正向和反向<br><br>创建模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">X=tf.placeholder(<span class="hljs-string">&quot;float&quot;</span>)<br>Y=tf.placeholder(<span class="hljs-string">&quot;float&quot;</span>)<br><span class="hljs-comment">#模型参数</span><br>W=tf.Variable(tf.random_normal([<span class="hljs-number">1</span>]),name=<span class="hljs-string">&quot;weight&quot;</span>)<br><span class="hljs-comment">#tf.random_normal()函数用于从服从指定正态分布的数值中取出指定个数的值</span><br>b=tf.Variable(tf.zeros([<span class="hljs-number">1</span>]),name=<span class="hljs-string">&quot;bias&quot;</span>)<br><span class="hljs-comment">#前向结构</span><br>z=tf.multiply(X,W)+b  <span class="hljs-comment">#乘以权值加上偏差</span><br><span class="hljs-comment">#反向优化</span><br>cost=tf.reduce_mean(tf.square(Y-z))<br><span class="hljs-comment">#学习率一般小于1，小而精确且慢</span><br>learning_rate=<span class="hljs-number">0.01</span><br><span class="hljs-comment">#梯度下降</span><br>optimizer=tf.train.GradientDescentOptimizer(learning_rate).minimize(cost)<br></code></pre></td></tr></table></figure><p>接下来迭代训练模型，先进行全局初始化，然后设置训练迭代的次数，启动session开始运行任务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python">init=tf.global_variables_initializer()<br><span class="hljs-comment">#定义参数</span><br>training_epochs=<span class="hljs-number">20</span> <span class="hljs-comment">#迭代次数</span><br>display_step=<span class="hljs-number">2</span><br>saver=tf.train.Saver()<br>savedir=<span class="hljs-string">&quot;log/&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">moving_average</span>(<span class="hljs-params">a,w=<span class="hljs-number">10</span></span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a)&lt;w:<br>        <span class="hljs-keyword">return</span> a[:]<br>    <span class="hljs-keyword">return</span> [val <span class="hljs-keyword">if</span> idx&lt;w <span class="hljs-keyword">else</span> <span class="hljs-built_in">sum</span>(a[(idx-w):idx])/w <span class="hljs-keyword">for</span> idx,val <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a)]<br><span class="hljs-comment">#启动session</span><br><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:<br>    sess.run(init)<br>    plotdata=&#123;<span class="hljs-string">&quot;batchsize&quot;</span>:[],<span class="hljs-string">&quot;loss&quot;</span>:[]&#125;  <span class="hljs-comment">#存放批次值和损失值</span><br>    <span class="hljs-comment">#向模型输入数据</span><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(training_epochs):<br>        <span class="hljs-keyword">for</span> (x,y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(train_X,train_Y):<br>            sess.run(optimizer,feed_dict=&#123;X:x,Y:y&#125;)<br>            <br>        <span class="hljs-comment">#显示训练中的详细信息</span><br>        <span class="hljs-keyword">if</span> epoch % display_step==<span class="hljs-number">0</span>:<br>            loss=sess.run(cost,feed_dict=&#123;X:train_X,Y:train_Y&#125;)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Epoch:&quot;</span>,epoch+<span class="hljs-number">1</span>,<span class="hljs-string">&quot;cost=&quot;</span>,loss,<span class="hljs-string">&quot;W=&quot;</span>,sess.run(W),<span class="hljs-string">&quot;b=&quot;</span>,sess.run(b))<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (loss==<span class="hljs-string">&quot;NA&quot;</span>):<br>                plotdata[<span class="hljs-string">&quot;batchsize&quot;</span>].append(epoch)<br>                plotdata[<span class="hljs-string">&quot;loss&quot;</span>].append(loss)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Finished!&quot;</span>)<br>    saver.save(sess,savedir+<span class="hljs-string">&quot;linermodel.cpkt&quot;</span>) <span class="hljs-comment">#保存模型</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;cost=&quot;</span>,sess.run(cost,feed_dict=&#123;X:train_X,Y:train_Y&#125;),<span class="hljs-string">&quot;W=&quot;</span>,sess.run(W),<br>         <span class="hljs-string">&quot;b=&quot;</span>,sess.run(b))<br><br>    <span class="hljs-comment">#训练模型可视化，可视化生成的模型和训练中的状态值</span><br>    plt.plot(train_X,train_Y,<span class="hljs-string">&#x27;ro&#x27;</span>,label=<span class="hljs-string">&#x27;Original data&#x27;</span>)<br>    plt.plot(train_X,sess.run(W)*train_X+sess.run(b),label=<span class="hljs-string">&#x27;Fittedline&#x27;</span>)<br>    plt.legend()<br>    plt.show()<br><br>    plotdata[<span class="hljs-string">&#x27;avgloss&#x27;</span>]=moving_average(plotdata[<span class="hljs-string">&quot;loss&quot;</span>])<br>    plt.figure(<span class="hljs-number">1</span>)<br>    plt.subplot(<span class="hljs-number">211</span>)<br>    plt.plot(plotdata[<span class="hljs-string">&quot;batchsize&quot;</span>],plotdata[<span class="hljs-string">&quot;avgloss&quot;</span>],<span class="hljs-string">&#x27;b--&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;Minibatch number&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;Loss&#x27;</span>)<br>    plt.title(<span class="hljs-string">&#x27;Minibatch run vs. Training loss&#x27;</span>)<br>    plt.show()<br><br>    <span class="hljs-comment">#模型训练后，使用模型</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x=0.2,z=&quot;</span>,sess.run(z,feed_dict=&#123;X:<span class="hljs-number">0.2</span>&#125;))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Epoch: 1 cost= 0.70816207 W= [0.75885475] b= [0.35309508]Epoch: 3 cost= 0.12805094 W= [1.649097] b= [0.11414018]Epoch: 5 cost= 0.08086114 W= [1.8904546] b= [0.02324806]Epoch: 7 cost= 0.0777822 W= [1.9530506] b= [-0.00074375]Epoch: 9 cost= 0.07760694 W= [1.9692401] b= [-0.00695578]Epoch: 11 cost= 0.0776032 W= [1.9734255] b= [-0.00856198]Epoch: 13 cost= 0.077605 W= [1.9745078] b= [-0.00897733]Epoch: 15 cost= 0.07760566 W= [1.9747877] b= [-0.0090847]Epoch: 17 cost= 0.077605836 W= [1.9748603] b= [-0.00911253]Epoch: 19 cost= 0.07760589 W= [1.9748794] b= [-0.00911988]Finished!cost= 0.077605896 W= [1.9748821] b= [-0.00912086]</code></pre><p><img src="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/output_6_1.png" alt="png"></p><p><img src="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/output_6_2.png" alt="png"></p><pre><code class="hljs">x=0.2,z= [0.3858556]</code></pre><p>Tensorflow将中间结点及结点间的运算关系定义在图上，图是静态的，会话是动态的，只有启动会话后才会将数据流向图中<br><br>定义数据时可以通过占位符，也可以通过字典方式，也可以直接定义</p><p>记得在session创建后初始化所有变量，而变量定义在此之前</p><br><p>TensorFlow模型构建的概念<br><img src="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%A8%A1%E5%9E%8B%E6%9E%84%E5%BB%BA%E6%A6%82%E5%BF%B5.png"></p><p>两个重要的机制：注入机制，取回机制</p><p>注入机制：占位符<br>placeholder，feed-dict<br><br>示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">a=tf.placeholder(tf.int32)<br>b=tf.placeholder(tf.int32)<br>add=tf.add(a,b)<br>multiply=tf.multiply(a,b)<br>mysess=tf.Session()<br><span class="hljs-built_in">print</span>(mysess.run(add,feed_dict=&#123;a:<span class="hljs-number">1</span>,b:<span class="hljs-number">2</span>&#125;))<br><span class="hljs-built_in">print</span>(mysess.run(multiply,feed_dict=&#123;a:<span class="hljs-number">1</span>,b:<span class="hljs-number">2</span>&#125;))<br><span class="hljs-comment">#一次取出多个结点</span><br><span class="hljs-built_in">print</span>(mysess.run([add,multiply],feed_dict=&#123;a:<span class="hljs-number">1</span>,b:<span class="hljs-number">2</span>&#125;))<br>mysess.close()<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">32[3, 2]</code></pre><p>建立session可以直接<br><br>也可以with tf.Session() as sess<br><br>然后还有方法是交换式session方式：<br><br>sess&#x3D;tf.InteractiveSession()<br><br>另一种是Supervisor方式：该方式会更高级一些， 使用起来也更加复<br>杂， 可以自动来管理session中的具体任务， 例如， 载入&#x2F;载出检查点文件、 写入TensorBoard等， 另外该方法还支持分布式训练的部署</p><br><p>保存和载入模型</p><p>保存模型<br><br>训练完模型后: tf.train.Saver().save(sess,”save_path&#x2F;file_name”)</p><p>载入模型<br><br>调用saver的restore函数</p><p>保存载入模型实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#保存模型见上文代码 中saver</span><br><span class="hljs-comment">#载入模型</span><br><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess2:<br>    sess2.run(tf.global_variables_initializer())<br>    saver.restore(sess2,savedir+<span class="hljs-string">&quot;linermodel.cpkt&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x=0.2,z=&quot;</span>,sess2.run(z,feed_dict=&#123;X:<span class="hljs-number">0.2</span>&#125;))<br></code></pre></td></tr></table></figure><pre><code class="hljs">WARNING:tensorflow:From E:\Python\Anaconda\lib\site-packages\tensorflow\python\training\saver.py:1276: checkpoint_exists (from tensorflow.python.training.checkpoint_management) is deprecated and will be removed in a future version.Instructions for updating:Use standard file APIs to check for files with this prefix.INFO:tensorflow:Restoring parameters from log/linermodel.cpktx=0.2,z= [0.3858556]</code></pre><p>打印模型内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tensorflow.python.tools.inspect_checkpoint <span class="hljs-keyword">import</span> print_tensors_in_checkpoint_file<br>savedir=<span class="hljs-string">&quot;log/&quot;</span><br>print_tensors_in_checkpoint_file(savedir+<span class="hljs-string">&quot;linermodel.cpkt&quot;</span>,<span class="hljs-literal">None</span>,<span class="hljs-literal">True</span>)<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">tensor_name:  bias[-0.00912086]tensor_name:  weight[1.9748821]# Total number of params: 2</code></pre><br><br><p>为模型添加保存检查点，继续修改原代码</p><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-comment">#定义生成loss可视化的函数</span><br>plotdata=&#123;<span class="hljs-string">&quot;batchsize&quot;</span>:[],<span class="hljs-string">&quot;loss&quot;</span>:[]&#125;<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">moving_average</span>(<span class="hljs-params">a,w=<span class="hljs-number">10</span></span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a)&lt;w:<br>        <span class="hljs-keyword">return</span> a[:]<br>    <span class="hljs-keyword">return</span> [val <span class="hljs-keyword">if</span> idx&lt;w <span class="hljs-keyword">else</span> <span class="hljs-built_in">sum</span>(a[(idx-w):idx])/w <span class="hljs-keyword">for</span> idx,val <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a)]<br><span class="hljs-comment">#生成模拟数据</span><br>train_X=np.linspace(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)<br>train_Y=<span class="hljs-number">2</span>*train_X+np.random.randn(<span class="hljs-number">100</span>)*<span class="hljs-number">0.3</span> <br><br>tf.reset_default_graph()<br><span class="hljs-comment">#创建模型</span><br><span class="hljs-comment">#占位符</span><br>X=tf.placeholder(<span class="hljs-string">&quot;float&quot;</span>)<br>Y=tf.placeholder(<span class="hljs-string">&quot;float&quot;</span>)<br><span class="hljs-comment">#模型参数</span><br>W=tf.Variable(tf.random_normal([<span class="hljs-number">1</span>]),name=<span class="hljs-string">&quot;weight&quot;</span>)<br>b=tf.Variable(tf.zeros([<span class="hljs-number">1</span>]),name=<span class="hljs-string">&quot;bias&quot;</span>)<br><span class="hljs-comment">#前向结构</span><br>z=tf.multiply(X,W)+b<br><br><span class="hljs-comment">#反向优化</span><br>cost=tf.reduce_mean(tf.square(Y-z))<br>learning_rate=<span class="hljs-number">0.01</span><br>optimizer=tf.train.GradientDescentOptimizer(learning_rate).minimize(cost)<br><span class="hljs-comment">#初始化所有变量</span><br>init=tf.global_variables_initializer()<br><span class="hljs-comment">#定义学习参数</span><br>training_epochs=<span class="hljs-number">20</span><br>display_step=<span class="hljs-number">2</span><br><span class="hljs-comment">#生成saver</span><br>saver=tf.train.Saver(max_to_keep=<span class="hljs-number">1</span>)<br>savedir=<span class="hljs-string">&quot;log/&quot;</span><br><span class="hljs-comment">#启动图</span><br><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:<br>    sess.run(init)<br>    <span class="hljs-comment">#向模型中输入数据</span><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(training_epochs):<br>        <span class="hljs-keyword">for</span> (x,y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(train_X,train_Y):<br>            sess.run(optimizer,feed_dict=&#123;X:x,Y:y&#125;)<br>        <span class="hljs-comment">#显示训练中的详细信息</span><br>        <span class="hljs-keyword">if</span> epoch % display_step==<span class="hljs-number">0</span>:<br>            loss=sess.run(cost,feed_dict=&#123;X:train_X,Y:train_Y&#125;)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Epoch:&quot;</span>,epoch+<span class="hljs-number">1</span>,<span class="hljs-string">&quot;cost=&quot;</span>,loss,<span class="hljs-string">&quot;W=&quot;</span>,sess.run(W),<span class="hljs-string">&quot;b=&quot;</span>,sess.run(b))<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (loss==<span class="hljs-string">&quot;NA&quot;</span>):<br>                plotdata[<span class="hljs-string">&quot;batchsize&quot;</span>].append(epoch)<br>                plotdata[<span class="hljs-string">&quot;loss&quot;</span>].append(loss)<br>            saver.save(sess,savedir+<span class="hljs-string">&quot;linermodel.cpkt&quot;</span>,global_step=epoch) <span class="hljs-comment">#保存模型</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Finished!&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;cost=&quot;</span>,sess.run(cost,feed_dict=&#123;X:train_X,Y:train_Y&#125;),<span class="hljs-string">&quot;W=&quot;</span>,sess.run(W),<br>         <span class="hljs-string">&quot;b=&quot;</span>,sess.run(b))<br><br>    <span class="hljs-comment">#训练模型可视化，可视化生成的模型和训练中的状态值</span><br>    plt.plot(train_X,train_Y,<span class="hljs-string">&#x27;ro&#x27;</span>,label=<span class="hljs-string">&#x27;Original data&#x27;</span>)<br>    plt.plot(train_X,sess.run(W)*train_X+sess.run(b),label=<span class="hljs-string">&#x27;Fittedline&#x27;</span>)<br>    plt.legend()<br>    plt.show()<br><br>    plotdata[<span class="hljs-string">&#x27;avgloss&#x27;</span>]=moving_average(plotdata[<span class="hljs-string">&quot;loss&quot;</span>])<br>    plt.figure(<span class="hljs-number">1</span>)<br>    plt.subplot(<span class="hljs-number">211</span>)<br>    plt.plot(plotdata[<span class="hljs-string">&quot;batchsize&quot;</span>],plotdata[<span class="hljs-string">&quot;avgloss&quot;</span>],<span class="hljs-string">&#x27;b--&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;Minibatch number&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;Loss&#x27;</span>)<br>    plt.title(<span class="hljs-string">&#x27;Minibatch run vs. Training loss&#x27;</span>)<br>    plt.show()<br><span class="hljs-comment">#重启session，载入检查点</span><br>load_epoch=<span class="hljs-number">18</span><br><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess2:<br>    sess2.run(tf.global_variables_initializer())<br>    saver.restore(sess2,savedir+<span class="hljs-string">&quot;linermodel.cpkt-&quot;</span>+<span class="hljs-built_in">str</span>(load_epoch))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x=0.2,z=&quot;</span>,sess2.run(z,feed_dict=&#123;X:<span class="hljs-number">0.2</span>&#125;))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Epoch: 1 cost= 1.4514498 W= [0.24221869] b= [0.5121559]Epoch: 3 cost= 0.18433338 W= [1.5415516] b= [0.16298366]Epoch: 5 cost= 0.07567732 W= [1.8937755] b= [0.03033424]Epoch: 7 cost= 0.067009285 W= [1.9851238] b= [-0.00467777]Epoch: 9 cost= 0.066090204 W= [2.0087478] b= [-0.01374275]Epoch: 11 cost= 0.06594107 W= [2.014856] b= [-0.0160868]Epoch: 13 cost= 0.06590843 W= [2.0164354] b= [-0.0166929]Epoch: 15 cost= 0.06590037 W= [2.016844] b= [-0.0168497]Epoch: 17 cost= 0.065898314 W= [2.0169504] b= [-0.01689044]Epoch: 19 cost= 0.0658978 W= [2.0169766] b= [-0.0169006]Finished!cost= 0.06589771 W= [2.0169811] b= [-0.01690225]</code></pre><p><img src="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/output_26_1.png" alt="png"></p><p><img src="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/output_26_2.png" alt="png"></p><br><br>模型操作相关函数<h1 id="常用函数总结（见pdf书籍）"><a href="#常用函数总结（见pdf书籍）" class="headerlink" title="常用函数总结（见pdf书籍）"></a>常用函数总结（见pdf书籍）</h1><h2 id="保存模型"><a href="#保存模型" class="headerlink" title="保存模型"></a>保存模型</h2><p><img src="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/hanshu1.png"></p><h2 id="数值操作相关函数"><a href="#数值操作相关函数" class="headerlink" title="数值操作相关函数"></a>数值操作相关函数</h2><p><img src="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/hanshu2.png"></p><p><img src="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/hanshu3.png"></p><h2 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h2><p><img src="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E5%8F%98%E6%8D%A2.png"></p><h2 id="形状变换函数"><a href="#形状变换函数" class="headerlink" title="形状变换函数"></a>形状变换函数</h2><ul><li>tf.shape(input,name&#x3D;None)<br>返回一个张量，值为输入参数input的shape，input可以是个张量，也可以是一个数组或list</li><li>tf.size(input,name&#x3D;None)<br>返回一个张量，内容为输入数据的元素数量</li><li>tf.rank(input,name&#x3D;None)<br>返回一个张量，其内容为输入数据input的rank，此处的rank看的是中括号的层数</li><li>tf.reshape(input,shape,name&#x3D;None)<br>将原有数据的shape按照指定形状进行变换，生成一个新的张量</li><li>tf.expand_dims(input,dim,name&#x3D;None)<br>插入维度1进入一个tensor中</li><li>tf.squeeze(input,dim,name&#x3D;None)<br>将dim指定的维度去掉(dim所指定的维度必须为1，如果不为1则会报错)</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编程实现KNN和朴素贝叶斯算法分类</title>
    <link href="/2019/10/19/%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0KNN%E5%92%8C%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/"/>
    <url>/2019/10/19/%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0KNN%E5%92%8C%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>大数据上机作业，编程实现K近邻和朴素贝叶斯算法</p><span id="more"></span><p>1、编程实现KNN算法对下表中两个未知类型的样本进行分类（冰川水或者湖泊水），其中K&#x3D;3，即选择最近的3个邻居。<br><img src="/2019/10/19/%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0KNN%E5%92%8C%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/KNN.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> math<br>a=np.array([[<span class="hljs-number">0.2</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">0.1</span>],[<span class="hljs-number">0.4</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.4</span>,<span class="hljs-number">0.3</span>],[<span class="hljs-number">0.3</span>,<span class="hljs-number">0.4</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">0.3</span>],[<span class="hljs-number">0.2</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.1</span>],[<span class="hljs-number">0.5</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0.3</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.4</span>,<span class="hljs-number">0.4</span>]])<br><span class="hljs-built_in">print</span>(a)<br>label=[<span class="hljs-string">&quot;冰川水&quot;</span>,<span class="hljs-string">&quot;湖泊水&quot;</span>,<span class="hljs-string">&quot;冰川水&quot;</span>,<span class="hljs-string">&quot;冰川水&quot;</span>,<span class="hljs-string">&quot;湖泊水&quot;</span>,<span class="hljs-string">&quot;湖泊水&quot;</span>]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">distance</span>(<span class="hljs-params">x,y</span>):<br>    <span class="hljs-built_in">sum</span>=<span class="hljs-number">0.0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x)):<br>        <span class="hljs-built_in">sum</span>+=math.<span class="hljs-built_in">pow</span>((x[i]-y[i]),<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> math.sqrt(<span class="hljs-built_in">sum</span>)<br><br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">classify</span>(<span class="hljs-params"><span class="hljs-built_in">input</span>,group,label,k</span>):<br>    mark=&#123;&#125;<br>    flag=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> group:<br>        tmpsum=distance(<span class="hljs-built_in">input</span>,i)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;计算两者之间距离为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(tmpsum))<br>        mark[flag]=tmpsum<br>        flag=flag+<span class="hljs-number">1</span><br>    sorted_mark = <span class="hljs-built_in">sorted</span>(mark.items(),key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])  <br>    after_mark=<span class="hljs-built_in">dict</span>(sorted_mark[:k])<br>    tmp=[]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> after_mark.keys():<br>        tmp.append(label[i])<br>    <span class="hljs-comment"># 直接统计</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(tmp, key=tmp.count))<br><br>    <br>Garr=np.array([<span class="hljs-number">0.3</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.2</span>])<br>Harr=np.array([<span class="hljs-number">0.1</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.2</span>])<br>classify(Garr,a,label,<span class="hljs-number">3</span>)<br>classify(Harr,a,label,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">计算两者之间距离为0.31622776601683794计算两者之间距离为0.17320508075688776计算两者之间距离为0.33166247903553997计算两者之间距离为0.34641016151377546计算两者之间距离为0.4计算两者之间距离为0.22360679774997902湖泊水计算两者之间距离为0.17320508075688776计算两者之间距离为0.42426406871192857计算两者之间距离为0.4690415759823429计算两者之间距离为0.17320508075688773计算两者之间距离为0.45825756949558405计算两者之间距离为0.4冰川水</code></pre><p><img src="/2019/10/19/%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0KNN%E5%92%8C%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF.png"></p><p>实现朴素贝叶斯算法预测是否适合户外活动</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data</span>(<span class="hljs-params">filename</span>):<br>    lines = csv.reader(<span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&quot;rt&quot;</span>))<br>    dataset = <span class="hljs-built_in">list</span>(lines)<br>    data=[]<br>   <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dataset:<br>        tmp=[]<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> i:<br>            j=j[:-<span class="hljs-number">1</span>]<br>            tmp.append(<span class="hljs-built_in">str</span>(j))<br>        data.append(tmp)<br>    <span class="hljs-keyword">return</span> data<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getSumOfC</span>(<span class="hljs-params">C,data</span>):<br>    c=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data:<br>        <span class="hljs-keyword">if</span>(i[<span class="hljs-built_in">len</span>(i)-<span class="hljs-number">1</span>]==C):<br>            c=c+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> c<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getPossibilityofCwhenData</span>(<span class="hljs-params">C,data</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;标签&#123;&#125;的概率为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(C,getSumOfC(C,data)/<span class="hljs-built_in">len</span>(data)))<br>    <span class="hljs-keyword">return</span> getSumOfC(C,data)/<span class="hljs-built_in">len</span>(data)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getPossibilityofXwhenC_Single</span>(<span class="hljs-params">X,C,data</span>):<br>    sum_X=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data:<br>        <span class="hljs-keyword">if</span> i[<span class="hljs-built_in">len</span>(i)-<span class="hljs-number">1</span>]==C:<br>            <span class="hljs-keyword">if</span> X <span class="hljs-keyword">in</span> i:<br>                sum_X=sum_X+<span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(sum_X)<br>    <br>    <span class="hljs-keyword">return</span> sum_X/getSumOfC(C,data)<br>                   <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getPossibilityofXwhenC_Summary</span>(<span class="hljs-params"><span class="hljs-built_in">input</span>,C,data</span>):<br>    sum_possibility=<span class="hljs-number">1.0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;传入的要检查的x值为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i))<br>        res=getPossibilityofXwhenC_Single(i,C,data)<br>        <span class="hljs-keyword">if</span> res!=<span class="hljs-number">0</span>:<br>            sum_possibility=sum_possibility*res<br>    <span class="hljs-keyword">return</span> sum_possibility<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getPossibility</span>(<span class="hljs-params"><span class="hljs-built_in">input</span>,C,data</span>):<br>    <span class="hljs-comment">#先获取标签总的概率</span><br>    a=getPossibilityofCwhenData(C,data)<br>    <span class="hljs-comment">#然后获取对应元素概率</span><br>    b=getPossibilityofXwhenC_Summary(<span class="hljs-built_in">input</span>,C,data)<br>    <span class="hljs-comment">#相乘获取结果概率</span><br>    result=a*b<br>    <span class="hljs-built_in">print</span>(result)<br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    filename=<span class="hljs-string">&quot;G:/学习/课程相关/大三/大数据挖掘/上机/3/thisdata.csv&quot;</span><br>    data=load_data(filename)<br>    <span class="hljs-built_in">input</span>=[<span class="hljs-string">&#x27;下雨&#x27;</span>,<span class="hljs-string">&#x27;低&#x27;</span>,<span class="hljs-string">&#x27;大&#x27;</span>,<span class="hljs-string">&#x27;微风&#x27;</span>]<br>    C1=getPossibility(<span class="hljs-built_in">input</span>,<span class="hljs-string">&#x27;适合&#x27;</span>,data)<br>    C2=getPossibility(<span class="hljs-built_in">input</span>,<span class="hljs-string">&#x27;不适合&#x27;</span>,data)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;概率为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;适合&quot;</span>,C1))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;概率为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;不适合&quot;</span>,C2))<br>    <span class="hljs-keyword">if</span> C1&lt;C2:<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最终答案为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;不适合&quot;</span>))<br>    <span class="hljs-keyword">else</span>:<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最终答案为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;适合&quot;</span>)) <br>               <br>main()<br></code></pre></td></tr></table></figure><pre><code class="hljs">标签适合的概率为0.6传入的要检查的x值为下雨3传入的要检查的x值为低3传入的要检查的x值为大2传入的要检查的x值为微风50.041666666666666664标签不适合的概率为0.4传入的要检查的x值为下雨1传入的要检查的x值为低1传入的要检查的x值为大3传入的要检查的x值为微风20.009375000000000001适合概率为0.041666666666666664不适合概率为0.009375000000000001最终答案为适合</code></pre>]]></content>
    
    
    <categories>
      
      <category>大数据挖掘及应用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编程实现Apriori算法</title>
    <link href="/2019/10/19/%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0Apriori%E7%AE%97%E6%B3%95/"/>
    <url>/2019/10/19/%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0Apriori%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>大数据课程上机应用，作业，记录以备复习</p><span id="more"></span><p>编程应用Apriori算法输出教材P159 表4-16的所有频繁项集（设最小支持度计数为2）<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> copy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">init_pass</span>(<span class="hljs-params">T</span>):   <span class="hljs-comment">#统计所有元素各自出现的总次数</span><br>    C = &#123;&#125;  <span class="hljs-comment">#C为字典</span><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> T: <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> t:<br>            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> C.keys():<br>                C[i] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                C[i] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> C  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">F</span>):<span class="hljs-comment">#生成新的集合，好进行下一轮遍历，筛选，F是之前筛选出来的所有满足支持度的集合</span><br>    C = []<br>    <span class="hljs-comment">#print(&quot;F=&#123;&#125;&quot;.format(F))</span><br>    k = <span class="hljs-built_in">len</span>(F[<span class="hljs-number">0</span>]) + <span class="hljs-number">1</span> <span class="hljs-comment">#k此时代表这次要选的集合中每个集合由几个元素组成</span><br>    <span class="hljs-keyword">for</span> f1 <span class="hljs-keyword">in</span> F:<br>        <span class="hljs-keyword">for</span> f2 <span class="hljs-keyword">in</span> F:<br>            <span class="hljs-comment">#print(&quot;f1[k-2]=&#123;0&#125;,f2[k-2]=&#123;1&#125;&quot;.format(f1[k-2],f2[k-2]))</span><br>            <span class="hljs-keyword">if</span> f1[k-<span class="hljs-number">2</span>] &lt; f2[k-<span class="hljs-number">2</span>]: <span class="hljs-comment">#使用k-2的原因之前k+1，然后数组下标从0开始，所有k-2刚好，就比如第一次生成时正好从下标0，也就是第一个元素开始</span><br>                c = copy.copy(f1)<br>                c.append(f2[k-<span class="hljs-number">2</span>])<br>                <span class="hljs-comment">#print(&quot;c=&#123;&#125;&quot;.format(c))</span><br>                <span class="hljs-keyword">if</span> c <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> C:<br>                    C.append(c)<br>    <span class="hljs-keyword">return</span> C <span class="hljs-comment">#最返回</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compareList</span>(<span class="hljs-params">A,B</span>): <span class="hljs-comment">#比较两个列表是否相等</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(A) &lt;= <span class="hljs-built_in">len</span>(B):<br>        <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> A:<br>            <span class="hljs-keyword">if</span> a <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> B:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> B:<br>            <span class="hljs-keyword">if</span> b <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> A:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">apriori</span>(<span class="hljs-params">T,minSupport</span>):<br>    D=[]<span class="hljs-comment">#暂存生成的所有索引，供之后筛选，存入F[k]中</span><br>    C=init_pass(T)  <span class="hljs-comment">#先分析一项集</span><br>    keys=<span class="hljs-built_in">list</span>(C.keys());<span class="hljs-comment">#.keys()方法，求出字典中的索引</span><br>    keys.sort() <br>    D.append(keys)<span class="hljs-comment">#加入D集中</span><br>    F=[[]] <span class="hljs-comment">#二维列表  F[0]存的是所有满足条件的一项集</span><br>    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> D[<span class="hljs-number">0</span>]:<br>        <span class="hljs-keyword">if</span> C[f]&gt;=minSupport:<br>            F[<span class="hljs-number">0</span>].append([f])  <span class="hljs-comment">#筛选出所有满足最小支持度的一项集</span><br>    k=<span class="hljs-number">1</span> <span class="hljs-comment">#k代表的是几项集 第几次遍历</span><br><br>    <span class="hljs-keyword">while</span> F[k-<span class="hljs-number">1</span>]!=[]:  <span class="hljs-comment">#k-1是因为下标从0开始</span><br>        D.append(generate(F[k-<span class="hljs-number">1</span>]))<br>        F.append([])<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> D[k]:<br>            count = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> T:<br>                <span class="hljs-keyword">if</span> compareList(c,t):<br>                    count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> count&gt;= minSupport:<br>                F[k].append(c)<br>        k += <span class="hljs-number">1</span><br><br>    U = []<br>    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> F:<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> f:<br>            U.append(x)<br>    <span class="hljs-keyword">return</span> U<br><br><br>T = [[<span class="hljs-string">&#x27;面包&#x27;</span>,<span class="hljs-string">&#x27;甜酱&#x27;</span>,<span class="hljs-string">&#x27;芝麻酱&#x27;</span>],[<span class="hljs-string">&#x27;面包&#x27;</span>,<span class="hljs-string">&#x27;芝麻酱&#x27;</span>],[<span class="hljs-string">&#x27;面包&#x27;</span>,<span class="hljs-string">&#x27;芝麻酱&#x27;</span>,<span class="hljs-string">&#x27;牛奶&#x27;</span>],[<span class="hljs-string">&#x27;面包&#x27;</span>,<span class="hljs-string">&#x27;啤酒&#x27;</span>],[<span class="hljs-string">&#x27;牛奶&#x27;</span>,<span class="hljs-string">&#x27;啤酒&#x27;</span>]]<br><br>Z= apriori(T,<span class="hljs-number">2</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> Z:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">set</span>(i))<br></code></pre></td></tr></table></figure><pre><code class="hljs">&#123;&#39;啤酒&#39;&#125;&#123;&#39;牛奶&#39;&#125;&#123;&#39;芝麻酱&#39;&#125;&#123;&#39;面包&#39;&#125;&#123;&#39;面包&#39;, &#39;芝麻酱&#39;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大数据挖掘及应用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IDEA搭建web项目相关问题</title>
    <link href="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>本次主要是为了跑书上的代码，了解struts2框架的基本使用，因此代码都是直接复制粘贴，主要讨论的是配置问题</p><span id="more"></span><p>使用maven创建项目，好处是可以由maven下载相关包，无需自己导入下载<br></p><ol><li><p>首先创建项目：选择maven-勾选Create from archetype-选择底下的webapp-然后点击next<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE.png"></p></li><li><p>接着项目命名随意,点击next<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE2.png"> </p></li><li><p>然后注意修改setting.xml文件<br>笔者这里是自己的setting.xml文件<br>修改方法参见这里：<br><br>修改maven镜像：<br><a href="https://jiangyuesong.me/2016/11/07/maven-intellij-change-mirrors/">https://jiangyuesong.me/2016/11/07/maven-intellij-change-mirrors/</a><br><br>原因是之前提到了 maven会自己下载所需包，但是有些包下载过慢，因此需要换用国内镜像<br><br>至于local repository所选位置可自定义，或默认并无影响<br><br>最后点击next-finish即完成创建<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE3.png"></p></li><li><p>创建完后，显示如下：<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/kaishi1.png"><br>选择ok<br>然后会有提示出来，在右下角<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E5%BC%80%E5%A7%8B2.png"><br>选择enable auto import，这就是maven在帮我们自动配置<br><br>如果之前没有修改镜像的话，这一步会特别慢，因此要注意<br></p></li><li><p>auto import后文件目录显示如下<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E7%9B%AE%E5%BD%95.png"></p></li></ol><p>在此对文件夹进行相应说明：<br>(<a href="https://www.jianshu.com/p/bbc0640276cf">原文链接</a>)</p><ul><li>.idea：是IDEA自动生成 ，.idea文件夹来存放项目的配置信息。其中包括版本控制信息、历史记录等等。如果你不小心删除它，下次它还会自动生成。</li><li>src：项目的资源总目录，基本所有的操作都在这个文件夹里面进行。</li><li>main：和src基本作用差不多</li><li>webapp：这是前端部分，可以在这个目录下创建css、js等文件夹用于存放前端的一些静态文件。以及创建JSP等网页文件。</li><li>WEB-INF：WEB-INF是Java的WEB应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。</li><li>web.xml：web.xml的作用很大，是用来沟通后端的桥梁，这里可以配置一些信息，比如哪些是网站入口（index.jsp）,声明404网页等等，以及声明哪些是后端的配置文件。整个web项目就是这样像纽带一样构建起来的。</li><li>pom.xml：pom.xml主要描述了项目的maven坐标，包依赖关系。我们不需要在手动下载一些jar包，然后手动依赖。只要遵循它规则，他会自动帮我们下载依赖，是不是很方便！！！</li></ul><ol start="6"><li><p>修改pom.xml,web.xml<br>打开pom.xml文件，找到dependencies标签<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/pom.png"><br>在标签添加依赖，添加方法很简单，你的项目用到了什么jar包你就去这个网站上进行搜索：<br><a href="https://mvnrepository.com/">https://mvnrepository.com</a><br><br>进行搜索：<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E6%90%9C%E7%B4%A21.png"><br>选择相应包:<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E6%90%9C%E7%B4%A22.png"><br>复制框中代码：<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E6%90%9C%E7%B4%A23.png"><br>粘贴到dependencies标签下：<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96.png"><br>之后要等一会自动配置完后<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E5%AE%8C.png"><br>由于本次创建是为了跑项目，项目中用到了struts2框架，因此我们才用了struts2相关包，自己应该根据实际需求自己判断添加哪些dependency<br></p></li><li><p>创建文件夹<br>在WEB-INF下创建classes文件夹用来存放编译后输出的classes文件<br><br>在main下新建java用来存放java代码,并将这个java文件夹标记为Sources Root<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E6%A0%87%E8%AE%B0java.png"><br>关于idea不同文件夹标记及含义问题如下：</p></li></ol><ul><li>Source roots (or source folders)<br>通过将文件夹加入这种类别，来告诉IntelliJ IDEA，这个文件夹和它的子文件夹中包含源码，在构建工程时，需要作为一部分被编译进去。</li><li>Test source roots (or test source folders; shown as rootTest)<br>这个类型的文件夹也用于存放源码，不过是测试的源码（比如单元测试）。test source 文件夹可以帮助你将测试代码和产品代码分离开。</li><li>Resource roots<br>该类文件夹用于存放你的应用中需要用到的资源文件（如：图片、xml或者properties配置文件等）。<br>在构建过程中，resources文件夹中的内容均会按照原文件的样子被复制到输出文件夹。和sources文件夹一样，你可以定制你的resources文件夹的结构。你也可以指定你的resources文件夹中的文件被拷贝到输出文件的哪个文件夹中。</li></ul><p>ps：<br></p><ul><li>默认情况下，工程编译后，resources中的文件和文件夹会被放置在和源码编译后相同的文件夹中，所以如果在源码中以相对路径读取resources中的配置文件时，可认为src中的java文件夹和resources为同一个根目录。</li><li>Test resource roots<br>只有在java模式中可以使用）用于存放测试源码中关联的资源文件。除此之外，和resource文件夹没有区别。</li></ul><ol start="8"><li>之后在java文件中创建新的class文件，右击——New-Java Class<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E5%88%9B%E5%BB%BAjava%E4%BB%A3%E7%A0%81.png"> 如果没有java Class选项，那就是上一步没做对<br>根据要运行的项目，我创建了两个java文件<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/java%E6%96%87%E4%BB%B6.png"><br>代码如下：<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> com.opensymphony.xwork2.Action;<br><span class="hljs-keyword">import</span> com.opensymphony.xwork2.ActionInvocation;<br><span class="hljs-keyword">import</span> com.opensymphony.xwork2.interceptor.AbstractInterceptor;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">intercept</span><span class="hljs-params">(ActionInvocation arg0)</span> throws Exception</span>&#123;<br>        <span class="hljs-comment">//得到StrutsAction类对象</span><br>        StrutsAction action=(StrutsAction)arg0.<span class="hljs-built_in">getAction</span>();<br>        <span class="hljs-comment">//如果Action类中的name属性的值为&quot;hello&quot;，返回错误页面</span><br>        <span class="hljs-keyword">if</span>(action.<span class="hljs-built_in">getName</span>().<span class="hljs-built_in">equals</span>(<span class="hljs-string">&quot;hello&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> Action.ERROR;<br>        &#125;<br>        <span class="hljs-comment">//继续执行其他拦截器或Action类中的方法</span><br>        <span class="hljs-keyword">return</span> arg0.<span class="hljs-built_in">invoke</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Map</span>;<br><span class="hljs-keyword">import</span> com.<span class="hljs-property">opensymphony</span>.<span class="hljs-property">xwork2</span>.<span class="hljs-property">ActionContext</span>;<br><span class="hljs-keyword">import</span> com.<span class="hljs-property">opensymphony</span>.<span class="hljs-property">xwork2</span>.<span class="hljs-property">ActionSupport</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrutsAction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ActionSupport</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">execute</span>() throws <span class="hljs-title class_">Exception</span>&#123;<br>        <span class="hljs-keyword">if</span>(!name.<span class="hljs-title function_">equals</span>(<span class="hljs-string">&quot;HelloWorld&quot;</span>))&#123;<br>            <span class="hljs-title class_">Map</span> request=(<span class="hljs-title class_">Map</span>)<span class="hljs-title class_">ActionContext</span>.<span class="hljs-title function_">getContext</span>().<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;request&quot;</span>);<br>            request.<span class="hljs-title function_">put</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-title function_">getName</span>());<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">validate</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">//如果姓名为空，则把错误信息添加到Action类的fieldErrors</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getName</span>()==<span class="hljs-literal">null</span>||<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getName</span>().<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>            <span class="hljs-title function_">addFieldError</span>(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;姓名是必须的！&quot;</span>);           <span class="hljs-comment">//把错误信息保存起来</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="9"><li>配置web.xml<br>修改文本.xml内容如下：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;3.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>struts2<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.FilterDispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>struts2<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file-list</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>struts2_1<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>struts2_1<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.action<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="10"><li><p>在创建的classes文件夹下新建struts.xml<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E5%88%9B%E5%BB%BAstrutsxml.png"><br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E5%88%9B%E5%BB%BAstrutsxml2.png"><br>修改其中内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">struts</span> <span class="hljs-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">struts</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;default&quot;</span> <span class="hljs-attr">extends</span>=<span class="hljs-string">&quot;struts-default&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">interceptors</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">interceptor</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myInterceptor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;MyInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">interceptors</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">default-interceptor-ref</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">default-interceptor-ref</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;struts&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;StrutsAction&quot;</span> &gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;success&quot;</span>&gt;</span>/welcome.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span>/hello.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;input&quot;</span>&gt;</span>/hello.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">interceptor-ref</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultStack&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">interceptor-ref</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">interceptor-ref</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">interceptor-ref</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">action</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">struts</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在index.jsp的位置添加并修改文件<br>最后共有三个jsp文件 index.jsp,hello.jsp,welcome.jsp<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E6%B7%BB%E5%8A%A0jsp.png"><br>index.jsp不变<br><br>hello.jsp代码如下：</p><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs vbscript-html"><span class="language-vbscript">&lt;%@ page language=<span class="hljs-string">&quot;java&quot;</span> import=<span class="hljs-string">&quot;java.util.*&quot;</span> pageEncoding=<span class="hljs-string">&quot;utf-8&quot;</span>%&gt;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="language-vbscript">&lt;%</span><br><span class="language-vbscript">String path = <span class="hljs-built_in">request</span>.getContextPath();</span><br><span class="language-vbscript">String basePath = <span class="hljs-built_in">request</span>.getScheme()+<span class="hljs-string">&quot;://&quot;</span>+<span class="hljs-built_in">request</span>.getServerName()+<span class="hljs-string">&quot;:&quot;</span>+<span class="hljs-built_in">request</span>.getServerPort()+path+<span class="hljs-string">&quot;/&quot;</span>;</span><br><span class="language-vbscript">%&gt;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;</span></span></span><span class="language-vbscript">&lt;%=basePath%&gt;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>实例5-1：struts2应用<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;pragma&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;no-cache&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;cache-control&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;no-cache&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;expires&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span>    </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;keyword1,keyword2,keyword3&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;This is my page&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!--</span></span><br><span class="hljs-comment"><span class="language-xml">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;</span></span><br><span class="hljs-comment"><span class="language-xml">--&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;struts.action&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span></span><br><span class="language-xml">    请输入姓名:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><p>welcome.jsp代码如下：</p><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs vbscript-html"><span class="language-vbscript">&lt;%@ page language=<span class="hljs-string">&quot;java&quot;</span> import=<span class="hljs-string">&quot;java.util.*&quot;</span> pageEncoding=<span class="hljs-string">&quot;utf-8&quot;</span>%&gt;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="language-vbscript">&lt;%</span><br><span class="language-vbscript">String path = <span class="hljs-built_in">request</span>.getContextPath();</span><br><span class="language-vbscript">String basePath = <span class="hljs-built_in">request</span>.getScheme()+<span class="hljs-string">&quot;://&quot;</span>+<span class="hljs-built_in">request</span>.getServerName()+<span class="hljs-string">&quot;:&quot;</span>+<span class="hljs-built_in">request</span>.getServerPort()+path+<span class="hljs-string">&quot;/&quot;</span>;</span><br><span class="language-vbscript">%&gt;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="language-vbscript">&lt;%@ taglib prefix=<span class="hljs-string">&quot;s&quot;</span> uri=<span class="hljs-string">&quot;/struts-tags&quot;</span> %&gt;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;</span></span></span><span class="language-vbscript">&lt;%=basePath%&gt;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>实例5-1：struts2应用<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;pragma&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;no-cache&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;cache-control&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;no-cache&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;expires&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span>    </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;keyword1,keyword2,keyword3&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;This is my page&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!--</span></span><br><span class="hljs-comment"><span class="language-xml">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;</span></span><br><span class="hljs-comment"><span class="language-xml">--&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    hello<span class="hljs-tag">&lt;<span class="hljs-name">s:property</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;#request.name&quot;</span>/&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure></li><li><p>更改配置<br>点击File-Project Structure或者快捷键ctrl+alt+shift+s 来打开面板<br>点击module-path修改编译的class文件输出路径<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E4%BF%AE%E6%94%B9class%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%84.png"><br>修改为：<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E4%BF%AE%E6%94%B9class%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%842.png"><br>都输出到建立的classes文件下，同时struts.xml也在这个文件下</p></li><li><p>进行运行前的服务器配置<br>同样是打开structure面板<br>修改Artifacts,点击exploded的选项，然后在如图所示的位置上右击，put into Output Root<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/Artifactsputinto.png"><br>结果如下：<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/putinto%E5%90%8E.png"></p></li><li><p>添加tomcat服务器<br>首先点击右上角Add Configuration添加配置<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/AddConfiguration.png"><br>点击加号<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E7%82%B9%E5%87%BB%E5%8A%A0%E5%8F%B7.png"><br>选择tomcat-local(需要自己下载tomcat，本文不提)<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/tomcat.png"><br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/tomcat2.png"><br>采取默认设置，点击右下角的fix,添加exploded（也可以通过Deployment添加)<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/tomcat3.png"><br>这里说一下exploded和普通的区别：</p><blockquote><p>war模式：将web工程以war包的形式上传到服务器<br>war exploed模式：将web工程以当前文件夹的位置关系上传到服务器<br>war模式这种可以称之为是发布模式，看名字也知道，这是先打包war包，再发布；<br>war exploded模式是直接把文件夹，jsp页面，classes等等移到Tomcat部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。<br>在平时开发的时候，使用热部署的话，应该对Tomcat进行相应的设置，这样的话修改的jsp界面什么的东西才可以及时的显示出来</p></blockquote></li><li><p>运行<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E8%BF%90%E8%A1%8C2.png"><br>首先点击项目上的小锤按钮进行编译,<br>编译后classes文件夹下如下：<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E7%BC%96%E8%AF%91.png"><br>然后点击箭头进行运行<br>结果如下：<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/1.png"><br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/2.png"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python常用库总结</title>
    <link href="/2019/10/06/python%E5%B8%B8%E7%94%A8%E5%BA%93%E6%80%BB%E7%BB%93/"/>
    <url>/2019/10/06/python%E5%B8%B8%E7%94%A8%E5%BA%93%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>均转载自他人文章，以便学习之用<br><br>Numpy:<br><br><a href="https://www.cnblogs.com/WSX1994/articles/9061516.html">https://www.cnblogs.com/WSX1994/articles/9061516.html</a><br><br>Matplotlib:<br><br><a href="https://blog.csdn.net/qq_34859482/article/details/80617391">https://blog.csdn.net/qq_34859482/article/details/80617391</a><br><br>sklearn:<br><br><a href="https://www.cnblogs.com/wj-1314/p/10179741.html">https://www.cnblogs.com/wj-1314/p/10179741.html</a></p><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习相关概念</title>
    <link href="/2019/10/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <url>/2019/10/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>转载<br><br>原文链接：<a href="https://blog.csdn.net/pangjiuzala/article/details/72630166">https://blog.csdn.net/pangjiuzala/article/details/72630166</a></p><h1 id="神经网络基础"><a href="#神经网络基础" class="headerlink" title="神经网络基础"></a>神经网络基础</h1><span id="more"></span><ol><li><p>神经元（Neuron）——就像形成我们大脑基本元素的神经元一样，神经元形成神经网络的基本结构。想象一下，当我们得到新信息时我们该怎么做。当我们获取信息时，我们一般会处理它，然后生成一个输出。类似地，在神经网络的情况下，神经元接收输入，处理它并产生输出，而这个输出被发送到其他神经元用于进一步处理，或者作为最终输出进行输出。</p></li><li><p>权重（Weights）——当输入进入神经元时，它会乘以一个权重。例如，如果一个神经元有两个输入，则每个输入将具有分配给它的一个关联权重。我们随机初始化权重，并在模型训练过程中更新这些权重。训练后的神经网络对其输入赋予较高的权重，这是它认为与不那么重要的输入相比更为重要的输入。为零的权重则表示特定的特征是微不足道的。<br><br>让我们假设输入为a，并且与其相关联的权重为W1，那么在通过节点之后，输入变为a * W1</p></li><li><p>偏差（Bias）——除了权重之外，另一个被应用于输入的线性分量被称为偏差。它被加到权重与输入相乘的结果中。基本上添加偏差的目的是来改变权重与输入相乘所得结果的范围的。添加偏差后，结果将看起来像a* W1 +偏差。这是输入变换的最终线性分量。</p></li><li><p>激活函数（Activation Function）——一旦将线性分量应用于输入，将会需要应用一个非线性函数。这通过将激活函数应用于线性组合来完成。激活函数将输入信号转换为输出信号。应用激活函数后的输出看起来像f（a * W1 + b），其中f（）就是激活函数。<br><br>在下图中，我们将“n”个输入给定为X1到Xn而与其相应的权重为Wk1到Wkn。我们有一个给定值为bk的偏差。权重首先乘以与其对应的输入，然后与偏差加在一起。而这个值叫做u。<br><br><img src="/2019/10/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/activate.png"><br><br>U &#x3D;ΣW* X+ b<br>激活函数被应用于u，即 f(u)，并且我们会从神经元接收最终输出，如yk &#x3D; f（u）。<br><br>最常用的激活函数就是Sigmoid，ReLU和softmax<br></p></li></ol><ul><li>Sigmoid——最常用的激活函数之一是Sigmoid，它被定义为：<br><br>sigmoid(x)&#x3D;$1 \over {1+e^{-x}}$<br><br>Sigmoid变换产生一个值为0到1之间更平滑的范围。我们可能需要观察在输入值略有变化时输出值中发生的变化。光滑的曲线使我们能够做到这一点，因此优于阶跃函数。</li><li>ReLU（整流线性单位）——与Sigmoid函数不同的是，最近的网络更喜欢使用ReLu激活函数来处理隐藏层。该函数定义为：<br><br>f(x)&#x3D;max(x,0)<br><br>当X&gt;0时，函数的输出值为X；当X&lt;&#x3D;0时，输出值为0。函数图如下图所示：<br>使用ReLU函数的最主要的好处是对于大于0的所有输入来说，它都有一个不变的导数值。常数导数值有助于网络训练进行得更快。</li><li>Softmax——Softmax激活函数通常用于输出层，用于分类问题。它与sigmoid函数是很类似的，唯一的区别就是输出被归一化为总和为1。<br>Sigmoid函数将发挥作用以防我们有一个二进制输出，但是如果我们有一个多类分类问题，softmax函数使为每个类分配值这种操作变得相当简单，而这可以将其解释为概率。<br><br>以这种方式来操作的话，我们很容易看到——假设你正在尝试识别一个可能看起来像8的6。该函数将为每个数字分配值如下。我们可以很容易地看出，最高概率被分配给6，而下一个最高概率分配给8，依此类推……</li></ul><ol start="5"><li><p>神经网络（Neural Network）——神经网络构成了深度学习的支柱。神经网络的目标是找到一个未知函数的近似值。它由相互联系的神经元形成。这些神经元具有权重和在网络训练期间根据错误来进行更新的偏差。激活函数将非线性变换置于线性组合，而这个线性组合稍后会生成输出。激活的神经元的组合会给出输出值。<br><br>一个很好的神经网络定义——<br>“神经网络由许多相互关联的概念化的人造神经元组成，它们之间传递相互数据，并且具有根据网络”经验“调整的相关权重。神经元具有激活阈值，如果通过其相关权重的组合和传递给他们的数据满足这个阈值的话，其将被解雇;发射神经元的组合导致“学习”。</p></li><li><p>输入&#x2F;输出&#x2F;隐藏层（Input &#x2F; Output &#x2F; Hidden Layer）——正如它们名字所代表的那样，输入层是接收输入那一层，本质上是网络的第一层。而输出层是生成输出的那一层，也可以说是网络的最终层。处理层是网络中的隐藏层。这些隐藏层是对传入数据执行特定任务并将其生成的输出传递到下一层的那些层。输入和输出层是我们可见的，而中间层则是隐藏的。</p></li><li><p>MLP（多层感知器）——单个神经元将无法执行高度复杂的任务。因此，我们使用堆栈的神经元来生成我们所需要的输出。在最简单的网络中，我们将有一个输入层、一个隐藏层和一个输出层。每个层都有多个神经元，并且每个层中的所有神经元都连接到下一层的所有神经元。这些网络也可以被称为完全连接的网络。</p></li><li><p>正向传播（Forward Propagation）——正向传播是指输入通过隐藏层到输出层的运动。在正向传播中，信息沿着一个单一方向前进。输入层将输入提供给隐藏层，然后生成输出。这过程中是没有反向运动的。</p></li><li><p>成本函数（Cost Function）——当我们建立一个网络时，网络试图将输出预测得尽可能靠近实际值。我们使用成本&#x2F;损失函数来衡量网络的准确性。而成本或损失函数会在发生错误时尝试惩罚网络。<br><br>我们在运行网络时的目标是提高我们的预测精度并减少误差，从而最大限度地降低成本。最优化的输出是那些成本或损失函数值最小的输出。<br><br>如果我将成本函数定义为均方误差，则可以写为：<br><br>C&#x3D; 1&#x2F;m ∑${(y–a)}^2$，<br><br>其中m是训练输入的数量，a是预测值，y是该特定示例的实际值。<br><br>学习过程围绕最小化成本来进行。</p></li><li><p>梯度下降（Gradient Descent）——梯度下降是一种最小化成本的优化算法。要直观地想一想，在爬山的时候，你应该会采取小步骤，一步一步走下来，而不是一下子跳下来。因此，我们所做的就是，如果我们从一个点x开始，我们向下移动一点，即Δh，并将我们的位置更新为x-Δh，并且我们继续保持一致，直到达到底部。考虑最低成本点。<br><br>在数学上，为了找到函数的局部最小值，我们通常采取与函数梯度的负数成比例的步长。</p></li><li><p>学习率（Learning Rate）——学习率被定义为每次迭代中成本函数中最小化的量。简单来说，我们下降到成本函数的最小值的速率是学习率。我们应该非常仔细地选择学习率，因为它不应该是非常大的，以至于最佳解决方案被错过，也不应该非常低，以至于网络需要融合。</p></li><li><p>反向传播（Backpropagation）——当我们定义神经网络时，我们为我们的节点分配随机权重和偏差值。一旦我们收到单次迭代的输出，我们就可以计算出网络的错误。然后将该错误与成本函数的梯度一起反馈给网络以更新网络的权重。 最后更新这些权重，以便减少后续迭代中的错误。使用成本函数的梯度的权重的更新被称为反向传播。<br><br>在反向传播中，网络的运动是向后的，错误随着梯度从外层通过隐藏层流回，权重被更新。</p></li><li><p>批次（Batches）——在训练神经网络的同时，不用一次发送整个输入，我们将输入分成几个随机大小相等的块。与整个数据集一次性馈送到网络时建立的模型相比，批量训练数据使得模型更加广义化。</p></li><li><p>周期（Epochs）——周期被定义为向前和向后传播中所有批次的单次训练迭代。这意味着1个周期是整个输入数据的单次向前和向后传递。<br><br>你可以选择你用来训练网络的周期数量，更多的周期将显示出更高的网络准确性，然而，网络融合也需要更长的时间。另外，你必须注意，如果周期数太高，网络可能会过度拟合。</p></li><li><p>丢弃（Dropout）——Dropout是一种正则化技术，可防止网络过度拟合套。顾名思义，在训练期间，隐藏层中的一定数量的神经元被随机地丢弃。这意味着训练发生在神经网络的不同组合的神经网络的几个架构上。你可以将Dropout视为一种综合技术，然后将多个网络的输出用于产生最终输出。</p></li><li><p>批量归一化（Batch Normalization）——作为一个概念，批量归一化可以被认为是我们在河流中设定为特定检查点的水坝。这样做是为了确保数据的分发与希望获得的下一层相同。当我们训练神经网络时，权重在梯度下降的每个步骤之后都会改变，这会改变数据的形状如何发送到下一层。<br><br>但是下一层预期分布类似于之前所看到的分布。 所以我们在将数据发送到下一层之前明确规范化数据。<br></p></li></ol><h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><ol start="17"><li><p>滤波器（Filters）——CNN中的滤波器与加权矩阵一样，它与输入图像的一部分相乘以产生一个回旋输出。我们假设有一个大小为28 * 28的图像，我们随机分配一个大小为3 * 3的滤波器，然后与图像不同的3 * 3部分相乘，形成所谓的卷积输出。滤波器尺寸通常小于原始图像尺寸。在成本最小化的反向传播期间，滤波器值被更新为重量值。</p></li><li><p>卷积神经网络（CNN）——卷积神经网络基本上应用于图像数据。假设我们有一个输入的大小（28 * 28 * 3），如果我们使用正常的神经网络，将有2352（28 * 28 * 3）参数。并且随着图像的大小增加参数的数量变得非常大。我们“卷积”图像以减少参数数量（如上面滤波器定义所示）。当我们将滤波器滑动到输入体积的宽度和高度时，将产生一个二维激活图，给出该滤波器在每个位置的输出。我们将沿深度尺寸堆叠这些激活图，并产生输出量。<br><br><img src="/2019/10/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/%E5%8D%B7%E7%A7%AF.png"></p></li><li><p>池化（Pooling）——通常在卷积层之间定期引入池层。这基本上是为了减少一些参数，并防止过度拟合。最常见的池化类型是使用MAX操作的滤波器尺寸（2,2）的池层。它会做的是，它将占用原始图像的每个4 * 4矩阵的最大值。<br><br><img src="/2019/10/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/%E6%B1%A0%E5%8C%96.png"><br><br>你还可以使用其他操作（如平均池）进行池化，但是最大池数量在实践中表现更好。</p></li><li><p>填充（Padding）——填充是指在图像之间添加额外的零层，以使输出图像的大小与输入相同。这被称为相同的填充。<br><br><img src="/2019/10/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/%E5%A1%AB%E5%85%85.png"><br><br>在应用滤波器之后，在相同填充的情况下，卷积层具有等于实际图像的大小。</p><br>有效填充是指将图像保持为具有实际或“有效”的图像的所有像素。在这种情况下，在应用滤波器之后，输出的长度和宽度的大小在每个卷积层处不断减小。</li><li><p>数据增强（Data Augmentation）——数据增强是指从给定数据导出的新数据的添加，这可能被证明对预测有益。例如，如果你使光线变亮，可能更容易在较暗的图像中看到猫，或者例如，数字识别中的9可能会稍微倾斜或旋转。在这种情况下，旋转将解决问题并提高我们的模型的准确性。通过旋转或增亮，我们正在提高数据的质量。这被称为数据增强。<br>循环神经网络</p></li></ol><h1 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h1><p><img src="/2019/10/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/%E5%BE%AA%E7%8E%AF.png"><br></p><ol start="22"><li><p>循环神经元（Recurrent Neuron）——循环神经元是在T时间内将神经元的输出发送回给它。如果你看图，输出将返回输入t次。展开的神经元看起来像连接在一起的t个不同的神经元。这个神经元的基本优点是它给出了更广义的输出。</p></li><li><p>循环神经网络（RNN）——循环神经网络特别用于顺序数据，其中先前的输出用于预测下一个输出。在这种情况下，网络中有循环。隐藏神经元内的循环使他们能够存储有关前一个单词的信息一段时间，以便能够预测输出。隐藏层的输出在t时间戳内再次发送到隐藏层。展开的神经元看起来像上图。只有在完成所有的时间戳后，循环神经元的输出才能进入下一层。发送的输出更广泛，以前的信息保留的时间也较长。<br><br>然后根据展开的网络将错误反向传播以更新权重。这被称为通过时间的反向传播（BPTT）。</p></li><li><p>消失梯度问题（Vanishing Gradient Problem）——激活函数的梯度非常小的情况下会出现消失梯度问题。在权重乘以这些低梯度时的反向传播过程中，它们往往变得非常小，并且随着网络进一步深入而“消失”。这使得神经网络忘记了长距离依赖。这对循环神经网络来说是一个问题，长期依赖对于网络来说是非常重要的。<br><br>这可以通过使用不具有小梯度的激活函数ReLu来解决。</p></li><li><p>激增梯度问题（Exploding Gradient Problem）——这与消失的梯度问题完全相反，激活函数的梯度过大。在反向传播期间，它使特定节点的权重相对于其他节点的权重非常高，这使得它们不重要。这可以通过剪切梯度来轻松解决，使其不超过一定值。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>监督学习之决策树</title>
    <link href="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="监督学习之决策树"><a href="#监督学习之决策树" class="headerlink" title="监督学习之决策树"></a>监督学习之决策树</h1><span id="more"></span><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> mglearn<br><span class="hljs-keyword">import</span> os<br>%matplotlib inline<br></code></pre></td></tr></table></figure><p>决策树是广泛用于分类和回归任务的模型。本质上，它从一层层的 if&#x2F;else 问题中进行学<br>习，并得出结论。</p><p>这些问题类似于你在“20 Questions”游戏中可能会问的问题。想象一下，你想要区分下面这四种动物：熊、鹰、企鹅和海豚。你的目标是通过提出尽可能少的 if&#x2F;else 问题来得到正确答案。你可能首先会问：这种动物有没有羽毛，这个问题会将可能的动物减少到只有两种。如果答案是“有”，你可以问下一个问题，帮你区分鹰和企鹅。例如，你可以问这种动物会不会飞。如果这种动物没有羽毛，那么可能是海豚或熊，所以你需要问一个问题来区分这两种动物——比如问这种动物有没有鳍。</p><p>这一系列问题可以表示为一棵决策树,如下图所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mglearn.plots.plot_animal_tree()<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/output_4_0.png" alt="png"></p><p>在这张图中，树的每个结点代表一个问题或一个包含答案的终结点（也叫叶结点）。树的边将问题的答案与将问的下一个问题连接起来。</p><p>用机器学习的语言来说就是，为了区分四类动物（鹰、企鹅、海豚和熊），我们利用三个特征（“有没有羽毛”“会不会飞”和“有没有鳍”）来构建一个模型。我们可以利用监督学习从数据中学习模型，而无需人为构建模型。</p><h2 id="1-构造决策树"><a href="#1-构造决策树" class="headerlink" title="1.构造决策树"></a>1.构造决策树</h2><p>我们在下图所示的二维分类数据集上构造决策树。这个数据集由 2 个半月形组成，每个类别都包含 50 个数据点。我们将这个数据集称为 two_moons 。</p><p>学习决策树，就是学习一系列 if&#x2F;else 问题，使我们能够以最快的速度得到正确答案。在机器学习中，这些问题叫作测试（不要与测试集弄混，测试集是用来测试模型泛化性能的数据）。数据通常并不是像动物的例子那样具有二元特征（是 &#x2F; 否）的形式，而是表示为连续特征，比如图 2-23 所示的二维数据集。用于连续数据的测试形式是：“特征 i 的值是否大于 a ?”</p><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/2-23.png"></p><p>为了构造决策树，算法搜遍所有可能的测试，找出对目标变量来说信息量最大的那一个。图 2-24 展示了选出的第一个测试。将数据集在 x[1]&#x3D;0.0596 处垂直划分可以得到最多信息，它在最大程度上将类别 0 中的点与类别 1 中的点进行区分。顶结点（也叫根结点）表示整个数据集，包含属于类别 0 的 50 个点和属于类别 1 的 50 个点。通过测试 x[1] &lt;&#x3D;0.0596 的真假来对数据集进行划分，在图中表示为一条黑线。如果测试结果为真，那么将这个点分配给左结点，左结点里包含属于类别 0 的 2 个点和属于类别 1 的 32 个点。否则将这个点分配给右结点，右结点里包含属于类别 0 的 48 个点和属于类别 1 的 18 个点。这两个结点对应于图 2-24 中的顶部区域和底部区域。尽管第一次划分已经对两个类别做了很好的区分，但底部区域仍包含属于类别 0 的点，顶部区域也仍包含属于类别 1 的点。我们可以在两个区域中重复寻找最佳测试的过程，从而构建出更准确的模型。图 2-25 展示了信息量最大的下一次划分，这次划分是基于 x[0] 做出的，分为左右两个区域</p><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/2-2425.png"></p><p>这一递归过程生成一棵二元决策树，其中每个结点都包含一个测试。或者你可以将每个测试看成沿着一条轴对当前数据进行划分。这是一种将算法看作分层划分的观点。由于每个测试仅关注一个特征，所以划分后的区域边界始终与坐标轴平行。</p><p>对数据反复进行递归划分，直到划分后的每个区域（决策树的每个叶结点）只包含单一目标值（单一类别或单一回归值）。如果树中某个叶结点所包含数据点的目标值都相同，那么这个叶结点就是纯的（pure）。这个数据集的最终划分结果见图 2-26。</p><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/2-26.png"></p><h2 id="2-控制决策树的复杂度"><a href="#2-控制决策树的复杂度" class="headerlink" title="2.控制决策树的复杂度"></a>2.控制决策树的复杂度</h2><p>通常来说，构造决策树直到所有叶结点都是纯的叶结点，这会导致模型非常复杂，并且对训练数据高度过拟合。纯叶结点的存在说明这棵树在训练集上的精度是 100%。训练集中的每个数据点都位于分类正确的叶结点中。在图 2-26 的左图中可以看出过拟合。你可以看到，在所有属于类别 0 的点中间有一块属于类别 1 的区域。另一方面，有一小条属于类别 0 的区域，包围着最右侧属于类别 0 的那个点。这并不是人们想象中决策边界的样子，这个决策边界过于关注远离同类别其他点的单个异常点。</p><p>防止过拟合有两种常见的策略：一种是及早停止树的生长，也叫预剪枝（pre-pruning）；另一种是先构造树，但随后删除或折叠信息量很少的结点，也叫后剪枝（post-pruning）或剪枝（pruning）。预剪枝的限制条件可能包括限制树的最大深度、限制叶结点的最大数目，或者规定一个结点中数据点的最小数目来防止继续划分。</p><p>scikit-learn 的决策树在 DecisionTreeRegressor 类和 DecisionTreeClassifier 类中实现。scikit-learn 只实现了预剪枝，没有实现后剪枝。</p><p>我们在乳腺癌数据集上更详细地看一下预剪枝的效果。和前面一样，我们导入数据集并将其分为训练集和测试集。然后利用默认设置来构建模型，默认将树完全展开（树不断分支，直到所有叶结点都是纯的）。我们固定树的 random_state ，用于在内部解决平局问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeClassifier<br><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_breast_cancer<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>cancer=load_breast_cancer()<br>X_train,X_test,y_train,y_test=train_test_split(cancer.data,cancer.target,<br>                                              stratify=cancer.target,random_state=<span class="hljs-number">42</span>)<br>tree=DecisionTreeClassifier(random_state=<span class="hljs-number">0</span>).fit(X_train,y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on training set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(tree.score(X_train,y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on test set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(tree.score(X_test,y_test)))<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">Accuracy on training set: 1.000Accuracy on test set: 0.937</code></pre><p>不出所料，训练集上的精度是 100%，这是因为叶结点都是纯的，树的深度很大，足以完美地记住训练数据的所有标签。测试集精度比之前讲过的线性模型略低，线性模型的精度约为 95%。</p><p>如果我们不限制决策树的深度，它的深度和复杂度都可以变得特别大。因此，未剪枝的树容易过拟合，对新数据的泛化性能不佳。现在我们将预剪枝应用在决策树上，这可以在完美拟合训练数据之前阻止树的展开。一种选择是在到达一定深度后停止树的展开。这里我们设置 max_depth&#x3D;4 ，这意味着只可以连续问 4 个问题（参见图 2-24 和图 2-26）。限制树的深度可以减少过拟合。这会降低训练集的精度，但可以提高测试集的精度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">tree=DecisionTreeClassifier(max_depth=<span class="hljs-number">4</span>,random_state=<span class="hljs-number">0</span>).fit(X_train,y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on training set :&#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(tree.score(X_train,y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on test set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(tree.score(X_test,y_test)))<br>      <br></code></pre></td></tr></table></figure><pre><code class="hljs">Accuracy on training set :0.988Accuracy on test set: 0.951</code></pre><h2 id="3-分析决策树"><a href="#3-分析决策树" class="headerlink" title="3.分析决策树"></a>3.分析决策树</h2><p>我们可以利用 tree 模块的 export_graphviz 函数来将树可视化。这个函数会生成一个 .dot 格式的文件，这是一种用于保存图形的文本文件格式。我们设置为结点添加颜色的选项，颜色表示每个结点中的多数类别，同时传入类别名称和特征名称，这样可以对树正确标记：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> export_graphviz<br>export_graphviz(tree, out_file=<span class="hljs-string">&quot;tree.dot&quot;</span>, class_names=[<span class="hljs-string">&quot;malignant&quot;</span>,<span class="hljs-string">&quot;benign&quot;</span>],<br>    feature_names=cancer.feature_names, impurity=<span class="hljs-literal">False</span>, filled=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>我们可以利用 graphviz 模块读取这个文件并将其可视化（你也可以使用任何能够读取 .dot文件的程序）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> graphviz<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;tree.dot&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    dot_graph = f.read()<br>    graphviz.Source(dot_graph).view()<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/3.png"></p><p>树的可视化有助于深入理解算法是如何进行预测的，也是易于向非专家解释的机器学习算法的优秀示例。不过，即使这里树的深度只有 4 层，也有点太大了。深度更大的树（深度为 10 并不罕见）更加难以理解。一种观察树的方法可能有用，就是找出大部分数据的实际路径。图中每个结点的 samples 给出了该结点中的样本个数， values 给出的是每个类别的样本个数。观察 worst radius &lt;&#x3D; 16.795 分支右侧的子结点，我们发现它只包含8 个良性样本，但有 134 个恶性样本。树的这一侧的其余分支只是利用一些更精细的区别将这 8 个良性样本分离出来。在第一次划分右侧的 142 个样本中，几乎所有样本（132 个）最后都进入最右侧的叶结点中。</p><p>再来看一下根结点的左侧子结点，对于 worst radius &gt; 16.795 ，我们得到 25 个恶性样本和 259 个良性样本。几乎所有良性样本最终都进入左数第二个叶结点中，大部分其他叶结点都只包含很少的样本。</p><h2 id="4-树的特征重要性"><a href="#4-树的特征重要性" class="headerlink" title="4.树的特征重要性"></a>4.树的特征重要性</h2><p>查看整个树可能非常费劲，除此之外，我还可以利用一些有用的属性来总结树的工作原理。其中最常用的是特征重要性（feature importance），它为每个特征对树的决策的重要性进行排序。对于每个特征来说，它都是一个介于 0 和 1 之间的数字，其中 0 表示“根本没用到”，1 表示“完美预测目标值”。特征重要性的求和始终为 1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Feature importances:\n&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(tree.feature_importances_))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Feature importances:[0.         0.         0.         0.         0.         0. 0.         0.         0.         0.         0.01019737 0.04839825 0.         0.         0.0024156  0.         0.         0. 0.         0.         0.72682851 0.0458159  0.         0. 0.0141577  0.         0.018188   0.1221132  0.01188548 0.        ]</code></pre><p>我们可以将特征重要性可视化，与我们将线性模型的系数可视化的方法类似：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_feature_importance_cancer</span>(<span class="hljs-params">model</span>):<br>    n_features = cancer.data.shape[<span class="hljs-number">1</span>]<br>    plt.barh(<span class="hljs-built_in">range</span>(n_features), model.feature_importances_, align=<span class="hljs-string">&#x27;center&#x27;</span>)<br>    plt.yticks(np.arange(n_features), cancer.feature_names)<br>    plt.xlabel(<span class="hljs-string">&quot;Feature importance&quot;</span>)<br>    plt.ylabel(<span class="hljs-string">&quot;Feature&quot;</span>)<br><br>plot_feature_importance_cancer(tree)<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/output_25_0.png" alt="png"></p><p>这里我们看到，顶部划分用到的特征（“worst radius”）是最重要的特征。这也证实了我们在分析树时的观察结论，即第一层划分已经将两个类别区分得很好。</p><p>但是，如果某个特征的 feature_importance_ 很小，并不能说明这个特征没有提供任何信息。这只能说明该特征没有被树选中，可能是因为另一个特征也包含了同样的信息。</p><p>与线性模型的系数不同，特征重要性始终为正数，也不能说明该特征对应哪个类别。特征重要性告诉我们“worst radius”（最大半径）特征很重要，但并没有告诉我们半径大表示样本是良性还是恶性。事实上，在特征和类别之间可能没有这样简单的关系，你可以在下面的例子中看出这一点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tree=mglearn.plots.plot_tree_not_monotone()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Feature importances: [0. 1.]</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/output_27_1.png" alt="png"></p><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/4.png"></p><p>该图显示的是有两个特征和两个类别的数据集。这里所有信息都包含在 X[1] 中，没有用到X[0] 。但 X[1] 和输出类别之间并不是单调关系，即我们不能这么说：“较大的 X[1] 对应类别 0，较小的 X[1] 对应类别 1”（反之亦然）。</p><p>虽然我们主要讨论的是用于分类的决策树，但对用于回归的决策树来说，所有内容都是类似的，在 DecisionTreeRegressor 中实现。回归树的用法和分析与分类树非常类似。但在将基于树的模型用于回归时，我们想要指出它的一个特殊性质。 DecisionTreeRegressor（以及其他所有基于树的回归模型）不能外推（extrapolate），也不能在训练数据范围之外进行预测。</p><p>我们利用计算机内存（RAM）历史价格的数据集来更详细地研究这一点。下图给出了这个数据集的图像，x 轴为日期，y 轴为那一年 1 兆字节（MB）RAM 的价格：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>ram_prices=pd.read_csv(<span class="hljs-string">&quot;data/ram_price.csv&quot;</span>)<br>plt.semilogy(ram_prices.date,ram_prices.price)<br>plt.xlabel(<span class="hljs-string">&#x27;Year&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Price in $/Mbyte&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">help</span>(plt.semilogy))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Help on function semilogy in module matplotlib.pyplot:semilogy(*args, **kwargs)    Make a plot with log scaling on the y axis.        Call signatures::            semilogy([x], y, [fmt], data=None, **kwargs)        semilogy([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)        This is just a thin wrapper around `.plot` which additionally changes    the y-axis to log scaling. All of the concepts and parameters of plot    can be used here as well.        The additional parameters *basey*, *subsy* and *nonposy* control the    y-axis properties. They are just forwarded to `.Axes.set_yscale`.        Parameters    ----------    basey : scalar, optional, default 10        Base of the y logarithm.        subsy : array_like, optional        The location of the minor yticks. If *None*, reasonable locations        are automatically chosen depending on the number of decades in the        plot. See `.Axes.set_yscale` for details.        nonposy : &#123;&#39;mask&#39;, &#39;clip&#39;&#125;, optional, default &#39;mask&#39;        Non-positive values in y can be masked as invalid, or clipped to a        very small positive number.        Returns    -------    lines        A list of `~.Line2D` objects representing the plotted data.        Other Parameters    ----------------    **kwargs        All parameters supported by `.plot`.None</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/output_30_1.png" alt="png"></p><p>注意 y 轴的对数刻度。在用对数坐标绘图时，二者的线性关系看起来非常好，所以预测应该相对比较容易，除了一些不平滑之处之外。</p><p>我们将利用 2000 年前的历史数据来预测 2000 年后的价格，只用日期作为特征。我们将对比两个简单的模型： DecisionTreeRegressor 和 LinearRegression 。我们对价格取对数，使得二者关系的线性相对更好。这对 DecisionTreeRegressor 不会产生什么影响，但对LinearRegression 的影响却很大（我们将在第 4 章中进一步讨论）。训练模型并做出预测之后，我们应用指数映射来做对数变换的逆运算。为了便于可视化，我们这里对整个数据集进行预测，但如果是为了定量评估，我们将只考虑测试数据集：</p><p>首先说明下np.newwaxis用法，增加一维</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">x1 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;the shape of x1 is &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(x1.shape))<br>x1_new=x1[:,np.newaxis]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;the shape of x1 after newwaxis is &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(x1_new.shape))<br></code></pre></td></tr></table></figure><pre><code class="hljs">the shape of x1 is (5,)the shape of x1 after newwaxis is (5, 1)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeRegressor<br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br><span class="hljs-comment">#利用历史数据预测2000年后的价格</span><br>data_train=ram_prices[ram_prices.date&lt;<span class="hljs-number">2000</span>]<br>data_test=ram_prices[ram_prices.date&gt;=<span class="hljs-number">2000</span>]<br><span class="hljs-comment">#基于日期来预测价格</span><br>X_train=data_train.date[:,np.newaxis]<br><span class="hljs-comment">#利用对数变换来得到数据和目标之间更简单的关系</span><br>y_train=np.log(data_train.price)<br>tree=DecisionTreeRegressor().fit(X_train,y_train)<br>linear_reg=LinearRegression().fit(X_train,y_train)<br><span class="hljs-comment">#对所有数据进行预测</span><br>X_all=ram_prices.date[:,np.newaxis]<br>pred_tree=tree.predict(X_all)<br>pred_lr=linear_reg.predict(X_all)<br><span class="hljs-comment">#对数变换逆运算</span><br>price_tree=np.exp(pred_tree)<br>price_lr=np.exp(pred_lr)<br><span class="hljs-comment"># 将决策树和线性回归模型的预测结果与真实值进行对比</span><br>plt.semilogy(data_train.date,data_train.price,label=<span class="hljs-string">&quot;Training data&quot;</span>)<br>plt.semilogy(data_test.date,data_test.price,label=<span class="hljs-string">&quot;Test data&quot;</span>)<br><br>plt.semilogy(ram_prices.date,price_tree,label=<span class="hljs-string">&quot;Tree prediction&quot;</span>)<br>plt.semilogy(ram_prices.date,price_lr,label=<span class="hljs-string">&quot;Linear prediction&quot;</span>)<br>plt.legend()<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.legend.Legend at 0x2263aa048d0&gt;</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/output_34_1.png" alt="png"></p><p>两个模型之间的差异非常明显。线性模型用一条直线对数据做近似，这是我们所知道的。这条线对测试数据（2000 年后的价格）给出了相当好的预测，不过忽略了训练数据和测试数据中一些更细微的变化。与之相反，树模型完美预测了训练数据。由于我们没有限制树的复杂度，因此它记住了整个数据集。但是，一旦输入超出了模型训练数据的范围，模型就只能持续预测最后一个已知数据点。树不能在训练数据的范围之外生成“新的”响应。所有基于树的模型都有这个缺点。</p><h2 id="5-优点，缺点和参数"><a href="#5-优点，缺点和参数" class="headerlink" title="5.优点，缺点和参数"></a>5.优点，缺点和参数</h2><p>如前所述，控制决策树模型复杂度的参数是预剪枝参数,<br><br>它在树完全展开之前停止树的构造。<br><br>通常来说，选择一种预剪枝策略（设置 max_depth 、 max_leaf_nodes 或 min_samples_leaf ）足以防止过拟合。<br><br>与前面讨论过的许多算法相比，决策树有两个优点：<br></p><ul><li>得到的模型很容易可视化，非专家也很容易理解（至少对于较小的树而言）；</li><li>算法完全不受数据缩放的影响。由于每个特征被单独处理，而且数据的划分也不依赖于缩放，因此决策树算法不需要特征预处理，比如归一化或标准化。<br>特别是特征的尺度完全不一样时或者二元特征和连续特征同时存在时，决策树的效果很好。<br></li></ul><p>决策树的主要缺点在于，即使做了预剪枝，它也经常会过拟合，泛化性能很差。<br><br>因此，在大多数应用中，往往使用下面介绍的集成方法来替代单棵决策树。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>监督学习之线性模型</title>
    <link href="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="监督学习之线性模型"><a href="#监督学习之线性模型" class="headerlink" title="监督学习之线性模型"></a>监督学习之线性模型</h1><span id="more"></span><h2 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h2><p><span class="mark">回归</span>：统计学中，回归分析（regression analysis)指的是确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。回归分析按照涉及的变量的多少，分为一元回归和多元回归分析；按照因变量的多少，可分为简单回归分析和多重回归分析；按照自变量和因变量之间的关系类型，可分为线性回归分析和非线性回归分析。<br><br><span class="mark">线性回归</span>：<br><br>线性回归是利用数理统计中回归分析，来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法，运用十分广泛。其表达形式为y &#x3D; w’x+e，e为误差服从均值为0的正态分布。 <br><br>回归分析中，只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。如果回归分析中包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则称为多元线性回归分析。</p><p><span class="mark">python中shape简易用法</span>：<br><br>通过安装导入numpy库，矩阵（ndarray）的shape属性可以获取矩阵的形状（例如二维数组的行列），获取的结果是一个元组<br><br><span class="girk">shape[0] 行<br><br>shape[1] 列</span><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> mglearn<br>%matplotlib inline<br></code></pre></td></tr></table></figure><p><span class="mark">线性模型利用输入特征的线性函数进行预测</span></p><h2 id="1-用于回归的线性模型"><a href="#1-用于回归的线性模型" class="headerlink" title="1.用于回归的线性模型"></a>1.用于回归的线性模型</h2><p>对于回归问题，线性模型预测的一般公式如下：</p><p>ŷ&#x3D;w[0]∗x[0]+w[1]∗x[1]+…+w[p]∗x[p]+b</p><p>这里 x[0]<br>到 x[p] 表示单个数据点的特征（本例中特征个数为 p+1），w 和 b 是学习模型的<br>参数，ŷ</p><p>是模型的预测结果。对于单一特征的数据集，公式如下：</p><p>ŷ&#x3D;w[0]∗x[0]+b</p><p>你可能还记得，这就是高中数学里的直线方程。这里 w[0]<br>是斜率，b 是 y 轴偏移。对于有<br>更多特征的数据集，w 包含沿每个特征坐标轴的斜率。或者，你也可以将预测的响应值看<br>作输入特征的加权求和，权重由 w 的元素给出（可以取负值）。<br>下列代码可以在一维 wave 数据集上学习参数 w[0] 和 b：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mglearn.plots.plot_linear_regression_wave()<br></code></pre></td></tr></table></figure><pre><code class="hljs">w[0]: 0.393906  b: -0.031804</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_6_1.png" alt="png"></p><p>有许多不同的线性回归模型。<br><br>这些模型之间的区别在于如何从训练数据中学习参数 w 和 b，以及如何控制模型复杂度。<br><br>下面介绍最常见的线性回归模型。<br></p><h2 id="2-线性回归"><a href="#2-线性回归" class="headerlink" title="2.线性回归"></a>2.线性回归</h2><p>线性回归，或者普通最小二乘法（ordinary least squares，OLS），是回归问题最简单也最经典的线性方法。<br><br>线性回归寻找参数 w 和 b，使得对训练集的预测值与真实的回归目标值 y 之间的均方误差最小。<br><br>均方误差（mean squared error）是预测值与真实值之差的平方和除以样本数。<br><br>线性回归没有参数，这是一个优点，但也因此无法控制模型的复杂度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X,y=mglearn.datasets.make_wave(n_samples=<span class="hljs-number">60</span>)<br>X_train,X_test,y_train,y_test=train_test_split(X,y,random_state=<span class="hljs-number">42</span>)<br>lr=LinearRegression().fit(X_train,y_train)<br><br></code></pre></td></tr></table></figure><p>“斜率”参数（w，也叫作权重或系数）被保存在 coef_ 属性中，而偏移或截距（b）被保存在 intercept_ 属性中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;lr.coef_:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lr.coef_))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;lr.intercept_:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lr.intercept_))<br></code></pre></td></tr></table></figure><pre><code class="hljs">lr.coef_:[0.39390555]lr.intercept_:-0.031804343026759746</code></pre><p>你可能注意到了 coef_ 和 intercept_ 结尾处奇怪的下划线。scikit-learn 总是将从训练数据中得出的值保存在以下划线结尾的属性中。这是为了将其与用户设置的参数区分开。</p><p>intercept_ 属性是一个浮点数，而 coef_ 属性是一个 NumPy 数组，每个元素对应一个输入特征。由于 wave 数据集中只有一个输入特征，所以 lr.coef_ 中只有一个元素。我们来看一下训练集和测试集的性能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Training set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lr.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lr.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Training set score: 0.67Test set score: 0.66</code></pre><p>对于更高维的数据集（即有大量特征的数据集），线性模型将变得更加强大，过拟合的可能性也会变大。我们来看一下 LinearRegression 在更复杂的数据集上的表现，比如波士顿房价数据集。记住，这个数据集有 506 个样本和 105个导出特征。首先，加载数据集并将其分为训练集和测试集。然后像前面一样构建线性回归模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">X,y=mglearn.datasets.load_extended_boston()<br>X_train,X_test,y_train,y_test=train_test_split(X,y,random_state=<span class="hljs-number">0</span>)<br>lr=LinearRegression().fit(X_train, y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Trainnig set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lr.score(X_train,y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lr.score(X_test,y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Trainnig set score: 0.95Test set score: 0.61</code></pre><p><span class="girk">训练集和测试集之间的性能差异是过拟合的明显标志</span>，因此我们应该试图找到一个可以控制复杂度的模型。<span class="mark">标准线性回归最常用的替代方法之一就是岭回归（ridge regression）</span>，下面来看一下。<br><br><br><span class="mark">过拟合</span>：一个假设在训练数据上能够获得比其他假设更好的拟合， 但是在训练数据外的数据集上却不能很好地拟合数据，此时认为这个假设出现了过拟合的现象。出现这种现象的主要原因是训练数据中存在噪音或者训练数据太少。 </p><h2 id="3-岭回归"><a href="#3-岭回归" class="headerlink" title="3.岭回归"></a>3.岭回归</h2><p><span class="mark">岭回归也是一种用于回归的线性模型，因此它的预测公式与普通最小二乘法相同。</span>但在岭回归中，对系数（w）的选择不仅要在训练数据上得到好的预测结果，而且还要拟合附加约束。我们还希望<span class="girk">系数尽量小</span>。换句话说，w 的所有元素都应接近于 0。直观上来看，这意味着每个特征对输出的影响应尽可能小（即斜率很小），同时仍给出很好的预测结果。这种约束是所谓正则化（regularization）的一个例子。正则化是指对模型做显式约束，以避免过拟合。岭回归用到的这种被称为 <span class="girk">L2 正则化</span>。<br><br>岭回归在 <span class="burk">linear_model.Ridge</span> 中实现。来看一下它对扩展的波士顿房价数据集的效果如何</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Ridge<br>ridge=Ridge().fit(X_train,y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Training set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(ridge.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(ridge.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Training set score: 0.89Test set score: 0.75</code></pre><p>可以看出， Ridge 在训练集上的分数要低于 LinearRegression ，但在测试集上的分数更高。这和我们的预期一致。线性回归对数据存在过拟合。 Ridge 是一种约束更强的模型，所以更不容易过拟合。复杂度更小的模型意味着在训练集上的性能更差，但泛化性能更好。由于我们只对泛化性能感兴趣，所以应该选择 Ridge 模型而不是 LinearRegression 模型。</p><p>Ridge 模型在模型的简单性（系数都接近于 0）与训练集性能之间做出权衡。简单性和训练集性能二者对于模型的重要程度可以由<span class="mark">用户通过设置 alpha 参数来指定</span>。在前面的例子中，我们用的是默认参数 alpha&#x3D;1.0 。但没有理由认为这会给出最佳权衡。 alpha 的最佳设定值取决于用到的具体数据集。<span class="mark">增大 alpha 会使得系数更加趋向于 0，从而降低训练集性能，但可能会提高泛化性能</span>。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ridge10=Ridge(alpha=<span class="hljs-number">10</span>).fit(X_train,y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Training set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(ridge10.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(ridge10.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Training set score: 0.79Test set score: 0.64</code></pre><p><span class="mark">减小 alpha 可以让系数受到的限制更小</span>。对于非常小的 alpha 值，系数几乎没有受到限制，我们得到一个与 LinearRegression 类似的模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ridge01=Ridge(alpha=<span class="hljs-number">0.1</span>).fit(X_train,y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Training set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(ridge01.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(ridge01.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Training set score: 0.93Test set score: 0.77</code></pre><p>这里 alpha&#x3D;0.1 似乎效果不错。我们可以尝试进一步减小 alpha 以提高泛化性能。<br><br>我们还可以查看 alpha 取不同值时模型的 coef_ 属性，从而更加定性地理解 alpha 参数是如何改变模型的。更大的 alpha 表示约束更强的模型，所以我们预计大 alpha 对应的 coef_ 元素比小 alpha 对应的 coef_ 元素要小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.plot(ridge.coef_, <span class="hljs-string">&#x27;s&#x27;</span>, label=<span class="hljs-string">&quot;Ridge alpha=1&quot;</span>)<br>plt.plot(ridge10.coef_, <span class="hljs-string">&#x27;^&#x27;</span>, label=<span class="hljs-string">&quot;Ridge alpha=10&quot;</span>)<br>plt.plot(ridge01.coef_, <span class="hljs-string">&#x27;v&#x27;</span>, label=<span class="hljs-string">&quot;Ridge alpha=0.1&quot;</span>)<br>plt.plot(lr.coef_, <span class="hljs-string">&#x27;o&#x27;</span>, label=<span class="hljs-string">&quot;LinearRegression&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;Coefficient index&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Coefficient magnitude&quot;</span>)<br>plt.hlines(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(lr.coef_))<br>plt.ylim(-<span class="hljs-number">25</span>, <span class="hljs-number">25</span>)<br>plt.legend()<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_24_1.png" alt="png"></p><p>这里 x 轴对应 coef_ 的元素： x&#x3D;0 对应第一个特征的系数， x&#x3D;1 对应第二个特征的系数，以此类推，一直到 x&#x3D;100 。y 轴表示该系数的具体数值。这里需要记住的是，对于 alpha&#x3D;10 ，系数大多在 -3 和 3 之间。对于 alpha&#x3D;1 的 Ridge 模型，系数要稍大一点。对于 alpha&#x3D;0.1 ，点的范围更大。对于没有做正则化的线性回归（即 alpha&#x3D;0 ），点的范围很大，许多点都超出了图像的范围。</p><p>还有一种方法可以用来理解正则化的影响，就是固定 alpha 值，但改变训练数据量。我们对波士顿房价数据集做二次抽样，并在数据量逐渐增加的子数据集上分别对 LinearRegression 和 Ridge(alpha&#x3D;1) 两个模型进行评估（将模型性能作为数据集大小的函数进行绘图，这样的图像叫作学习曲线):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mglearn.plots.plot_ridge_n_samples()<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_26_0.png" alt="png"></p><h2 id="4-lasso"><a href="#4-lasso" class="headerlink" title="4.lasso"></a>4.lasso</h2><p>除了 Ridge ，还有一种正则化的线性回归是 Lasso 。与岭回归相同，<span class="girk">使用 lasso 也是约束系数使其接近于 0，但用到的方法不同，叫作 L1 正则化。L1 正则化的结果是，使用 lasso 时某些系数刚好为 0。这说明某些特征被模型完全忽略。</span>这可以看作是一种自动化的特征选择。某些系数刚好为 0，这样模型更容易解释，也可以呈现模型最重要的特征。</p><p>我们将 lasso 应用在扩展的波士顿房价数据集上：</div></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Lasso<br>lasso=Lasso().fit(X_train,y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Training set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lasso.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lasso.score(X_test, y_test)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Number of features used: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(np.<span class="hljs-built_in">sum</span>(lasso.coef_ != <span class="hljs-number">0</span>)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Number of all feature: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lasso.coef_.shape[<span class="hljs-number">0</span>]))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Training set score: 0.29Test set score: 0.21Number of features used: 4Number of all feature: 104</code></pre><p>如你所见， Lasso 在训练集与测试集上的表现都很差。这表示存在欠拟合，我们发现模型只用到了 105 个特征中的 4 个。与 Ridge 类似， <span class="mark">Lasso 也有一个正则化参数 alpha ，可以控制系数趋向于 0 的强度</span>。在上一个例子中，我们用的是默认值 alpha&#x3D;1.0 。为了降低欠拟合，我们尝试减小 alpha 。这么做的同时，我们还需要增加 max_iter 的值（运行迭代的最大次数）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 我们增大max_iter的值，否则模型会警告我们，说应该增大max_iter</span><br>lasso001 = Lasso(alpha=<span class="hljs-number">0.01</span>, max_iter=<span class="hljs-number">100000</span>).fit(X_train, y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Training set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lasso001.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lasso001.score(X_test, y_test)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Number of features used: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(np.<span class="hljs-built_in">sum</span>(lasso001.coef_ != <span class="hljs-number">0</span>)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Training set score: 0.90Test set score: 0.77Number of features used: 33</code></pre><p>alpha 值变小，我们可以拟合一个更复杂的模型，在训练集和测试集上的表现也更好。模型性能比使用 Ridge 时略好一点，而且我们只用到了 105 个特征中的 33 个。这样模型可能更容易理解。</p><p>但如果把 alpha 设得太小，那么就会消除正则化的效果，并出现过拟合，得到与LinearRegression 类似的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">lasso00001 = Lasso(alpha=<span class="hljs-number">0.0001</span>, max_iter=<span class="hljs-number">100000</span>).fit(X_train, y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Training set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lasso00001.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lasso00001.score(X_test, y_test)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Number of features used: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(np.<span class="hljs-built_in">sum</span>(lasso00001.coef_ != <span class="hljs-number">0</span>)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Training set score: 0.95Test set score: 0.64Number of features used: 96</code></pre><p>对不同模型的系数进行作图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.plot(lasso.coef_, <span class="hljs-string">&#x27;s&#x27;</span>, label=<span class="hljs-string">&quot;Lasso alpha=1&quot;</span>)<br>plt.plot(lasso001.coef_, <span class="hljs-string">&#x27;^&#x27;</span>, label=<span class="hljs-string">&quot;Lasso alpha=0.01&quot;</span>)<br>plt.plot(lasso00001.coef_, <span class="hljs-string">&#x27;v&#x27;</span>, label=<span class="hljs-string">&quot;Lasso alpha=0.0001&quot;</span>)<br>plt.plot(ridge01.coef_, <span class="hljs-string">&#x27;o&#x27;</span>, label=<span class="hljs-string">&quot;Ridge alpha=0.1&quot;</span>)<br>plt.legend(ncol=<span class="hljs-number">2</span>, loc=(<span class="hljs-number">0</span>, <span class="hljs-number">1.05</span>))<br>plt.ylim(-<span class="hljs-number">25</span>, <span class="hljs-number">25</span>)<br>plt.xlabel(<span class="hljs-string">&quot;Coefficient index&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Coefficient magnitude&quot;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Text(0, 0.5, &#39;Coefficient magnitude&#39;)</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_35_1.png" alt="png"></p><p>在 alpha&#x3D;1 时，我们发现不仅大部分系数都是 0（我们已经知道这一点），而且其他系数也都很小。将 alpha 减小至 0.01 ，我们得到图中向上的三角形，大部分特征等于 0。alpha&#x3D;0.0001 时，我们得到正则化很弱的模型，大部分系数都不为 0，并且还很大。为了便于比较，图中用圆形表示 Ridge 的最佳结果。 alpha&#x3D;0.1 的 Ridge 模型的预测性能与alpha&#x3D;0.01 的 Lasso 模型类似，但 Ridge 模型的所有系数都不为 0。</p><p><span class="mark">在实践中，在两个模型中一般首选岭回归</span>。但如果特征很多，你认为只有其中几个是重要的，那么选择 Lasso 可能更好。同样，如果你想要一个容易解释的模型， Lasso 可以给出更容易理解的模型，因为它只选择了一部分输入特征。 scikit-learn 还提供了 ElasticNet类，结合了 Lasso 和 Ridge 的惩罚项。在实践中，这种结合的效果最好，不过代价是要调节两个参数：一个用于 L1 正则化，一个用于 L2 正则化。</p><h2 id="5-用于分类的线性模型"><a href="#5-用于分类的线性模型" class="headerlink" title="5.用于分类的线性模型"></a>5.用于分类的线性模型</h2><p>线性模型也广泛应用于分类问题。我们首先来看二分类。这时可以利用下面的公式进行<br>预测：</p><p>ŷ &#x3D;w[0]∗x[0]+w[1]∗x[1]+…+w[p]∗x[p]+b&gt;0</p><p>这个公式看起来与线性回归的公式非常相似，但我们没有返回特征的加权求和，而是为预测设置了阈值（0）。如果函数值小于 0，我们就预测类别 -1；如果函数值大于 0，我们就预测类别 +1。对于所有用于分类的线性模型，这个预测规则都是通用的。同样，有很多种不同的方法来找出系数（w）和截距（b）。</p><p>对于用于回归的线性模型，输出 ŷ 是特征的线性函数，是直线、平面或超平面（对于更高维的数据集）。对于用于分类的线性模型，决策边界是输入的线性函数。换句话说，（二元）线性分类器是利用直线、平面或超平面来分开两个类别的分类器。本节我们将看到这方面的例子。</p><p>学习线性模型有很多种算法。这些算法的区别在于以下两点：</p><pre><code class="hljs">系数和截距的特定组合对训练数据拟合好坏的度量方法；是否使用正则化，以及使用哪种正则化方法。</code></pre><p>不同的算法使用不同的方法来度量“对训练集拟合好坏”。由于数学上的技术原因，不可能调节 w 和 b 使得算法产生的误分类数量最少。对于我们的目的，以及对于许多应用而言，上面第一点（称为损失函数）的选择并不重要。</p><p>最常见的两种线性分类算法是 <span class="mark">Logistic 回归（logistic regression）和线性支持向量机（linear support vector machine，线性 SVM）</span>，前者在 <span class="burk">linear_model.LogisticRegression</span> 中实现，后者在 <span class="burk">svm.LinearSVC</span> （SVC 代表支持向量分类器）中实现。虽然 LogisticRegression的名字中含有回归（regression），但它是一种分类算法，并不是回归算法，不应与LinearRegression 混淆。</p><p>我们可以将 LogisticRegression 和 LinearSVC 模型应用到 forge 数据集上，并将线性模型找到的决策边界可视化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> LinearSVC<br><span class="hljs-keyword">import</span> mglearn<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br>X,y=mglearn.datasets.make_forge()<br>figs,axes=plt.subplots(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">3</span>))<br><span class="hljs-keyword">for</span> model,ax <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>([LinearSVC(),LogisticRegression()],axes):<br>    clf=model.fit(X,y)<br>    mglearn.plots.plot_2d_separator(clf, X, fill=<span class="hljs-literal">False</span>, eps=<span class="hljs-number">0.5</span>, ax=ax, alpha=<span class="hljs-number">.7</span>)<br>    mglearn.discrete_scatter(X[:,<span class="hljs-number">0</span>], X[:,<span class="hljs-number">1</span>],y, ax=ax)<br>    ax.set_title(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(clf.__class__.__name__))<br>    ax.set_xlabel(<span class="hljs-string">&quot;Feature 0&quot;</span>)<br>    ax.set_ylabel(<span class="hljs-string">&quot;Feature 1&quot;</span>)<br>axes[<span class="hljs-number">0</span>].legend()  <span class="hljs-comment">#在第一个绘图区显示图例</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">help</span>(mglearn.plots.plot_2d_separator))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">help</span>(mglearn.discrete_scatter))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Help on function plot_2d_separator in module mglearn.plot_2d_separator:plot_2d_separator(classifier, X, fill=False, ax=None, eps=None, alpha=1, cm=&lt;matplotlib.colors.ListedColormap object at 0x0000025366254198&gt;, linewidth=None, threshold=None, linestyle=&#39;solid&#39;)NoneHelp on function discrete_scatter in module mglearn.plot_helpers:discrete_scatter(x1, x2, y=None, markers=None, s=10, ax=None, labels=None, padding=0.2, alpha=1, c=None, markeredgewidth=None)    Adaption of matplotlib.pyplot.scatter to plot classes or clusters.        Parameters    ----------        x1 : nd-array        input data, first axis        x2 : nd-array        input data, second axis        y : nd-array        input data, discrete labels        cmap : colormap        Colormap to use.        markers : list of string        List of markers to use, or None (which defaults to &#39;o&#39;).        s : int or float        Size of the marker        padding : float        Fraction of the dataset range to use for padding the axes.        alpha : float        Alpha value for all points.None</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_38_2.png" alt="png"></p><p>在这张图中， forge 数据集的第一个特征位于 x 轴，第二个特征位于 y 轴，与前面相同。图中分别展示了 LinearSVC 和 LogisticRegression 得到的决策边界，都是直线，将顶部归为类别 1 的区域和底部归为类别 0 的区域分开了。换句话说，对于每个分类器而言，位于黑线上方的新数据点都会被划为类别 1，而在黑线下方的点都会被划为类别 0。</p><p>两个模型得到了相似的决策边界。注意，两个模型中都有两个点的分类是错误的。两个模型都默认使用 L2 正则化，就像 Ridge 对回归所做的那样。</p><p>对于 <span class="mark">LogisticRegression 和 LinearSVC ，决定正则化强度的权衡参数叫作 C</span> 。 C 值越大，对应的正则化越弱。换句话说，<span class="girk">如果参数 C 值较大，那么 LogisticRegression 和LinearSVC 将尽可能将训练集拟合到最好，而如果 C 值较小，那么模型更强调使系数向量（w）接近于 0</span>。参数 C 的作用还有另一个有趣之处。较小的 C 值可以让算法尽量适应“大多数”数据点，而较大的 C 值更强调每个数据点都分类正确的重要性。下面是使用 LinearSVC 的图示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mglearn.plots.plot_linear_svc_regularization()<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_40_0.png" alt="png"></p><p>在左侧的图中， C 值很小，对应强正则化。大部分属于类别 0 的点都位于底部，大部分属于类别 1 的点都位于顶部。强正则化的模型会选择一条相对水平的线，有两个点分类错误。在中间的图中， C 值稍大，模型更关注两个分类错误的样本，使决策边界的斜率变大。最后，在右侧的图中，模型的 C 值非常大，使得决策边界的斜率也很大，现在模型对类别 0 中所有点的分类都是正确的。类别 1 中仍有一个点分类错误，这是因为对这个数据集来说，不可能用一条直线将所有点都分类正确。右侧图中的模型尽量使所有点的分类都正确，但可能无法掌握类别的整体分布。换句话说，这个模型很可能过拟合。</p><p>与回归的情况类似，用于分类的线性模型在低维空间中看起来可能非常受限，决策边界只能是直线或平面。同样，在高维空间中，用于分类的线性模型变得非常强大，当考虑更多特征时，避免过拟合变得越来越重要。</p><p>我们在乳腺癌数据集上详细分析 LogisticRegression ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_breast_cancer<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">help</span>(train_test_split))<br>cancer=load_breast_cancer()<br><span class="hljs-comment"># stratify  按某个层次分配</span><br>X_train,X_test,y_train,y_test=train_test_split(cancer.data,cancer.target,<br>                                               stratify=cancer.target,random_state=<span class="hljs-number">42</span>)<br>logreg=LogisticRegression().fit(X_train,y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Taining set score:&#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(logreg.score(X_train,y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score:&#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(logreg.score(X_test,y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Help on function train_test_split in module sklearn.model_selection._split:train_test_split(*arrays, **options)    Split arrays or matrices into random train and test subsets        Quick utility that wraps input validation and    ``next(ShuffleSplit().split(X, y))`` and application to input data    into a single call for splitting (and optionally subsampling) data in a    oneliner.        Read more in the :ref:`User Guide &lt;cross_validation&gt;`.        Parameters    ----------    *arrays : sequence of indexables with same length / shape[0]        Allowed inputs are lists, numpy arrays, scipy-sparse        matrices or pandas dataframes.        test_size : float, int or None, optional (default=None)        If float, should be between 0.0 and 1.0 and represent the proportion        of the dataset to include in the test split. If int, represents the        absolute number of test samples. If None, the value is set to the        complement of the train size. If ``train_size`` is also None, it will        be set to 0.25.        train_size : float, int, or None, (default=None)        If float, should be between 0.0 and 1.0 and represent the        proportion of the dataset to include in the train split. If        int, represents the absolute number of train samples. If None,        the value is automatically set to the complement of the test size.        random_state : int, RandomState instance or None, optional (default=None)        If int, random_state is the seed used by the random number generator;        If RandomState instance, random_state is the random number generator;        If None, the random number generator is the RandomState instance used        by `np.random`.        shuffle : boolean, optional (default=True)        Whether or not to shuffle the data before splitting. If shuffle=False        then stratify must be None.        stratify : array-like or None (default=None)        If not None, data is split in a stratified fashion, using this as        the class labels.        Returns    -------    splitting : list, length=2 * len(arrays)        List containing train-test split of inputs.            .. versionadded:: 0.16            If the input is sparse, the output will be a            ``scipy.sparse.csr_matrix``. Else, output type is the same as the            input type.        Examples    --------    &gt;&gt;&gt; import numpy as np    &gt;&gt;&gt; from sklearn.model_selection import train_test_split    &gt;&gt;&gt; X, y = np.arange(10).reshape((5, 2)), range(5)    &gt;&gt;&gt; X    array([[0, 1],           [2, 3],           [4, 5],           [6, 7],           [8, 9]])    &gt;&gt;&gt; list(y)    [0, 1, 2, 3, 4]        &gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split(    ...     X, y, test_size=0.33, random_state=42)    ...    &gt;&gt;&gt; X_train    array([[4, 5],           [0, 1],           [6, 7]])    &gt;&gt;&gt; y_train    [2, 0, 3]    &gt;&gt;&gt; X_test    array([[2, 3],           [8, 9]])    &gt;&gt;&gt; y_test    [1, 4]        &gt;&gt;&gt; train_test_split(y, shuffle=False)    [[0, 1, 2], [3, 4]]NoneTaining set score:0.955Test set score:0.958</code></pre><p>C&#x3D;1 的默认值给出了相当好的性能，在训练集和测试集上都达到 95% 的精度。但由于训练集和测试集的性能非常接近，所以模型很可能是欠拟合的。我们尝试增大 C 来拟合一个更灵活的模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">logreg100 = LogisticRegression(C=<span class="hljs-number">100</span>).fit(X_train, y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Training set score: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(logreg100.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(logreg100.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Training set score: 0.972Test set score: 0.965</code></pre><p>使用 C&#x3D;100 可以得到更高的训练集精度，也得到了稍高的测试集精度，这也证实了我们的直觉，即更复杂的模型应该性能更好。<br>我们还可以研究使用正则化更强的模型时会发生什么。设置 C&#x3D;0.01 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">logreg001 = LogisticRegression(C=<span class="hljs-number">0.01</span>).fit(X_train, y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Training set score: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(logreg001.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(logreg001.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Training set score: 0.934Test set score: 0.930</code></pre><p>最后，来看一下正则化参数 C 取三个不同的值时模型学到的系数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.plot(logreg.coef_.T, <span class="hljs-string">&#x27;o&#x27;</span>, label=<span class="hljs-string">&quot;C=1&quot;</span>)<br>plt.plot(logreg100.coef_.T, <span class="hljs-string">&#x27;^&#x27;</span>, label=<span class="hljs-string">&quot;C=100&quot;</span>)<br>plt.plot(logreg001.coef_.T, <span class="hljs-string">&#x27;v&#x27;</span>, label=<span class="hljs-string">&quot;C=0.001&quot;</span>)<br><span class="hljs-comment">#指定坐标轴的刻度</span><br>plt.xticks(<span class="hljs-built_in">range</span>(cancer.data.shape[<span class="hljs-number">1</span>]), cancer.feature_names, rotation=<span class="hljs-number">90</span>)<br><span class="hljs-comment">#matplotlib.pyplot.hlines(y, xmin, xmax)表示横线，参数(y的值，横线开始横坐标，横线结束横坐标)</span><br><span class="hljs-comment">#matplotlib.pyplot.vlines(y, xmin, xmax)表示竖线，参数(x的值，竖线开始纵坐标，竖线结束纵坐标)</span><br>plt.hlines(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, cancer.data.shape[<span class="hljs-number">1</span>])<br><span class="hljs-comment"># 指定y轴范围</span><br>plt.ylim(-<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)<br>plt.xlabel(<span class="hljs-string">&quot;Coefficient index&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Coefficient magnitude&quot;</span>)<br>plt.legend()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Help on function hlines in module matplotlib.pyplot:hlines(y, xmin, xmax, colors=&#39;k&#39;, linestyles=&#39;solid&#39;, label=&#39;&#39;, *, data=None, **kwargs)    Plot horizontal lines at each *y* from *xmin* to *xmax*.        Parameters    ----------    y : scalar or sequence of scalar        y-indexes where to plot the lines.        xmin, xmax : scalar or 1D array_like        Respective beginning and end of each line. If scalars are        provided, all lines will have same length.        colors : array_like of colors, optional, default: &#39;k&#39;        linestyles : &#123;&#39;solid&#39;, &#39;dashed&#39;, &#39;dashdot&#39;, &#39;dotted&#39;&#125;, optional        label : string, optional, default: &#39;&#39;        Returns    -------    lines : `~matplotlib.collections.LineCollection`        Other Parameters    ----------------    **kwargs :  `~matplotlib.collections.LineCollection` properties.        See also    --------    vlines : vertical lines    axhline: horizontal line across the axes        Notes    -----            .. note::        In addition to the above described arguments, this function can take a        **data** keyword argument. If such a **data** argument is given, the        following arguments are replaced by **data[&lt;arg&gt;]**:            * All arguments with the following names: &#39;colors&#39;, &#39;xmax&#39;, &#39;xmin&#39;, &#39;y&#39;.            Objects passed as **data** must support item access (``data[&lt;arg&gt;]``) and        membership test (``&lt;arg&gt; in data``).None</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_48_1.png" alt="png"></p><p>由于 LogisticRegression 默认应用 L2 正则化，所以其结果与图 2-12 中 Ridge 的结果类似。更强的正则化使得系数更趋向于 0，但系数永远不会正好等于 0。进一步观察图像，还可以在第 3 个系数那里发现有趣之处，这个系数是“平均周长”（mean perimeter）。C&#x3D;100 和 C&#x3D;1 时，这个系数为负，而C&#x3D;0.001 时这个系数为正，其绝对值比 C&#x3D;1 时还要大。在解释这样的模型时，人们可能会认为，系数可以告诉我们某个特征与哪个类别有关。例如，人们可能会认为高“纹理错误”（texture error）特征与“恶性”样本有关。但“平均周长”系数的正负号发生变化，说明较大的“平均周长”可以被当作“良性”的指标或“恶性”的指标，具体取决于我们考虑的是哪个模型。这也说明，对线性模型系数的解释应该始终持保留态度。</p><p>如果想要一个可解释性更强的模型，使用 L1 正则化可能更好，因为它约束模型只使用少<br>数几个特征。下面是使用 L1 正则化的系数图像和分类精度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> C, marker <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>([<span class="hljs-number">0.001</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>], [<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;^&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>]):<br>    lr_l1 = LogisticRegression(C=C, penalty=<span class="hljs-string">&quot;l1&quot;</span>).fit(X_train, y_train)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Training accuracy of l1 logreg with C=&#123;:.3f&#125;: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>    C, lr_l1.score(X_train, y_train)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test accuracy of l1 logreg with C=&#123;:.3f&#125;: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>    C, lr_l1.score(X_test, y_test)))<br>    plt.plot(lr_l1.coef_.T, marker, label=<span class="hljs-string">&quot;C=&#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(C))<br>plt.xticks(<span class="hljs-built_in">range</span>(cancer.data.shape[<span class="hljs-number">1</span>]), cancer.feature_names, rotation=<span class="hljs-number">90</span>)<br>plt.hlines(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, cancer.data.shape[<span class="hljs-number">1</span>])<br>plt.xlabel(<span class="hljs-string">&quot;Coefficient index&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Coefficient magnitude&quot;</span>)<br>plt.ylim(-<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)<br>plt.legend(loc=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Training accuracy of l1 logreg with C=0.001: 0.91Test accuracy of l1 logreg with C=0.001: 0.92Training accuracy of l1 logreg with C=1.000: 0.96Test accuracy of l1 logreg with C=1.000: 0.96Training accuracy of l1 logreg with C=100.000: 0.99Test accuracy of l1 logreg with C=100.000: 0.98</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_50_4.png" alt="png"></p><h2 id="6-用于多分类的线性模型"><a href="#6-用于多分类的线性模型" class="headerlink" title="6.用于多分类的线性模型"></a>6.用于多分类的线性模型</h2><p>许多线性分类模型只适用于二分类问题，不能轻易推广到多类别问题（除了 Logistic 回归）。将二分类算法推广到多分类算法的一种常见方法是“一对其余”（one-vs.-rest）方法。在“一对其余”方法中，对每个类别都学习一个二分类模型，将这个类别与所有其他类别尽量分开，这样就生成了与类别个数一样多的二分类模型。在测试点上运行所有二类分类器来进行预测。在对应类别上分数最高的分类器“胜出”，将这个类别标签返回作为预测结果。</p><p>每个类别都对应一个二类分类器，这样每个类别也都有一个系数（w）向量和一个截距（b）。下面给出的是分类置信方程，其结果中最大值对应的类别即为预测的类别标签：</p><p>w[0]∗x[0]+w[1]∗x[1]+…+w[p]∗x[p]+b</p><p>多分类 Logistic 回归背后的数学与“一对其余”方法稍有不同，但它也是对每个类别都有一个系数向量和一个截距，也使用了相同的预测方法。</p><p>我们将“一对其余”方法应用在一个简单的三分类数据集上。我们用到了一个二维数据集，每个类别的数据都是从一个高斯分布中采样得出的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> make_blobs<br>X,y=make_blobs(random_state=<span class="hljs-number">42</span>)<br>mglearn.discrete_scatter(X[:,<span class="hljs-number">0</span>],X[:,<span class="hljs-number">1</span>],y)<br>plt.xlabel(<span class="hljs-string">&quot;Feature 0&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Feature 1&quot;</span>)<br>plt.legend([<span class="hljs-string">&quot;Class 0&quot;</span>,<span class="hljs-string">&quot;Class 1&quot;</span>,<span class="hljs-string">&quot;Class 2&quot;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">help</span>(mglearn.discrete_scatter))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Help on function discrete_scatter in module mglearn.plot_helpers:discrete_scatter(x1, x2, y=None, markers=None, s=10, ax=None, labels=None, padding=0.2, alpha=1, c=None, markeredgewidth=None)    Adaption of matplotlib.pyplot.scatter to plot classes or clusters.        Parameters    ----------        x1 : nd-array        input data, first axis        x2 : nd-array        input data, second axis        y : nd-array        input data, discrete labels        cmap : colormap        Colormap to use.        markers : list of string        List of markers to use, or None (which defaults to &#39;o&#39;).        s : int or float        Size of the marker        padding : float        Fraction of the dataset range to use for padding the axes.        alpha : float        Alpha value for all points.None</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_52_1.png" alt="png"></p><p>现在，在这个数据集上训练一个 LinearSVC 分类器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">linear_svm=LinearSVC().fit(X,y)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Coefficient shape: &quot;</span>, linear_svm.coef_.shape)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Intercept shape: &quot;</span>, linear_svm.intercept_.shape)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Coefficient shape:  (3, 2)Intercept shape:  (3,)</code></pre><p>我们看到， coef_ 的形状是 (3, 2) ，说明 coef_ 每行包含三个类别之一的系数向量，每列包含某个特征（这个数据集有 2 个特征）对应的系数值。现在 intercept_ 是一维数组，保存每个类别的截距。</p><p>我们将这 3 个二类分类器给出的直线可视化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>mglearn.discrete_scatter(X[:, <span class="hljs-number">0</span>], X[:, <span class="hljs-number">1</span>], y)<br>line = np.linspace(-<span class="hljs-number">15</span>, <span class="hljs-number">15</span>)<br><span class="hljs-keyword">for</span> coef, intercept, color <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(linear_svm.coef_, linear_svm.intercept_, [<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>]):<br>    plt.plot(line, -(line*coef[<span class="hljs-number">0</span>]+intercept)/coef[<span class="hljs-number">1</span>], c=color)<br>plt.ylim(-<span class="hljs-number">10</span>,<span class="hljs-number">15</span>)<br>plt.xlim(-<span class="hljs-number">10</span>, <span class="hljs-number">8</span>)<br>plt.xlabel(<span class="hljs-string">&quot;Feature 0&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Feature 1&quot;</span>)<br>plt.legend([<span class="hljs-string">&#x27;Class 0&#x27;</span>, <span class="hljs-string">&#x27;Class 1&#x27;</span>, <span class="hljs-string">&#x27;Class 2&#x27;</span>, <span class="hljs-string">&#x27;Line class 0&#x27;</span>, <span class="hljs-string">&#x27;Line class 1&#x27;</span>,<br><span class="hljs-string">&#x27;Line class 2&#x27;</span>], loc=(<span class="hljs-number">1.01</span>, <span class="hljs-number">0.3</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.legend.Legend at 0x2537d7a06a0&gt;</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_56_1.png" alt="png"></p><p>你可以看到，训练集中所有属于类别 0 的点都在与类别 0 对应的直线上方，这说明它们位于这个二类分类器属于“类别 0”的那一侧。属于类别 0 的点位于与类别 2 对应的直线上方，这说明它们被类别 2 的二类分类器划为“其余”。属于类别 0 的点位于与类别 1 对应的直线左侧，这说明类别 1 的二元分类器将它们划为“其余”。因此，这一区域的所有点都会被最终分类器划为类别 0（类别 0 的分类器的分类置信方程的结果大于 0，其他两个类别对应的结果都小于 0）。</p><p>但<span class="mark">图像中间的三角形区域属于</span>哪一个类别呢，3 个二类分类器都将这一区域内的点划为“其余”。这里的点应该划归到哪一个类别呢？答案是<span class="mark">分类方程结果最大的那个类别，即最接近的那条线对应的类别</span>。下面的例子给出了二维空间中所有区域的预测结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">mglearn.plots.plot_2d_classification(linear_svm, X, fill=<span class="hljs-literal">True</span>, alpha=<span class="hljs-number">.6</span>)<br>mglearn.discrete_scatter(X[:, <span class="hljs-number">0</span>], X[:, <span class="hljs-number">1</span>], y)<br>line = np.linspace(-<span class="hljs-number">15</span>, <span class="hljs-number">15</span>)<br><span class="hljs-keyword">for</span> coef, intercept, color <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(linear_svm.coef_, linear_svm.intercept_,<br>[<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>]):<br>    plt.plot(line, -(line * coef[<span class="hljs-number">0</span>] + intercept) / coef[<span class="hljs-number">1</span>], c=color)<br>plt.legend([<span class="hljs-string">&#x27;Class 0&#x27;</span>, <span class="hljs-string">&#x27;Class 1&#x27;</span>, <span class="hljs-string">&#x27;Class 2&#x27;</span>, <span class="hljs-string">&#x27;Line class 0&#x27;</span>, <span class="hljs-string">&#x27;Line class 1&#x27;</span>,<br><span class="hljs-string">&#x27;Line class 2&#x27;</span>], loc=(<span class="hljs-number">1.01</span>, <span class="hljs-number">0.3</span>))<br>plt.xlabel(<span class="hljs-string">&quot;Feature 0&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Feature 1&quot;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Text(0, 0.5, &#39;Feature 1&#39;)</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_58_1.png" alt="png"></p><h2 id="7-优点，缺点和参数"><a href="#7-优点，缺点和参数" class="headerlink" title="7.优点，缺点和参数"></a>7.优点，缺点和参数</h2><p>线性模型的主要参数是正则化参数，在回归模型中叫作 alpha ，在 LinearSVC 和 Logistic-Regression 中叫作 C 。 alpha 值较大或 C 值较小，说明模型比较简单。特别是对于回归模型而言，调节这些参数非常重要。通常在对数尺度上对 C 和 alpha 进行搜索。你还需要确定的是用 L1 正则化还是 L2 正则化。如果你假定只有几个特征是真正重要的，那么你应该用L1 正则化，否则应默认使用 L2 正则化。如果模型的可解释性很重要的话，使用 L1 也会有帮助。由于 L1 只用到几个特征，所以更容易解释哪些特征对模型是重要的，以及这些特征的作用。</p><p>线性模型的训练速度非常快，预测速度也很快。这种模型可以推广到非常大的数据集，对稀疏数据也很有效。如果你的数据包含数十万甚至上百万个样本，你可能需要研究如何使用 LogisticRegression 和 Ridge 模型的 solver&#x3D;’sag’ 选项，在处理大型数据时，这一选项比默认值要更快。其他选项还有 SGDClassifier 类和 SGDRegressor 类，它们对本节介绍的线性模型实现了可扩展性更强的版本。</p><p>线性模型的另一个优点在于，利用我们之间见过的用于回归和分类的公式，理解如何进行预测是相对比较容易的。不幸的是，往往并不完全清楚系数为什么是这样的。如果你的数据集中包含高度相关的特征，这一问题尤为突出。在这种情况下，可能很难对系数做出解释。</p><p>如果<span class="mark">特征数量大于样本数量，线性模型的表现通常都很好</span>。它也常用于非常大的数据集，只是因为训练其他模型并不可行。但在更低维的空间中，其他模型的泛化性能可能更好。2.3.7 节会介绍几个线性模型不适用的例子。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>监督学习之决策树集成</title>
    <link href="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91%E9%9B%86%E6%88%90/"/>
    <url>/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91%E9%9B%86%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="监督学习之决策树集成"><a href="#监督学习之决策树集成" class="headerlink" title="监督学习之决策树集成"></a>监督学习之决策树集成</h1><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> mglearn<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>%matplotlib inline<br></code></pre></td></tr></table></figure><p><span class="burk">集成（ensemble）是合并多个机器学习模型来构建更强大模型的方法</span>。在机器学习文献中有许多模型都属于这一类，但已证明有两种集成模型对大量分类和回归的数据集都是有效的，二者都以决策树为基础，分别是<span class="mark">随机森林（random forest</span>）和<span class="girk">梯度提升决策树</span>（gradient boosted decision tree）。</p><h2 id="1-随机森林"><a href="#1-随机森林" class="headerlink" title="1.随机森林"></a>1.随机森林</h2><p>我们刚刚说过，决策树的一个主要缺点在于经常对训练数据过拟合。随机森林是解决这个问题的一种方法。随机森林本质上是许多决策树的集合，其中每棵树都和其他树略有不同。随机森林背后的思想是，每棵树的预测可能都相对较好，但可能对部分数据过拟合。如果构造很多树，并且每棵树的预测都很好，但都以不同的方式过拟合，那么我们可以对这些树的结果取平均值来降低过拟合。既能减少过拟合又能保持树的预测能力，这可以在数学上严格证明。</p><p>为了实现这一策略，我们需要构造许多决策树。每棵树都应该对目标值做出可以接受的预测，还应该与其他树不同。随机森林的名字来自于将随机性添加到树的构造过程中，以确保每棵树都各不相同。随机森林中树的随机化方法有两种：一种是通过选择用于构造树的数据点，另一种是通过选择每次划分测试的特征。我们来更深入地研究这一过程。</p><h3 id="1-1-构造随机森林"><a href="#1-1-构造随机森林" class="headerlink" title="1.1 构造随机森林"></a>1.1 构造随机森林</h3><p>想要构造一个随机森林模型，你需要确定用于构造的树的个数（ RandomForestRegressor 或 RandomForestClassifier 的 n_estimators 参数）。比如我们想要构造 10 棵树。这些树在构造时彼此完全独立，算法对每棵树进行不同的随机选择，以确保树和树之间是有区别的。想要构造一棵树，<span class="mark">首先要对数据进行自助采样（bootstrap sample）</span>。也就是说，从 n_samples 个数据点中有放回地（即同一样本可以被多次抽取）重复随机抽取一个样本，共抽取n_samples 次。这样会创建一个与原数据集大小相同的数据集，但有些数据点会缺失（大约三分之一），有些会重复。</p><p>举例说明，比如我们想要创建列表 [‘a’, ‘b’, ‘c’, ‘d’] 的自助采样。一种可能的自主采样是 [‘b’, ‘d’, ‘d’, ‘c’] ，另一种可能的采样为 [‘d’, ‘a’, ‘d’, ‘a’] 。</p><p>接下来，基于这个新创建的数据集来构造决策树。但是，要对我们在介绍决策树时描述的算法稍作修改。<span class="mark">在每个结点处，算法随机选择特征的一个子集，并对其中<span class="girk">一个特征</span>寻找最佳测试</span>，而不是对每个结点都寻找最佳测试<span class="girk">。选择的特征个数由 max_features 参数来控制</span>。每个结点中特征子集的选择是相互独立的，这样树的每个结点可以使用特征的不同子集来做出决策。</p><p>由于使用了自助采样，随机森林中构造每棵决策树的数据集都是略有不同的。由于每个结点的特征选择，每棵树中的每次划分都是基于特征的不同子集。这两种方法共同保证随机森林中所有树都不相同。</p><p>在这个过程中的一个关键参数是 max_features 。如果我们设置 max_features 等于n_features ，那么每次划分都要考虑数据集的所有特征，在特征选择的过程中没有添加随机性（不过自助采样依然存在随机性）。如果设置 max_features 等于 1 ，那么在划分时将无法选择对哪个特征进行测试，只能对随机选择的某个特征搜索不同的阈值。因此，如果 max_features 较大，那么随机森林中的树将会十分相似，利用最独特的特征可以轻松拟合数据。如果 max_features 较小，那么随机森林中的树将会差异很大，为了很好地拟合数据，每棵树的深度都要很大。</p><p>想要利用随机森林进行预测，算法首先对森林中的每棵树进行预测。对于回归问题，我们可以对这些结果<span class="girk"><span class="girk"><span class="girk">取平均值</span></span></span>作为最终预测。对于<span class="mark">分类问题</span>，则用到了“软投票”（soft voting）策略。也就是说，每个算法做出“软”预测，<span class="mark">给出每个可能的输出标签的概率。对所有树的预测概率取平均值，然后将<span class="girk">概率最大</span>的类别作为预测结果</span></p><h3 id="1-2-分析随机森林"><a href="#1-2-分析随机森林" class="headerlink" title="1.2 分析随机森林"></a>1.2 分析随机森林</h3><p>下面将由5棵树组成的随机森林应用到前面研究过的two_moons数据集上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> make_moons<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X,y=make_moons(n_samples=<span class="hljs-number">100</span>,noise=<span class="hljs-number">0.25</span>,random_state=<span class="hljs-number">3</span>)<br>X_train,X_test,y_train,y_test=train_test_split(X,y,stratify=y,random_state=<span class="hljs-number">42</span>)<br>forest=RandomForestClassifier(n_estimators=<span class="hljs-number">5</span>,random_state=<span class="hljs-number">2</span>)<br>forest.fit(X_train,y_train)<br></code></pre></td></tr></table></figure><pre><code class="hljs">RandomForestClassifier(bootstrap=True, class_weight=None, criterion=&#39;gini&#39;,                       max_depth=None, max_features=&#39;auto&#39;, max_leaf_nodes=None,                       min_impurity_decrease=0.0, min_impurity_split=None,                       min_samples_leaf=1, min_samples_split=2,                       min_weight_fraction_leaf=0.0, n_estimators=5,                       n_jobs=None, oob_score=False, random_state=2, verbose=0,                       warm_start=False)</code></pre><p>作为随机森林的一部分，树被保存在 estimator_ 属性中。我们将每棵树学到的决策边界可视化，也将它们的总预测（即整个森林做出的预测）可视化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">fig,axes=plt.subplots(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))<br><span class="hljs-keyword">for</span> i,(ax,tree) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(axes.ravel(),forest.estimators_)):<br>    ax.set_title(<span class="hljs-string">&quot;Tree &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i))<br>    mglearn.plots.plot_tree_partition(X_train,y_train,tree,ax=ax)<br>mglearn.plots.plot_2d_separator(forest,X_train,fill=<span class="hljs-literal">True</span>,ax=axes[-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>],alpha=<span class="hljs-number">.4</span>)<br>axes[-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>].set_title(<span class="hljs-string">&quot;Random Forest&quot;</span>)<br>mglearn.discrete_scatter(X_train[:,<span class="hljs-number">0</span>],X_train[:,<span class="hljs-number">1</span>],y_train)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[&lt;matplotlib.lines.Line2D at 0x24c9b4de9e8&gt;, &lt;matplotlib.lines.Line2D at 0x24c9d400f28&gt;]</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91%E9%9B%86%E6%88%90/output_8_1.png" alt="png"></p><p>你可以清楚地看到，这 5 棵树学到的决策边界大不相同。每棵树都犯了一些错误，因为这里画出的一些训练点实际上并没有包含在这些树的训练集中，原因在于自助采样。</p><p>随机森林比单独每一棵树的过拟合都要小，给出的决策边界也更符合直觉。在任何实际应用中，我们会用到更多棵树（通常是几百或上千），从而得到更平滑的边界。</p><p>再举一个例子，我们将包含 100 棵树的随机森林应用在乳腺癌数据集上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_breast_cancer<br>cancer=load_breast_cancer()<br>X_train,X_test,y_train,y_test=train_test_split(cancer.data,cancer.target,random_state=<span class="hljs-number">0</span>)<br>forest=RandomForestClassifier(n_estimators=<span class="hljs-number">100</span>,random_state=<span class="hljs-number">0</span>)<br>forest.fit(X_train,y_train)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on training set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(forest.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on test set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(forest.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Accuracy on training set: 1.000Accuracy on test set: 0.972</code></pre><p>在没有调节任何参数的情况下，随机森林的精度为 97%，比线性模型或单棵决策树都要好。我们可以调节 max_features 参数，或者像单棵决策树那样进行预剪枝。但是，随机森林的默认参数通常就已经可以给出很好的结果。</p><p>与决策树类似，随机森林也可以给出特征重要性，计算方法是将森林中所有树的特征重要性求和并取平均。一般来说，随机森林给出的特征重要性要比单棵树给出的更为可靠。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_feature_importance_cancer</span>(<span class="hljs-params">model</span>):<br>    n_features = cancer.data.shape[<span class="hljs-number">1</span>]<br>    <span class="hljs-comment">#barh():绘制水平方向的条形图，基本使用方法为：barh(y, width, height=0.8,align=&#x27;center&#x27;)</span><br>    <span class="hljs-comment">#参数详情：y:代表直方图在y轴上的位置</span><br>    <span class="hljs-comment">#width:代表直方图的宽度，即每个直方图具体的数值</span><br>    plt.barh(<span class="hljs-built_in">range</span>(n_features), model.feature_importances_, align=<span class="hljs-string">&#x27;center&#x27;</span>)<br>    <span class="hljs-comment">#plt.xticks/yticks设置轴记号，人为设置坐标轴的刻度显示的值，</span><br>    <span class="hljs-comment">#第一个参数代表坐标轴的位置，第二个参数代表显示的值，</span><br>    <span class="hljs-comment">#np.arrange 均匀地等分区间，支持步长为小数</span><br>    plt.yticks(np.arange(n_features), cancer.feature_names)<br>    plt.xlabel(<span class="hljs-string">&quot;Feature importance&quot;</span>)<br>    plt.ylabel(<span class="hljs-string">&quot;Feature&quot;</span>)<br><br>plot_feature_importance_cancer(forest)<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91%E9%9B%86%E6%88%90/output_13_0.png" alt="png"></p><p>如你所见，与单棵树相比，随机森林中有更多特征的重要性不为零。与单棵决策树类似，随机森林也给了“worst radius”（最大半径）特征很大的重要性，但从总体来看，它实际上却选择“worst perimeter”（最大周长）作为信息量最大的特征。由于构造随机森林过程中的随机性，算法需要考虑多种可能的解释，结果就是随机森林比单棵树更能从总体把握数据的特征。</p><h3 id="1-3-优点，缺点和参数"><a href="#1-3-优点，缺点和参数" class="headerlink" title="1.3 优点，缺点和参数"></a>1.3 优点，缺点和参数</h3><p><span class="mark">用于回归和分类的随机森林是目前应用最广泛的机器学习方法之一。这种方法非常强大，通常不需要反复调节参数就可以给出很好的结果，也不需要对数据进<br>行缩放。</span></p><p>从本质上看，随机森林拥有决策树的所有优点，同时弥补了决策树的一些缺陷。仍然使用决策树的一个原因是需要决策过程的紧凑表示。基本上不可能对几十棵甚至上百棵树做出详细解释，随机森林中树的深度往往比决策树还要大（因为用到了特征子集）。因此，如果你需要以可视化的方式向非专家总结预测过程，那么选择单棵决策树可能更好。虽然在大型数据集上构建随机森林可能比较费时间，但在一台计算机的多个 CPU 内核上并行计算也很容易。如果你用的是多核处理器（几乎所有的现代化计算机都是），你可以用 n_jobs 参数来调节使用的内核个数。使用更多的 CPU 内核，可以让速度线性增加（使用 2 个内核，随机森林的训练速度会加倍），但设置 n_jobs 大于内核个数是没有用的。你<span class="mark">可以设置 n_jobs&#x3D;-1 来使用计算机的所有内核</span>。</p><p>你应该记住，随机森林本质上是随机的，设置不同的随机状态（或者不设置 random_state参数）可以彻底改变构建的模型。森林中的树越多，它对随机状态选择的鲁棒性就越好。<span class="mark">如果你希望结果可以重现，固定 random_state 是很重要的</span>。</p><p>对于维度非常高的稀疏数据（比如文本数据），随机森林的表现往往不是很好。对于这种数据，使用线性模型可能更合适。即使是非常大的数据集，随机森林的表现通常也很好，训练过程很容易并行在功能强大的计算机的多个 CPU 内核上。不过，随机森林需要更大的内存，训练和预测的速度也比线性模型要慢。对一个应用来说，如果时间和内存很重要的话，那么换用线性模型可能更为明智。</p><p><span class="mark">需要调节的重要参数有 n_estimators 和 max_features ，可能还包括预剪枝选项（如 max_depth ）。 n_estimators 总是越大越好。</span>对更多的树取平均可以降低过拟合，从而得到鲁棒性更好的集成。不过收益是递减的，而且树越多需要的内存也越多，训练时间也越长。常用的经验法则就是“在你的时间 &#x2F; 内存允许的情况下尽量多”。</p><p>前面说过， max_features 决定每棵树的随机性大小，较小的 max_features 可以降低过拟合。一般来说，好的经验就是使用默认值：<span class="mark">对于分类，默认值是 max_features&#x3D;sqrt(n_features) ；对于回归，默认值是 max_features&#x3D;n_features 。</span>增大 max_features 或 max_leaf_nodes 有时也可以提高性能。它还可以大大降低用于训练和预测的时间和空间要求。</p><h2 id="2-梯度提升回归树-梯度提升机"><a href="#2-梯度提升回归树-梯度提升机" class="headerlink" title="2.梯度提升回归树(梯度提升机)"></a>2.梯度提升回归树(梯度提升机)</h2><p>梯度提升回归树是另一种集成方法，通过合并多个决策树来构建一个更为强大的模型。虽然名字中含有“回归”，但这个模型既可以用于回归也可以用于分类。与随机森林方法不同，梯度提升采用<span class="mark"><span class="girk">连续</span></span>的方式构造树，<span class="mark">每棵树都试图纠正前一棵树的错误</span>。默认情况下，梯度提升回归树中没有随机化，而是用到了<span class="mark"><span class="burk">强预剪枝</span></span>。梯度提升树通常使用深度很小（1 到 5 之间）的树，这样模型占用的内存更少，预测速度也更快。</p><p>梯度提升背后的主要思想是合并许多简单的模型（在这个语境中叫作弱学习器），比如深度较小的树。每棵树只能对部分数据做出好的预测，因此，添加的树越来越多，可以不断迭代提高性能。</p><p>梯度提升树经常是机器学习竞赛的优胜者，并且广泛应用于业界。与随机森林相比，它通常对参数设置更为敏感，但如果参数设置正确的话，模型精度更高。</p><p><span class="mark">除了预剪枝与集成中树的数量之外，梯度提升的另一个重要参数是 <span class="girk">learning_rate （学习率）</span></span>，用于控制每棵树纠正前一棵树的错误的强度。较高的学习率意味着每棵树都可以做出较强的修正，这样模型更为复杂。通过增大 n_estimators 来向集成中添加更多树，也可以增加模型复杂度，因为模型有更多机会纠正训练集上的错误。</p><p>下面是在乳腺癌数据集上应用 GradientBoostingClassifier 的示例。默认使用 100 棵树，最大深度是 3，学习率为 0.1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> GradientBoostingClassifier<br>X_train,X_test,y_train,y_test=train_test_split(cancer.data,cancer.target,random_state=<span class="hljs-number">0</span>)<br>gbrt=GradientBoostingClassifier(random_state=<span class="hljs-number">0</span>)<br>gbrt.fit(X_train,y_train)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on training set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(gbrt.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on test set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(gbrt.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Accuracy on training set: 1.000Accuracy on test set: 0.965</code></pre><p>由于训练集精度达到 100%，所以很可能存在过拟合。为了降低过拟合，我们可以限制最大深度来加强预剪枝，也可以降低学习率：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">gbrt=GradientBoostingClassifier(random_state=<span class="hljs-number">0</span>,max_depth=<span class="hljs-number">1</span>)<br>gbrt.fit(X_train,y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on training set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(gbrt.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on test set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(gbrt.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Accuracy on training set: 0.991Accuracy on test set: 0.972</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">gbrt = GradientBoostingClassifier(random_state=<span class="hljs-number">0</span>, learning_rate=<span class="hljs-number">0.01</span>)<br>gbrt.fit(X_train, y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on training set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(gbrt.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on test set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(gbrt.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Accuracy on training set: 0.988Accuracy on test set: 0.965</code></pre><p>降低模型复杂度的两种方法都降低了训练集精度，这和预期相同。在这个例子中，减小树的最大深度显著提升了模型性能，而降低学习率仅稍稍提高了泛化性能。</p><p>对于其他基于决策树的模型，我们也可以将特征重要性可视化，以便更好地理解模型<br><br>由于我们用到了 100 棵树，所以即使所有树的深度都是 1，查看所有树也是不现实的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">gbrt=GradientBoostingClassifier(random_state=<span class="hljs-number">0</span>,max_depth=<span class="hljs-number">1</span>)<br>gbrt.fit(X_train,y_train)<br>plot_feature_importance_cancer(gbrt)<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91%E9%9B%86%E6%88%90/output_22_0.png" alt="png"></p><p>可以看到，梯度提升树的特征重要性与随机森林的特征重要性有些类似，不过梯度提升完全忽略了某些特征。</p><p>由于梯度提升和随机森林两种方法在类似的数据上表现得都很好，因此一种常用的方法就是<span class="mark">先尝试随机森林</span>，它的鲁棒性很好。<span class="girk">如果随机森林效果很好，但预测时间太长，或者机器学习模型精度小数点后第二位的提高也很重要，那么切换成梯度提升通常会有用。</span></p><p>如果你想要将梯度提升应用在大规模问题上，可以研究一下 xgboost 包及其 Python 接口，在写作本书时，这个库在许多数据集上的速度都比 scikit-learn 对梯度提升的实现要快（有时调参也更简单）。</p><h2 id="2-1-优点，缺点和参数"><a href="#2-1-优点，缺点和参数" class="headerlink" title="2.1 优点，缺点和参数"></a>2.1 优点，缺点和参数</h2><p><span class="burk"><span class="girk"><span class="girk">梯度提升</span></span>决策树是监督学习中最强大也最常用的模型之一</span>。其主要缺点是需要仔细调参，而且训练时间可能会比较长。与其他基于树的模型类似，这一算法不需要对数据进行缩放就可以表现得很好，而且也适用于二元特征与连续特征同时存在的数据集。与其他基于树的模型相同，它也通常不适用于高维稀疏数据。（1是训练时间慢，2是特征选择会浪费大量的有效特征）</p><p><span class="mark">梯度提升树模型的主要参数包括树的数量 n_estimators 和学习率 learning_rate</span> ，后者用于控制每棵树对前一棵树的错误的纠正强度。这两个参数高度相关，因为 learning_rate 越低，就需要更多的树来构建具有相似复杂度的模型。<span class="mark">随机森林的 n_estimators 值总是越大越好</span>，但<span class="girk">梯度提升不同</span>，增大 n_estimators 会导致模型更加复杂，进而可能导致过拟合。通常的做法是根据时间和内存的预算选择<span class="girk">合适的 n_estimators ，然后对不同的learning_rate 进行遍历</span>。</p><p>另一个重要参数是 max_depth （或 max_leaf_nodes ），用于降低每棵树的复杂度。梯度提升模型的 <span class="mark">max_depth 通常都设置得很小，一般不超过 5。</span></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>监督学习之k近邻</title>
    <link href="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8Bk%E8%BF%91%E9%82%BB/"/>
    <url>/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8Bk%E8%BF%91%E9%82%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="监督学习之k近邻"><a href="#监督学习之k近邻" class="headerlink" title="监督学习之k近邻"></a>监督学习之k近邻</h1><span id="more"></span><h2 id="所需要的所有包"><a href="#所需要的所有包" class="headerlink" title="所需要的所有包"></a>所需要的所有包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> mglearn<br>%matplotlib inline<br><span class="hljs-comment"># 由于 %matplotlib inline 的存在，当输入plt.plot(x,y_1)后，不必再输入 plt.show()</span><br><span class="hljs-comment">#图像将自动显示出来</span><br><br></code></pre></td></tr></table></figure><h2 id="1-k近邻分类"><a href="#1-k近邻分类" class="headerlink" title="1.k近邻分类"></a>1.k近邻分类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> mglearn<br>%matplotlib inline<br>mglearn.plots.plot_knn_classification(n_neighbors=<span class="hljs-number">1</span>)<br><br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8Bk%E8%BF%91%E9%82%BB/output_3_0.png" alt="png"></p><p>除了仅考虑最近邻，我还可以考虑任意个（k 个）邻居。这也是 k 近邻算法名字的来历。在考虑多于一个邻居的情况时，我们<span class="burk">用“投票法”（voting）来指定标签</span>。也就是说，对于每个测试点，我们数一数多少个邻居属于类别 0，多少个邻居属于类别 1。然后将出现<span class="mark">次数更多的类别（也就是 k 个近邻中占多数的类别）作为预测结果</span>。下面的例子（图 2-5）用到了 3 个近邻：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mglearn.plots.plot_knn_classification(n_neighbors=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8Bk%E8%BF%91%E9%82%BB/output_5_0.png" alt="png"></p><p>通过scikit-learn来应用k近邻算法</p><ul><li>导入类并将其实例化。这时可以设定参数，如邻居的个数</li><li>利用训练集对这个分类器进行拟合</li><li>调用 predict 方法来对测试数据进行预测</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X,y=mglearn.datasets.make_forge()<br>X_train,X_test,y_train,y_test=train_test_split(X,y,random_state=<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br>clf=KNeighborsClassifier(n_neighbors=<span class="hljs-number">3</span>)<br>clf.fit(X_train,y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set predictions: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(clf.predict(X_test)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set accuracy: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(clf.score(X_test,y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Test set predictions: [1 0 1 0 1 0 0]Test set accuracy: 0.86</code></pre><h2 id="2-分析KNeighborsClassifier"><a href="#2-分析KNeighborsClassifier" class="headerlink" title="2.分析KNeighborsClassifier"></a>2.分析KNeighborsClassifier</h2><p>对于二维数据集，我们还可以在 xy 平面上画出所有可能的测试点的预测结果。我们根据平面中每个点所属的类别对平面进行着色。这样可以查看决策边界（decision boundary），即算法对类别 0 和类别 1 的分界线。</p><p>zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。<br><br>zip 方法在 Python 2 和 Python 3 中的不同：在 Python 3.x 中为了减少内存，zip() 返回的是一个对象。如需展示列表，需手动 list() 转换。</p><p>subplots参数与subplots相似。<br><br>两者都可以规划figure划分为n个子图，但每条subplot命令只会创建一个子图，而一条subplots就可以将所有子图创建好。<br><br>subplots用法示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br> <br>x = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br><span class="hljs-comment">#划分子图</span><br>fig,axes=plt.subplots(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>ax1=axes[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>ax2=axes[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>ax3=axes[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>ax4=axes[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br> <br><span class="hljs-comment">#作图1</span><br>ax1.plot(x, x)<br><span class="hljs-comment">#作图2</span><br>ax2.plot(x, -x)<br><span class="hljs-comment">#作图3</span><br>ax3.plot(x, x ** <span class="hljs-number">2</span>)<br>ax3.grid(color=<span class="hljs-string">&#x27;r&#x27;</span>, linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, linewidth=<span class="hljs-number">1</span>,alpha=<span class="hljs-number">0.3</span>)<br><span class="hljs-comment">#作图4</span><br>ax4.plot(x, np.log(x))<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8Bk%E8%BF%91%E9%82%BB/output_11_1.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">fig,axes=plt.subplots(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">3</span>))<br><span class="hljs-keyword">for</span> n_neighbors,ax <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>],axes):<br>    clf=KNeighborsClassifier(n_neighbors=n_neighbors).fit(X,y)<br>    mglearn.plots.plot_2d_separator(clf,X,fill=<span class="hljs-literal">True</span>,eps=<span class="hljs-number">0.5</span>,ax=ax,alpha=<span class="hljs-number">.4</span>)<br>    mglearn.discrete_scatter(X[:,<span class="hljs-number">0</span>],X[:,<span class="hljs-number">1</span>],y,ax=ax)<br>    ax.set_title(<span class="hljs-string">&quot;&#123;&#125; neighbor(s)&quot;</span>.<span class="hljs-built_in">format</span>(n_neighbors))<br>    ax.set_xlabel(<span class="hljs-string">&quot;feature 0&quot;</span>)<br>    ax.set_ylabel(<span class="hljs-string">&quot;feature 1&quot;</span>)<br>axes[<span class="hljs-number">0</span>].legend(loc=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.legend.Legend at 0x242302ba9b0&gt;</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8Bk%E8%BF%91%E9%82%BB/output_12_1.png" alt="png"></p><p>用单一邻居绘制的决策边界紧跟着训练数据。随着邻居个数越来越多，决策边界也越来越平滑。更平滑的边界对应更简单的模型。换句话说，使用更少的邻居对应更高的模型复杂度，而使用更多的邻居对应更低的模型复杂度。假如考虑极端情况，即邻居个数等于训练集中所有数据点的个数，那么每个测试点的邻居都完全相同（即所有训练点），所有预测结果也完全相同（即训练集中出现次数最多的类别）。</p><p>在现实世界的乳腺癌数据集上进行研究，证实模型复杂度和泛化能力的关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_breast_cancer<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> neighbors<br>cancer=load_breast_cancer()  <span class="hljs-comment">#加载癌症数据集</span><br>X_train,X_test,y_train,y_test=train_test_split(cancer.data,cancer.target,<br>                                                stratify=cancer.target,random_state=<span class="hljs-number">66</span>)<br><br>training_accuracy=[]<br>test_accuracy=[]<br><br><span class="hljs-comment">#neighbors取值从1到10</span><br>neighbors_settings=<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>)<br><br><span class="hljs-keyword">for</span> n_neighbors <span class="hljs-keyword">in</span> neighbors_settings:<br>    clf=KNeighborsClassifier(n_neighbors=n_neighbors)<br>    clf.fit(X_train,y_train)<br>    training_accuracy.append(clf.score(X_train,y_train))<br>    test_accuracy.append(clf.score(X_test,y_test))<br>    <br>plt.plot(neighbors_settings,training_accuracy,label=<span class="hljs-string">&quot;trainning accuracy&quot;</span>)<br>plt.plot(neighbors_settings,test_accuracy,label=<span class="hljs-string">&quot;test_accuracy&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Accuracy&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;n_neighbors&quot;</span>)<br>plt.legend()<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.legend.Legend at 0x24230a4b5c0&gt;</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8Bk%E8%BF%91%E9%82%BB/output_15_1.png" alt="png"></p><p>仅考虑单一近邻时，训练集上的预测结果十分完美。但随着邻居个数的增多，模型变得更简单，训练集精度也随之下降。单一邻居时的测试集精度比使用更多邻居时要低，这表示单一近邻的模型过于复杂。与之相反，当考虑 10 个邻居时，模型又过于简单，性能甚至变得更差。最佳性能在中间的某处，邻居个数大约为 6。不过最好记住这张图的坐标轴刻度。最差的性能约为 88% 的精度，这个结果仍然可以接受。</p><h2 id="3-K近邻回归"><a href="#3-K近邻回归" class="headerlink" title="3.K近邻回归"></a>3.K近邻回归</h2><p>k近邻算法还可以用于回归(把邻居的平均值赋给目标)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mglearn.plots.plot_knn_regression(n_neighbors=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8Bk%E8%BF%91%E9%82%BB/output_18_0.png" alt="png"></p><p>用多个近邻进行回归,预测结果为这些邻居的平均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mglearn.plots.plot_knn_regression(n_neighbors=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8Bk%E8%BF%91%E9%82%BB/output_20_0.png" alt="png"></p><p>用于回归的k近邻算法在sklearn的KNeighborsRegressor类中实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsRegressor<br>X,y=mglearn.datasets.make_wave(n_samples=<span class="hljs-number">40</span>)<br><span class="hljs-comment"># 划分训练数据集</span><br>X_train,X_test,y_train,y_test=train_test_split(X,y,random_state=<span class="hljs-number">0</span>)<br><span class="hljs-comment"># 实例化模型，邻居设定为3</span><br>reg=KNeighborsRegressor(n_neighbors=<span class="hljs-number">3</span>)<br><span class="hljs-comment"># 拟合模型</span><br>reg.fit(X_train,y_train)<br><br><br></code></pre></td></tr></table></figure><pre><code class="hljs">KNeighborsRegressor(algorithm=&#39;auto&#39;, leaf_size=30, metric=&#39;minkowski&#39;,                    metric_params=None, n_jobs=None, n_neighbors=3, p=2,                    weights=&#39;uniform&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set predictions:\n&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(reg.predict(X_test)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set R^2:&#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(reg.score(X_test,y_test)))<br><br><br></code></pre></td></tr></table></figure><pre><code class="hljs">Test set predictions:[-0.05396539  0.35686046  1.13671923 -1.89415682 -1.13881398 -1.63113382  0.35686046  0.91241374 -0.44680446 -1.13881398]Test set R^2:0.83</code></pre><p>可以用score方法来评估模型，对于回归问题，这一方法返回的是$R^2$分数，也叫做决定系数，是回归模型预测的优度度量，位于0到1之间，1完美预测，0对于常数模型，即总是预测训练集响应(y_train)的平均值</p><h2 id="4-分析KNeigborsRegressor"><a href="#4-分析KNeigborsRegressor" class="headerlink" title="4.分析KNeigborsRegressor"></a>4.分析KNeigborsRegressor</h2><p>对于我们的一维数据集，可以查看所有特征取值对应的预测结果（图 2-10）。为了便于绘<br>图，我们创建一个由许多点组成的测试数据集</p><p>np reshape  array  linespace 用法：<br>numpy.arange(n).reshape(a, b); 依次生成n个自然数，并且以a行b列的数组形式显示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-built_in">print</span>(np.array([<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>))<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">[[1] [1] [1]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(np.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-number">2</span>).reshape(<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[  1.] [100.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">fig,axes=plt.subplots(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,figsize=(<span class="hljs-number">15</span>,<span class="hljs-number">4</span>))<br><span class="hljs-comment">#创建1000个数据点，在-3和3之间均匀分布</span><br>line=np.linspace(-<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1000</span>).reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> n_neighbors,ax <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>],axes):<br>    reg=KNeighborsRegressor(n_neighbors=n_neighbors)<br>    reg.fit(X_train,y_train)<br>    ax.plot(line,reg.predict(line))<br>    ax.plot(X_train,y_train,<span class="hljs-string">&#x27;^&#x27;</span>,c=mglearn.cm2(<span class="hljs-number">0</span>),markersize=<span class="hljs-number">8</span>)<br>    ax.plot(X_test,y_test,<span class="hljs-string">&#x27;v&#x27;</span>,c=mglearn.cm2(<span class="hljs-number">1</span>),markersize=<span class="hljs-number">8</span>)<br>    ax.set_title(<br>    <span class="hljs-string">&quot;&#123;&#125; neighbor(s) \n train score:&#123;:.2f&#125; test_score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>    n_neighbors,reg.score(X_train,y_train),reg.score(X_test,y_test)))<br>    ax.set_xlabel(<span class="hljs-string">&quot;Feature&quot;</span>)<br>    ax.set_ylabel(<span class="hljs-string">&quot;Target&quot;</span>)<br>axes[<span class="hljs-number">0</span>].legend([<span class="hljs-string">&quot;Model predictions&quot;</span>,<span class="hljs-string">&quot;Training data/target&quot;</span>,<br>               <span class="hljs-string">&quot;Test data/target&quot;</span>],loc=<span class="hljs-string">&quot;best&quot;</span>)<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.legend.Legend at 0x2422e47e5c0&gt;</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8Bk%E8%BF%91%E9%82%BB/output_29_1.png" alt="png"></p><p>从图中可以看出，仅使用单一邻居，训练集中的每个点都对预测结果有显著影响，预测结果的图像经过所有数据点。这导致预测结果非常不稳定。考虑更多的邻居之后，预测结果变得更加平滑，但对训练数据的拟合也不好。</p><h2 id="5-优点，缺点和参数"><a href="#5-优点，缺点和参数" class="headerlink" title="5.优点，缺点和参数"></a>5.优点，缺点和参数</h2><p>一般来说， KNeighbors 分类器有 2 个重要参数：邻居个数与数据点之间距离的度量方法。在实践中，使用较小的邻居个数（比如 3 个或 5 个）往往可以得到比较好的结果，但你应该调节这个参数。选择合适的距离度量方法超出了本书的范围。默认使用欧式距离，它在许多情况下的效果都很好。</p><p>k-NN 的优点之一就是模型很容易理解，通常不需要过多调节就可以得到不错的性能。在考虑使用更高级的技术之前，尝试此算法是一种很好的基准方法。构建最近邻模型的速度通常很快，但如果训练集很大（特征数很多或者样本数很大），预测速度可能会比较慢。使用 k-NN 算法时，对数据进行预处理是很重要的（见第 3 章）。这一算法对于有很多特征（几百或更多）的数据集往往效果不好，对于大多数特征的大多数取值都为 0 的数据集（所谓的稀疏数据集）来说，这一算法的效果尤其不好。</p><p>虽然 k 近邻算法很容易理解，但由于预测速度慢且不能处理具有很多特征的数据集，所以在实践中往往不会用到</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>鸢尾花的例子</title>
    <link href="/2019/10/05/%E9%B8%A2%E5%B0%BE%E8%8A%B1%E7%9A%84%E4%BE%8B%E5%AD%90/"/>
    <url>/2019/10/05/%E9%B8%A2%E5%B0%BE%E8%8A%B1%E7%9A%84%E4%BE%8B%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="监督学习问题：预测花的品种"><a href="#监督学习问题：预测花的品种" class="headerlink" title="监督学习问题：预测花的品种"></a>监督学习问题：预测花的品种</h1><span id="more"></span><p>数据分类：花瓣：长度，宽度；花萼：长度，宽度   单位厘米<br>花的品种：setosa，versicolor，virginica<br>目标：构建机器学习模型，从已有的测量数据进行学习，预测新花的品种</p><h2 id="1-认识数据"><a href="#1-认识数据" class="headerlink" title="1.认识数据"></a>1.认识数据</h2><p>加载必要的库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <span class="hljs-comment">#矩阵运算</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt  <span class="hljs-comment">#绘图</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd  <span class="hljs-comment">#基于numpy的数据分析库</span><br><span class="hljs-keyword">import</span> mglearn <span class="hljs-comment">#美化图像</span><br></code></pre></td></tr></table></figure><p>鸢尾花(iris)数据集，是机器学习和统计学中一个经典的数据集<br><br>包含在scikit-learn的datasets模块中<br><br>可以通过调用load_iris函数来加载数据<br><br>scikit是一个建立在Scipy基础上用于机器学习的python模块，包含众多顶级机器学习算法<br><br>Scipy包含的功能有最优化、线性代数、积分、插值、拟合、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算<br>Scipy是一个用于数学、科学、工程领域的常用软件包，可以处理插值、积分、优化、图像处理、常微分方程数值解的求解、信号处理等问题。它用于有效计算Numpy矩阵，使Numpy和Scipy协同工作，高效解决问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris<br>iris_dataset=load_iris()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;keys of iris_dataset: \n&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(iris_dataset.keys()))<br></code></pre></td></tr></table></figure><pre><code class="hljs">keys of iris_dataset: dict_keys([&#39;data&#39;, &#39;target&#39;, &#39;target_names&#39;, &#39;DESCR&#39;, &#39;feature_names&#39;, &#39;filename&#39;])</code></pre><p>load_iris返回的iris对象是一个Bunch对象，包含键，值，以下输出各个键对应的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> iris_dataset.keys():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;对应值为：&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(iris_dataset[i],end=<span class="hljs-string">&#x27;\n&#x27;</span>)<br>    <br><br></code></pre></td></tr></table></figure><pre><code class="hljs">data对应值为：[[5.1 3.5 1.4 0.2] [4.9 3.  1.4 0.2] [4.7 3.2 1.3 0.2] [4.6 3.1 1.5 0.2] [5.  3.6 1.4 0.2] [5.4 3.9 1.7 0.4] [4.6 3.4 1.4 0.3] [5.  3.4 1.5 0.2] [4.4 2.9 1.4 0.2] [4.9 3.1 1.5 0.1] [5.4 3.7 1.5 0.2] [4.8 3.4 1.6 0.2] [4.8 3.  1.4 0.1] [4.3 3.  1.1 0.1] [5.8 4.  1.2 0.2] [5.7 4.4 1.5 0.4] [5.4 3.9 1.3 0.4] [5.1 3.5 1.4 0.3] [5.7 3.8 1.7 0.3] [5.1 3.8 1.5 0.3] [5.4 3.4 1.7 0.2] [5.1 3.7 1.5 0.4] [4.6 3.6 1.  0.2] [5.1 3.3 1.7 0.5] [4.8 3.4 1.9 0.2] [5.  3.  1.6 0.2] [5.  3.4 1.6 0.4] [5.2 3.5 1.5 0.2] [5.2 3.4 1.4 0.2] [4.7 3.2 1.6 0.2] [4.8 3.1 1.6 0.2] [5.4 3.4 1.5 0.4] [5.2 4.1 1.5 0.1] [5.5 4.2 1.4 0.2] [4.9 3.1 1.5 0.2] [5.  3.2 1.2 0.2] [5.5 3.5 1.3 0.2] [4.9 3.6 1.4 0.1] [4.4 3.  1.3 0.2] [5.1 3.4 1.5 0.2] [5.  3.5 1.3 0.3] [4.5 2.3 1.3 0.3] [4.4 3.2 1.3 0.2] [5.  3.5 1.6 0.6] [5.1 3.8 1.9 0.4] [4.8 3.  1.4 0.3] [5.1 3.8 1.6 0.2] [4.6 3.2 1.4 0.2] [5.3 3.7 1.5 0.2] [5.  3.3 1.4 0.2] [7.  3.2 4.7 1.4] [6.4 3.2 4.5 1.5] [6.9 3.1 4.9 1.5] [5.5 2.3 4.  1.3] [6.5 2.8 4.6 1.5] [5.7 2.8 4.5 1.3] [6.3 3.3 4.7 1.6] [4.9 2.4 3.3 1. ] [6.6 2.9 4.6 1.3] [5.2 2.7 3.9 1.4] [5.  2.  3.5 1. ] [5.9 3.  4.2 1.5] [6.  2.2 4.  1. ] [6.1 2.9 4.7 1.4] [5.6 2.9 3.6 1.3] [6.7 3.1 4.4 1.4] [5.6 3.  4.5 1.5] [5.8 2.7 4.1 1. ] [6.2 2.2 4.5 1.5] [5.6 2.5 3.9 1.1] [5.9 3.2 4.8 1.8] [6.1 2.8 4.  1.3] [6.3 2.5 4.9 1.5] [6.1 2.8 4.7 1.2] [6.4 2.9 4.3 1.3] [6.6 3.  4.4 1.4] [6.8 2.8 4.8 1.4] [6.7 3.  5.  1.7] [6.  2.9 4.5 1.5] [5.7 2.6 3.5 1. ] [5.5 2.4 3.8 1.1] [5.5 2.4 3.7 1. ] [5.8 2.7 3.9 1.2] [6.  2.7 5.1 1.6] [5.4 3.  4.5 1.5] [6.  3.4 4.5 1.6] [6.7 3.1 4.7 1.5] [6.3 2.3 4.4 1.3] [5.6 3.  4.1 1.3] [5.5 2.5 4.  1.3] [5.5 2.6 4.4 1.2] [6.1 3.  4.6 1.4] [5.8 2.6 4.  1.2] [5.  2.3 3.3 1. ] [5.6 2.7 4.2 1.3] [5.7 3.  4.2 1.2] [5.7 2.9 4.2 1.3] [6.2 2.9 4.3 1.3] [5.1 2.5 3.  1.1] [5.7 2.8 4.1 1.3] [6.3 3.3 6.  2.5] [5.8 2.7 5.1 1.9] [7.1 3.  5.9 2.1] [6.3 2.9 5.6 1.8] [6.5 3.  5.8 2.2] [7.6 3.  6.6 2.1] [4.9 2.5 4.5 1.7] [7.3 2.9 6.3 1.8] [6.7 2.5 5.8 1.8] [7.2 3.6 6.1 2.5] [6.5 3.2 5.1 2. ] [6.4 2.7 5.3 1.9] [6.8 3.  5.5 2.1] [5.7 2.5 5.  2. ] [5.8 2.8 5.1 2.4] [6.4 3.2 5.3 2.3] [6.5 3.  5.5 1.8] [7.7 3.8 6.7 2.2] [7.7 2.6 6.9 2.3] [6.  2.2 5.  1.5] [6.9 3.2 5.7 2.3] [5.6 2.8 4.9 2. ] [7.7 2.8 6.7 2. ] [6.3 2.7 4.9 1.8] [6.7 3.3 5.7 2.1] [7.2 3.2 6.  1.8] [6.2 2.8 4.8 1.8] [6.1 3.  4.9 1.8] [6.4 2.8 5.6 2.1] [7.2 3.  5.8 1.6] [7.4 2.8 6.1 1.9] [7.9 3.8 6.4 2. ] [6.4 2.8 5.6 2.2] [6.3 2.8 5.1 1.5] [6.1 2.6 5.6 1.4] [7.7 3.  6.1 2.3] [6.3 3.4 5.6 2.4] [6.4 3.1 5.5 1.8] [6.  3.  4.8 1.8] [6.9 3.1 5.4 2.1] [6.7 3.1 5.6 2.4] [6.9 3.1 5.1 2.3] [5.8 2.7 5.1 1.9] [6.8 3.2 5.9 2.3] [6.7 3.3 5.7 2.5] [6.7 3.  5.2 2.3] [6.3 2.5 5.  1.9] [6.5 3.  5.2 2. ] [6.2 3.4 5.4 2.3] [5.9 3.  5.1 1.8]]target对应值为：[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2]target_names对应值为：[&#39;setosa&#39; &#39;versicolor&#39; &#39;virginica&#39;]DESCR对应值为：.. _iris_dataset:Iris plants dataset--------------------**Data Set Characteristics:**    :Number of Instances: 150 (50 in each of three classes)    :Number of Attributes: 4 numeric, predictive attributes and the class    :Attribute Information:        - sepal length in cm        - sepal width in cm        - petal length in cm        - petal width in cm        - class:                - Iris-Setosa                - Iris-Versicolour                - Iris-Virginica                    :Summary Statistics:    ============== ==== ==== ======= ===== ====================                    Min  Max   Mean    SD   Class Correlation    ============== ==== ==== ======= ===== ====================    sepal length:   4.3  7.9   5.84   0.83    0.7826    sepal width:    2.0  4.4   3.05   0.43   -0.4194    petal length:   1.0  6.9   3.76   1.76    0.9490  (high!)    petal width:    0.1  2.5   1.20   0.76    0.9565  (high!)    ============== ==== ==== ======= ===== ====================    :Missing Attribute Values: None    :Class Distribution: 33.3% for each of 3 classes.    :Creator: R.A. Fisher    :Donor: Michael Marshall (MARSHALL%PLU@io.arc.nasa.gov)    :Date: July, 1988The famous Iris database, first used by Sir R.A. Fisher. The dataset is takenfrom Fisher&#39;s paper. Note that it&#39;s the same as in R, but not as in the UCIMachine Learning Repository, which has two wrong data points.This is perhaps the best known database to be found in thepattern recognition literature.  Fisher&#39;s paper is a classic in the field andis referenced frequently to this day.  (See Duda &amp; Hart, for example.)  Thedata set contains 3 classes of 50 instances each, where each class refers to atype of iris plant.  One class is linearly separable from the other 2; thelatter are NOT linearly separable from each other... topic:: References   - Fisher, R.A. &quot;The use of multiple measurements in taxonomic problems&quot;     Annual Eugenics, 7, Part II, 179-188 (1936); also in &quot;Contributions to     Mathematical Statistics&quot; (John Wiley, NY, 1950).   - Duda, R.O., &amp; Hart, P.E. (1973) Pattern Classification and Scene Analysis.     (Q327.D83) John Wiley &amp; Sons.  ISBN 0-471-22361-1.  See page 218.   - Dasarathy, B.V. (1980) &quot;Nosing Around the Neighborhood: A New System     Structure and Classification Rule for Recognition in Partially Exposed     Environments&quot;.  IEEE Transactions on Pattern Analysis and Machine     Intelligence, Vol. PAMI-2, No. 1, 67-71.   - Gates, G.W. (1972) &quot;The Reduced Nearest Neighbor Rule&quot;.  IEEE Transactions     on Information Theory, May 1972, 431-433.   - See also: 1988 MLC Proceedings, 54-64.  Cheeseman et al&quot;s AUTOCLASS II     conceptual clustering system finds 3 classes in the data.   - Many, many more ...feature_names对应值为：[&#39;sepal length (cm)&#39;, &#39;sepal width (cm)&#39;, &#39;petal length (cm)&#39;, &#39;petal width (cm)&#39;]filename对应值为：E:\Python\Anaconda\lib\site-packages\sklearn\datasets\data\iris.csv</code></pre><p>对数据进行说明：<br>data：每一行4个数对应花瓣的长宽，花萼的长宽<br><br>target：每一朵花对应的类别，0,1,2对应target_name的下标<br><br>target_name:花的类别集合<br><br>DESCR：数据集的简要说明<br><br>feature_name：数据说明，声明每一个特征<br><br>(机器学习中的个体叫做样本，其属性叫做特征)<br></p><h2 id="2-训练和测试数据"><a href="#2-训练和测试数据" class="headerlink" title="2.训练和测试数据"></a>2.训练和测试数据</h2><p>构建机器学习模型<br><br>已有数据集分为两部分，一部分构建模型，一部分测试模型<br><br>scikit-learn中的train_test_split函数可以打乱数据集并进行拆分<br><br>将75%的行数据及对应标签作为训练集，25%作为训练集，这是推荐分配方式<br><br>scikit-learn 中的数据通常用大写的 X 表示，而标签用小写的 y 表示。<br><br>这是受到了数学标准公式 f(x)&#x3D;y 的启发，其中 x 是函数的输入，y 是输出。我们用大写的 X 是因为数据是一个二维数组（矩阵），用小写的 y 是因为目标是一个一维数组（向量），这也是数学中的约定。</p><h3 id="对数据调用train-test-split划分数据集"><a href="#对数据调用train-test-split划分数据集" class="headerlink" title="对数据调用train_test_split划分数据集"></a>对数据调用train_test_split划分数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X_train,X_test,y_train,y_test=train_test_split(iris_dataset[<span class="hljs-string">&#x27;data&#x27;</span>],<br>iris_dataset[<span class="hljs-string">&#x27;target&#x27;</span>],random_state=<span class="hljs-number">0</span>) <span class="hljs-comment">#为了保证多次运行同一函数能得到相同输出，利用random_state指定了生成随机参数的种子</span><br><span class="hljs-comment">#输出的结果都是Numpy数组</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;X_train shape: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(X_train.shape))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;y_train shape: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(y_train.shape))<br></code></pre></td></tr></table></figure><pre><code class="hljs">X_train shape: (112, 4)y_train shape: (112,)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x_test shape: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(X_test.shape))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;y_test shape: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(y_test.shape))<br></code></pre></td></tr></table></figure><pre><code class="hljs">x_test shape: (38, 4)y_test shape: (38,)</code></pre><h2 id="3-观察数据"><a href="#3-观察数据" class="headerlink" title="3.观察数据"></a>3.观察数据</h2><p>构建机器学习模型之前，检测数据，排查异常数据<br><br>利用数据可视化：</p><ul><li>绘制散点图：分为x，y轴，一次只能绘制两个特征</li><li>绘制散点图矩阵：无法同时显示所有特征之间的关系</li></ul><h3 id="利用pandas的scatter-matrix函数绘制散点图矩阵"><a href="#利用pandas的scatter-matrix函数绘制散点图矩阵" class="headerlink" title="利用pandas的scatter_matrix函数绘制散点图矩阵"></a>利用pandas的scatter_matrix函数绘制散点图矩阵</h3><h4 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释:"></a>参数解释:</h4><p>frame：数据的dataframe,本例为4<em>150的矩阵;<br><br>c是颜色,本例中按照y_train的不同来分配不同的颜色;<br><br>figsize设置图片的尺寸;<br><br>marker是散点的形状,’o’是圆形,’</em>‘是星形 ;<br><br>hist_kwds是直方图的相关参数,{‘bins’:20}是生成包含20个长条的直方图;<br><br>s是大图的尺寸 ; <br><br>alpha是图的透明度;<br><br>cmap是colourmap,就是颜色板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> mglearn<br><span class="hljs-comment">#利用X_train中的数据创建DataFrame</span><br><span class="hljs-comment">#利用iris_dataset.feature_names中的字符串对数据列进行标记</span><br>iris_dataframe=pd.DataFrame(X_train,columns=iris_dataset.feature_names)<br><span class="hljs-comment">#利用DataFrame创建散点图矩阵，按y_train着色</span><br>grr=pd.plotting.scatter_matrix(iris_dataframe,c=y_train,figsize=(<span class="hljs-number">15</span>,<span class="hljs-number">15</span>),marker=<span class="hljs-string">&#x27;o&#x27;</span>,<br>                              hist_kwds=&#123;<span class="hljs-string">&#x27;bins&#x27;</span>:<span class="hljs-number">20</span>&#125;,s=<span class="hljs-number">60</span>,alpha=<span class="hljs-number">.8</span>,cmap=mglearn.cm3)<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E9%B8%A2%E5%B0%BE%E8%8A%B1%E7%9A%84%E4%BE%8B%E5%AD%90/output_18_0.png" alt="png"></p><h2 id="4-KNN算法"><a href="#4-KNN算法" class="headerlink" title="4.KNN算法"></a>4.KNN算法</h2><p>开始构建机器学习模型<br><br>skikit-learn中有许多<br>可用的分类算法<br><br>这里采用k近邻算法：<br>考虑训练集中与新数据点最近的任意 k 个邻居（比如说，距离最近的 3 个或 5 个邻居），而不是只考虑最近的那一个。然后，我们可以用这些邻居中数量最多的类别做出预测<br><br>scikit-learn 中所有的机器学习模型都在各自的类中实现，这些类被称为 Estimator类。k 近邻分类算法是在 neighbors 模块的 KNeighborsClassifier 类中实现的。我们需要将这个类实例化为一个对象，然后才能使用这个模型。这时我们需要设置模型的参数。KNeighborsClassifier 最重要的参数就是邻居的数目，这里我们设为 1 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br>knn=KNeighborsClassifier(n_neighbors=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>想要基于训练集来构建模型，需要调用 knn 对象的 fit 方法，输入参数为 X_train 和 y_train<br><br>二者都是 NumPy 数组，前者包含训练数据，后者包含相应的训练标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">knn.fit(X_train,y_train)<br></code></pre></td></tr></table></figure><pre><code class="hljs">KNeighborsClassifier(algorithm=&#39;auto&#39;, leaf_size=30, metric=&#39;minkowski&#39;,                     metric_params=None, n_jobs=None, n_neighbors=1, p=2,                     weights=&#39;uniform&#39;)</code></pre><h2 id="5-预测和评估"><a href="#5-预测和评估" class="headerlink" title="5.预测和评估"></a>5.预测和评估</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">y_pred=knn.predict(X_test)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set predictions:\n &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(y_pred))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Test set predictions: [2 1 0 2 0 2 0 1 1 1 2 1 1 1 1 0 1 1 0 0 2 1 0 0 2 0 0 1 1 0 2 1 0 2 2 1 0 2]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(np.mean(y_pred==y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Test set score: 0.97</code></pre><p>对于这个模型来说，测试集的精度约为 0.97，也就是说，对于测试集中的鸢尾花，我们的预测有 97% 是正确的。根据一些数学假设，对于新的鸢尾花，可以认为我们的模型预测结果有 97% 都是正确的。</p><h2 id="完整代码如下："><a href="#完整代码如下：" class="headerlink" title="完整代码如下："></a>完整代码如下：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <span class="hljs-comment">#矩阵运算</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt  <span class="hljs-comment">#绘图</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd  <span class="hljs-comment">#基于numpy的数据分析库</span><br><span class="hljs-keyword">import</span> mglearn <span class="hljs-comment">#美化图像</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br>iris_dataset=load_iris()<br>X_train,X_test,y_train,y_test=train_test_split(iris_dataset[<span class="hljs-string">&#x27;data&#x27;</span>],<br>iris_dataset[<span class="hljs-string">&#x27;target&#x27;</span>],random_state=<span class="hljs-number">0</span>) <span class="hljs-comment">#为了保证多次运行同一函数能得到相同输出，利用random_state指定了生成随机参数的种子</span><br><span class="hljs-comment">#输出的结果都是Numpy数组</span><br><span class="hljs-comment">#利用X_train中的数据创建DataFrame</span><br><span class="hljs-comment">#利用iris_dataset.feature_names中的字符串对数据列进行标记</span><br>iris_dataframe=pd.DataFrame(X_train,columns=iris_dataset.feature_names)<br><span class="hljs-comment">#利用DataFrame创建散点图矩阵，按y_train着色</span><br>grr=pd.plotting.scatter_matrix(iris_dataframe,c=y_train,figsize=(<span class="hljs-number">15</span>,<span class="hljs-number">15</span>),marker=<span class="hljs-string">&#x27;o&#x27;</span>,<br>                              hist_kwds=&#123;<span class="hljs-string">&#x27;bins&#x27;</span>:<span class="hljs-number">20</span>&#125;,s=<span class="hljs-number">60</span>,alpha=<span class="hljs-number">.8</span>,cmap=mglearn.cm3)<br>knn=KNeighborsClassifier(n_neighbors=<span class="hljs-number">1</span>)<br>knn.fit(X_train,y_train)<br>y_pred=knn.predict(X_test)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(np.mean(y_pred==y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Test set score: 0.97</code></pre><p><img src="/%E9%B8%A2%E5%B0%BE%E8%8A%B1%E7%9A%84%E4%BE%8B%E5%AD%90%5Coutput_28_1.png" alt="png"></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Jupyter Notebook的使用</title>
    <link href="/2019/10/01/Jupyter-Notebook%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/10/01/Jupyter-Notebook%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Jupyter Notebook的配置与使用</p><span id="more"></span><p>亲测实用有效教程：<br></p><p><a href="https://blog.csdn.net/weixin_42814873/article/details/82842925">配置juster notebook全步骤，更改默认路径</a></p><p><a href="http://baijiahao.baidu.com/s?id=1601883438842526311&wfr=spider&for=pc">入门｜始于Jupyter Notebooks：一份全面的初学者实用指南(这个最全几乎解决了基础的所有问题)</a></p><p>快捷键：<br><br>Jupyter Notebooks 提供了两种不同的键盘输入模式——命令和编辑<br><br>命令模式是将键盘和笔记本层面的命令绑定起来，并且由带有蓝色左边距的灰色单元边框表示。<br><br>编辑模式让你可以在活动单元中输入文本（或代码），用绿色单元边框表示。<br></p><p>可以分别使用 Esc 和 Enter 在命令模式和编辑模式之间跳跃。<br></p><p>进入命令模式之后（此时你没有活跃单元），你可以尝试以下快捷键：</p><table><thead><tr><th>按键</th><th>作用</th></tr></thead><tbody><tr><td>A</td><td>会在活跃单元之上插入一个新的单元</td></tr><tr><td>B</td><td>会在活跃单元之下插入一个新单元</td></tr><tr><td>连续按两次 D</td><td>可以删除一个单元。</td></tr><tr><td>Z</td><td>撤销被删除的单元</td></tr><tr><td>Y</td><td>会将当前活跃的单元变成一个代码单元</td></tr><tr><td>Shift +上或下箭头</td><td>选择多个单元</td></tr><tr><td>在多选模式时，按住 Shift + M</td><td>可合并你的选择</td></tr><tr><td>F</td><td>会弹出「查找和替换」菜单。</td></tr></tbody></table><p>处于编辑模式时（在命令模式时按 Enter 会进入编辑模式），你会发现下列快捷键很有用：</p><table><thead><tr><th>按键</th><th>作用</th></tr></thead><tbody><tr><td>Ctrl + Home</td><td>到达单元起始位置</td></tr><tr><td>Ctrl + S</td><td>保存进度</td></tr><tr><td>Ctrl + Enter</td><td>运行整个单元块</td></tr><tr><td>Alt + Enter</td><td>不止会运行单元块，还会在下面添加一个新单元</td></tr><tr><td>Ctrl + Shift + F</td><td>打开命令面板。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客添加代码高亮,代码复制与评论系统</title>
    <link href="/2019/09/27/hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE-%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
    <url>/2019/09/27/hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE-%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>此配置针对next主题，进行代码高亮，代码块复制，评论系统相关操作</p><span id="more"></span><h1 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h1><p>在主题的_config.yml搜索</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Code</span> Highlight theme<br><br></code></pre></td></tr></table></figure><p>找到代码块对highlight_theme进行配置更改主题</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># Code Highlight theme</span><br><span class="hljs-meta"># Available values: normal | night | night eighties | night blue | night bright</span><br><span class="hljs-meta"># https:<span class="hljs-comment">//github.com/chriskempson/tomorrow-theme</span></span><br><span class="hljs-symbol">highlight_theme:</span> night bright<br><br></code></pre></td></tr></table></figure><h1 id="代码复制"><a href="#代码复制" class="headerlink" title="代码复制"></a>代码复制</h1><p><a href="http://www.zhyong.cn/posts/ca02/">http://www.zhyong.cn/posts/ca02/</a><br><br>有一点问题：<br>复制按钮显示异常<br></p><p>修改</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>: inline-block;<br><br></code></pre></td></tr></table></figure><p>为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><br><span class="hljs-attribute">display</span>: block;<br><br></code></pre></td></tr></table></figure><p>修改后对应代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs css"><br>//代码块复制按钮<br><span class="hljs-selector-class">.highlight</span>&#123;<br>  //方便copy代码按钮（btn-copy）的定位<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.btn-copy</span> &#123;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">cursor</span>: pointer;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#eee</span>;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">#fcfcfc</span>,<span class="hljs-number">#eee</span>);<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#d5d5d5</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;<br>    -webkit-user-select: none;<br>    -moz-user-select: none;<br>    -ms-user-select: none;<br>    user-select: none;<br>    -webkit-appearance: none;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">13px</span>;<br>    <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">700</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>    -webkit-<span class="hljs-attribute">transition</span>: opacity .<span class="hljs-number">3s</span> ease-in-out;<br>    -o-<span class="hljs-attribute">transition</span>: opacity .<span class="hljs-number">3s</span> ease-in-out;<br>    <span class="hljs-attribute">transition</span>: opacity .<span class="hljs-number">3s</span> ease-in-out;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">2px</span> <span class="hljs-number">6px</span>;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.btn-copy</span> <span class="hljs-selector-tag">span</span> &#123;<br>    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">5px</span>;<br>&#125;<br><span class="hljs-selector-class">.highlight</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.btn-copy</span>&#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="添加评论系统"><a href="#添加评论系统" class="headerlink" title="添加评论系统"></a>添加评论系统</h1><ol><li><a href="http://houyimin.cn/2017/05/26/Hexo%E7%9A%84NexT%E4%B8%BB%E9%A2%98%EF%BC%9A%E6%B7%BB%E5%8A%A0%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA/">添加来必力评论系统</a></li><li><a href="https://me.idealli.com/post/3453c710.html">进行修改优化</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>hexo博客相关配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本排序算法</title>
    <link href="/2019/09/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2019/09/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>排序算法是最基本的算法，本文使用语言为C&#x2F;C++<br><br>详细了解参考以下链接：<br><br><a href="https://github.com/hustcc/JS-Sorting-Algorithm">十大排序算法</a><br><br>个人认为应该牢记的是归并排序，快速排序，基本的冒泡排序以及sort()函数的使用方法，这些是在比赛和做题时经常遇到的。</p><span id="more"></span><h1 id="各排序算法分析"><a href="#各排序算法分析" class="headerlink" title="各排序算法分析"></a>各排序算法分析</h1><p><img src="/2019/09/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/sort.png"></p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>是稳定的排序算法，适用于大规模的基本有序的数据<br></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>不断地划分区间，一分二，二分四，直到最后一个小数组只有一个元素，然后开始逐层向上合并，合并时要按想要的顺序(从小到大，或是从大到小)进行选择然后合并，因此要用到递归<br></p><p>原理动图如下：<br></p><p><img src="/2019/09/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/mergeSort.gif"></p><p>算法采用C++实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//合并函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> mid,<span class="hljs-type">int</span> R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> len=R-L+<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> *t=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span> [len+<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> i=L,j=mid+<span class="hljs-number">1</span>,k=<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//比较，选择小的一个</span><br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=R)<br>    &#123;<br>        t[k++]=a[i]&lt;a[j]?a[i++]:a[j++];<br>    &#125;<br>    <span class="hljs-comment">//比较完后如果有剩余元素，都添加进数组中</span><br>    <span class="hljs-keyword">while</span>(i&lt;=mid)<br>    &#123;<br>        t[k++]=a[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j&lt;=R)<br>    &#123;<br>        t[k++]=a[j++];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m=L;m&lt;=R;m++)<br>    &#123;<br>        a[m]=t[m-L+<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">delete</span> [] t;<br>&#125;<br><span class="hljs-comment">//用来递归成小区间进行排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(L&gt;=R)<span class="hljs-comment">//这个条件不能忘记，否则会死循环</span><br>    <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> mid=(L+R+<span class="hljs-number">0.5</span>)/<span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">MergeSort</span>(a,L,mid);<br>        <span class="hljs-built_in">MergeSort</span>(a,mid+<span class="hljs-number">1</span>,R);<br>        <span class="hljs-built_in">Merge</span>(a,L,mid,R);<br>    &#125;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cout&lt;&lt;<span class="hljs-string">&quot;input num of items:&quot;</span>;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> *a=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">MergeSort</span>(a,<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">delete</span> [] a;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>对完全无序的数据执行结果最优<br></p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>在一组数据中选择一个基准数，一个左标记，一个右标记，将所有比这个数小的数放在左边，比这个数大的数放在其右侧，不断重复此过程，直至左标记与右标记重合，最后让基准数归位。<br>原理的动图如下：<br></p><p><img src="/2019/09/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quickSort.gif"></p><p>用C++实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *x,<span class="hljs-type">int</span> *y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> temp=*x;<br>    *x=*y;<br>    *y=temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> base=a[L];<br>    <span class="hljs-keyword">while</span>(L&lt;R)  <br>    &#123; <br>        <span class="hljs-comment">//从右标记开始先找，之后左标记找，然后交换</span><br>        <span class="hljs-keyword">while</span>(R&gt;L&amp;&amp;a[R]&gt;base)<br>        R--;<br>        <span class="hljs-keyword">while</span>(L&lt;R&amp;&amp;a[L]&lt;base)<br>        L++;<br>        <span class="hljs-built_in">swap</span>(a[R],a[L]);<br>    &#125;<br>    a[L]=base;<span class="hljs-comment">//基准数归位</span><br>    <span class="hljs-keyword">return</span> L;<span class="hljs-comment">//返回这个基准数的位置，之后排序它左右的两个小区间</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(L&gt;=R) <span class="hljs-comment">//这个条件不能忘记，否则会死循环</span><br>    <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid=<span class="hljs-built_in">sort</span>(a,L,R);<br>    <span class="hljs-built_in">QuickSort</span>(a,L,mid<span class="hljs-number">-1</span>);<span class="hljs-comment">//排序左区间</span><br>    <span class="hljs-built_in">QuickSort</span>(a,mid+<span class="hljs-number">1</span>,R);<span class="hljs-comment">//排序右区间</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> N;<br>    cin&gt;&gt;N;<br>    <span class="hljs-type">int</span> *a=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[N+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)<br>    cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">QuickSort</span>(a,<span class="hljs-number">1</span>,N);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)<br>    cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">delete</span> [] a;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="sort的基础用法"><a href="#sort的基础用法" class="headerlink" title="sort的基础用法"></a>sort的基础用法</h1><p>包含在头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">&lt;algorithm&gt;<br></code></pre></td></tr></table></figure><p>中<br><br>有三个参数</p><ul><li>第一个是要排序的数组的起始地址。</li><li>第二个是结束的地址（最后一位要排序的地址的下一地址）</li><li>第三个参数是排序的方法，可以是从大到小也可是从小到大，还可以不写第三个参数，此时默认的排序方法是从小到大排序。</li></ul><p> 第一种用法：直接比较<br><br> 第二种：传入一个返回值为布尔类型的比较函数，用来进行比较<br></p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>原理：前后两个元素进行比较<br><br>原理动图：</p><p><img src="/2019/09/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/bubbleSort.gif"></p><p>采用C++实现情况如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *x, <span class="hljs-type">int</span> *y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = *x;<br>    *x = *y;<br>    *y = t;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> *a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; a[i];<br>    <span class="hljs-comment">//最外面代表一共要进行n-1趟排序，第n趟时实际已经排好了</span><br>    <span class="hljs-comment">//j&lt;=n-i是因为每一趟排序最后都会累积一个排好的数，可见图</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n - i; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (a[j] &gt; a[j + <span class="hljs-number">1</span>])<br>                <span class="hljs-built_in">swap</span>(a[j], a[j+<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span>[] a;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解计算机系统学习记录1</title>
    <link href="/2019/09/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/"/>
    <url>/2019/09/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    
    <content type="html"><![CDATA[<h1 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h1><p>学习《深入理解计算机系统》第二章，记录个人觉得重要的点</p><span id="more"></span><ol><li>二进制，十进制，16进制之间的转换<br><br>按四位一组划分二进制可转换为16进制<br><br>转换表：<br></li></ol><table><thead><tr><th>二进制</th><th>10进制</th><th>16进制</th></tr></thead><tbody><tr><td>0000</td><td>0</td><td>0</td></tr><tr><td>0001</td><td>1</td><td>1</td></tr><tr><td>0010</td><td>2</td><td>2</td></tr><tr><td>0011</td><td>3</td><td>3</td></tr><tr><td>0100</td><td>4</td><td>4</td></tr><tr><td>0101</td><td>5</td><td>5</td></tr><tr><td>0110</td><td>6</td><td>6</td></tr><tr><td>0111</td><td>7</td><td>7</td></tr><tr><td>1000</td><td>8</td><td>8</td></tr><tr><td>1001</td><td>9</td><td>9</td></tr><tr><td>1010</td><td>10</td><td>A</td></tr><tr><td>1011</td><td>11</td><td>B</td></tr><tr><td>1100</td><td>12</td><td>C</td></tr><tr><td>1101</td><td>13</td><td>D</td></tr><tr><td>1110</td><td>14</td><td>E</td></tr><tr><td>1111</td><td>15</td><td>F</td></tr></tbody></table><blockquote><p>十六进制数字0代表4个二进制0。所以，当n表示为i+4j的形式，其中0&lt;&#x3D;i&lt;&#x3D;3，我们可以把x写成开头的十六进制数字为<br>(i&#x3D;0)，2(i&#x3D;1)，4(i&#x3D;2)或者8(i&#x3D;3)，后面跟随着j个十六进制的0。比如，x&#x3D;2048&#x3D;2^11，我们有n&#x3D;11&#x3D;3+4*2，从而得到0x800</p></blockquote><ol start="2"><li><p>.C语言格式化输出<br><br>%d,%c,%x,%u,%f,%.2x</p></li><li><p>指针和数组<br><br>C语言中指针和数组可以互相表示<br></p></li><li><blockquote><p>C语言中字符串被编码成一个以null，值为0的字符结尾的字符数组。十进制数字x的ASCII码正好是0x3x，而终止字节的试卷进制为0x00.在使用ASCII码的任何系统上都将得到相同结果，与字节顺序和字大小无关，因此文本数据比二进制数据具有更强的平台独立性</p></blockquote></li><li><p>utf-8表示将每个字符编码成一个字节序列，java编程语言使用Unicode来表示字符串<br></p></li><li><p>逻辑运算和位运算<br><br>逻辑运算：与&amp;&amp;，或||，非！<br><br>位运算：&amp;，|，^<br><br>要分清区别:<br><br>按位运算只有在特殊情况下，也就是参数限制为0，1时才与其对应的逻辑运算有相同的行为，逻辑运算符&amp;&amp;，||与位级运算&amp;，|之间重要的区别就是如果对第一个参数求值就能确定表达式的结果，那么逻辑运算就不会对第二个参数求值<br></p></li><li><p>C语言中的移位运算<br></p></li><li><p>左移K位 &lt;&lt; k: 丢弃最高的k位，并在右端补k个0<br><br>右移k位 &gt;&gt; k:<br><br>有两种形式：逻辑右移和算术右移<br></p></li></ol><ul><li>逻辑右移，补0</li><li>算术右移，补最高有效位的值，即1</li></ul><p>而C语言对这点并没有明确规定<br><br>实际上所有的编译器&#x2F;机器组合都对有符号数使用算术右移，且许多程序员也都假设机器会使用这种右移，另一方面，对于无符号数，右移是必须的。与c相比，java对于如何进行右移有明确的定义，<strong>逻辑右移：x&gt;&gt;&gt;k，算术右移：x&gt;&gt;k</strong>  <br><br>9. C&#x2F;C++都支持有符号(默认)和无符号数，java只支持有符号数<br><br>10. 无符号编码，补码编码具有唯一性<br></p>]]></content>
    
    
    <categories>
      
      <category>深入理解计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同时部署hexo到github和coding上</title>
    <link href="/2019/09/25/%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2hexo%E5%88%B0github%E5%92%8Ccoding%E4%B8%8A/"/>
    <url>/2019/09/25/%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2hexo%E5%88%B0github%E5%92%8Ccoding%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<p>同时部署hexo到github和coding上而不是一次只能布置一个，至于具体的对github，coding各自的布置方法请自行查找</p><span id="more"></span><p>采用以下方法：<br>修改hexo博客_config.xml：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">deploy:<br>  type: git<br>  repository: <br>    github: https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/3422878082/</span><span class="hljs-number">3422878082</span>.github.io.git<br>    coding: https:<span class="hljs-regexp">//</span>dev.tencent.com<span class="hljs-regexp">/u/</span>shanhainanhua<span class="hljs-regexp">/p/</span>shanhainanhua.coding.me.git<br>  branch: master<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hexo博客相关配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据关联分析</title>
    <link href="/2019/09/24/%E6%95%B0%E6%8D%AE%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/"/>
    <url>/2019/09/24/%E6%95%B0%E6%8D%AE%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>数据关联分析</p><span id="more"></span><p>今日学习了第三章和第四章<br><br>第三章数据可视化暂且不提<br></p><h1 id="第四章数据关联分析"><a href="#第四章数据关联分析" class="headerlink" title="第四章数据关联分析"></a>第四章数据关联分析</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>频繁模式和关联规则的广泛应用为数据分析的研究和机器学习的发展起到了极大的推动作用<br><br>频繁模式可以进一步描述成数据对象间的关联规则<br><br>判断序列模式是否频繁使用两个基本的度量：<br><br><strong>支持度</strong>：模式的有用性<br><br><strong>置信度</strong>：规则的确定性<br>频繁项集和关联规则<br><br><strong>项集</strong>：项的集合,<br>包含k个项的项集称为k项集，项集的出现频数是包含项集的事务数<br><br><strong>支持度</strong>：在所有的事务中同时出现某项的概率：<br><br>  support(A)&#x3D;${count(A \in T)} \over{|D|}$<br><br><br>频繁项集：出现次数到一定程度，大于最小支持度阈值<br><br>关联规则：A→B中A，B分别称为关联规则的前件，后件<br><br>在事务集D中，对某条关联规则而言，其支持度s表示在所有的事务中同时出现A和B的概率，<br>即P(AB),support(A&#x3D;&gt;B)&#x3D;${count(A \cup B)} \over {|D|}$<br><br>置信度：又称可信度，对A-&gt;B而言，置信度表示A出现同时B出现概率，即P(B|A)<br><br>confidence(A&#x3D;&gt;B)&#x3D;${support(A \cup B)} \over {support(A)}$<br><br><br>如果某个关联规则同时满足最小支持度阈值和最小置信度阈值，则认为这个关联规则是有趣的<br><br>如果同时满足&gt;&#x3D;,是强关联，否则是弱关联<br><img src="/2019/09/24/%E6%95%B0%E6%8D%AE%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/1.jpg"><br>Aprior算法：寻找所有支持度不小于min_sup的频繁项集<br><img src="/2019/09/24/%E6%95%B0%E6%8D%AE%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/2.jpg" alt="Aprior算法实例"></p>]]></content>
    
    
    <categories>
      
      <category>大数据挖掘及应用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统第二章-进程</title>
    <link href="/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B/"/>
    <url>/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="进程的控制和描述"><a href="#进程的控制和描述" class="headerlink" title="进程的控制和描述"></a>进程的控制和描述</h1><p><img src="/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6.png" alt="总图"></p><h2 id="前驱图和程序执行"><a href="#前驱图和程序执行" class="headerlink" title="前驱图和程序执行"></a>前驱图和程序执行</h2><p><img src="/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B/%E5%89%8D%E9%A9%B1%E5%9B%BE%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C.png" alt="前驱图和程序执行"><br> <font color="#97FFF"> 有向无循环图 DAG</font></p><ul><li>用于描述进程之间执行的先后顺序</li><li>图中每个节点可以用来表示一个进程或程序段，乃至一条语句</li><li>节点的有向边表示两个节点之间存在的偏序关系，，用→表示</li><li>把没有前驱的结点称为初始结点，对应有终止结点</li><li>每个结点有一个重量，用于表示该结点所含有的程序量或程序的执行时间</li></ul><h2 id="进程描述"><a href="#进程描述" class="headerlink" title="进程描述"></a>进程描述</h2><p><img src="/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0.png" alt="进程描述"></p><h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><p><img src="/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB.png" alt="PCB"></p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p><img src="/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6.png" alt="进程控制"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统第一章-引论</title>
    <link href="/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"/>
    <url>/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA.jpg" alt="操作系统引论"><br><img src="/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD.png" alt="操作系统主要功能"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown进阶</title>
    <link href="/2019/09/22/markdown%E8%BF%9B%E9%98%B6/"/>
    <url>/2019/09/22/markdown%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h1><p>Markdown颜色对应二进制表<br><img src="/2019/09/22/markdown%E8%BF%9B%E9%98%B6/rgb.png" alt="rgb颜色对应表"></p><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>Markdown公式手册<br><img src="/2019/09/22/markdown%E8%BF%9B%E9%98%B6/%E5%85%AC%E5%BC%8F.png" alt="公式"></p>]]></content>
    
    
    <categories>
      
      <category>各种搭建配置坑的记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计组习题纠错总结</title>
    <link href="/2019/09/22/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%BA%A0%E9%94%99%E6%80%BB%E7%BB%93/"/>
    <url>/2019/09/22/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%BA%A0%E9%94%99%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>例2.6 某机字长32位，浮点表示时，指数部分（即阶码）占8位（含一位符号位），尾数部分占24位（含一位符号位），问:</p></blockquote><ol><li>带符号定点小数的最大表示范围是多少？</li><li>带符号定点整数的最大表示范围是多少？</li><li>浮点表示时，最大正数是多少？</li><li>浮点表示时，最大负数是多少？</li><li>浮点表示时，最小的规格化正数是多少？</li></ol><p>分析：<br><br>采用补码表示时，可表示的数据范围最大。因此本题可用补码来求解。<br><br><font color="#FF7F24">带符号的定点小数通常就是浮点数。</font><br>浮点数据表示阶码占8位，尾数占24位，各包含一位符号位。此时阶码的表示范围为：-128 ～ 127；尾数的表示范围为：-1 ～ 1-$2 ^{– 23}$。<br><br>带符号的定点整数其符号位1位，其余位均用来表示数据。此时的表示范围为：-$2^{31}$ ～ $2^{31}$-1。<br><br>浮点表示时，最大正数为阶码最大，尾数最大的正数。最大负数为阶码最小，尾数最小的负数。<br>采用规格化数据表示时要注意尾数必须保证大于等于0.5，小于1。因此，浮点表示时，最小的规格化正数阶码最小，尾数最小为0.5。<br><br>解：<br><br>采用补码进行数据表示的范围最大。整数表示时符号位1位，数据位31位。浮点表示时，阶码占8位，尾数占24位，各包含一位符号位。因此：<br></p><ol><li>带符号定点小数的最大表示范围为：-1×$2^{127}$ ～ （1-$2^{-23}$）×$2^{127}$。</li><li>   带符号定点整数的最大表示范围为：-$2^{31}$ ～ $2^{31}$-1。</li><li>   浮点表示时，最大正数为：（1-$2^{-23}$）×$2^{127}$。</li><li>   浮点表示时，最大负数为：-$2^{-23}$×$2^{-128}$。</li><li>   浮点表示时，最小的规格化正数为：0.5×$2^{-128}$。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo next主题 markdown数学公式不正常显示问题</title>
    <link href="/2019/09/18/hexo-next%E4%B8%BB%E9%A2%98-markdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8D%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"/>
    <url>/2019/09/18/hexo-next%E4%B8%BB%E9%A2%98-markdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8D%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>近期写博客，遇到有些地方需要写数学公式，因为一直没用过所以初次使用遇到了问题。<br><br>使用markdown编写的公式在hexo博客中并不会正常显示出来。<br>网上查阅后发现原因如下：</p><blockquote><p>Hexo默认使用”hexo-renderer-marked”引擎渲染网页，该引擎会把一些特殊的markdown符号转换为相应的html标签，比如在markdown语法中，下划线’<em>‘代表斜体，会被渲染引擎处理为<em>标签。<br>因为类Latex格式书写的数学公式下划线 ‘</em>‘ 表示下标，有特殊的含义，如果被强制转换为<em>标签，那么MathJax引擎在渲染数学公式的时候就会出错。例如，$x_i$在开始被渲染的时候，处理为$x<em>i</em>$，这样MathJax引擎就认为该公式有语法错误，因为不会渲染。<br>类似的语义冲突的符号还包括’*’, ‘{‘, ‘}’, ‘&#39;等。<br><a href="https://www.jianshu.com/p/d87d7d2dcea9">https://www.jianshu.com/p/d87d7d2dcea9</a></p></blockquote><p>解决方法：</p><ol><li>首先需要安装Mathjax插件：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> hexo-<span class="hljs-keyword">math</span> --save<br></code></pre></td></tr></table></figure></li><li>接着更换Hexo的Markdown渲染引擎<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm uninstall hexo-renderer-marked <span class="hljs-comment">--save</span><br>npm install hexo-renderer-kramed <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure></li><li>之后进入博客根目录下的node_modules\kramed\lib\rules\inline.js<br>找到escape，将其后的内容改为：<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs r">escape<span class="hljs-operator">:</span> <span class="hljs-operator">/</span><span class="hljs-operator">^</span><span class="hljs-punctuation">\</span><span class="hljs-punctuation">\</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">[</span>`*\[\]()#$+\-.!_&gt;])/,<br></code></pre></td></tr></table></figure>  同理，修改em为：<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,<br></code></pre></td></tr></table></figure></li><li>最后进入主题下的_config.yml配置文件中，搜索math，我的在497行<br> 修改enable为true，如果不修改的话也行，那就是默认每个页面都需要渲染，而改为true之后在写文章时<br> 在文章头部加上 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mathjax:</span> <span class="hljs-literal">true</span> <br></code></pre></td></tr></table></figure> 这样可以调高访问速度</li></ol>]]></content>
    
    
    <categories>
      
      <category>各种搭建配置坑的记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置环境</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载与反射</title>
    <link href="/2019/09/15/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    <url>/2019/09/15/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><h2 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h2><p>java.lang.Class类封装一个对象和接口运行时的状态。<br><br>当加载类时Class类型的对象将自动创建，通过Class对象就可以访问JVM中类的所有信息。<br><br>Class类没有公共构造方法，其对象是JVM在加载类时通过类加载器中的defineClass（）方法自动构造的，因此不能显式地构造一个Class对象。<br><br>可以获取所有构造方法，方法，变量，内部类，外部类，对应类的修饰符，并且判断类型。<br><br>获取Class对象有三种方法:</p><ol><li>Class.forName(“所需类的全限定类名”)</li><li>调用某个类的class方法  Float.class</li><li>调用某个对象的getClass（）方法   a.getClass()</li></ol><h2 id="类加载步骤"><a href="#类加载步骤" class="headerlink" title="类加载步骤"></a>类加载步骤</h2><p>当程序主动使用某个类时，如果该类还未被加载到内存中，系统将通过加载，连接和初始化三个步骤对类进行初始化。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器负责将磁盘或者网络上的.class文件加载到内存中，并为之生成对应的java.lang.Class对象<br><br>类加载器负责加载所有的类,JVM启动时，会形成由三个类加载器组成的初始类加载器层次结构：</p><ul><li>Bootstrap ClassLoader：根类加载器，负责加载Java的核心类库</li><li>Extension ClassLoader：扩展类加载器，负责加载JRE的扩展目录中的jar包</li><li>System ClassLoader：系统类加载器，负责在JVM启动时加载来自Java命令的-classpath选项，java.class.path系统属性，或CLASSPATH环境变量所指定的jar包和类路径</li><li>用户也可以自定义加载器<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">根类加载器<br>    <span class="hljs-string">|</span><br>扩展类加载器<br>    <span class="hljs-string">|</span><br>系统类加载器<br>    <span class="hljs-string">| </span><br>用户类加载器<br></code></pre></td></tr></table></figure></li></ul><p><strong>tips：类加载机制：全盘负责，父类委托，缓存机制</strong></p><h2 id="ClassLoader类"><a href="#ClassLoader类" class="headerlink" title="ClassLoader类"></a>ClassLoader类</h2><p>java.lang.ClassLoader是一个抽象类，通过继承ClassLoader类来实现自定义的用户类加载器，重写方法<br>实现自定义的类加载器可以通过重写ClassLoader类的loadClass()或findClass（）方法来实现。推荐重写findClass()避免覆盖默认类加载器的父类委托，缓冲机制两种策略</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>java中有许多对象在运行时都会出现两种类型：编译时类型和运行时类型，<br><br>某些情况下程序会在运行时接收到外部传入的一个对象，该对象的编译时类型和运行时类型不同，<br>但程序需要调用该对象运行时类型的方法，在无法预知该对象属于哪些类的情况下，必须通过反射来发现该对象和类的真实信息。<br><br>反射机制允许程序在运行时借助Reflection API取得任何类的内部信息，并能直接操作对象的内部属性和方法。反射被视为动态语言的关键。<br><br>java反射机制主要提供了以下功能：</p><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时获取任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法</li><li>生成动态代理</li></ul><p>Reflection API提供了Constructor，Field和Method类，这三个类定义在java.lang.reflect包中，分别用于描述类的构造方法，属性和方法<br><br>java.lang.reflect包下的Executable抽象类，该对象代表可执行的类成员。<br>Executable抽象类派生了Constructor和Method两个子类。</p><p>Executable抽象类提供了大量方法来获取参数，修饰符或注解等信息<br><br>Executable方法列表</p><table><thead><tr><th>方法</th><th>功能描述</th></tr></thead><tbody><tr><td>Parameter[] getParameters()</td><td>获取所有形参，返回一个Parameter[]数组</td></tr><tr><td>int getParameterCount()</td><td>获取形参个数</td></tr><tr><td>abstract int getModifiers</td><td>获取修饰符，返回的整数是修饰符所对应的常量</td></tr><tr><td>boolean isVarArgs（）</td><td>判断是否包含数量可变的形参</td></tr></tbody></table><p>Constructor类用于表示类的构造方法，通过调用Class对象的getConstructor()方法可以获取当前类的构造方法的集合<br><br>Constructor类方法列表</p><table><thead><tr><th>方法</th><th>功能描述</th></tr></thead><tbody><tr><td>String getName()</td><td>返回构造方法的名称</td></tr><tr><td>Class[] getParameterTypes()</td><td>返回当前构造方法的参数类型</td></tr><tr><td>int  getModifiers()</td><td>返回修饰符的整型标识，返回的整数是修饰符public，protected，private，final，static，abstract等关键字所对应的常量，需要使用Modifier工具类的方法解码后才能获得真实的修饰符</td></tr></tbody></table><p>Method类用于封装方法的信息，调用Class对象的getMethods（）方法或getMethod（）可以获取当前类的所有方法或指定方法<br>Method类常用方法</p><table><thead><tr><th>方法</th><th>功能描述</th></tr></thead><tbody><tr><td>String getName（）</td><td>返回方法的名称</td></tr><tr><td>Class[] getParameterTypes（）</td><td>返回当前方法的参数类型</td></tr><tr><td>int getModifiers（）</td><td>返回修饰符的整型标识</td></tr><tr><td>Class getReturnType（）</td><td>返回当前方法的返回类型</td></tr></tbody></table><p>Field类用于封装属性的信息，调用Class对象的getFields（）或getField（）方法可以获得当前类的所有属性或指定属性。<br><br>Field类常用方法</p><table><thead><tr><th>方法</th><th>功能描述</th></tr></thead><tbody><tr><td>String getName（）</td><td>返回属性的名称</td></tr><tr><td>int getModifiers（）</td><td>返回修饰符的整型标识</td></tr><tr><td>getXxx（Object obj）</td><td>获取属性的值，此处的Xxx对应java中基本类型；如果属性是引用类型，则直接使用get（Object obj）</td></tr><tr><td>setXxx（Object obj，Xxx val）</td><td>设置属性值；set（Object obj，Object val）</td></tr><tr><td>Class []  getType（）</td><td>返回当前属性的类型</td></tr></tbody></table><p>Parameter类，每个Parameter对象代表方法的一个参数。Parameter类中提供了许多方法来获取参数信息。<br><br>Parameter类常用方法</p><table><thead><tr><th>方法</th><th>功能描述</th></tr></thead><tbody><tr><td>int getModifiers（）</td><td>获取参数的修饰符</td></tr><tr><td>String getName（）</td><td>获取参数的形参名</td></tr><tr><td>Type getParameterizedType（）</td><td>获取带泛型的形参类型</td></tr><tr><td>Class&lt;?&gt;getType（）</td><td>获取形参类型</td></tr><tr><td>boolean isVarArgs（）</td><td>判断该参数是否是可变参数</td></tr><tr><td>boolean isNamePresent（）</td><td>判断.class文件中是否包含方法的形参名信息</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章 数据认知与预处理</title>
    <link href="/2019/09/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%AE%A4%E7%9F%A5%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/"/>
    <url>/2019/09/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%AE%A4%E7%9F%A5%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="属性的定义"><a href="#属性的定义" class="headerlink" title="属性的定义"></a>属性的定义</h2><p>是一个字段，表示数据对象的一个特征<br><br>属性的取值范围决定了属性的类型，通常可以分为两大类：</p><ul><li>定性描述：标称属性，布尔属性，序值属性</li><li>定量描述：数值属性</li></ul><h2 id="标称属性"><a href="#标称属性" class="headerlink" title="标称属性"></a>标称属性</h2><p>标称属性取值仅是一些不同的符号或事物的名称，每个值提供了足够的信息以区分对象<br>可以将这些值看成枚举的，如邮政编码，学生ID，头发颜色等</p><h2 id="二元属性"><a href="#二元属性" class="headerlink" title="二元属性"></a>二元属性</h2><p>是只有两个可选值的属性  </p><h2 id="序值属性"><a href="#序值属性" class="headerlink" title="序值属性"></a>序值属性</h2><ul><li>提供了足够的信息确定数据对象之间的序，但是值之间的差是未知的，例如产品的优，良，差</li><li>数值属性可以转换为序值属性——通过值域的离散化</li><li>序值属性可以定义众数，中位数，百分位数，但是不能定义均值</li></ul><h2 id="数值属性"><a href="#数值属性" class="headerlink" title="数值属性"></a>数值属性</h2><p>可度量，用整数或实数值来表示，定量地描述对象<br>一些文献中将数值属性又划分为区间标度或比率标度属性</p><h1 id="数据的统计描述方法"><a href="#数据的统计描述方法" class="headerlink" title="数据的统计描述方法"></a>数据的统计描述方法</h1><p>主要讨论两种基本统计描述：</p><ol><li>度量整个数据集合的中心趋势的方法：均值，中位数，众数，中列数</li><li>度量整个数据集的离散趋势的方法：极差，分位数，五数概括，方差，标准差</li></ol><h2 id="中心趋势度量"><a href="#中心趋势度量" class="headerlink" title="中心趋势度量"></a>中心趋势度量</h2><p>均值，众数，<br>中位数：<br><br>中列数：数据集最大值和最小值的平均值</p><h2 id="离散趋势度量"><a href="#离散趋势度量" class="headerlink" title="离散趋势度量"></a>离散趋势度量</h2><h3 id="极差（全距"><a href="#极差（全距" class="headerlink" title="极差（全距)"></a>极差（全距)</h3><p> 一组数据中的最大值和最小值之差</p><h3 id="k分位数（以四分位数为例）"><a href="#k分位数（以四分位数为例）" class="headerlink" title="k分位数（以四分位数为例）"></a>k分位数（以四分位数为例）</h3><p>将有序数据集分为4个间距相等的部分，这时产生三个数据点，称之为四分位数<br><br>假设12个数据：<br></p><ul><li>Q1（12+1）*0.25</li><li>Q2 （12+1）*0.5</li><li>Q3（12+1）*0.75</li><li>四分位距：IOR&#x3D;Q3-Q1</li><li>最小观测值：min&#x3D;Q1-1.5*IQR</li><li>最大观测值：max&#x3D;Q3+1.5*IQR</li></ul><p><strong>以上Q1,Q1,Q3计算结果均取整</strong></p><h3 id="五数概括与盒图"><a href="#五数概括与盒图" class="headerlink" title="五数概括与盒图"></a>五数概括与盒图</h3><p>为了完整地描述数据的分布情况，引入五数概括：中位数，四分位数（Q1和Q3），最大和最小观测值<br><br>一般按次序：min，Q1，中位数，Q3，max写出<br><br>通常使用盒图来直观地对五数进行可视化表示：</p><ol><li>盒的端点在四分位数上，下端点是Q1，上端点是Q3，盒的长度是IQR</li><li>中位数在盒内用横线进行标记</li><li>盒外用两条虚线分别延伸至最小和最大观测值，这两条虚线又称为胡须</li></ol><h1 id="数据对象关系的计算方法"><a href="#数据对象关系的计算方法" class="headerlink" title="数据对象关系的计算方法"></a>数据对象关系的计算方法</h1><h2 id="数据相似性计算方法"><a href="#数据相似性计算方法" class="headerlink" title="数据相似性计算方法"></a>数据相似性计算方法</h2><h3 id="标称属性相似性"><a href="#标称属性相似性" class="headerlink" title="标称属性相似性"></a>标称属性相似性</h3><p>假设标称属性的状态数目是M，p是刻画对象的属性总数，m是两个对象取值相同的属性数，则计算公式如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">d（i，j）<span class="hljs-operator">=</span>（p-m）/p<br></code></pre></td></tr></table></figure><h3 id="二元属性相似性"><a href="#二元属性相似性" class="headerlink" title="二元属性相似性"></a>二元属性相似性</h3><p>分为对称的和非对陈两种情况<br><br>假设：  q是对象i，j都取1的二元属性数；r是i&#x3D;1，j&#x3D;0；s是i&#x3D;0，j&#x3D;1；t是i&#x3D;j&#x3D;0<br>则对称的话： </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">d（i，j）=（<span class="hljs-built_in">r</span>+s）/（q+<span class="hljs-built_in">r</span>+s+t）<br></code></pre></td></tr></table></figure><p>如果非对陈且当属性值为1时权重最高，则t可忽略：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">d（i，j）=（<span class="hljs-built_in">r</span>+s）/（q+<span class="hljs-built_in">r</span>+s）<br></code></pre></td></tr></table></figure><h3 id="数值属性相似性"><a href="#数值属性相似性" class="headerlink" title="数值属性相似性"></a>数值属性相似性</h3><ul><li><p>欧式距离<br><img src="/2019/09/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%AE%A4%E7%9F%A5%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/os.jpeg" alt="欧式距离"></p></li><li><p>曼哈顿距离（街区距离）<br><img src="/2019/09/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%AE%A4%E7%9F%A5%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB.jpeg" alt="欧式距离"></p></li><li><p>切比雪夫距离（确界距离）<br><img src="/2019/09/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%AE%A4%E7%9F%A5%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB.jpeg" alt="欧式距离"></p></li><li><p>闵可夫斯基距离<br><img src="/2019/09/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%AE%A4%E7%9F%A5%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E8%B7%9D%E7%A6%BB.jpeg" alt="欧式距离"></p></li><li><p>标准化欧式距离<br><img src="/2019/09/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%AE%A4%E7%9F%A5%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/%E6%A0%87%E5%87%86%E5%8C%96%E6%AC%A7%E5%BC%8F%E8%B7%9D%E7%A6%BB.jpeg" alt="欧式距离"></p></li></ul><h3 id="序值属性相似性"><a href="#序值属性相似性" class="headerlink" title="序值属性相似性"></a>序值属性相似性</h3><p>将数值属性的值域划分为有限个类别，再离散化数值属性得到序值属性。<br><br>比如  苹果，梨，白菜，桃子<br><br> 对应的品级分别为·优 优，良，良<br><br>而值域类别为优 ，良，中，差。<br><br>假设f是用于描述n个对象的一组序值属性之一，关于f的邻近性计算步骤如下：<br></p><ol><li>第i个对象的f值为Xif，属性f有Mf个有序的状态，表示排位1，2，..Mf,<br>对应的排位rif{1，2,…Mf}取代Xif</li><li>用Zif代替第i个对象的rif来实现数据标准化<br></li></ol><p>  $Z_if$&#x3D;${r_if-1 \over M_f-1}$</p><p>苹果 &#x3D;优 ,$r_if$&#x3D;1 , $Z_if$&#x3D;${1-1 \over 4-1}$&#x3D;0  <br><br>白菜 $X_if$&#x3D;良，$r_if$&#x3D;2 , $Z_if$&#x3D;${2-1 \over 4-1}$</p><h3 id="Jaccard相似性"><a href="#Jaccard相似性" class="headerlink" title="Jaccard相似性"></a>Jaccard相似性</h3><p>通过获得两个对象的特征集合的交集的大小来获得集合之间的相似性。<br><br>两个集合A，B<br>sim（A，B）&#x3D;${A \cap B  \over  A \cup B}$</p><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><p>字符串A到B的编辑距离等于将字符串A变换为字符串B所需要的单字符插入及删除等操作的最小数目</p><h3 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h3><p>两个向量中值不相同分量的个数</p><h3 id="余弦相似度"><a href="#余弦相似度" class="headerlink" title="余弦相似度"></a>余弦相似度</h3><p>sim（A，B）&#x3D;${AB \over ||A||X||B| |}$</p><h2 id="数据相关性计算方法"><a href="#数据相关性计算方法" class="headerlink" title="数据相关性计算方法"></a>数据相关性计算方法</h2><h3 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h3><p>一组数据的期望值E(X)即为数据的均值<br><br>期望值分别为E(X)&#x3D;u,E(Y)&#x3D;v的两个实数随机变量X与Y之间的协方差定义为：<br><br>cov(x,y)&#x3D;E((X-u)(Y-v))<br>            &#x3D;E(XY)-uv<br><br>E(XY)等于x，y对应位置数据相乘之和&#x2F;一组数据的数据个数</p><h1 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h1><p>数据收集——数据预处理——数据挖掘——数据应用<br><br>数据预处理包括：数据清洗与集成，数据归纳，数据转换<br></p><h2 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h2><p>分箱法：</p><pre><code class="hljs">• 等深分箱 ：数据从小到大排序，等分为k部分• 等宽分箱 ：变量的取值范围分为k个等宽区间，每个区间当做一个分箱• 平滑技术：箱均值平滑，箱中位数平滑，箱边界平滑（箱中所有值用最近的边界值替换）</code></pre><h2 id="数据归纳"><a href="#数据归纳" class="headerlink" title="数据归纳"></a>数据归纳</h2><p>得到数据集的一个简化版本  放回的随机抽样，不放回的随机抽样，分层抽样</p><h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><p>数据规范化：</p><ol><li>最小—最大规范化</li><li>z分数规范化</li></ol><p><img src="/2019/09/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%AE%A4%E7%9F%A5%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/%E8%A7%84%E8%8C%83%E5%8C%96.jpeg" alt="数据规范化"></p>]]></content>
    
    
    <categories>
      
      <category>大数据挖掘及应用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章</title>
    <link href="/2019/09/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <url>/2019/09/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="真值和机器数"><a href="#真值和机器数" class="headerlink" title="真值和机器数"></a>真值和机器数</h2><p><strong>真值</strong>：正负符号加二进制绝对值<br><br><strong>机器数</strong>:正负号分别用0和1来代替，一般放在最高位<br><br><strong>数的机器码表示：在远离小数点的位置补0</strong></p><h2 id="原码表示法"><a href="#原码表示法" class="headerlink" title="原码表示法"></a>原码表示法</h2><ul><li><p>纯小数时</p><ul><li>正数：本身数值</li><li>负数：本身数值加上符号位 0为正，1为负</li></ul></li><li><p>纯整数时</p><ul><li>正数：本身数值</li><li>负数：本身数值加上2的n-1次方（n为字长）</li></ul></li></ul><h2 id="补码表示法"><a href="#补码表示法" class="headerlink" title="补码表示法"></a>补码表示法</h2><p>补码中1.0000000表示负1，补码的零只有一个<br><br>对于n位数来说，其模的大小为n位数全为1后再在最末位加1<br><br>如果某一数有n位整数（包括符号位），则它的模为2^n<br><br>如果是n位小数，它的模总是是2</p><ul><li>纯小数时<ul><li>正数：本身数值</li><li>负数：2-本身数值</li></ul></li><li>纯整数时：<ul><li>正数：本身数值</li><li>负数：2^n-本身数值</li></ul></li></ul><h2 id="反码表示法"><a href="#反码表示法" class="headerlink" title="反码表示法"></a>反码表示法</h2><ul><li>正数：本身数值</li><li>负数：本身数值按位取反</li><li>+0反码：00000000</li><li>-0反码：11111111</li></ul><h2 id="移码表示法"><a href="#移码表示法" class="headerlink" title="移码表示法"></a>移码表示法</h2><p>将补码符号位求反<br></p><h2 id="数的定点表示"><a href="#数的定点表示" class="headerlink" title="数的定点表示"></a>数的定点表示</h2><p><strong>定点小数：用于尾数（表示数值）</strong><br><strong>定点整数：用于阶码（表示指数）</strong></p><h2 id="数的浮点表示法"><a href="#数的浮点表示法" class="headerlink" title="数的浮点表示法"></a>数的浮点表示法</h2><h3 id="浮点数的表示格式"><a href="#浮点数的表示格式" class="headerlink" title="浮点数的表示格式"></a>浮点数的表示格式</h3><ul><li>阶码+尾数：其中阶码是定点整数，用补码表示；尾数是定点小数，用补码显示</li><li>尾数符+阶码+尾数值：其中阶码是定点整数，用移码表示；尾数值是定点小数，用补码表示</li></ul><h3 id="浮点数的规格化"><a href="#浮点数的规格化" class="headerlink" title="浮点数的规格化"></a>浮点数的规格化</h3><p>可以提高数据的精度，—–&gt;提高精度可以有两种方法</p><ol><li>尾数位数增加</li><li>尾数规格化<br><br>所谓规格化就是调整阶码使其尾数满足如下形式：</li></ol><ul><li>原码规格化后：正数为0.1开头，负数为1.1开头</li><li>补码规格化后：正数为0.1开头，负数为1.0开头</li></ul><h3 id="浮点数规格化习题示例"><a href="#浮点数规格化习题示例" class="headerlink" title="浮点数规格化习题示例"></a>浮点数规格化习题示例</h3><p>某机器用32位表示一个数，阶码部分占8位（含一个符号位），尾数部分占24位（含一个符号位）<br>设x1&#x3D;-256.5，x2&#x3D;127&#x2F;256，试写出x1和x2的两种浮点数表示格式：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dns">首先分析x1<br>x1真值为-<span class="hljs-number">256</span>.<span class="hljs-number">5</span><br>写成原码就是二进制真值就是-（<span class="hljs-number">100000000.1</span>）<br>因为规格化后要满足：正数为<span class="hljs-number">0</span>.<span class="hljs-number">1</span>开头，负数为<span class="hljs-number">1</span>.<span class="hljs-number">0</span>开头<br>所以可以写成-<span class="hljs-number">2</span>^<span class="hljs-number">9</span>*<span class="hljs-number">0</span>.<span class="hljs-number">1000000001</span>，也就是<span class="hljs-number">2</span>^<span class="hljs-number">9</span>*<span class="hljs-number">1</span>.<span class="hljs-number">1000000001</span>(接下来取补码后成为<span class="hljs-number">1</span>.<span class="hljs-number">0</span>开头）<br>先计算阶码：<br>阶码的原码为<span class="hljs-number">9</span><br>所以阶码的补码为：<span class="hljs-number">1001</span>，占<span class="hljs-number">8</span>位，所以在远离小数点的地方补<span class="hljs-number">0</span>，最后可得<span class="hljs-number">00001001</span><br>移码为补码的符号位取反，所以移码为<span class="hljs-number">10001001</span><br>接着计算尾数：<br>尾数的补码为：<span class="hljs-number">1</span>.<span class="hljs-number">01111111110000000000000</span><br>接着组合写成格式即可<br><br>再来分析x2<br>x<span class="hljs-number">2=127/256</span>可以写成<span class="hljs-number">1111111*2</span>^(-<span class="hljs-number">8</span>)=<span class="hljs-number">0.1111111*2</span>^(-<span class="hljs-number">1</span>)<br>阶码的补码为：-<span class="hljs-number">1</span>的补码=<span class="hljs-number">11111111</span><br>阶码的移码为：<span class="hljs-number">01111111</span><br>尾数为：<span class="hljs-number">0</span>.<span class="hljs-number">11111110000000000000000</span><br>组合即可<br></code></pre></td></tr></table></figure><h3 id="浮点数的表示范围（设阶码和尾数均为n位）"><a href="#浮点数的表示范围（设阶码和尾数均为n位）" class="headerlink" title="浮点数的表示范围（设阶码和尾数均为n位）"></a>浮点数的表示范围（设阶码和尾数均为n位）</h3><ol><li>阶码表示范围</li></ol><table><thead><tr><th>————</th><th>最小负数</th><th>最大负数</th><th>最小正数</th><th>最大正数</th></tr></thead><tbody><tr><td>二进制补码</td><td>100…0(共n位，最小则全为0）</td><td>111…1(共n位，首位的1代表负，最大则剩下的全补1)</td><td>000…1(共n位，第一位0为符号位)</td><td>011…1(共n位，第一位0为符号位)</td></tr><tr><td>十进制真值</td><td>计算可得</td><td>计算可得</td><td>计算可得</td><td>计算可得</td></tr><tr><td>2. 规格化尾数表示范围（补码规格化后正数为0.1…形式，负数为1.0…形式）</td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>—————</th><th>最小负数</th><th>最大负数</th><th>最小正数</th><th>最大正数</th></tr></thead><tbody><tr><td>二进制补码</td><td>1.0….0</td><td>1.011..1</td><td>0.10…0</td><td>0.11…1</td></tr><tr><td>十进制真值</td><td>计算可得</td><td>计算可得</td><td>计算可得</td><td>计算可得</td></tr><tr><td>3. 规格化浮点数表示范围</td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>最小负数</th><th>最大负数</th><th>最小正数</th><th>最大正数</th></tr></thead><tbody><tr><td>尾数负最小*2^(正阶码最大)</td><td>尾数负最大*2^(负阶码最小)</td><td>尾数正最小*2^(负阶码最小)</td><td>尾数正最大*2^(正阶码最大)</td></tr></tbody></table><h2 id="非数值数据的表示"><a href="#非数值数据的表示" class="headerlink" title="非数值数据的表示"></a>非数值数据的表示</h2><h3 id="字符表示"><a href="#字符表示" class="headerlink" title="字符表示"></a>字符表示</h3><p>ASCII码（美国信息交换标准码）：<br>共有128个字符，即2^7，因此占据7位，最高位为0，而汉字编码最高位为1<br>所以可以根据最高位来区分是否为汉字编码</p><h3 id="汉字的表示"><a href="#汉字的表示" class="headerlink" title="汉字的表示"></a>汉字的表示</h3><p>区位码(不唯一)→十进制区位码→十六进制+2020H→国标码十六进制+8080H→机内码(唯一)<br>一个汉字用两个字节表示区内码<br><br><img src="/2019/09/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0/hz.png"></p><h2 id="定点加减法运算"><a href="#定点加减法运算" class="headerlink" title="定点加减法运算"></a>定点加减法运算</h2><p>在计算机中，常将数值转化为补码后再进行加减运算，优点是可以将减法运算转化为加法运算<br></p><h3 id="加减法运算规则："><a href="#加减法运算规则：" class="headerlink" title="加减法运算规则："></a>加减法运算规则：</h3><ol><li>补码运算</li><li>数值位和符号位一同参与运算</li><li>求差时，将减数求补，用求和代替求差</li><li>运算结果为补码，符号位0表示正数，符号位1表示负数</li><li>符号位的进位为模值，应该丢掉</li></ol><h3 id="加法运算："><a href="#加法运算：" class="headerlink" title="加法运算："></a>加法运算：</h3><p> [X]补+[Y]补&#x3D;[X+Y]补</p><h3 id="减法运算"><a href="#减法运算" class="headerlink" title="减法运算"></a>减法运算</h3><p>[X]补-[Y]补&#x3D;[X+(-Y)]补&#x3D;[X]补+[-Y]补<br>因为[-Y]补+[Y]补&#x3D;[0]补&#x3D;0<br>所以[-Y]补&#x3D;-[Y]补<br>所以只要能通过[Y]补求得[-Y]补，就可以将补码减法运算化为补码加法运算<br>已知[Y]补，求[-Y]补的法则是：<br>对[Y]补各位(包括符号位)求反，然后在末位加上1<br>例如：[Y]补&#x3D;1.1010 ，则[-Y]补&#x3D;0.0110</p><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p>求负数的补码：把它的原码自低位向高位看去，遇到的第一个’1’及其右边的’0’都不变，将左边的所有位按位取反，符号位不变。</p><h3 id="溢出判断法："><a href="#溢出判断法：" class="headerlink" title="溢出判断法："></a>溢出判断法：</h3><p>在运算结果超出机器所能表示的数值范围后，就会产生溢出。<br><br>溢出有两种判断的方法：双符号法和进位判断法<br></p><h4 id="双符号法："><a href="#双符号法：" class="headerlink" title="双符号法："></a>双符号法：</h4><p>也叫做变形补码法，模4补码法<br><br>采用的方法是用两个相同的符号位表示一个数的符号，左边第一位为第一符号位，第二位为第二符号位<br><br>第一符号位始终表示真正的符号，如果计算结果超出模值，则丢掉<br></p><table><thead><tr><th>符号</th><th>表示</th></tr></thead><tbody><tr><td>00</td><td>正数</td></tr><tr><td>01</td><td>正溢出</td></tr><tr><td>10</td><td>负溢出</td></tr><tr><td>11</td><td>负数</td></tr></tbody></table><h4 id="进位判断法："><a href="#进位判断法：" class="headerlink" title="进位判断法："></a>进位判断法：</h4><p>当两个单符号位的补码进行加减运算时，若最高数值位向符号位的进位值C与符号位产生的进位输出值S相同则没有溢出发生，否则，有溢出发生<br><br>用异或的方式进行判断</p><h2 id="基本的二进制加，减法器"><a href="#基本的二进制加，减法器" class="headerlink" title="基本的二进制加，减法器"></a>基本的二进制加，减法器</h2><p><img src="/2019/09/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%8A%A0%E5%87%8F%E6%B3%95%E5%99%A8.png" alt="基本的加减法器"></p><ol><li><p>加法的实现<br><br><img src="/2019/09/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%AE%9E%E7%8E%B0.png" alt="实现的图片"></p><ol><li>p&#x3D;0</li><li>设$Y_{n-1}$&#x3D;0，异或门输出为0；设$Y_{n-1}$为1，异或门输出为1。</li><li>总结：异或门输出&#x3D;$Y_{n-1}$</li><li>加法：[X]补+[Y]补&#x3D;[X+Y]补</li></ol></li><li><p>减法的实现<br><br><img src="/2019/09/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%AE%9E%E7%8E%B0.png" alt="实现的图片"></p><ol><li>p&#x3D;1</li><li>设$Y_{n-1}$&#x3D;0，异或门输出为1；反之为0；</li><li>总结：异或门输出&#x3D;$Y_{n-1}$取反</li><li>减法实现：[X]补-[Y]补&#x3D;[X]补+[Y]补取反+$2 ^{-n}$  (n是小数点之后的位数，+$2 ^{-n}$的意思是在末尾+1)</li><li>末尾的加1来源于一开始的Cn，Cn&#x3D;p&#x3D;1 （设计巧妙）</li></ol></li></ol><h2 id="定点乘法运算"><a href="#定点乘法运算" class="headerlink" title="定点乘法运算"></a>定点乘法运算</h2><h3 id="原码一位乘法"><a href="#原码一位乘法" class="headerlink" title="原码一位乘法"></a>原码一位乘法</h3><h4 id="乘法的本质："><a href="#乘法的本质：" class="headerlink" title="乘法的本质："></a>乘法的本质：</h4><p>将乘法变成加法和右移运算的结果</p><h4 id="运算法则："><a href="#运算法则：" class="headerlink" title="运算法则："></a>运算法则：</h4><ol><li>被乘数和乘数均取绝对值参加运算，符号位单独考虑</li><li>被乘数取双符号位，部分积的长度与被乘数的长度相同，初值为0</li><li>从乘数的最低位的$y_n$位开始对乘数进行判断：若$y_n$&#x3D;1，则部分积加上被乘数|X|，然后右移一位；若$y_n$&#x3D;0，则部分积加上0，然后右移一位</li><li>重复3的判断n次</li></ol><h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><p><img src="/%E7%AC%AC%E4%BA%8C%E7%AB%A0%5C%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95.jpg" alt="原码一位乘法"></p><p>之后符号位就是x，y的符号位进行异或运算为0，数值位就是|X|.|Y|&#x3D;0.10001111<br>所以最后结果为0.10001111</p><h3 id="补码一位乘法"><a href="#补码一位乘法" class="headerlink" title="补码一位乘法"></a>补码一位乘法</h3><h4 id="运算规则："><a href="#运算规则：" class="headerlink" title="运算规则："></a>运算规则：</h4><ol><li>符号位参与运算，运算的数均以补码表示</li><li>被乘数一般取双符号位参与运算，部分积初始值为0</li><li>看乘数小数点位数决定移多少次</li><li>乘数末位增设附加位$y_{n+1}$，且初值为0</li><li>按下表进行操作</li></ol><table><thead><tr><th>$y_n$(高位)</th><th>$y_{n+1}$(低位)</th><th>操作</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>部分积右移一位</td></tr><tr><td>0</td><td>1</td><td>部分积加[x]补，右移一位</td></tr><tr><td>1</td><td>0</td><td>部分积加[-x]补，右移一位</td></tr><tr><td>1</td><td>1</td><td>部分积右移一位</td></tr></tbody></table><h4 id="例题：-1"><a href="#例题：-1" class="headerlink" title="例题："></a>例题：</h4><p><img src="/%E7%AC%AC%E4%BA%8C%E7%AB%A0%5C%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95.jpg" alt="补码一位乘法"></p><h3 id="补码两位乘法"><a href="#补码两位乘法" class="headerlink" title="补码两位乘法"></a>补码两位乘法</h3><p>减少运算步骤，提高运算速度<br><br>运算规则如下：<br><br>符号位参与运算，两数均以补码表示<br><br>部分积与被乘数均采用<strong>3位符号</strong>表示，乘数<strong>末位增加一位</strong>$y_{n+1}$，其初值为0<br></p><table><thead><tr><th>$Y_{n-1}$</th><th>$Y_n$</th><th>$Y_{n+1}$</th><th>操作</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>加0，右移两位</td></tr><tr><td>0</td><td>0</td><td>1</td><td>加[x]补，右移两位</td></tr><tr><td>0</td><td>1</td><td>0</td><td>加[x]补，右移两位</td></tr><tr><td>0</td><td>1</td><td>1</td><td>加2[x]补，右移两位</td></tr><tr><td>1</td><td>0</td><td>0</td><td>加2[-x]补，右移两位</td></tr><tr><td>1</td><td>0</td><td>1</td><td>加[-x]补，右移两位</td></tr><tr><td>1</td><td>1</td><td>0</td><td>加[-x]补，右移两位</td></tr><tr><td>1</td><td>1</td><td>1</td><td>加0，右移两位</td></tr></tbody></table><p>总结：<br><br>$Y_{n-1}$为0，代表正，即“+”，之后看1的个数决定加几个[x]补<br><br>$Y_{n-1}$为1，代表负，即“-”，之后看0的个数决定加几个[-x]补<br><br>若尾数n为偶数，则乘数用两位符号，最后一步不移位；<br><br>若尾数n为奇数，则乘数用一位符号，最后一步移一位<br><br>示例：<br>第一题：<br><img src="/%E7%AC%AC%E4%BA%8C%E7%AB%A0%5C%E8%A1%A5%E7%A0%81%E4%B8%A4%E4%BD%8D%E4%B9%98%E6%B3%951.jpg" alt="第二章\补码两位乘法1.jpg"><br>第二题：<br><img src="/%E7%AC%AC%E4%BA%8C%E7%AB%A0%5C%E8%A1%A5%E7%A0%81%E4%B8%A4%E4%BD%8D%E4%B9%98%E6%B3%952.jpg" alt="第二章\补码两位乘法2.jpg"></p><h2 id="定点除法运算"><a href="#定点除法运算" class="headerlink" title="定点除法运算"></a>定点除法运算</h2><h3 id="补码一位除法"><a href="#补码一位除法" class="headerlink" title="补码一位除法"></a>补码一位除法</h3><p>本质：加法和左移<br><br>三个规则：</p><ul><li>比较上商规则：比较被除数与除数符号，余数和除数符号</li><li>商的校正规则</li><li>余数校正规则<br>补码不恢复余数法的算法规则；</li></ul><ol><li>符号位参加运算，除数与被除数均用双符号位补码表示</li><li>当被除数与除数同号时，用被除数减去除数；被除数与除数异号时，用被除数加上除数；商符号位的取值见3</li><li>当余数与除数同号时，商上1，余数左移一位减去除数；余数与除数异号时，商上0，余数左移一位加上除数</li><li>余数左移加上或减去除数后就得到了新余数</li><li>采用校正法包括符号位在内，规则3应重复n+1次</li></ol><p>商的校正原则：</p><ol><li>当刚好能除尽(即运算过程中任一步余数为0)时，</li></ol><ul><li>若除数为正，则商不必校正；</li><li>若除数为负，则商需要校正，即加$2^{-n}$进行修正</li></ul><ol start="2"><li>当不能除尽时，</li></ol><ul><li>若商为正，则不必校正；</li><li>若商为负，则商需要加$2^{-n}$校正</li></ul><p>余数之所以要校正，是因为在补码不恢复余数除法运算过程中先比较后上商的缘故<br><br>余数的校正方法：</p><ul><li>若商为正，则当余数与被除数异号时，应将余数加上除数进行校正才能获得正确的余数</li><li>若商为负，则当余数与被除数异号时，余数需要减去除数进行校正</li></ul><p>商校正，能除尽，看除数；不能除尽，看商，正的不必校正<br>余数校正，看被除数，同号不校正；异号看商，正加，负减除数<br>思维导图示例：<br><img src="/%E7%AC%AC%E4%BA%8C%E7%AB%A0%5C%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E9%99%A4%E6%B3%95%E6%A0%A1%E6%AD%A3.png" alt="补码一位除法思维导图"><br>习题示例：<br><img src="/%E7%AC%AC%E4%BA%8C%E7%AB%A0%5C%E8%A1%A5%E7%A0%81%E9%99%A4%E6%B3%95.jpg" alt="补码除法习题"></p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Win10下安装Linux子系统</title>
    <link href="/2019/09/08/Win10%E4%B8%8B%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2019/09/08/Win10%E4%B8%8B%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="第一步-打开更新和安全选项"><a href="#第一步-打开更新和安全选项" class="headerlink" title="第一步 打开更新和安全选项"></a>第一步 打开更新和安全选项</h2><p><img src="/2019/09/08/Win10%E4%B8%8B%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/step1.png" alt="step1"></p><h2 id="第二步-开启开发人员模式"><a href="#第二步-开启开发人员模式" class="headerlink" title="第二步 开启开发人员模式"></a>第二步 开启开发人员模式</h2><p><img src="/2019/09/08/Win10%E4%B8%8B%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/step2.png" alt="step2"></p><h2 id="第三步-打开应用与功能选项，找到相关设置"><a href="#第三步-打开应用与功能选项，找到相关设置" class="headerlink" title="第三步  打开应用与功能选项，找到相关设置"></a>第三步  打开应用与功能选项，找到相关设置</h2><p><img src="/2019/09/08/Win10%E4%B8%8B%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/step3.png" alt="step3"></p><h2 id="第四步-启动或关闭Windows功能"><a href="#第四步-启动或关闭Windows功能" class="headerlink" title="第四步 启动或关闭Windows功能"></a>第四步 启动或关闭Windows功能</h2><p><img src="/2019/09/08/Win10%E4%B8%8B%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/step4.png" alt="step4"></p><h2 id="第五步-勾选适用于Linux的Windows子系统"><a href="#第五步-勾选适用于Linux的Windows子系统" class="headerlink" title="第五步  勾选适用于Linux的Windows子系统"></a>第五步  勾选适用于Linux的Windows子系统</h2><p><img src="/2019/09/08/Win10%E4%B8%8B%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/step5.png" alt="step5"></p><h2 id="第六步-按提示重启电脑-之后打开Windows商店"><a href="#第六步-按提示重启电脑-之后打开Windows商店" class="headerlink" title="第六步  按提示重启电脑,之后打开Windows商店"></a>第六步  按提示重启电脑,之后打开Windows商店</h2><p><img src="/2019/09/08/Win10%E4%B8%8B%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/step6-2.png" alt="step6"></p><h2 id="第七步-搜索，安装-启动"><a href="#第七步-搜索，安装-启动" class="headerlink" title="第七步 搜索，安装,启动"></a>第七步 搜索，安装,启动</h2><p><img src="/2019/09/08/Win10%E4%B8%8B%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/step.png" alt="step7"></p><h2 id="第七步-启动后设置用户名，密码"><a href="#第七步-启动后设置用户名，密码" class="headerlink" title="第七步 启动后设置用户名，密码"></a>第七步 启动后设置用户名，密码</h2><p><img src="/2019/09/08/Win10%E4%B8%8B%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/step7.png" alt="step7"></p>]]></content>
    
    
    <categories>
      
      <category>各种搭建配置坑的记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用gulp优化hexo</title>
    <link href="/2019/09/08/%E4%BD%BF%E7%94%A8gulp%E4%BC%98%E5%8C%96hexo/"/>
    <url>/2019/09/08/%E4%BD%BF%E7%94%A8gulp%E4%BC%98%E5%8C%96hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法:"></a>主要方法:<br></h1><p>参考这位博主的文章：<br><br><a href="https://segmentfault.com/a/1190000019842178">Hexo博客使用gulp压缩静态资源</a><br><br>以下插件如果安装过慢参考：<br><br><a href="https://www.cnblogs.com/sddai/p/9388261.html">https://www.cnblogs.com/sddai/p/9388261.html</a></p><h2 id="1、全局安装gulp"><a href="#1、全局安装gulp" class="headerlink" title="1、全局安装gulp"></a>1、全局安装gulp</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> gulp -g<br><span class="hljs-comment"># 查看版本</span><br>gulp -v<br></code></pre></td></tr></table></figure><h2 id="2、安装gulp插件"><a href="#2、安装gulp插件" class="headerlink" title="2、安装gulp插件"></a>2、安装gulp插件</h2><p>在hexo根目录下安装</p><ul><li><p>npm install gulp –save</p></li><li><p>npm install gulp-minify-css –save</p></li><li><p>npm install gulp-uglify –save</p></li><li><p>npm install gulp-htmlmin –save</p></li><li><p>npm install gulp-htmlclean –save</p></li><li><p>npm install gulp-imagemin –save</p><br>*解决【Gulp打包问题】 GulpUglifyError: unable to minify JavaScript*<br>*解决 gulp-uglify 压缩JavaScript 不兼容 es5 语法的问题*<br></li><li><p>npm install <a href="mailto:&#98;&#97;&#98;&#x65;&#108;&#x2d;&#99;&#111;&#x72;&#101;&#x40;&#x36;&#x2e;&#x32;&#x36;&#46;&#51;">&#98;&#97;&#98;&#x65;&#108;&#x2d;&#99;&#111;&#x72;&#101;&#x40;&#x36;&#x2e;&#x32;&#x36;&#46;&#51;</a> –save</p></li><li><p>npm install <a href="mailto:&#103;&#117;&#108;&#x70;&#x2d;&#98;&#97;&#98;&#101;&#108;&#64;&#x37;&#46;&#x30;&#x2e;&#49;">&#103;&#117;&#108;&#x70;&#x2d;&#98;&#97;&#98;&#101;&#108;&#64;&#x37;&#46;&#x30;&#x2e;&#49;</a> –save</p></li><li><p>npm install <a href="mailto:&#98;&#97;&#x62;&#101;&#x6c;&#x2d;&#x70;&#x72;&#101;&#x73;&#101;&#116;&#x2d;&#101;&#115;&#x32;&#48;&#49;&#x35;&#64;&#54;&#x2e;&#50;&#x34;&#46;&#49;">&#98;&#97;&#x62;&#101;&#x6c;&#x2d;&#x70;&#x72;&#101;&#x73;&#101;&#116;&#x2d;&#101;&#115;&#x32;&#48;&#49;&#x35;&#64;&#54;&#x2e;&#50;&#x34;&#46;&#49;</a> –save<br><br><em>gulp-babel 取消严格模式方法(“use strict”)</em></p></li><li><p>npm install babel-plugin-transform-remove-strict-mode –save</p><p>  问题：如果安装gulp-imagemin错误请执行以下语句<br>  sudo npm i gulp-imagemin –unsafe-perms</p></li></ul><h2 id="3、创建gulpfile-js文件"><a href="#3、创建gulpfile-js文件" class="headerlink" title="3、创建gulpfile.js文件"></a>3、创建gulpfile.js文件</h2><p>在 Hexo 站点下新建gulpfile.js文件，文件内容如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs awk">var gulp = require(<span class="hljs-string">&#x27;gulp&#x27;</span>);<br>var minifycss = require(<span class="hljs-string">&#x27;gulp-minify-css&#x27;</span>);<br>var uglify = require(<span class="hljs-string">&#x27;gulp-uglify&#x27;</span>);<br>var htmlmin = require(<span class="hljs-string">&#x27;gulp-htmlmin&#x27;</span>);<br>var htmlclean = require(<span class="hljs-string">&#x27;gulp-htmlclean&#x27;</span>);<br>var imagemin = require(<span class="hljs-string">&#x27;gulp-imagemin&#x27;</span>);<br>var babel = require(<span class="hljs-string">&#x27;gulp-babel&#x27;</span>);<br><br><span class="hljs-regexp">//</span> 压缩css文件<br>gulp.task(<span class="hljs-string">&#x27;minify-css&#x27;</span>, <span class="hljs-keyword">function</span> (done) &#123;<br>    return gulp.src(<span class="hljs-string">&#x27;./public/**/*.css&#x27;</span>)<br>        .pipe(minifycss())<br>        .pipe(gulp.dest(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>    done();<br>&#125;);<br><br><span class="hljs-regexp">//</span> 压缩html文件<br>gulp.task(<span class="hljs-string">&#x27;minify-html&#x27;</span>, <span class="hljs-keyword">function</span> (done) &#123;<br>    return gulp.src(<span class="hljs-string">&#x27;./public/**/*.html&#x27;</span>)<br>        .pipe(htmlclean())<br>        .pipe(htmlmin(&#123;<br>            removeComments: true,<br>            minifyJS: true,<br>            minifyCSS: true,<br>            minifyURLs: true,<br>        &#125;))<br>        .pipe(gulp.dest(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>    done();<br>&#125;);<br><br><span class="hljs-regexp">//</span> 压缩js文件<br>gulp.task(<span class="hljs-string">&#x27;minify-js&#x27;</span>, <span class="hljs-keyword">function</span> (done) &#123;<br>    return gulp.src([<span class="hljs-string">&#x27;./public/**/*.js&#x27;</span>, <span class="hljs-string">&#x27;!./public/**/*.min.js&#x27;</span>])<br>        .pipe(babel(&#123;<br>            <span class="hljs-regexp">//</span>将ES6代码转译为可执行的JS代码<br>            presets: [<span class="hljs-string">&#x27;es2015&#x27;</span>] <span class="hljs-regexp">//</span> es5检查机制<br>        &#125;))<br>        .pipe(uglify())<br>        .pipe(gulp.dest(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>    done();<br>&#125;);<br><br><span class="hljs-regexp">//</span> 压缩 public/images 目录内图片(Version&lt;<span class="hljs-number">3</span>)<br><span class="hljs-regexp">//</span> gulp.task(<span class="hljs-string">&#x27;minify-images&#x27;</span>, <span class="hljs-keyword">function</span> () &#123;<br><span class="hljs-regexp">//</span>     gulp.src(<span class="hljs-string">&#x27;./public/images/**/*.*&#x27;</span>)<br><span class="hljs-regexp">//</span>         .pipe(imagemin(&#123;<br><span class="hljs-regexp">//</span>             optimizationLevel: <span class="hljs-number">5</span>, <span class="hljs-regexp">//</span>类型：Number  默认：<span class="hljs-number">3</span>  取值范围：<span class="hljs-number">0</span>-<span class="hljs-number">7</span>（优化等级）<br><span class="hljs-regexp">//</span>             progressive: true, <span class="hljs-regexp">//</span>类型：Boolean 默认：false 无损压缩jpg图片<br><span class="hljs-regexp">//</span>             interlaced: false, <span class="hljs-regexp">//</span>类型：Boolean 默认：false 隔行扫描gif进行渲染<br><span class="hljs-regexp">//</span>             multipass: false, <span class="hljs-regexp">//</span>类型：Boolean 默认：false 多次优化svg直到完全优化<br><span class="hljs-regexp">//</span>         &#125;))<br><span class="hljs-regexp">//</span>         .pipe(gulp.dest(<span class="hljs-string">&#x27;./public/images&#x27;</span>));<br><span class="hljs-regexp">//</span> &#125;);<br><br><span class="hljs-regexp">//</span> 压缩 public/images 目录内图片(Version&gt;<span class="hljs-number">3</span>)<br>gulp.task(<span class="hljs-string">&#x27;minify-images&#x27;</span>, <span class="hljs-keyword">function</span> (done) &#123;<br>    gulp.src(<span class="hljs-string">&#x27;./public/images/**/*.*&#x27;</span>)<br>        .pipe(imagemin([<br>            imagemin.gifsicle(&#123;interlaced: true&#125;),<br>            imagemin.jpegtran(&#123;progressive: true&#125;),<br>            imagemin.optipng(&#123;optimizationLevel: <span class="hljs-number">5</span>&#125;),<br>            imagemin.svgo(&#123;<br>                plugins: [<br>                    &#123;removeViewBox: true&#125;,<br>                    &#123;cleanupIDs: false&#125;<br>                ]<br>            &#125;)<br>        ]))<br>        .pipe(gulp.dest(<span class="hljs-string">&#x27;./public/images&#x27;</span>));<br>    done();<br>&#125;);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">4.0</span>以前的写法 <br><span class="hljs-regexp">//gu</span>lp.task(<span class="hljs-string">&#x27;default&#x27;</span>, [<br><span class="hljs-regexp">//</span>  <span class="hljs-string">&#x27;minify-html&#x27;</span>, <span class="hljs-string">&#x27;minify-css&#x27;</span>, <span class="hljs-string">&#x27;minify-js&#x27;</span>, <span class="hljs-string">&#x27;minify-images&#x27;</span><br><span class="hljs-regexp">//</span>]);<br><span class="hljs-regexp">//</span><span class="hljs-number">4.0</span>以后的写法<br><span class="hljs-regexp">//</span> 执行 gulp 命令时执行的任务<br>gulp.task(<span class="hljs-string">&#x27;default&#x27;</span>, gulp.series(gulp.parallel(<span class="hljs-string">&#x27;minify-html&#x27;</span>, <span class="hljs-string">&#x27;minify-css&#x27;</span>, <span class="hljs-string">&#x27;minify-js&#x27;</span>, <span class="hljs-string">&#x27;minify-images&#x27;</span>)), <span class="hljs-keyword">function</span> () &#123;<br>    console.log(<span class="hljs-string">&quot;----------gulp Finished----------&quot;</span>);<br>    <span class="hljs-regexp">//</span> Do something after a, b, and c are finished.<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="4、创建-babelrc文件"><a href="#4、创建-babelrc文件" class="headerlink" title="4、创建.babelrc文件"></a>4、创建.babelrc文件</h2><p>在 Hexo 站点下新建.babelrc文件，文件内容如下：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>    <span class="hljs-string">&#x27;presets&#x27;</span>: [<span class="hljs-string">&#x27;es2015&#x27;</span>],<br>    <span class="hljs-string">&quot;plugins&quot;</span>: [<span class="hljs-string">&quot;transform-remove-strict-mode&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、静态资源压缩"><a href="#5、静态资源压缩" class="headerlink" title="5、静态资源压缩"></a>5、静态资源压缩</h2><pre><code class="hljs">只需要每次在执行 generate 命令后执行 gulp 就可以实现对静态资源的压缩</code></pre><p>hexo g<br>gulp</p><h2 id="6、补充："><a href="#6、补充：" class="headerlink" title="6、补充："></a>6、补充：</h2><h3 id="1-windows下创建-babelrc文件"><a href="#1-windows下创建-babelrc文件" class="headerlink" title="1.windows下创建.babelrc文件"></a>1.windows下创建.babelrc文件</h3><p>在windows系统下无法直接创建.babelrc文件，需要进入进入cmd窗口，进入hexo所在路径，使用<code>type nul&gt;名称 </code>来创建文件</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">type</span> <span class="hljs-built_in">nul</span>&gt;.babelrc<br></code></pre></td></tr></table></figure><h3 id="2-解决npm速度过慢问题"><a href="#2-解决npm速度过慢问题" class="headerlink" title="2.解决npm速度过慢问题"></a>2.解决npm速度过慢问题</h3><p><a href="https://www.cnblogs.com/sddai/p/9388261.html">npm过慢的解决方案</a></p>]]></content>
    
    
    <categories>
      
      <category>hexo博客相关配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程(3)</title>
    <link href="/2019/09/07/%E7%BA%BF%E7%A8%8B-3/"/>
    <url>/2019/09/07/%E7%BA%BF%E7%A8%8B-3/</url>
    
    <content type="html"><![CDATA[<h2 id="Timer和Swing-Timer"><a href="#Timer和Swing-Timer" class="headerlink" title="Timer和Swing Timer"></a>Timer和Swing Timer</h2><ul><li>java提供了Timer和Swing Timer控件，用于执行规划好的任务或循环任务 *</li></ul><h3 id="Timer："><a href="#Timer：" class="headerlink" title="Timer："></a>Timer：</h3><p>使用步骤：</p><ol><li>定义一个类继承TimerTask，重写其中的run（）方法，这个方法就是所要执行的任务代码</li><li>创建Timer对象，通常使用不带参数的构造方法Timer（）直接实例化</li><li>调用Timer对象的schedule（）方法安排任务，传递一个TimerTask对象作为参数</li></ol><ul><li>schedule（TimerTask task，Date time）：在指定的时间执行任务</li><li>schedule（TimerTask task，Date firstTime，long period）：第一次到达指定时间firsttime时执行特定任务，并且每隔period参数指定的时间（毫秒）重复执行该任务</li><li>schedule（TimerTask task，long delay，long period）：延迟delay时间第一次执行任务，并且每隔period时间重复执行该任务</li></ul><ol start="4"><li>为取消一个规划好的任务，调用Timer对象的cancel方法</li></ol><h3 id="Swing-Timer："><a href="#Swing-Timer：" class="headerlink" title="Swing Timer："></a>Swing Timer：</h3><p>功能与Timer类一样，但只能在Swing应用程序中使用，可以处理线程共享，且不用将规划好的任务放在TimerTask子类的run（）方法中，而是在actionPerformed（）方法中编写所要执行的任务代码。<br><br>当要取消某个任务时，只需调用stop（）方法即可<br></p><h4 id="语法格式："><a href="#语法格式：" class="headerlink" title="语法格式："></a>语法格式：</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Timer（<span class="hljs-type">int</span> delay，ActionListener listener）<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>参数delay用于规定从调用start（）方法开始到第一次执行该任务的时间间隔（单位为毫秒）</li><li>参数listener指定监听对象，即ActionListener类的实例</li></ul><h4 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h4><ol><li>定义一个监听类，实现ActionListener监听接口，并重写actionPerformed方法，在该方法中编写所执行任务的代码</li><li>创建javax.swing.Timer对象</li><li>调用start（）方法启动Swing Timer</li><li>取消任务时可以调用stop（）方法停止Swing Timer</li></ol><h2 id="代码实例："><a href="#代码实例：" class="headerlink" title="代码实例："></a>代码实例：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 线程;<br><span class="hljs-keyword">import</span> java.awt.Color;<br><span class="hljs-keyword">import</span> java.awt.Font;<br><span class="hljs-keyword">import</span> java.awt.event.ActionEvent;<br><span class="hljs-keyword">import</span> java.awt.event.ActionListener;<br><span class="hljs-keyword">import</span> java.util.Timer;<br><span class="hljs-keyword">import</span> java.util.TimerTask;<br><br><span class="hljs-keyword">import</span> javax.swing.JButton;<br><span class="hljs-keyword">import</span> javax.swing.JFrame;<br><span class="hljs-keyword">import</span> javax.swing.JLabel;<br><span class="hljs-comment">//多线程案例，采用三种方法实现窗口背景，标签文字，不断变化，按钮左右移动</span><br><span class="hljs-keyword">import</span> javax.swing.JPanel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MutilThreadDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JFrame</span>&#123;<br>    <span class="hljs-comment">// 定义窗口，标签，按钮</span><br>JPanel jPanel=<span class="hljs-literal">null</span>;<br>JLabel jLabel=<span class="hljs-literal">null</span>;<br>JButton jButton=<span class="hljs-literal">null</span>;<br>String word[]= &#123;<span class="hljs-string">&quot;桐乃&quot;</span>,<span class="hljs-string">&quot;小埋&quot;</span>,<span class="hljs-string">&quot;宫子&quot;</span>,<span class="hljs-string">&quot;日向&quot;</span>&#125;;<br>    <span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> movex=<span class="hljs-number">5</span>;<br><span class="hljs-comment">//构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">MutilThreadDemo</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>jPanel=<span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>();<br>jLabel=<span class="hljs-keyword">new</span> <span class="hljs-title class_">JLabel</span>(word[<span class="hljs-number">0</span>]);<br>jButton=<span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">&quot;左右横移&quot;</span>);<br>jLabel.setFont(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>(<span class="hljs-string">&quot;黑体&quot;</span>,Font.BOLD,<span class="hljs-number">28</span>));<br>jLabel.setBounds(<span class="hljs-number">80</span>,<span class="hljs-number">50</span>,<span class="hljs-number">250</span>,<span class="hljs-number">50</span>);<br>jButton.setBounds(<span class="hljs-number">0</span>,<span class="hljs-number">150</span>,<span class="hljs-number">120</span>,<span class="hljs-number">25</span>);<br>jPanel.add(jLabel);<br>jPanel.add(jButton);<br><span class="hljs-built_in">this</span>.add(jPanel);<br><span class="hljs-built_in">this</span>.setSize(<span class="hljs-number">500</span>,<span class="hljs-number">300</span>);<br><span class="hljs-built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br><span class="hljs-comment">//采用Thread改变背景</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ChangeColor</span>().start();<br><span class="hljs-comment">//采用Timer改变文字</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>().schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChangeWord</span>(), <span class="hljs-number">0</span>,<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//采用Swing Timer改变按钮位置</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">javax</span>.swing.Timer(<span class="hljs-number">100</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChangePos</span>()).start();<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeColor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.isAlive()) &#123;<br><span class="hljs-type">int</span> r=(<span class="hljs-type">int</span>)(Math.random()*<span class="hljs-number">256</span>);<br><span class="hljs-type">int</span> g=(<span class="hljs-type">int</span>)(Math.random()*<span class="hljs-number">256</span>);<br><span class="hljs-type">int</span> b=(<span class="hljs-type">int</span>)(Math.random()*<span class="hljs-number">256</span>);<br>jPanel.setBackground(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(r,g,b));<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeWord</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TimerTask</span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>    jLabel.setText(word[index++]);<br>    <span class="hljs-keyword">if</span>(index==word.length)<br>    index=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangePos</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ActionListener</span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span><span class="hljs-params">(ActionEvent arg0)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>   <span class="hljs-type">int</span> x=jButton.getX()+movex;<br>   <span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-number">0</span>) &#123;<br>   <span class="hljs-comment">//换方向</span><br>   x=<span class="hljs-number">0</span>;<br>   movex=-movex;<br>   &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&gt;=getWidth()-jButton.getWidth()) &#123;<br>   x=getWidth()-jButton.getWidth();<br>   movex=-movex;<br>   &#125;<br>  jButton.setLocation(x,jButton.getY());<br>&#125;<br>&#125;<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>MutilThreadDemo mutilThreadDemo=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MutilThreadDemo</span>();<br>mutilThreadDemo.setVisible(<span class="hljs-literal">true</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：<br><br><img src="/2019/09/07/%E7%BA%BF%E7%A8%8B-3/output.gif" alt="运行结果"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程(2)</title>
    <link href="/2019/09/06/%E7%BA%BF%E7%A8%8B-2/"/>
    <url>/2019/09/06/%E7%BA%BF%E7%A8%8B-2/</url>
    
    <content type="html"><![CDATA[<h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>线程具有生命周期，当线程被创建并启动后，不会立即进入执行状态，也不会一直处于执行状态。<br><br>在线程的生命周期中，要经过5种状态:</p><pre><code class="hljs">• 新建 • 就绪• 运行 • 阻塞• 死亡</code></pre><h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><pre><code class="hljs">• 只能对新建状态的线程调用start方法，且只能调用一次• 如果调用start（）方法后需要线程立即开始执行，可以使用Thread.sleep（1）来让当前运行的主线程休眠1毫秒，此时子线程处于就绪状态的子线程• 被阻塞的线程阻塞解除后进入就绪状态</code></pre><h3 id="相关的一些方法："><a href="#相关的一些方法：" class="headerlink" title="相关的一些方法："></a>相关的一些方法：</h3><ul><li>sleep（）：暂停执行的方法，参数以毫秒为单位，注意抛出异常</li><li>如果一个线程包含了很长的循环，在循环的每次迭代之后把该线程切换到sleep休眠状态时一种很好的策略，这可以保证其他线程不必等待很长时间就能轮到处理器执行。</li><li>isALive（）：判断线程是否处于执行状态，当处于就绪，运行，阻塞状态时返回true</li><li>stop（）：直接停止线程，容易导致死锁，通常不推荐使用</li><li>join（）：可以让一个线程等待另一个线程完成后，继续执行原线程中的任务。当在某个程序执行流中调用其他线程的join方法时，当前线程将会被阻塞，直到另一个线程执行完成为止。</li></ul><h3 id="关于join的使用的实例："><a href="#关于join的使用的实例：" class="headerlink" title="关于join的使用的实例："></a>关于join的使用的实例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 线程;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JoinThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">JoinThread</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated constructor stub</span><br><span class="hljs-built_in">super</span>(name);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10</span>; i++)<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + i);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JoinDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// 输出当前线程的名称，发现为main</span><br>System.out.println(Thread.currentThread().getName());<br><span class="hljs-type">JoinThread</span> <span class="hljs-variable">jThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JoinThread</span>(<span class="hljs-string">&quot;子线程&quot;</span>);<br>jThread.start();<br><span class="hljs-comment">// 输出当前线程的名称,发现依然为main  jThread只是就绪</span><br>System.out.println(Thread.currentThread().getName());<br><span class="hljs-keyword">try</span> &#123;<br>jThread.join();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">// 输出当前线程的名称，发现为main</span><br>System.out.println(Thread.currentThread().getName());<br><span class="hljs-comment">// 输出当前子线程的状态</span><br>System.out.println(jThread.isAlive());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：<br><br><img src="/2019/09/06/%E7%BA%BF%E7%A8%8B-2/JoinDemo.PNG" alt="JoinDemo运行结果"></p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><ul><li>每个线程执行时都有一定的优先级，系统根据优先级调度线程</li><li>每个线程都有默认的优先级，与父线程相同</li><li>主线程具有普通优先级</li><li>Thread类提供三个静态常量来标识线程的优先级<ul><li>MAX_PRIORITY  最高优先级，其值为10</li><li>NORM_PRIORITY 普通优先级，其值为5，默认优先级</li><li>MIN_PRIORITY  最低优先级，值为1</li></ul></li><li>优先级高的线程提前获得执行的机会也会更多</li></ul><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>多线程访问同一资源会带来安全问题，java中提供了线程同步的概念来保证某个资源在<br>某一时刻只能由一个线程访问，保证共享数据的一致性<br>线程同步通常采用以下三种方式：</p><ul><li>同步代码块</li><li>同步方法</li><li>同步锁</li></ul><h3 id="同步代码块："><a href="#同步代码块：" class="headerlink" title="同步代码块："></a>同步代码块：</h3><p>将对实例的访问语句放入一个同步块中，语法格式如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>（object）&#123;<br><span class="hljs-comment">//需要同步的代码块</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中synchronized是关键字，object是监视器<br>实例，客户在银行中存钱，账户唯一，用线程进行存取钱操作，初始余额5000.<br><br>假设客户进行了5次操作，如果没有同步，可能执行时候每个操作都以初始值5000为起点，最后得到的值是错的;<br>而执行同步操作后，每次只进行一种操作，以上次操作结果为起点，可以保证操作的正确性</p><h3 id="同步方法："><a href="#同步方法：" class="headerlink" title="同步方法："></a>同步方法：</h3><p>使用synchronized关键字修饰需要同步的方法，语法格式如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">[访问修饰符]<span class="hljs-keyword">synchronized</span> 返回类型 方法名（参数）&#123;<br><span class="hljs-comment">//方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一个具有同步方法的类也被称为“线程安全类”<br><br>synchronized锁定的是对象，而不是代码块或方法，也可以修饰类</p><h3 id="同步锁："><a href="#同步锁：" class="headerlink" title="同步锁："></a>同步锁：</h3><p>Lock是控制多个线程对共享资源进行访问的工具，能够对共享资源进行独占访问<br><br>有ReentrantLock（可重入锁）实现类<br>步骤：</p><ol><li>定义一个ReentrantLock锁对象，该对象是final常量</li><li>在需要保证线程安全的代码之前增加“加锁”操作</li><li>在执行完线程安全的代码后释放锁</li></ol><h3 id="代码示例-使用同步方法，同步锁-："><a href="#代码示例-使用同步方法，同步锁-：" class="headerlink" title="代码示例(使用同步方法，同步锁)："></a>代码示例(使用同步方法，同步锁)：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 线程;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-comment">//银行账户</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span> &#123;<br><span class="hljs-comment">// 银行账户</span><br><span class="hljs-keyword">private</span> String bankNo;<br><span class="hljs-comment">// 银行余额</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">double</span> balance;<br>    <span class="hljs-comment">//定义锁对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock lock=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">BankAccount</span><span class="hljs-params">(String bankNO, <span class="hljs-type">double</span> balance)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated constructor stub</span><br><span class="hljs-built_in">this</span>.bankNo = bankNO;<br><span class="hljs-built_in">this</span>.balance = balance;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> balance;<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBankNo</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> bankNo;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBalance</span><span class="hljs-params">(<span class="hljs-type">double</span> balance)</span> &#123;<br><span class="hljs-built_in">this</span>.balance = balance;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBankNo</span><span class="hljs-params">(String bankNo)</span> &#123;<br><span class="hljs-built_in">this</span>.bankNo = bankNo;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">access</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-comment">//lock.lock();</span><br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span>(money&lt;<span class="hljs-number">0</span>&amp;balance&lt;-money)<br>&#123;<br>System.out.println(<span class="hljs-string">&quot;余额不足，操作失败&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>balance+=money;<br>System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;操作成功，目前余额为：&quot;</span>+balance);<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1</span>);<br>&#125;<span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>e.printStackTrace();<br>&#125;<span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">//lock.unlock();</span><br>&#125;<br>&#125;<br><br>&#125;<br><br><br><span class="hljs-keyword">package</span> 线程;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BankLock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><span class="hljs-keyword">private</span> BankAccount account;<br><span class="hljs-keyword">private</span> <span class="hljs-type">double</span> money;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">BankLock</span><span class="hljs-params">(String name, BankAccount account, <span class="hljs-type">double</span> money)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated constructor stub</span><br><span class="hljs-built_in">super</span>(name);<br><span class="hljs-built_in">this</span>.money = money;<br><span class="hljs-built_in">this</span>.account = account;<br>&#125;<br><br><span class="hljs-comment">// 线程任务</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-built_in">this</span>.account.access(money);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// 创建账户，启动线程</span><br><span class="hljs-type">BankAccount</span> <span class="hljs-variable">cAccount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankAccount</span>(<span class="hljs-string">&quot;WT&quot;</span>, <span class="hljs-number">5000</span>);<br><span class="hljs-type">BankLock</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankLock</span>(<span class="hljs-string">&quot;task1&quot;</span>, cAccount, -<span class="hljs-number">3000</span>);<br><span class="hljs-type">BankLock</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankLock</span>(<span class="hljs-string">&quot;task2&quot;</span>, cAccount, -<span class="hljs-number">3000</span>);<br><span class="hljs-type">BankLock</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankLock</span>(<span class="hljs-string">&quot;task3&quot;</span>, cAccount, <span class="hljs-number">1000</span>);<br><span class="hljs-type">BankLock</span> <span class="hljs-variable">t4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankLock</span>(<span class="hljs-string">&quot;task4&quot;</span>, cAccount, -<span class="hljs-number">2000</span>);<br><span class="hljs-type">BankLock</span> <span class="hljs-variable">t5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankLock</span>(<span class="hljs-string">&quot;task5&quot;</span>, cAccount, <span class="hljs-number">2000</span>);<br>t1.start();<br>t2.start();<br>t3.start();<br>t4.start();<br>t5.start();<br><span class="hljs-keyword">try</span> &#123;<br>t1.join();<br>t2.join();<br>t3.join();<br>t4.join();<br>t5.join();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>e.printStackTrace();<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;账户：&quot;</span> + cAccount.getBankNo());<br>System.out.println(<span class="hljs-string">&quot;余额：&quot;</span> + cAccount.getBalance());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>加入目前系统中有生产和消费两个线程，系统要求不断重复生产，消费操作，并要求每当一个线程生产后，另一个线程立即进行消费，不允许连续两次生产，也不允许连续两次消费，实现这种功能，可以采用线程间的通信技术<br>相关方法：</p><ul><li>wait（）方法</li><li>notify（）方法</li><li>notifyAll（）方法<br>详细的解释:<br><br><a href="https://blog.csdn.net/u011635492/article/details/83043212">https://blog.csdn.net/u011635492/article/details/83043212</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程</title>
    <link href="/2019/09/05/%E7%BA%BF%E7%A8%8B/"/>
    <url>/2019/09/05/%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="线程和进程："><a href="#线程和进程：" class="headerlink" title="线程和进程："></a>线程和进程：</h2><h3 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h3><p>在操作系统中，每个独立运行的程序就是一个进程，当一个程序进入内存运行时，即变成一个进程。<br><br>进程是操作系统进行资源分配和调度的一个独立单位，进程之间资源不共享，多进程之间通过信号，管道进行交互。<br></p><h3 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h3><p>是进程的组成部分，一个进程可以有多个线程，至少有一个。线程是最小的处理单位，可以拥有自己的堆栈，计数器，局部变量，但不能拥有系统资源，多线程之间数据块可以共享</p><h2 id="java线程模型"><a href="#java线程模型" class="headerlink" title="java线程模型"></a>java线程模型</h2><p>java线程模型提供线程所必需的功能支持，基本的java线程模型有<strong>Thread类，Runnable接口，Callable接口和Future接口</strong>等。</p><h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><h3 id="主要方法："><a href="#主要方法：" class="headerlink" title="主要方法："></a>主要方法：</h3><ul><li>Thread构造方法，包含多个重载类型</li><li>getName（）获取线程名称</li><li>setName（）设置线程名称</li><li>isAlive（） 判断线程是否处于激活状态，返回boolean值</li><li>getId（）获取线程ID</li><li>setPriority（）设置线程优先级</li><li>getPriority（） 获取线程优先级</li><li>join（）等待线程死亡</li><li>sleep（）将线程挂起一段时间，以毫秒为单位</li><li>run（）线程的执行方法</li><li>start（）开始线程</li><li>stop（）停止线程，已过期</li><li>interrput（）中断线程</li><li>activeCount（）返回激活的线程数</li></ul><h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><p>在java语言中，每个能够独立运行的Java程序都至少有一个主线程，且在程序启动时，JVM会自动创建一个主线程来执行该程序中的main（）方法<br><br>在多线程编程时，main（）方法的方法体就是主线程的执行体，main（）方法中的代码就是主线程要完成的任务</p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>三种方法：</p><ul><li>继承Thread类，重写Thread类中的run（）方法，直接创建线程</li><li>实现Runnable接口，再通过Thread类和Runnable的实现类间接创建一个线程</li><li>使用Callable和Future的接口间接创建线程</li></ul><p>上述三种方式从本质上是一致的，最终都是通过Thread类来建立线程，提供接口是由与java不支持多继承，用这种方法还可以继承其他类。</p><h3 id="1-继承Thread类："><a href="#1-继承Thread类：" class="headerlink" title="1.继承Thread类："></a>1.继承Thread类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 线程;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>   <span class="hljs-comment">//重新run方法</span><br>     <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">10</span>;i++) &#123;<br>    System.out.println(<span class="hljs-built_in">this</span>.getName()+<span class="hljs-string">&quot; : &quot;</span>+i);<br>    &#125;<br>    &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Thread1 thread1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread1</span>();<br><span class="hljs-comment">//启动线程</span><br>thread1.start();<br><span class="hljs-comment">//主线程任务</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1000</span>;i&lt;=<span class="hljs-number">1010</span>;i++) &#123;<br>System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; : &quot;</span>+i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：<br><br><img src="/2019/09/05/%E7%BA%BF%E7%A8%8B/Thread1.PNG" alt="继承Threadd类实现线程的结果"></p><h3 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2.实现Runnable接口"></a>2.实现Runnable接口</h3><p>Runnable接口中只有一个run（）方法，一个类实现Runnable接口后，并不代表该类是个“线程类”，不能直接启动线程，必须通过Thread类的实例来创建并启动线程<br>步骤如下：</p><pre><code class="hljs">1 定义一个类实现Runnable接口，并实现run（）方法2 以实现类为参数创建一个Thread类的实例3 调用Thread对象的start（）方法启动线程</code></pre><p>实例如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 线程;<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>   <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-comment">//使用Runnable接口时，只能使用Thread.currentThread()获取当前线程</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">10</span>;i++)<br>   System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; : &quot;</span>+i);<br>&#125;<br>   &#125;<br>   <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread2</span> &#123;<br>  <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Thread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>());<br>thread.start();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1000</span>;i&lt;=<span class="hljs-number">1010</span>;i++)<br>System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; : &quot;</span>+i);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：<br><br><img src="/2019/09/05/%E7%BA%BF%E7%A8%8B/Thread2.PNG" alt="使用Runnable接口实现线程"></p><h3 id="3-使用Callable和Future接口"><a href="#3-使用Callable和Future接口" class="headerlink" title="3.使用Callable和Future接口"></a>3.使用Callable和Future接口</h3><p>Callable接口提供一个call（）方法作为线程的执行体，该方法的返回值使用Future接口来代表。使用Callable和Future接口的最大优势在于可以在线程执行完任务之后获取执行结果，步骤如下：</p><pre><code class="hljs">1 创建Callable接口的实现类，并实现call（）方法，该方法将作为线程的执行体，并且有返回值；然后创建Callable实现类的实例2 使用FutureTask类来包装Callable对象，在FutureTask对象中封装了Callable对象的call（）方法的返回值3 使用FutureTask对象作为Thread对象的target，创建并启动新线程4 调用FutureTask对象的get（）方法来获得子线程执行结束后的返回值</code></pre><p>实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 线程;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-comment">//1.创建Callable接口的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-keyword">for</span> (; i &lt;= <span class="hljs-number">10</span>; i++)<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + i);<br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread3</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br><span class="hljs-comment">// 2.使用FutureTask类包装Callable实现类的实例</span><br>FutureTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;Integer&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>());<br><span class="hljs-comment">// 3.创建线程，使用FutureTask对象task作为Thread对象的Target，并调用start方法启动线程</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;子线程&quot;</span>).start();<br><span class="hljs-comment">// 4.调用FutureTask对象task的get()方法获取子线程执行结束后的返回值</span><br>System.out.println(<span class="hljs-string">&quot;子线程返回值：&quot;</span> + task.get());<br><span class="hljs-comment">// 主线程任务</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>; i &lt;= <span class="hljs-number">1010</span>; i++) &#123;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + i);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：<br><br><img src="/2019/09/05/%E7%BA%BF%E7%A8%8B/Thread3.PNG" alt="采用Callable和Future接口实现线程"><br>从java8开始可以直接使用Lambda表达式创建Callable对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 线程;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread4</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException  &#123;<br>FutureTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;Integer&gt;(<br>(Callable&lt;Integer&gt;)()-&gt;&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; i &lt;= <span class="hljs-number">10</span>; i++)<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + i);<br><span class="hljs-keyword">return</span> i;<br>&#125;<br>);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;子线程&quot;</span>).start();<br>System.out.println(<span class="hljs-string">&quot;子线程返回值：&quot;</span> + task.get());<br><span class="hljs-comment">// 主线程任务</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>; i &lt;= <span class="hljs-number">1010</span>; i++) &#123;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果同上</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC</title>
    <link href="/2019/09/04/JDBC/"/>
    <url>/2019/09/04/JDBC/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>JDBC（Java Database Connectivity，Java 数据库连接）是一种执行SQL语句的Java API。程序可以通过JDBC API连接到关系数据库，并使用SQL结构化查询语言来完成对数据库的增删改查操作。<br><br>基本工作：</p><pre><code class="hljs">• 建立与数据库的连接• 执行SQL语句• 获取执行结果</code></pre><h2 id="JDBC驱动："><a href="#JDBC驱动：" class="headerlink" title="JDBC驱动："></a>JDBC驱动：</h2><p>数据库驱动程序负责将JDBC调用映射成特定的数据库调用</p><pre><code class="hljs">• JDBC-ODBC桥• 本地API驱动• 网络协议驱动• 本地协议驱动</code></pre><h2 id="JDBC-API："><a href="#JDBC-API：" class="headerlink" title="JDBC API："></a>JDBC API：</h2><pre><code class="hljs"> 1. DriverManger类：用于管理JDBC驱动的服务类，主要功能是加载和卸载各种驱动程序，建立数据库的连接并获取连接对象。包含的方法有：• getConnection（url，user，password）：获取指定URL的数据库连接• getDriver（url）：返回能够打开url所指定的数据库的驱动程序2. Connection接口：用于连接数据库，通过DriverManager类的getConnection方法返回一个Connection对象，该对象中提供了创建SQL语句的方法，以完成基本的SQL操作，同时为数据库事务提供了提交和回滚的方法：</code></pre><p> <img src="/2019/09/04/JDBC/connetion.jpg" alt="Connection的常用方法"></p><pre><code class="hljs"> Statement接口：一般用于执行SQL语句，接口中提供的createStatement（），prepareStatement（），prepareCall（）方法分别返回一个用于执行SQL语句的Statement对象，PreparedStatement对象，CallableStatement对象，对应三种查询方式：一般查询，参数查询，存储过程&lt;br&gt;</code></pre><p><img src="/2019/09/04/JDBC/jc.png"></p><p><img src="/2019/09/04/JDBC/statement.jpg" alt="Statement常用方法"></p><p>ResultSet接口：用于封装结果集对象，该对象包含访问查询结果的方法，提供了一套getXXX（）方法对结果集中的数据进行访问，这些方法可以通过列索引或列名获得数据</p><p><img src="/2019/09/04/JDBC/resultset.jpg" alt="ResultSet常用方法"></p><p>具体操作流程为：</p><pre><code class="hljs">1. 通过java Class类加载驱动2. 使用DriverManger类的getConnection方法获取数据库连接对象3. 创建Statement对象，三种4. 执行SQL语句：ececuteQuery（）返回结果集，executeUpdate（）执行语句，execute（）：execute几乎可以执行任何SQL语句，返回boolean值，若返回值为true，可以通过getResultSet（）方法获得结果集5. 访问结果集 getXXX（）6. 最后关闭结果集，关闭对象，结束连接   close（）</code></pre><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><a href="https://github.com/3422878082/Learn-JDBC">https://github.com/3422878082/Learn-JDBC</a></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>jdbc</tag>
      
      <tag>JDBC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章</title>
    <link href="/2019/09/03/%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2019/09/03/%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>习题<br><br>冯诺依曼计算机体系的基本思想是什么？<br><br>按此思想设计的计算机硬件系统应由哪些部件组成？<br><br>各起什么作用？<br></p><p>1 计算机由五部分组成：输入设备，存储器，运算器，控制器，输出设备</p><ul><li>首先是输入设备，负责输入程序，数据，将信息转换为机器能识别的形式</li><li>之后将信息存在存储器中，并且按地址顺序地存放</li><li>运算器负责进行算数运算和逻辑运算，而控制器负责指挥程序运行，</li><li>最后输出设备负责将结果转换为人们熟悉的形式</li></ul><p>2 计算机内部应采用二进制来表示指令和数据</p><p>3 编好的程序顺序自动执行</p><pre><code class="hljs">• PC（程序计数器） 装入程序首地址• PC+1→PC</code></pre><p>4 程序跳跃用指令实现</p><p>执行示意图：<br><br><br><img src="/2019/09/03/%E7%AC%AC%E4%B8%80%E7%AB%A0/zhixing.PNG" alt="执行流程图"><br><br></p><p>计算机发展经过了几代？每一代的基本特征是什么？<br></p><pre><code class="hljs">1. 电子管2. 晶体管3. 中小规模集成电路 MSI，SSI4. 大规模集成电路和超大规模集成电路 LSI，VLSI</code></pre><p>计算机系统从功能上可划分为哪些层次？各层次在计算机系统中起什么作用？<br><br><br><img src="/2019/09/03/%E7%AC%AC%E4%B8%80%E7%AB%A0/cengci.PNG" alt="计算机功能层次图"></p><p><strong>各层次作用</strong>：</p><ul><li>第一级是微程序设计级，微程序直接由硬件执行，属于硬件级</li><li>第二级是一般机器级，一条机器指令对应着一段微程序，属于硬件级</li><li>第三级是操作系统级，由操作系统程序实现。这些操作系统由机器指令和广义指令组成，这些广义指令是操作系统定义和解释的软件指令，所以这一级也称为混合级。</li><li>第四级是汇编语言级，给程序人员提供一种符号形式语言，以减少程序编写的复杂性。这一级由汇编程序支持和执行，属于软件级</li><li>第五级是高级语言级，这是面向用户的，为方便用户编写应用程序而设置的，属于软件级</li></ul><p>计算机内部有哪两股信息在流动？它们彼此有什么关系？<br><br>信息流，控制流<br><br>信息流受控制流的控制<br><br></p><p>固件：<br><br>固件(Firmware)就是写入EPROM（可擦写可编程只读存储器）或EEPROM(电可擦可编程只读存储器)中的程序。<br><br>固件是指设备内部保存的设备“驱动程序”，通过固件，操作系统才能按照标准的设备驱动实现特定机器的运行动作，比如光驱、刻录机等都有内部固件。<br><br>固件是担任着一个系统最基础最底层工作的软件。而在硬件设备中，固件就是硬件设备的灵魂，因为一些硬件设备除了固件以外没有其它软件组成，因此固件也就决定着硬件设备的功能及性能。<br></p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java网络编程</title>
    <link href="/2019/09/03/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2019/09/03/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>java中有关网络方面的功能定义都在java.net包中</strong></p><h2 id="InetAddress类封装IP或域名"><a href="#InetAddress类封装IP或域名" class="headerlink" title="InetAddress类封装IP或域名"></a>InetAddress类封装IP或域名</h2><p>包含的方法：</p><pre><code class="hljs">* 获取本机对应的InetAdress对象：getLocalHost* 根据主机获得对应的InetAdress对象，参数为String类型，可以是ip地址或域名：getByName（String ）* 根据主机获得具有相同名字的一组InetAddress对象：getAllByName（String）* 获取addr所封装的IP地址对应的InetAddress对象：getByAddress（byte[] addr）* 获取ip地址：getHostAddress* 获取域名：getHostName* 判断是否可以到达该地址：isReachable</code></pre><h2 id="URL类（Uniform-Resource-Locator，统一资源定位器"><a href="#URL类（Uniform-Resource-Locator，统一资源定位器" class="headerlink" title="URL类（Uniform Resource Locator，统一资源定位器)"></a>URL类（Uniform Resource Locator，统一资源定位器)</h2><p>通常语法格式：  协议名：&#x2F;&#x2F;主机名：端口号&#x2F;资源名 <br><br>getXXX（）返回相应信息<br></p><h2 id="URI类-统一资源标识符"><a href="#URI类-统一资源标识符" class="headerlink" title="URI类  统一资源标识符"></a>URI类  统一资源标识符</h2><p>唯一作用就是解析  可以将URL理解成URI的特例<br><br>创建URL对象需要抛出异常<br><br>openConnection方法用于返回一个URLConnection对象，URLConnection类提供一些更强的方法</p><pre><code class="hljs">• 获得文件的长度，类型，创建时间，修改时间  getXXX（）• 获得输入流，以便读取文件的数据  getInputStream（）• 获得输出流，以便输出数据 getOutputStream（）• 设置请求属性值：setRequestProperty（String key，String value）</code></pre><h2 id="基于TCP的网络编程-关于套接字-socket"><a href="#基于TCP的网络编程-关于套接字-socket" class="headerlink" title="基于TCP的网络编程  关于套接字 socket"></a>基于TCP的网络编程  关于套接字 socket</h2><p>使用TCP&#x2F;IP协议进行通信时，会在通信的两端各建立一个Socket（套接字），从而形成虚拟链路<br><br>使用Socket对象封装了两端的通信端口，屏蔽了底层细节，其允许用户将网络连接当成一个IO流，<br><br>读写数据<br><br>主要使用java.net包下的两个类：</p><p>   <strong>ServeSocket</strong>类：服务器套接字<br><br>   <strong>Socket</strong>类：客户端套接字<br><br><strong>都必须抛出异常</strong></p><hr><p>基础用法：<br><br><strong>客户端</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 网络编程;<br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.io.PrintStream;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//创建连接到本机对象</span><br>Socket socket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;10.0.218.101&quot;</span>,<span class="hljs-number">28888</span>);<br><span class="hljs-comment">//将socket对应的输出对象包装成printstream</span><br>PrintStream printStream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(socket.getOutputStream());<br><span class="hljs-comment">//往服务器发送信息</span><br>printStream.println(<span class="hljs-string">&quot;我是客户&quot;</span>);<br>printStream.flush();<br><span class="hljs-comment">//获取服务器的信息,将socket对应的输入流包装成bufferreader</span><br><span class="hljs-comment">//BufferedInputStream bufferedInputStream=new BufferedInputStream(socket.getInputStream());</span><br>    BufferedReader bufferedReader=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream()));<br>    String line=bufferedReader.readLine();<br>    System.out.println(<span class="hljs-string">&quot;来自服务器的数据：&quot;</span>+line);<br>    <span class="hljs-comment">//关闭</span><br>    bufferedReader.close();<br>    printStream.close();<br>    socket.close();<br>&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>e.printStackTrace();<br>&#125;<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>服务端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 网络编程;<br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.io.PrintStream;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>ServerSocket server;<br><span class="hljs-comment">// 计数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Server</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 创建serversocket，用于监听客户端对应的端口号是否有socket</span><br><span class="hljs-keyword">try</span> &#123;<br>server = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">28888</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">// 启动当前线程，执行run方法</span><br><span class="hljs-built_in">this</span>.start();<br>System.out.println(<span class="hljs-string">&quot;服务器启动&quot;</span>);<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.isAlive()) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 首先接受客户端的Socket</span><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> server.accept();<br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream()));<br><span class="hljs-comment">// 读客户端发送的消息并显示</span><br><span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> bufferedReader.readLine();<br>System.out.println(<span class="hljs-string">&quot;客户端发送的消息为：&quot;</span> + line);<br><span class="hljs-comment">// 将socket对应的输出流包装成为printstream</span><br><span class="hljs-type">PrintStream</span> <span class="hljs-variable">printStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(socket.getOutputStream());<br><span class="hljs-comment">// 往客户端发送消息</span><br>printStream.println(<span class="hljs-string">&quot;您是第&quot;</span> + (++num) + <span class="hljs-string">&quot;个访问服务器的用户！&quot;</span>);<br>printStream.close();<br>bufferedReader.close();<br>socket.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>应用：实现一个简易的聊天室</strong></p><pre><code class="java">客户端：package 网络编程;import java.awt.BorderLayout;import java.awt.Label;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.PrintStream;import java.net.Socket;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JPanel;import javax.swing.JScrollPane;import javax.swing.JTextArea;import javax.swing.JTextField;public class chatClient extends JFrame &#123;    Socket socket = null;    PrintStream pStream = null;    BufferedReader bReader = null;    JPanel jPanelbottom = null;    JScrollPane jScrollPane = null;    JLabel label_name = null;    JLabel label_txt = null;    JButton send = null;    JTextArea maintxt = null;    JTextField txt_name = null;    JTextField txt_input = null;    public chatClient() &#123;        // TODO Auto-generated constructor stub        // 组装底部一栏        super(&quot;聊天室&quot;);        label_name = new JLabel(&quot;昵称&quot;);        txt_name = new JTextField(5);        label_txt = new JLabel(&quot;输入消息&quot;);        txt_input = new JTextField(20);        send = new JButton(&quot;发送&quot;);        jPanelbottom = new JPanel();        jPanelbottom.add(label_name);        jPanelbottom.add(txt_name);        jPanelbottom.add(label_txt);        jPanelbottom.add(txt_input);        jPanelbottom.add(send);        this.add(jPanelbottom, BorderLayout.SOUTH);        // 组装显示主界面        maintxt = new JTextArea();        maintxt.setEditable(false);        jScrollPane = new JScrollPane(maintxt);        this.add(jScrollPane);        this.setSize(500, 300);        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        try &#123;            // 创建socket对象            socket = new Socket(&quot;10.0.218.101&quot;, 28888);            // 创建一个往socket里写数据的管道            pStream = new PrintStream(socket.getOutputStream());            // 创建一个从socket里读数据的管道            bReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));        &#125; catch (Exception e) &#123;            e.printStackTrace();// TODO: handle exception        &#125;        // 为发送按钮注册监听        send.addActionListener(new ActionListener() &#123;            @Override            public void actionPerformed(ActionEvent arg0) &#123;                // TODO Auto-generated method stub                String name = txt_name.getText();                String msg = txt_input.getText();                if (!msg.equals(&quot;&quot;)) &#123;                    pStream.println(name + &quot;说：&quot; + msg);                    pStream.flush();                    // 发送完毕清空输入框                    txt_input.setText(&quot;&quot;);                &#125;            &#125;        &#125;);        // 启动线程        new GetMsg().start();    &#125;    // 接收服务器返回信息的线程    class GetMsg extends Thread &#123;        public void run() &#123;            while (this.isAlive()) &#123;                try &#123;                    String getMsg = bReader.readLine();                    if (getMsg != null) &#123;                        // 主窗口显示信息并换行                        maintxt.append(getMsg + &quot;\n&quot;);                    &#125;                    Thread.sleep(50);                &#125; catch (Exception e) &#123;                    e.printStackTrace();// TODO: handle exception                &#125;            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        new chatClient().setVisible(true);    &#125;&#125;服务端：package 网络编程;import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.LinkedList;import javax.swing.JFrame;public class chatServer extends JFrame &#123;    // 声明服务器端套接字    ServerSocket serverSocket;    // 输入流列表集合    ArrayList&lt;BufferedReader&gt; bReaders = new ArrayList&lt;BufferedReader&gt;();    // 输出流列表集合    ArrayList&lt;PrintWriter&gt; pStreams = new ArrayList&lt;PrintWriter&gt;();    // 聊天信息链表集合    LinkedList&lt;String&gt; msgList = new LinkedList&lt;String&gt;();    public chatServer() &#123;        try &#123;            serverSocket = new ServerSocket(28888);        &#125; catch (Exception e) &#123;            e.printStackTrace();// TODO: handle exception        &#125;        // 创建接收客户端Socket的线程实例，并启动        new getMsg().start();        // 创建给客户端发送消息的线程实例，并启动        new SendMag().start();        System.out.println(&quot;服务器已经启动&quot;);    &#125;    // 接收客户端消息线程    class getMsg extends Thread &#123;        @Override        public void run() &#123;            // TODO Auto-generated method stub            while (this.isAlive()) &#123;                try &#123;                    // 接收一个客户端socket对象                    Socket socket = serverSocket.accept();                    if (socket != null) &#123;                        // 获取socket对象的输入流                        BufferedReader bReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));                        // 将输入流添加入输入流列表集合中                        bReaders.add(bReader);                        // 开启一个线程接收该客户的聊天信息                        new getMsg1(bReader).start();                        // 获取socket对象的输出流，并将其加入输出流列表中                        pStreams.add(new PrintWriter(socket.getOutputStream()));                    &#125;                &#125; catch (Exception e) &#123;                    e.printStackTrace();// TODO: handle exception                &#125;            &#125;        &#125;    &#125;    // 接收客户聊天信息的线程    class getMsg1 extends Thread &#123;        BufferedReader bReader;        public getMsg1(BufferedReader bReader) &#123;            this.bReader = bReader;        &#125;        @Override        public void run() &#123;            while (this.isAlive()) &#123;                try &#123;                    // 从输入流中读取一行消息                    String strMsg = bReader.readLine();                    if (strMsg != null) &#123;                        SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);                        String strTime = dateFormat.format(new Date());                        msgList.addFirst(&quot;&lt;== &quot; + strTime + &quot; ==&gt;\n&quot; + strMsg);                    &#125;                &#125; catch (Exception e) &#123;                    e.printStackTrace();// TODO: handle exception                &#125;            &#125;        &#125;    &#125;    // 给所有客户发送聊天信息的线程    class SendMag extends Thread &#123;        @Override        public void run() &#123;            while (this.isAlive()) &#123;                try &#123;                    // 如果信息链表不为空 发送                    if (!msgList.isEmpty()) &#123;                        String msg = msgList.removeLast();                        for (int i = 0; i &lt; pStreams.size(); i++) &#123;                            pStreams.get(i).println(msg);                            pStreams.get(i).flush();                        &#125;                    &#125;                &#125; catch (Exception e) &#123;                    // TODO: handle exception                &#125;            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        new chatServer();    &#125;&#125; </code></pre>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Eclipse连接MySQL数据库</title>
    <link href="/2019/05/21/Eclipse%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2019/05/21/Eclipse%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>其实很简单，但还是应该记录一下<br>参考了这个作者的<a href="http://www.cnblogs.com/fnng/archive/2011/07/18/2110023.html">博客</a><br></p><p>MySQL我选择了Navicat for MySQL这个软件，中文版，挺好用的</p>]]></content>
    
    
    <categories>
      
      <category>各种搭建配置坑的记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录hexo博客的建立</title>
    <link href="/2019/05/19/%E8%AE%B0%E5%BD%95hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
    <url>/2019/05/19/%E8%AE%B0%E5%BD%95hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B/</url>
    
    <content type="html"><![CDATA[<p>一直想有个自己单独的博客，这几天呢，踩了大大小小的坑，终于把它给弄好了，配置的过程参考了很多人的博客，在此记录:<br><br>1.<a href="https://www.bilibili.com/video/av44544186?from=search&seid=2380386286865002522/" title="手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo">首先是B站一个up主的视频</a><br><br>up主介绍的虽然比较详细，但是所演示的环境并非在windows之下，然后我在视频评论中找到了这个老哥的链接<br><br>2.<a href="https://caiyantao.gitee.io/2019/04/13/Hexo-%E4%B8%80/#more/" title="Hexo学习">windows下的讲解</a><br><br>一路走下去还算顺利，中间遇到了一个错误，解决方法在这:<a href="https://www.v2ex.com/t/175940/" title="可能其他人不会遇到，仅提醒，可以试一下">错误解决</a>,之后老哥是部署到Coding上的，我注册时出现问题，就没成功，于是接着找了其他人的教程（当然了，最后我在github和Coding上都部署成功了）<br><br>3.<a href="https://zhuanlan.zhihu.com/p/26625249/" title="GitHub+Hexo 搭建个人网站详细教程">知乎教程</a><br><br>这份教程特别详细，其实可以完全从一开始就按上面来.部署成功后自然是选择主题，优化主题，经过试错后选择了最多人用的next主题，简洁又不简单，资料又好找，之后可能会多尝试其他主题，不过呢，在安装next主题时注意安装目前的新版，此教程中的是旧版，可能会与某些插件有不兼容的问题<br><br>4.<a href="https://blog.csdn.net/qq_36759224/article/details/85420403/" title="Hexo 博客优化之博客美化（看板娘/鼠标点击爱心字体烟花爆炸效果/自定义鼠标指针样式/彩色滚动变换字体/背景音乐/网页标题恶搞/动态线条/人体时钟挂件/雪花飘落/背景动态彩带......）">主题配置和优化</a><br><br>这方面网上教程特别多，不过看一两篇就够了，因为内容大多一样 <br><br>5.<a href="https://gaomf.cn/2015/11/01/Hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6/" title="Hexo博客优化加载速度">优化博客访问速度</a> <br><br>因为一开始是部署到Github上的，实在是有些慢，所以还是尝试部署在国内平台，参考了这位博主的教程成功了<br><br><br>在写博客时，有些特定的博客不想让其他人看见，我们可以加密自己的博客，具体参考<a href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md">这里</a><br>这样其他人就需要输入密码才能访问我们的博客<br><br>在写博客时，markdown编辑器的话，我用的是vs code ,装Markdown All in One 这个插件就够了，其他的按自己需要，感觉是目前用过的最好用的了.</p>]]></content>
    
    
    <categories>
      
      <category>hexo博客相关配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置环境</tag>
      
      <tag>总结</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
