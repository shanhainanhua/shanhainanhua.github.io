<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Games101-课程3~4(变换)</title>
      <link href="/2023/04/04/Games101-%E8%AF%BE%E7%A8%8B3-4-%E5%8F%98%E6%8D%A2/"/>
      <url>/2023/04/04/Games101-%E8%AF%BE%E7%A8%8B3-4-%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>课程3~4介绍了基础变换，齐次坐标，mvp矩阵</p><span id="more"></span><p>modeling<br>viewing</p><h1 id="base"><a href="#base" class="headerlink" title="base"></a>base</h1><p>二维变换 矩阵</p><p>切变</p><p><img src="https://tcs.teambition.net/storage/312r61ff0d63d17e96a9ee5c76fe2fe5935e?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnI2MWZmMGQ2M2QxN2U5NmE5ZWU1Yzc2ZmUyZmU1OTM1ZSJ9.tH8cizYxuMq0jNjsHHtdgeOMR7gj_JhfhOj4iWsPuEM&download=image.png"></p><p>旋转 考虑不同的点 两个特殊点 推出来旋转公式</p><p><img src="https://tcs.teambition.net/storage/312r65f6938161b3c7f980d130d81eb1adb0?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnI2NWY2OTM4MTYxYjNjN2Y5ODBkMTMwZDgxZWIxYWRiMCJ9.0xpXNA5ZNytwoQnFG0Ozb6Nwjro2gGLnspBc7YnSwYQ&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312r90af93e4381d2ae8c5ec46cce55f3ccd?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnI5MGFmOTNlNDM4MWQyYWU4YzVlYzQ2Y2NlNTVmM2NjZCJ9.7XXRR9O18ZwDwwXeNXAjOJBwiTs9lQ4KEJB_b6HEj7s&download=image.png"></p><p>齐次坐标</p><p><img src="https://tcs.teambition.net/storage/312r95fcd0c9027e2eb9dc9bbb32e1d44326?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnI5NWZjZDBjOTAyN2UyZWI5ZGM5YmJiMzJlMWQ0NDMyNiJ9.rg24bzwCwe-14d07S8u37kfc77rfdhb9BTzCMzv0KlQ&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312r0612649373987b8e935cdaf18be386aa?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnIwNjEyNjQ5MzczOTg3YjhlOTM1Y2RhZjE4YmUzODZhYSJ9.xIciB-kjge6GUPB8wf1a_iayh2rYyy3NqgpP6PTOZrA&download=image.png"></p><p>点相加 表示这两个点的终点</p><p><img src="https://tcs.teambition.net/storage/312se66bfe93ddedb00a75c40821b911da23?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNlNjZiZmU5M2RkZWRiMDBhNzVjNDA4MjFiOTExZGEyMyJ9.our2X8JdU7sESozDvPxSyf-ygatSrhCU7kNAwkV1lhM&download=image.png"></p><p>y反的原因  z叉乘x得到y所以反</p><p>任意旋转：</p><p>任意旋转可以拆成x，y，z轴上旋转的组合，旋转角度就是欧拉角</p><p>罗德里格斯旋转公式：</p><p><img src="https://tcs.teambition.net/storage/312s261b6a9b469c165d662f27bffa86f5fe?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnMyNjFiNmE5YjQ2OWMxNjVkNjYyZjI3YmZmYTg2ZjVmZSJ9.dDFFfYZsMK-Ah62Ms953nTOEPSOrIPLHXJQVchJjyIw&download=image.png"></p><p>旋转矩阵不太适合做差值 四元数的引入更多的是为了旋转的差值</p><h1 id="Viewing-transformation"><a href="#Viewing-transformation" class="headerlink" title="Viewing transformation"></a>Viewing transformation</h1><h2 id="View-x2F-Camera-Transformation"><a href="#View-x2F-Camera-Transformation" class="headerlink" title="View&#x2F;Camera Transformation"></a>View&#x2F;Camera Transformation</h2><p>MVP变换 </p><p><a href="https://zhuanlan.zhihu.com/p/261097735">计算机图形学 5：齐次坐标与 MVP 矩阵变换</a></p><p><img src="https://tcs.teambition.net/storage/312sa2ee82784c45048b4d10290ae4406e3f?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNhMmVlODI3ODRjNDUwNDhiNGQxMDI5MGFlNDQwNmUzZiJ9.V-MddZUAHPT1EcMamIupDg547ENoJJac51TIxMS35Co&download=image.png"></p><p>约定俗成：相机放在0，0，0 看向-z方向 向上方向是y</p><p><img src="https://tcs.teambition.net/storage/312sde204c34c7f8eeca6b8727351c219707?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNkZTIwNGMzNGM3ZjhlZWNhNmI4NzI3MzUxYzIxOTcwNyJ9.GhWBjQ4VMgQHo-J6_-HkoDrFAjsRKaXAeyP0WIAwMUQ&download=image.png"></p><p>怎么移动相机从e g t到标准位置</p><p>首先考虑移动e，</p><p><img src="https://tcs.teambition.net/storage/312s0366ac6bafbca7e269ed3685a0e91379?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnMwMzY2YWM2YmFmYmNhN2UyNjllZDM2ODVhMGU5MTM3OSJ9.wGiyU03Q7T16bV309txHCl5FkbBiLkkeHcVPzv8c0EY&download=image.png"></p><p>然后旋转g到-z，t到y，gxt到x轴，直接算不方便。可以先求由标准位置旋转到现在位置的矩阵，也就是先算逆矩阵</p><p><img src="https://tcs.teambition.net/storage/312s74ea9369bc7f80bb6f11a4dca20d521c?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM3NGVhOTM2OWJjN2Y4MGJiNmYxMWE0ZGNhMjBkNTIxYyJ9.pWQY906Ol6zPY2ksM4BR-qiNN-wyXdjVDmFla9abFTE&download=image.png"></p><p>然后旋转矩阵是个正交矩阵，具有性质：逆矩阵&#x3D;转置矩阵，所以求出来对应旋转矩阵</p><p><img src="https://tcs.teambition.net/storage/312sebf23ea346b9b5b5d34e22fb115dd7e4?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNlYmYyM2VhMzQ2YjliNWI1ZDM0ZTIyZmIxMTVkZDdlNCJ9.LQ8QcjhzGHW15nV1iHz73Zw0T6mXwrCsaVYoVCQMX4E&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312s205028d0a75191c4f90c2606e115c38c?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnMyMDUwMjhkMGE3NTE5MWM0ZjkwYzI2MDZlMTE1YzM4YyJ9.PNYoEY42glO0JwGyZe6Ey4cAanmjgvFNSY-cyWNvcYU&download=image.png"></p><p>相对运动，得到结果一样，相机和物体应用同样变换</p><h2 id="Projection-transformation"><a href="#Projection-transformation" class="headerlink" title="Projection transformation"></a>Projection transformation</h2><h3 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h3><p>相机放在标准位置上，把z扔掉自然就是在x y上，然后规范到-1到1的范围内</p><p><img src="https://tcs.teambition.net/storage/312s3bce78b98044cee3fd0cc3caec78878f?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnMzYmNlNzhiOTgwNDRjZWUzZmQwY2MzY2FlYzc4ODc4ZiJ9.XNPOEgNw_C2H4YdsTy8Sy3ZTYQdRH25KYbpCXLOyQPY&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312s4c22a7a4482230068a9c21b92415503b?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM0YzIyYTdhNDQ4MjIzMDA2OGE5YzIxYjkyNDE1NTAzYiJ9.LkeUN-NM4th2T7e_jkZmlXfz6zoPvXOCi9lPi7j-n6Y&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312seeb9da250164ce0e9d27129419ee7ffd?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNlZWI5ZGEyNTAxNjRjZTBlOWQyNzEyOTQxOWVlN2ZmZCJ9.QVUCYKV2Uyo9sY3ZwIYFLxhYKUSwqSk44kc0qDr5MRA&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312sa8a6868ae21566de0620c4870d02d162?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNhOGE2ODY4YWUyMTU2NmRlMDYyMGM0ODcwZDAyZDE2MiJ9.3OPh3dsVLl6I28QzV30ZZRownZx_wPz-0VhqIQPJ-v0&download=image.png"></p><h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p>怎么做透视投影</p><p>先挤在正交</p><p><img src="https://tcs.teambition.net/storage/312s1a4c74b16015d5630f3f38526bf222af?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnMxYTRjNzRiMTYwMTVkNTYzMGYzZjM4NTI2YmYyMjJhZiJ9.voFEic_CtDPowK4kms9K36t4b0C9ELJ2xLqHL6cHzsw&download=image.png"></p><p>挤压注意：近平面不变 z不会发生变化 远平面的中心点也不会发生变化</p><p>从侧面来看，相似三角形求解：</p><p><img src="https://tcs.teambition.net/storage/312s6657ccdc7bb25cadd18d5d1870c1768e?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM2NjU3Y2NkYzdiYjI1Y2FkZDE4ZDVkMTg3MGMxNzY4ZSJ9.DkPviGBc-zSxDHH40H2CHgZxckwSjgrzFJ7WkNlArgU&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312sdbb4c1bf290e5123caffbf1e9efc3cec?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNkYmI0YzFiZjI5MGU1MTIzY2FmZmJmMWU5ZWZjM2NlYyJ9.Je3FtGs5dbUJiQPMbm044shuihNMT-Y3CFo26IEA5RQ&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312s16005832662be900530b7be2e9904fc0?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnMxNjAwNTgzMjY2MmJlOTAwNTMwYjdiZTJlOTkwNGZjMCJ9.gT0rXqrH3_33d2pVCQUdUHAamgAXw5yKio7SOhLdD9s&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312sfd3ee381047752c99d61ba2b5d1af667?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNmZDNlZTM4MTA0Nzc1MmM5OWQ2MWJhMmI1ZDFhZjY2NyJ9.qbXSLT5g2YyLIVwBcnVMg-RyGSZgzjfdT6bbEVQQLLo&download=image.png"></p><p>利用近平面点变换不变的特性 ：</p><p><img src="https://tcs.teambition.net/storage/312sb7cf89f2a85f31a7b303595361408be5?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNiN2NmODlmMmE4NWYzMWE3YjMwMzU5NTM2MTQwOGJlNSJ9.5ZX8pRPLYiEmL4g_P7Td-529m8-J9gRp9dg4oedRMcU&download=image.png"></p><p>利用远平面z不变的特性：</p><p><img src="https://tcs.teambition.net/storage/312s8a5f74bf7deeeaa71c0748b54ae318b0?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM4YTVmNzRiZjdkZWVlYWE3MWMwNzQ4YjU0YWUzMThiMCJ9.EeoEVeG7YPzXW9whhz0C9ShJw9KnMb2D6tsKp8Pgqgw&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312sa012c26e3a7062da827f1d9ce0593942?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNhMDEyYzI2ZTNhNzA2MmRhODI3ZjFkOWNlMDU5Mzk0MiJ9.6Vms4yrF-46ca5KzERaBGTL4M33aOhJe61-v_QPQX1U&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312s78e16cd89caf6439ada11d34120b609a?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjExOCwiaWF0IjoxNjgwNjE3MzE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM3OGUxNmNkODljYWY2NDM5YWRhMTFkMzQxMjBiNjA5YSJ9.klYU9bwyPhwxTVJqsSOdV3YUsI67MDSfoK5Gd5cCl_s&download=image.png"></p><p><a href="https://juejin.cn/post/7085176703085412383">GAMES101投影矩阵推导详解和分析 - 掘金</a></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-课程2</title>
      <link href="/2023/04/04/Games101-%E8%AF%BE%E7%A8%8B2/"/>
      <url>/2023/04/04/Games101-%E8%AF%BE%E7%A8%8B2/</url>
      
        <content type="html"><![CDATA[<p>课程2为复习基本数学概念</p><span id="more"></span><p>图形学默认列向量</p><p>点乘</p><p><img src="https://tcs.teambition.net/storage/312r6970f5ac1e384e850d784ce4c6714fea?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjE1NSwiaWF0IjoxNjgwNjE3MzU1LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnI2OTcwZjVhYzFlMzg0ZTg1MGQ3ODRjZTRjNjcxNGZlYSJ9.5C5zpBwbW3n48vexM7qb3uo08xHCS5DLQQkdKTawz4I&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312rca742a52c48aec36603a64636c139eb1?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjE1NSwiaWF0IjoxNjgwNjE3MzU1LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnJjYTc0MmE1MmM0OGFlYzM2NjAzYTY0NjM2YzEzOWViMSJ9.3jSOksDu6t36FCic-mlhC05fRNmxP9Kmv1mlDGyw5So&download=image.png"></p><p>点乘最大作用就是找到方向之间的夹角，一个向量投影到另一个向量上长什么样。</p><p>是否接近，前与后关系</p><p>叉乘 之后得到一个垂直a,b所在平面的向量</p><p>右手定则，右手螺旋定则：四指方向就是旋转方向，看大拇指指向就是新向量方向。</p><p>没有交换律，交换要有负号</p><p><img src="https://tcs.teambition.net/storage/312rd2970394d4d2edfa6301c10ace5ebdaf?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjE1NSwiaWF0IjoxNjgwNjE3MzU1LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnJkMjk3MDM5NGQ0ZDJlZGZhNjMwMWMxMGFjZTVlYmRhZiJ9.j7pfXZ9qj85BZnxexPJiwrsbCyMvHXqTqf-pWSAk6DM&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312r6e34cdcecd945bf3850faebdc2f0f332?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjE1NSwiaWF0IjoxNjgwNjE3MzU1LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnI2ZTM0Y2RjZWNkOTQ1YmYzODUwZmFlYmRjMmYwZjMzMiJ9.R4CHWk4NYU92KApIkjR4Iw_j6EIPnaZsvawwBY8CPp4&download=image.png"></p><p>1、判定左和右</p><p>2、判定外与内  光栅化基础  三角形覆盖哪些像素</p><p><img src="https://tcs.teambition.net/storage/312r2fc8cb3f3347cd06e21058d196ebb2f7?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjE1NSwiaWF0IjoxNjgwNjE3MzU1LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnIyZmM4Y2IzZjMzNDdjZDA2ZTIxMDU4ZDE5NmViYjJmNyJ9.0ctkdUXrLgL2jV2vPWa96i-B_NsYJj8t2-QI9FZBX6A&download=image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101-课程1</title>
      <link href="/2023/04/04/Games101-%E8%AF%BE%E7%A8%8B1/"/>
      <url>/2023/04/04/Games101-%E8%AF%BE%E7%A8%8B1/</url>
      
        <content type="html"><![CDATA[<p>课程1为概述</p><span id="more"></span><p>Course Topics (mainly 4 parts)</p><ul><li><p>Rasterization</p></li><li><p>Curves and Meshes</p></li><li><p>Ray Tracing</p></li><li><p>Animation &#x2F; Simulation</p></li></ul><p>Rasterization：光栅化，三维空间的几何形体显示在屏幕上</p><p>实时图形学：每秒30张图片以上 fps30</p><p>Curves and Meshes：曲线，曲面 表示 变化  保持拓扑结构</p><p>Ray Tracing：光线追踪 </p><p>Animation &#x2F; Simulation：动画模拟 仿真</p><p>计算机图形学与计算机视觉</p><p><img src="https://tcs.teambition.net/storage/312rcddab54d6cfcbbb15015deec90d173b7?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMjEzMSwiaWF0IjoxNjgwNjE3MzMxLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnJjZGRhYjU0ZDZjZmNiYmIxNTAxNWRlZWM5MGQxNzNiNyJ9.98cza-EgdseqTzpaaPAskcNYfhZrgkIJ7EOyXlWt3Mw&download=image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL专题一</title>
      <link href="/2023/04/04/STL%E4%B8%93%E9%A2%98%E4%B8%80/"/>
      <url>/2023/04/04/STL%E4%B8%93%E9%A2%98%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>STL基础概念和常用函数</p><span id="more"></span><h1 id="1、认识headers、版本、重要资源"><a href="#1、认识headers、版本、重要资源" class="headerlink" title="1、认识headers、版本、重要资源"></a>1、认识headers、版本、重要资源</h1><p>标准库以header files形式呈现</p><p>新式C头文件不带h 例如<cstdio> 带h依旧可用</p><p>新式headers内的组件封装于namespace “std”</p><p>旧式头文件没有封装在std中</p><p>重要网站：</p><p><a href="https://cplusplus.com/">https://cplusplus.com/</a></p><p><a href="https://en.cppreference.com/w/">cppreference.com</a></p><p>[GCC, the GNU Compiler Collection</p><ul><li>GNU Project](<a href="http://gcc.gnu.org/">http://gcc.gnu.org/</a>)</li></ul><p>书籍：</p><p>c++11 the c++ standard library 第二版</p><p>stl源码剖析</p><h1 id="2、STL体系结构基础介绍"><a href="#2、STL体系结构基础介绍" class="headerlink" title="2、STL体系结构基础介绍"></a>2、STL体系结构基础介绍</h1><p>STL六大部件</p><p>容器 containers  模板类</p><p>分配器 allocators</p><p>算法 algorithm</p><p>迭代器 iterators 泛化的指针</p><p>适配器 adapters 意在转换</p><p>仿函数 functors 作用像是一种函数 类+-</p><p>数据在容器，操作在另外  分开 非oo 模板编程</p><p>示例代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ia[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">27</span>,<span class="hljs-number">210</span>,<span class="hljs-number">12</span>,<span class="hljs-number">47</span>,<span class="hljs-number">109</span>,<span class="hljs-number">83</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>,allocator&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">vi</span>(ia,ia+<span class="hljs-number">6</span>); <span class="hljs-comment">//容器，分配器</span><br>cout&lt;&lt;<span class="hljs-built_in">count_if</span>(vi.<span class="hljs-built_in">begin</span>(),vi.<span class="hljs-built_in">end</span>(),<br><span class="hljs-built_in">notl</span>(<span class="hljs-built_in">bind2nd</span>(<span class="hljs-built_in">less</span>&lt;<span class="hljs-type">int</span>&gt;(),<span class="hljs-number">40</span>)));<br><span class="hljs-comment">//找出所有小于40的元素，使用less，然后bind2nd绑定第二参数40，</span><br></code></pre></td></tr></table></figure><p>容器会默认写分配器,，分配器本身也是一个模板，分配内存</p><p>使用类型说明：</p><p>count_if：algorithm</p><p>notl：function adapter（negator）</p><p>bind2nd：function adapter（binder）</p><p>less：function object</p><p>40：predicate</p><p>前闭后开区间：end最后一个元素的下一个位置</p><p>range-based for statement:</p><p>for(decl:coll){</p><p>statement</p><p>}</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">13</span>,<span class="hljs-number">17</span>,<span class="hljs-number">19</span>&#125;)<br>cout&lt;&lt;i&lt;&lt;endl;<br>vector&lt;<span class="hljs-type">double</span>&gt; vec;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> elem:vec)<br>cout&lt;&lt;elem&lt;&lt;endl;<br></code></pre></td></tr></table></figure><h1 id="3、容器之分类与各种测试"><a href="#3、容器之分类与各种测试" class="headerlink" title="3、容器之分类与各种测试"></a>3、容器之分类与各种测试</h1><h2 id="结构与分类"><a href="#结构与分类" class="headerlink" title="结构与分类"></a>结构与分类</h2><p>容器分类：</p><p><strong>序列式容器：Sequence Containers</strong></p><p>Array：无法扩张</p><p>Vector：后头扩充 分配器自动扩充 2倍扩展</p><p>Deque：两端扩充</p><p>List：双向链表</p><p>Forward-list：单向链表</p><p><strong>关联式容器：Associative Containers ，有key value 快速查找</strong></p><p>Set&#x2F;Multiset：红黑树 高度平衡二叉树</p><p>Map&#x2F;Multimap：红黑树</p><p>set的key和value是一样的，不分的</p><p><strong>Unordered Containers     hashtable</strong></p><p>hashtable separate chaining</p><p><img src="https://tcs.teambition.net/storage/312sf084765b1d111064f476e7ea49f45c3e?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTkyMSwiaWF0IjoxNjgwNjE3MTIxLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNmMDg0NzY1YjFkMTExMDY0ZjQ3NmU3ZWE0OWY0NWMzZSJ9.QpUQ2pfJq7wrOx2Lb1k1iIFCwKJ5rj4tVXadev2NnhU&download=image.png"></p><h3 id="array容器"><a href="#array容器" class="headerlink" title="array容器"></a>array容器</h3><p>在 C++ 普通数组的基础上，添加了一些成员函数和全局函数</p><p><img src="https://tcs.teambition.net/storage/312s116056f96999d658c475d79e7343dc6f?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTkyMSwiaWF0IjoxNjgwNjE3MTIxLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnMxMTYwNTZmOTY5OTlkNjU4YzQ3NWQ3OWU3MzQzZGM2ZiJ9.fkMXzdy-J3jI9GNarQ5vfutu5hzjtq-P9BgY8V067zs&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312s6dbd31878c4777d9657ec0bf0b4b1a0b?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTkyMSwiaWF0IjoxNjgwNjE3MTIxLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM2ZGJkMzE4NzhjNDc3N2Q5NjU3ZWMwYmYwYjRiMWEwYiJ9.BE5zCD6ePDnDrIfOO5raoeU-Z9UJNdGj2-Y5qCphJhE&download=image.png"></p><h3 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h3><p><img src="https://tcs.teambition.net/storage/312s23e7c17fe9a2c521d3e618111684803c?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTkyMSwiaWF0IjoxNjgwNjE3MTIxLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnMyM2U3YzE3ZmU5YTJjNTIxZDNlNjE4MTExNjg0ODAzYyJ9.xHmhf-xKjUNGtGo6tMG0IWy4zmXpgj5SuxIWVI0AZtc&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312s0d5a10b82dae8aa222853ad42a4eb949?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTkyMSwiaWF0IjoxNjgwNjE3MTIxLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnMwZDVhMTBiODJkYWU4YWEyMjI4NTNhZDQyYTRlYjk0OSJ9.gskSqNDhMAPVLSTJKxTsbwwoWUIGL4dqatqo7Jk4gRI&download=image.png"></p><h3 id="List容器"><a href="#List容器" class="headerlink" title="List容器"></a>List容器</h3><p>list 容器，又称双向链表容器，即该容器的底层是以双向链表的形式实现的，这意味着，list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。</p><p><img src="https://tcs.teambition.net/storage/312se4666656f183315924fd58f50d6c6249?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTkyMSwiaWF0IjoxNjgwNjE3MTIxLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNlNDY2NjY1NmYxODMzMTU5MjRmZDU4ZjUwZDZjNjI0OSJ9.oqtsfr278J2qq5IK8Vi2INKvJ8u9xWzmTm5PeLFG9bY&download=image.png"></p><p>它可以在序列已知的任何位置快速插入或删除元素（时间复杂度为<code>O(1)</code>）。并且在 list 容器中移动元素，也比其它容器的效率高。</p><p>使用 list 容器的缺点是，它不能像 array 和 vector 那样，通过位置直接访问元素</p><p>常用函数：</p><p><img src="https://tcs.teambition.net/storage/312s0a62d55a9761898484e8bbeaab03ec66?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTkyMSwiaWF0IjoxNjgwNjE3MTIxLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnMwYTYyZDU1YTk3NjE4OTg0ODRlOGJiZWFhYjAzZWM2NiJ9.KlxtHLqQzq-RZwr7ILGKC6tjgRNRx1bDncTNvVTy5Z8&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312s1cb6a071e4b8b1ace00713457ea9b509?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTkyMSwiaWF0IjoxNjgwNjE3MTIxLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnMxY2I2YTA3MWU0YjhiMWFjZTAwNzEzNDU3ZWE5YjUwOSJ9.ZTtDPvWM6HlSSFs3ZuzLDDlG8by5N1BxPJnK1_eKLNE&download=image.png"></p><h3 id="forward-list"><a href="#forward-list" class="headerlink" title="forward list"></a>forward list</h3><p><img src="https://tcs.teambition.net/storage/312sa214e083a4aff0c7714dedbbd4193f58?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTkyMSwiaWF0IjoxNjgwNjE3MTIxLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNhMjE0ZTA4M2E0YWZmMGM3NzE0ZGVkYmJkNDE5M2Y1OCJ9.5mNOxnFRV1PaoRUHrKDywAeAY63quF1vHu-dXzpwCuE&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312s69268bac9daff5491daa27a918fdcd96?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTkyMSwiaWF0IjoxNjgwNjE3MTIxLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM2OTI2OGJhYzlkYWZmNTQ5MWRhYTI3YTkxOGZkY2Q5NiJ9.MrLVVGuuDIMrKlMaArKyUqGmlkjPhFAtRDlABEvQ7kQ&download=image.png"></p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>分段连续 每次扩充一个buffer</p><p><img src="https://tcs.teambition.net/storage/312s11a405fb3131d7154eba9efb604edb89?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTkyMSwiaWF0IjoxNjgwNjE3MTIxLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnMxMWE0MDVmYjMxMzFkNzE1NGViYTllZmI2MDRlZGI4OSJ9.BRiODdyKr7oBoWkvb9DuF5ySHwkajCRiwEpMi-jCZuQ&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312s04346ccc3b11bf7e301c495d3dfbd4d7?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTkyMSwiaWF0IjoxNjgwNjE3MTIxLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnMwNDM0NmNjYzNiMTFiZjdlMzAxYzQ5NWQzZGZiZDRkNyJ9.-1LMdOJH1EdvtmQ9AHUsdHztIHv-SnAf4468adh09kI&download=image.png"></p><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>利用deque</p><p><img src="https://tcs.teambition.net/storage/312s818ad91c81c7b04f493462f10aa206bb?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTkyMSwiaWF0IjoxNjgwNjE3MTIxLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM4MThhZDkxYzgxYzdiMDRmNDkzNDYyZjEwYWEyMDZiYiJ9.CotgQd_tjUkYS6i_oMaVmJgDatzWRN5L_EqRZhz8ytY&download=image.png"></p><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>利用deque</p><p><img src="https://tcs.teambition.net/storage/312s5a81c234ce2a6a2e3d6da38c337a0c7b?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTkyMSwiaWF0IjoxNjgwNjE3MTIxLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM1YTgxYzIzNGNlMmE2YTJlM2Q2ZGEzOGMzMzdhMGM3YiJ9.hKO9a-xc26nbX67wTCrqv1r4uMAGz1EWEh6mXvmebT8&download=image.png"></p><p>unordered_multiset:</p><p>哈希表  篮子一定比元素多</p><h2 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h2><p>种类：</p><p><img src="https://tcs.teambition.net/storage/312s4152264ee168758ceab894ed9844f7a9?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTkyMSwiaWF0IjoxNjgwNjE3MTIxLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM0MTUyMjY0ZWUxNjg3NThjZWFiODk0ZWQ5ODQ0ZjdhOSJ9.OHZ-eWW3mQKHcNKQoqK0nliZl8uodRLIALm_7a7Bt7o&download=image.png"></p><p>命名空间 __gnu_cxx::</p><h1 id="4、OOP-vs-GP"><a href="#4、OOP-vs-GP" class="headerlink" title="4、OOP vs GP"></a>4、OOP vs GP</h1><p>OOP：数据和操作在一起</p><p>GP：分开来</p><p>为什么list不能使用::sort排序  因为iterator要求不一样  sort需要随机访问迭代器</p><p>基础：</p><p>操作符重载</p><p>模板：类模板，函数模板，成员模板</p><p>类模板一定要写出来类型</p><p>编译器对function template进行实参推导</p><p>全特化：template&lt;&gt;  加指定类型</p><p>偏特化 多个参数类型  指定其中一个 数量上的局部，范围上的局部</p><p><img src="https://tcs.teambition.net/storage/312s2be4186c1c11c1bf945f034a26ba54b0?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTkyMSwiaWF0IjoxNjgwNjE3MTIxLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnMyYmU0MTg2YzFjMTFjMWJmOTQ1ZjAzNGEyNmJhNTRiMCJ9.cEMbuibskjGtXO53sZbSuVpiwbdZ-1QIqFB4FTwpPUE&download=image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板专题</title>
      <link href="/2023/04/04/%E6%A8%A1%E6%9D%BF%E4%B8%93%E9%A2%98/"/>
      <url>/2023/04/04/%E6%A8%A1%E6%9D%BF%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>C++模板类和函数的特化和偏特化</p><span id="more"></span><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><img src="https://tcs.teambition.net/storage/312s3468e004bebeac3947b7486c896741a1?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTcxOCwiaWF0IjoxNjgwNjE2OTE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnMzNDY4ZTAwNGJlYmVhYzM5NDdiNzQ4NmM4OTY3NDFhMSJ9.m56a3a7A39x_sb2PsTfzWWMRu6GvmRDd_oIRbff5ecM&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312s3dab4f0709492803fe1fcf34daddb531?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTcxOCwiaWF0IjoxNjgwNjE2OTE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnMzZGFiNGYwNzA5NDkyODAzZmUxZmNmMzRkYWRkYjUzMSJ9.Xw14JkinK7gGsZhSP3S1ETImXz8TsVAEOeEZQMZ5fBw&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312sea8c9683e00db76ae6b5b7078fee9ebd?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTcxOCwiaWF0IjoxNjgwNjE2OTE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNlYThjOTY4M2UwMGRiNzZhZTZiNWI3MDc4ZmVlOWViZCJ9.JKI7L18_rsyqDq4aUSxmnoAD0lUlSVwkHmSSLjs9rK0&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312s5e63b1d1d9d8d0ffebe7f9ec8872a7f5?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTcxOCwiaWF0IjoxNjgwNjE2OTE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM1ZTYzYjFkMWQ5ZDhkMGZmZWJlN2Y5ZWM4ODcyYTdmNSJ9.qhYU3w3pGoxYapKUSWaqaJHYiNjCkGTxfMnm3n6aHYE&download=image.png"></p><p><a href="https://zhuanlan.zhihu.com/p/377484369">c++中typename、typedef以及using关键字用法</a></p><h1 id="模板特化"><a href="#模板特化" class="headerlink" title="模板特化"></a>模板特化</h1><p>特化（specialization）是根据一个或多个特殊的整数或类型，给出模板实例化时的一个指定内容。</p><h2 id="类模板特化"><a href="#类模板特化" class="headerlink" title="类模板特化"></a>类模板特化</h2><p><img src="https://tcs.teambition.net/storage/312scd12e5de5a4682015bb51f9aeef41a30?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTcxOCwiaWF0IjoxNjgwNjE2OTE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNjZDEyZTVkZTVhNDY4MjAxNWJiNTFmOWFlZWY0MWEzMCJ9.wE0ARTGm_bZxZWpZWrErf69sZD92_1efOPIfmZCwLMI&download=image.png"></p><h2 id="函数模板特化"><a href="#函数模板特化" class="headerlink" title="函数模板特化"></a>函数模板特化</h2><p><img src="https://tcs.teambition.net/storage/312sb334b67563768455b50799c29e893c10?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTcxOCwiaWF0IjoxNjgwNjE2OTE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNiMzM0YjY3NTYzNzY4NDU1YjUwNzk5YzI5ZTg5M2MxMCJ9.KEdmDjc2CB4TI54m-yHuwdaxs4ihIAGMfiAlkZrZKto&download=image.png"></p><h1 id="模板偏特化"><a href="#模板偏特化" class="headerlink" title="模板偏特化"></a>模板偏特化</h1><h2 id="类偏特化"><a href="#类偏特化" class="headerlink" title="类偏特化"></a>类偏特化</h2><p><img src="https://tcs.teambition.net/storage/312s40e5a74adb2a4649e6f3512c72698fcf?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTcxOCwiaWF0IjoxNjgwNjE2OTE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM0MGU1YTc0YWRiMmE0NjQ5ZTZmMzUxMmM3MjY5OGZjZiJ9.NTsdJfm4CHmKgFTialqLcG2v3EwTcugaxzL2osOQYoo&download=image.png"></p><h2 id="函数偏特化"><a href="#函数偏特化" class="headerlink" title="函数偏特化"></a>函数偏特化</h2><p>实际不支持函数偏特化的方法</p><p>替代方法：</p><p><a href="https://zhuanlan.zhihu.com/p/268600376">C++函数模板的偏特化</a></p><p>1、借助类模板实现偏特化</p><p><img src="https://tcs.teambition.net/storage/312s606fc12171a93f9ae08eb6208b7a02fc?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTcxOCwiaWF0IjoxNjgwNjE2OTE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM2MDZmYzEyMTcxYTkzZjlhZTA4ZWI2MjA4YjdhMDJmYyJ9.79Cshz4uegX2Q3hcyJrxzLfdkAal_75Ej_bJnjgCzDc&download=image.png"></p><p>2、使用标签分发</p><p>C++标准虽然不支持函数模板的偏特化，但函数的重载显然是支持的。使用标签分发(Tag Dispatch)的方案就是通过函数实现不同的函数重载实现，根据不同实参类型选择具体的函数实现，以达到函数模板偏特化的实现。</p><p>这种方案是利用函数重载的特性以达到根据实参类型筛选不同函数实现的能力。我们将这种实现称为标签分发</p><p><img src="https://tcs.teambition.net/storage/312s1078222f5d8c41b54f8070443abb882e?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTcxOCwiaWF0IjoxNjgwNjE2OTE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnMxMDc4MjIyZjVkOGM0MWI1NGY4MDcwNDQzYWJiODgyZSJ9.ugIdRUAWZcSqd5Jcov1hTY9Jppodt4KVmcT3P_I7y7k&download=image.png"></p><p>3、concept</p><p><img src="https://tcs.teambition.net/storage/312scd030b3193dc75c352e9ae0f6494fe42?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIyMTcxOCwiaWF0IjoxNjgwNjE2OTE4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNjZDAzMGIzMTkzZGM3NWMzNTJlOWFlMGY2NDk0ZmU0MiJ9.7RAaDYtaI0Nhuw2z11jyVzJbPygZnhdy7cQ8R8Wx1Zc&download=image.png"></p><p>模板在实际应用中，也会有一些固定的需求和解决方案。比较常见的场景包括：泛型（最基本的用法）、通过类型获得相应的信息（型别萃取）、编译期间的计算、类型间的推导和变换（从一个类型变换成另外一个类型，比如boost::function）</p><h1 id="萃取"><a href="#萃取" class="headerlink" title="萃取"></a>萃取</h1>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统八股一</title>
      <link href="/2023/04/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A1%E4%B8%80/"/>
      <url>/2023/04/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A1%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p> 记录常考，应知应会的操作系统八股，主要参考<a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/02-02-os.html">阿秀的学习笔记</a><br> <span id="more"></span></p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="操作系统内存管理功能"><a href="#操作系统内存管理功能" class="headerlink" title="操作系统内存管理功能"></a>操作系统内存管理功能</h2><ul><li><p>操作系统负责内存空间的分配与回收。</p></li><li><p>操作系统需要提供某种技术从逻辑上对内存空间进行扩充。</p></li><li><p>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。</p></li><li><p>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰</p></li></ul><h2 id="进程，线程，协程"><a href="#进程，线程，协程" class="headerlink" title="进程，线程，协程"></a>进程，线程，协程</h2><p><img src="https://tcs.teambition.net/storage/312s8286d7938efe4cb90d573a6cd1c9406b?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIxODIyOCwiaWF0IjoxNjgwNjEzNDI4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM4Mjg2ZDc5MzhlZmU0Y2I5MGQ1NzNhNmNkMWM5NDA2YiJ9.hn4zp9Ii5GVglmLLEbWdep8dOf__piIowfXeRefOp7Q&download=image.png"></p><p>根本区别在于 多进程中每个进程有自己的地址空间，线程则共享地址空间</p><p>进程通信方式：</p><p><img src="https://tcs.teambition.net/storage/312s4b0abe7a324cb323ea33ee1330570f66?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIxODIyOCwiaWF0IjoxNjgwNjEzNDI4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM0YjBhYmU3YTMyNGNiMzIzZWEzM2VlMTMzMDU3MGY2NiJ9.5tW2VgJyLHk4D3-0SDokfpEKjbwHwGZmUuqbbD0zSG8&download=image.png"></p><p>线程通信方式：</p><p><img src="https://tcs.teambition.net/storage/312sc22e9a71ff59e3084daf18351aeae152?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIxODIyOCwiaWF0IjoxNjgwNjEzNDI4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNjMjJlOWE3MWZmNTllMzA4NGRhZjE4MzUxYWVhZTE1MiJ9.OjHE-LEWzGT3ar-rfLqSboYpHiQo-jpNEcBHf3C2DjI&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312s58871d06cd5be8998835dcd63b336579?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIxODIyOCwiaWF0IjoxNjgwNjEzNDI4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM1ODg3MWQwNmNkNWJlODk5ODgzNWRjZDYzYjMzNjU3OSJ9.A7PUTPUcN0gTy246ThTro2YI9gxSMWtPnRWQLrd3M6c&download=image.png"></p><p>为什么会有协程是轻量级线程的说法呢？因为协程具有中断可恢复的特性，那么只需要在开一个全局的数组存储所有的协程，在协程中断时，不断轮转调用下一个协程继续运行即可； 这看起来似乎和线程无异，但其实有巨大的区别，<strong>因为协程本质是函数，调用协程后原来的地方就会被阻塞，协程处理完了才返回结果，这是天然同步的</strong>，而多线程无法做到这点，因为多线程的调度受内核控制，触发点来自于硬件时钟中断不可预见，同时又运行在多核心下，调用后运行次序是不确定的，想实现同步调用就必须通过std::promise&#x2F;future 去辅佐，但为了性能往往见到的是异步+回调的方式进行多线程的交互，异步回调代码的可读性是很差的而且还需要考虑一大堆并发上锁的情况，<strong>协程因其函数本质，是天然同步的，而在遇到阻塞条件时候，把cpu让给别的协程，等条件满足了再通过中断可恢复的特性再继续运行，就实现了并发，同步+并发就是协程强大的地方，其使用范式和轮转+同步非阻塞很像</strong></p><p>最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p><p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多</p><p><a href="https://zhuanlan.zhihu.com/p/279383752">Unity协程的原理与应用</a></p><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p>1、先来先服务</p><p>2、短作业优先</p><p>3、最短剩余时间优先</p><p>4、时间片轮转</p><p>5、优先级调度</p><p>6、多级反馈队列</p><h2 id="进程同步的四种方法"><a href="#进程同步的四种方法" class="headerlink" title="进程同步的四种方法"></a>进程同步的四种方法</h2><p>1、临界区</p><p>2、同步与互斥</p><p>3、信号量（生产者，消费者问题）</p><p>4、管程（引入了条件变量和相关操作）在信号量基础上改进的并发编程模型</p><p><img src="https://tcs.teambition.net/storage/312sa58a1bf6197190c903d0b7ec193eaedf?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIxODIyOCwiaWF0IjoxNjgwNjEzNDI4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNhNThhMWJmNjE5NzE5MGM5MDNkMGI3ZWMxOTNlYWVkZiJ9.kfevWp4H9LfHsMsIf4TDeeLxlRIbKsPB0gBEwkbYDCw&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312s199216a1a2a9d90294fdc96d78cad3bf?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIxODIyOCwiaWF0IjoxNjgwNjEzNDI4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnMxOTkyMTZhMWEyYTlkOTAyOTRmZGM5NmQ3OGNhZDNiZiJ9.9u05WNMbFz4a7iZEe5dZQe0flLXSBMq4jgk6xDV7UJQ&download=image.png"></p><h2 id="进程状态转换"><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h2><p><img src="https://tcs.teambition.net/storage/312sc81ae0a07962003ad5444f4cffe38711?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIxODIyOCwiaWF0IjoxNjgwNjEzNDI4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNjODFhZTBhMDc5NjIwMDNhZDU0NDRmNGNmZmUzODcxMSJ9.uRhzEpzXaS_iQemnIQp3hgZ60wOmIOcoxhftezv4Tek&download=image.png"></p><ul><li><p>就绪状态（ready）：等待被调度</p></li><li><p>运行状态（running）</p></li><li><p>阻塞状态（waiting）：等待资源</p></li></ul><p>应该注意以下内容：</p><ul><li><p>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</p></li><li><p>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</p></li></ul><h2 id="回收线程方法"><a href="#回收线程方法" class="headerlink" title="回收线程方法"></a>回收线程方法</h2><ul><li><p><strong>等待线程结束：</strong> int pthread_join(pthread_t tid, void** retval);主线程调用，等待子线程退出并回收其资源，类似于进程中wait&#x2F;waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。</p><ul><li><p>tid：创建线程时通过指针得到tid值。</p></li><li><p>retval：指向返回值的指针。</p></li></ul></li><li><p><strong>结束线程：</strong> void pthread_exit(void *retval);子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。</p><ul><li>retval：同上。</li></ul></li><li><p><strong>分离线程：</strong> int pthread_detach(pthread_t tid);主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。</p></li></ul><p>终端退出，终端运行的进程会怎么样？</p><p>终端在退出时会发送SIGHUP给对应的bash进程，bash进程收到这个信号后首先将它发给session下面的进程，如果程序没有对SIGHUP信号做特殊处理，那么进程就会随着终端关闭而退出</p><h2 id="如何让进程后台运行"><a href="#如何让进程后台运行" class="headerlink" title="如何让进程后台运行"></a>如何让进程后台运行</h2><p>（1）命令后面加上&amp;即可，实际上，这样是将命令放入到一个作业队列中了</p><p>（2）ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程</p><p>（3）nohup + &amp;，将标准输出和标准错误缺省会被重定向到 nohup.out 文件中，忽略所有挂断（SIGHUP）信号</p><p>（4）运行指令前面 + setsid，使其父进程编程init进程，不受HUP信号的影响</p><p>（5）将 命令+ &amp;放在()括号中，也可以是进程不受HUP信号的影响</p><h2 id="进程终止的几种方式"><a href="#进程终止的几种方式" class="headerlink" title="进程终止的几种方式"></a>进程终止的几种方式</h2><p>1、main函数的自然返回，<code>return</code> </p><p>2、调用<code>exit</code>函数，属于c的函数库 </p><p>3、调用<code>_exit</code>函数，属于系统调用 </p><p>4、调用<code>abort</code>函数，异常程序终止，同时发送SIGABRT信号给调用进程。 </p><p>5、接受能导致进程终止的信号：ctrl+c (^C)、SIGINT(SIGINT中断进程)</p><p><img src="https://tcs.teambition.net/storage/312s79bd22620f4016c67d23e4d02f2c318d?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IjYwM2NkZGQ4NjZiNjNmMzk4ZjA3ZGQxZCIsImV4cCI6MTY4MDYxOTgwOSwiaWF0IjoxNjgwNjE2MjA5LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM3OWJkMjI2MjBmNDAxNmM2N2QyM2U0ZDAyZjJjMzE4ZCJ9.d02LRxy_DTWiRqHydF0QDLXh4FXTrkJOlWsZ_L8MpRQ&download=image.png"></p><h2 id="守护进程、僵尸进程和孤儿进程"><a href="#守护进程、僵尸进程和孤儿进程" class="headerlink" title="守护进程、僵尸进程和孤儿进程"></a>守护进程、僵尸进程和孤儿进程</h2><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等</p><p>创建守护进程要点：</p><p>（1）让程序在后台执行。方法是调用fork（）产生一个子进程，然后使父进程退出。</p><p>（2）调用setsid（）创建一个新对话期。控制终端、登录会话和进程组通常是从父进程继承下来的，守护进程要摆脱它们，不受它们的影响，方法是调用setsid（）使进程成为一个会话组长。setsid（）调用成功后，进程成为新的会话组长和进程组长，并与原来的登录会话、进程组和控制终端脱离。</p><p>（3）禁止进程重新打开控制终端。经过以上步骤，进程已经成为一个无终端的会话组长，但是它可以重新申请打开一个终端。为了避免这种情况发生，可以通过使进程不再是会话组长来实现。再一次通过fork（）创建新的子进程，使调用fork的进程退出。</p><p>（4）关闭不再需要的文件描述符。子进程从父进程继承打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。首先获得最高文件描述符值，然后用一个循环程序，关闭0到最高文件描述符值的所有文件描述符。</p><p>（5）将当前目录更改为根目录。</p><p>（6）子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权。为防止这一点，使用unmask（0）将屏蔽字清零。</p><p>（7）处理SIGCHLD信号。对于服务器进程，在请求到来时往往生成子进程处理请求。如果子进程等待父进程捕获状态，则子进程将成为僵尸进程（zombie），从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN。这样，子进程结束时不会产生僵尸进程。</p><p><img src="https://tcs.teambition.net/storage/312sbf93ac27536bd00b7ecd220e92f3acc5?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IjYwM2NkZGQ4NjZiNjNmMzk4ZjA3ZGQxZCIsImV4cCI6MTY4MDYxODAzMywiaWF0IjoxNjgwNjE0NDMzLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNiZjkzYWMyNzUzNmJkMDBiN2VjZDIyMGU5MmYzYWNjNSJ9.KphocziHcQ5tFYvV1hrXuXFxTlEW34204l6OWy8cj6M&download=image.png"></p><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>如果父进程先退出，子进程还没退出，那么子进程的父进程将变为init进程。（注：任何一个进程都必须有父进程）。</p><p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作</p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。</p><p>设置<strong>僵尸进程的目</strong>的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）</p><h3 id="避免僵尸进程"><a href="#避免僵尸进程" class="headerlink" title="避免僵尸进程"></a>避免僵尸进程</h3><ul><li><p>通过signal(SIGCHLD, SIG_IGN)通知内核对子进程的结束不关心，由内核回收。如果不想让父进程挂起，可以在父进程中加入一条语句：signal(SIGCHLD,SIG_IGN);表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。</p></li><li><p>父进程调用wait&#x2F;waitpid等函数等待子进程结束，如果尚无子进程退出wait会导致父进程阻塞。waitpid可以通过传递WNOHANG使父进程不阻塞立即返回。</p></li><li><p>如果父进程很忙可以用signal注册信号处理函数，在信号处理函数调用wait&#x2F;waitpid等待子进程退出。</p></li><li><p>通过两次调用fork。父进程首先调用fork创建一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由init进程接管，孙进程结束后，init会等待回收。</p></li></ul><p>第一种方法忽略SIGCHLD信号，这常用于并发服务器的性能的一个技巧因为并发服务器常常fork很多子进程，子进程终结之后需要服务器进程去wait清理资源。如果将此信号的处理方式设为忽略，可让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。</p><h2 id="父进程、子进程、进程组、作业和会话"><a href="#父进程、子进程、进程组、作业和会话" class="headerlink" title="父进程、子进程、进程组、作业和会话"></a>父进程、子进程、进程组、作业和会话</h2><h3 id="父进程"><a href="#父进程" class="headerlink" title="父进程"></a>父进程</h3><p>已创建一个或多个子进程的进程</p><h3 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h3><p>由fork创建的新进程被称为子进程（child process）。该函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新进程（子进程）的进程 id。将子进程id返回给父进程的理由是：因为一个进程的子进程可以多于一个，没有一个函数使一个进程可以获得其所有子进程的进程id。对子进程来说，之所以fork返回0给它，是因为它随时可以调用getpid()来获取自己的pid；也可以调用getppid()来获取父进程的id。(进程id 0总是由交换进程使用，所以一个子进程的进程id不可能为0 )。</p><p>fork之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这2个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同，也就是说，子进程是从fork返回处开始执行的），但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。</p><p>子进程从父进程继承的有：</p><p>1.进程的资格(真实(real)&#x2F;有效(effective)&#x2F;已保存(saved)用户号(UIDs)和组号(GIDs))</p><p>2.环境(environment)</p><p>3.堆栈</p><p>4.内存</p><p>5.进程组号</p><p>独有：</p><p>1.进程号；</p><p>2.不同的父进程号(译者注：即子进程的父进程号与父进程的父进程号不同， 父进程号可由getppid函数得到)；</p><p>3.资源使用(resource utilizations)设定为0</p><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>进程组就是多个进程的集合，其中肯定有一个组长，其进程PID等于进程组的PGID。只要在某个进程组中一个进程存在，该进程组就存在，这与其组长进程是否终止无关</p><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p>一个作业是我们提交给shell的一项任务或者批处理，和操作系统无关。</p><p>一个作业通常包括几个进程，几个进程共同完成一个任务，即作业。</p><p> 进程是具体执行的一个可执行程序，是操作系统调度的对象</p><p>shell分前后台来控制的不是进程而是作业（job）或者进程组（Process Group）。</p><p>一个前台作业可以由多个进程组成，一个后台也可以由多个进程组成，shell可以运行一个前台作业和任意多个后台作业，这称为作业控制</p><p><strong>为什么只能运行一个前台作业？</strong></p><p>答：当我们在前台新起了一个作业，shell就被提到了后台，因此shell就没有办法再继续接受我们的指令并且解析运行了。 但是如果前台进程退出了，shell就会有被提到前台来，就可以继续接受我们的命令并且解析运行。</p><p>作业与进程组的区别：如果作业中的某个进程有创建了子进程，则该子进程是不属于该作业的。 一旦作业运行结束，shell就把自己提到前台（子进程还存在，但是子进程不属于作业），如果原来的前台进程还存在（这个子进程还没有终止），他将自动变为后台进程组</p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>会话（Session）是一个或多个进程组的集合。一个会话可以有一个控制终端。在xshell或者WinSCP中打开一个窗口就是新建一个会话。</p><h2 id="C-socket"><a href="#C-socket" class="headerlink" title="C++ socket"></a>C++ socket</h2><p>socket顾名思义就是套接字的意思，用于描述地址和端口，是一个通信链的句柄。应用程序通过socket向网络发出请求或者回应</p><p><a href="https://blog.csdn.net/qq_27923041/article/details/83857964">C++:实现socket通信（TCP&#x2F;IP）实例_c++ socket_Cche1的博客-CSDN博客</a></p><h2 id="Linux下同步机制"><a href="#Linux下同步机制" class="headerlink" title="Linux下同步机制"></a>Linux下同步机制</h2><p>POSIX信号量：可用于进程同步，也可用于线程同步</p><p>POSIX互斥锁+条件变量：只能用于线程同步</p><h2 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h2><p>①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</p><p>②如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</p><p>③如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)</p><p><img src="https://tcs.teambition.net/storage/312s4bf5d89126a94650856641e578749e92?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IjYwM2NkZGQ4NjZiNjNmMzk4ZjA3ZGQxZCIsImV4cCI6MTY4MDYxNzY1OSwiaWF0IjoxNjgwNjE0MDU5LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM0YmY1ZDg5MTI2YTk0NjUwODU2NjQxZTU3ODc0OWU5MiJ9.q9Q0YR8A5xiGM4Wpj6gkjJ7kqB1hg2oHgMUF2cn-c-0&download=image.png"></p><h2 id="逻辑地址-x3D-gt-物理地址"><a href="#逻辑地址-x3D-gt-物理地址" class="headerlink" title="逻辑地址&#x3D;&gt;物理地址"></a>逻辑地址&#x3D;&gt;物理地址</h2><p>可以借助进程的页表将逻辑地址转换为物理地址。</p><p>通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB) 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><p>注意:页面大小是2的整数幂 设页面大小为L，逻辑地址A到物理地址E的变换过程如下：</p><p><img src="https://tcs.teambition.net/storage/312sd0a417832687c63684d52c75f4a8fcea?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIxODIyOCwiaWF0IjoxNjgwNjEzNDI4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNkMGE0MTc4MzI2ODdjNjM2ODRkNTJjNzVmNGE4ZmNlYSJ9.O7TWxSGvrK-YK3CDXfPbPT7dTQCOyjB3xE6ubRQ9Sxo&download=image.png"></p><p>计算物理地址：</p><p><img src="https://tcs.teambition.net/storage/312s7cfdeb6bfd6c2d80ac929cf4f71f56df?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIxODIyOCwiaWF0IjoxNjgwNjEzNDI4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM3Y2ZkZWI2YmZkNmMyZDgwYWM5MjljZjRmNzFmNTZkZiJ9.HTgypvjvctSAfgNSMGnzcIb9azhq_WKjVXCI52Xe2KI&download=image.png"></p><h2 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h2><p><img src="https://tcs.teambition.net/storage/312s8444da01754b03726bb13e147ffc23fc?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIxODIyOCwiaWF0IjoxNjgwNjEzNDI4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM4NDQ0ZGEwMTc1NGIwMzcyNmJiMTNlMTQ3ZmZjMjNmYyJ9.gifNII9FqSdEl3iRcmbTRa7xj-aCuQMdpEw6xhcbuoA&download=image.png"></p><p>内部碎片和外部碎片区别：</p><p>固定分区存储管理会产生内部碎片，可变分区存储可能会产生外部碎片</p><p>内外是相对于分区而言的</p><ul><li><p>内碎片：是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间，占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块</p></li><li><p>外碎片：是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域，这些存储块的总和可以满足当前申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请</p></li></ul><h2 id="虚拟内存目的"><a href="#虚拟内存目的" class="headerlink" title="虚拟内存目的"></a>虚拟内存目的</h2><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。</p><p>这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。</p><h2 id="读写锁问题"><a href="#读写锁问题" class="headerlink" title="读写锁问题"></a>读写锁问题</h2><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> semaphore;<br>semaphore count_mutex = <span class="hljs-number">1</span>;<br>semaphore data_mutex = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(TRUE) &#123;<br>        <span class="hljs-built_in">down</span>(&amp;count_mutex);<br>        count++;<br>        <span class="hljs-keyword">if</span>(count == <span class="hljs-number">1</span>) <span class="hljs-built_in">down</span>(&amp;data_mutex); <span class="hljs-comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span><br>        <span class="hljs-built_in">up</span>(&amp;count_mutex);<br>        <span class="hljs-built_in">read</span>();<br>        <span class="hljs-built_in">down</span>(&amp;count_mutex);<br>        count--;<br>        <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>) <span class="hljs-built_in">up</span>(&amp;data_mutex);<span class="hljs-comment">//最后一个读者要对数据进行解锁，防止写进程无法访问</span><br>        <span class="hljs-built_in">up</span>(&amp;count_mutex);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">writer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(TRUE) &#123;<br>        <span class="hljs-built_in">down</span>(&amp;data_mutex);<br>        <span class="hljs-built_in">write</span>();<br>        <span class="hljs-built_in">up</span>(&amp;data_mutex);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://tcs.teambition.net/storage/312sf8158918cc2fd0bd3eaaac8583999099?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY4MTIxODIyOCwiaWF0IjoxNjgwNjEzNDI4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnNmODE1ODkxOGNjMmZkMGJkM2VhYWFjODU4Mzk5OTA5OSJ9.IjCtC0gfiw43I16f0r9VhRpFEpQcBPDbt6-2XRgcbuQ&download=image.png"></p><p><a href="https://zhuanlan.zhihu.com/p/612035861">C++线程中的五种常见锁与C++ RAII锁的常见用法</a></p><h2 id="常见线程锁"><a href="#常见线程锁" class="headerlink" title="常见线程锁"></a>常见线程锁</h2><h3 id="互斥锁（mutex）"><a href="#互斥锁（mutex）" class="headerlink" title="互斥锁（mutex）"></a><strong>互斥锁（mutex）</strong></h3><p>互斥锁属于sleep-waiting类型的锁。例如在一个双核的机器上有两个线程A和B，它们分别运行在core 0和core 1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞，此时会通过上下文切换将线程A置于等待队列中，此时core 0就可以运行其他的任务（如线程C）。</p><h3 id="条件变量-cond"><a href="#条件变量-cond" class="headerlink" title="条件变量(cond)"></a><strong>条件变量(cond)</strong></h3><h3 id="自旋锁-spin"><a href="#自旋锁-spin" class="headerlink" title="自旋锁(spin)"></a><strong>自旋锁(spin)</strong></h3><p>自旋锁属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，如果自旋锁已经被线程B所持有，那么线程A就会一直在core 0上进行忙等待并不停的进行锁请求，检查该自旋锁是否已经被线程B释放，直到得到这个锁为止。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。</p><p>虽然它的效率比互斥锁高，但是它也有些不足之处：</p><ul><li><p>自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。</p></li><li><p>在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。</p></li><li><p>自旋锁只有在内核可抢占式或SMP的情况下才真正需要，在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。</p></li></ul><h2 id="内存的覆盖，交换"><a href="#内存的覆盖，交换" class="headerlink" title="内存的覆盖，交换"></a>内存的覆盖，交换</h2><p>覆盖：</p><p>由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成为一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。</p><p>覆盖技术的特点：是打破了必须将一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，再而，大家要注意到，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存</p><p>缺点：覆盖结构必须要<strong>用户（程序员）声明</strong>，<strong>对用户不透明</strong>。用于早期，现在早已成为<strong>历史</strong></p><p>交换：</p><p><strong>交换(对换)技术的设计思想</strong>：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)</p><p>换入：把准备好竞争CPU运行的程序从辅存移到内存。 换出：把处于等待状态（或CPU调度原则下被剥夺运行权力）的程序从内存移到辅存，把内存空间腾出来</p><p><img src="https://tcs.teambition.net/storage/312s06c57d449d2af0f70e419fc586ea447f?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IjYwM2NkZGQ4NjZiNjNmMzk4ZjA3ZGQxZCIsImV4cCI6MTY4MDYxNzQxMCwiaWF0IjoxNjgwNjEzODEwLCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnMwNmM1N2Q0NDlkMmFmMGY3MGU0MTlmYzU4NmVhNDQ3ZiJ9.TKShIBrB90_e_bNoT0ScK1z4ZMa_MBBREP1Gp8PusDs&download=image.png"></p><p><img src="https://tcs.teambition.net/storage/312s70410a137d79c6652f4c0bc1a96b8b4b?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IjYwM2NkZGQ4NjZiNjNmMzk4ZjA3ZGQxZCIsImV4cCI6MTY4MDYxNzQ4NywiaWF0IjoxNjgwNjEzODg3LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnM3MDQxMGExMzdkNzljNjY1MmY0YzBiYzFhOTZiOGI0YiJ9.ZwEypmq0eIhqLBwZ-3Bejiau3Nz3JvVEOvWaoWN3Sx8&download=image.png"></p><p><strong>区别？</strong></p><p>1.覆盖是在<strong>同一个进程或程序之</strong>间的，交换是在<strong>不同</strong>的进程或作业之间的。</p><p>2.覆盖技术打破了程<strong>序必须全部装入内存</strong>才能运行的<strong>限制</strong>。而交换技术打破了<strong>进程进入内存就会一直运行到结束的限制</strong>。</p><h2 id="在执行malloc申请内存的时候，操作系统是怎么做的？"><a href="#在执行malloc申请内存的时候，操作系统是怎么做的？" class="headerlink" title="在执行malloc申请内存的时候，操作系统是怎么做的？"></a>在执行malloc申请内存的时候，操作系统是怎么做的？</h2><p>从操作系统层面上看，malloc是通过两个系统调用来实现的： brk和mmap</p><ul><li><p>brk是将进程数据段(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小</p></li><li><p>mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。</p></li></ul><p>通常，分配的内存小于128k时，使用brk调用来获得虚拟内存，大于128k时就使用mmap来获得虚拟内存。</p><p>进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。</p><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>主要分为<strong>时间局部性和空间局部性</strong>。</p><p>时间局部性:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环) 空间局部性:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)</p><p><img src="https://tcs.teambition.net/storage/312s37e8bccb1eb76f020b3c3f23c9964f47?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IjYwM2NkZGQ4NjZiNjNmMzk4ZjA3ZGQxZCIsImV4cCI6MTY4MDYxODQwOCwiaWF0IjoxNjgwNjE0ODA4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnMzN2U4YmNjYjFlYjc2ZjAyMGIzYzNmMjNjOTk2NGY0NyJ9.AZF9QwjMpxGEzJ-DIEYrroWuysSmHmPKB4stW-SdIgM&download=image.png"></p><h2 id="Linux异常和中断区别"><a href="#Linux异常和中断区别" class="headerlink" title="Linux异常和中断区别"></a>Linux异常和中断区别</h2><p>中断是由硬件设备产生的，而它们从物理上说就是电信号，之后，它们通过中断控制器发送给CPU，接着CPU判断收到的中断来自于哪个硬件设备（这定义在内核中），最后，由CPU发送给内核，有内核处理中断。</p><p><strong>异常是由CPU产生的，同时，它会发送给内核，要求内核处理这些异常</strong></p><p><strong>相同点</strong></p><ul><li><p>最后都是由CPU发送给内核，由内核去处理</p></li><li><p>处理程序的流程设计上是相似的</p></li></ul><p><strong>不同点</strong></p><ul><li><p>产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的</p></li><li><p>内核需要根据是异常还是中断调用不同的处理程序</p></li><li><p>中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的</p></li><li><p>当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity简易解密游戏练习</title>
      <link href="/2023/03/25/Unity%E7%AE%80%E6%98%93%E8%A7%A3%E5%AF%86%E6%B8%B8%E6%88%8F%E7%BB%83%E4%B9%A0/"/>
      <url>/2023/03/25/Unity%E7%AE%80%E6%98%93%E8%A7%A3%E5%AF%86%E6%B8%B8%E6%88%8F%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>参考B站教程<a href="https://www.bilibili.com/video/BV19a411i7Tw/?spm_id_from=pageDriver&vd_source=71dde4a51421e8a6f41a13340e537c04">《迷失岛2》游戏框架开发</a>作为Unity日常练习</p><span id="more"></span>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity实现简易背包系统</title>
      <link href="/2023/03/25/Unity%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/03/25/Unity%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>Unity中使用ScriptableObject和UI实现背包系统</p><span id="more"></span><p>ScriptableObject：<br></p><ul><li>ScriptableObject 是 Unity 提供的一个数据配置存储基类，它是一个可以用来保存大量数据的数据容器，我们可以将它保存为自定义的数据资源文件。</li><li>ScriptableObject 是一个类似 MonoBehaviour 的基类，继承自 UnityEngine.Object 。要想使用它，需要我们写个脚本去继承 ScriptableObject 。需要注意的是，继承自 SctiptableObject 的脚本无法挂载到游戏物体上，毕竟它不是继承自 MonoBehaviour。</li><li>ScriptableObject 类的实例会被保存成资源文件（.asset文件），和预制体，材质球，音频文件等类似，都是一种资源文件，存放在 Assets 文件夹下，创建出来的实例也是唯一存在的</li><li>详细链接：<a href="https://blog.csdn.net/qq_46044366/article/details/124310241?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-124310241-blog-99649941.235%5Ev27%5Epc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-124310241-blog-99649941.235%5Ev27%5Epc_relevant_3mothn_strategy_recovery&utm_relevant_index=2">Unity进阶：ScriptableObject使用指南</a></li></ul><p>背包系统详细实现链接：<a href="https://blog.csdn.net/qq_42896549/article/details/105033887">背包系统制作</a></p><h1 id="背包功能实现"><a href="#背包功能实现" class="headerlink" title="背包功能实现"></a>背包功能实现</h1><p>核心代码和想法：<br><br>两个ScriptableObject: 分别代表物品和背包<br><br>Item.cs 物品</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">CreateAssetMenu(fileName =<span class="hljs-string">&quot;New Item&quot;</span>,menuName =<span class="hljs-string">&quot;Inventory/New Item&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Item</span> : <span class="hljs-title">ScriptableObject</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> itemName;  <span class="hljs-comment">//物品名称</span><br>    <span class="hljs-keyword">public</span> Sprite itemImage;    <span class="hljs-comment">//物品图片</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> itemHeld;    <span class="hljs-comment">//物品数量</span><br>    [<span class="hljs-meta">TextArea</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> itemInfo; <span class="hljs-comment">//物品信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> equip;  <span class="hljs-comment">//物品是否可装备</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>Inventory.cs 背包</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">CreateAssetMenu(fileName =<span class="hljs-string">&quot;New Inventory&quot;</span>,menuName =<span class="hljs-string">&quot;Inventory/New Inventory&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Inventory</span> : <span class="hljs-title">ScriptableObject</span><br>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;Item&gt; itemList=<span class="hljs-keyword">new</span> List&lt;Item&gt;(); <span class="hljs-comment">//存放物品</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>让我们按照事件触发的逻辑走起。<br><br>首先我们是要碰撞到世界中的一个物体，然后会调用背包管理脚本添加物品。<br></p><p>那么世界中的物体需要脚本来控制，在触发碰撞且碰撞对象为玩家（Player）时就要调用背包管理脚本添加物品，同时销毁自己。<br><br>当前物体在挂载脚本之后需要绑定两个object：Item和Inventory，表示是哪种类型的物体，该放在哪一个背包中。<br><br>让我们来看代码实现吧：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ItemOnWorld</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Item thisItem;<br>    <span class="hljs-keyword">public</span> Inventory playerInventory;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter2D</span>(<span class="hljs-params">Collider2D other</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(other.gameObject.CompareTag(<span class="hljs-string">&quot;Player&quot;</span>))<br>        &#123;<br>            AddNewItem();<br>            Destroy(gameObject);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddNewItem</span>()</span>&#123;<br>        <span class="hljs-comment">//判断是否在列表中，在 先加1</span><br>        <span class="hljs-keyword">if</span>(!playerInventory.itemList.Contains(thisItem))&#123;<br>            <span class="hljs-comment">// playerInventory.itemList.Add(thisItem);</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;playerInventory.itemList.Count;i++)&#123;<br>                <span class="hljs-keyword">if</span>(playerInventory.itemList[i]==<span class="hljs-literal">null</span>)&#123;<br>                    playerInventory.itemList[i]=thisItem;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            thisItem.itemHeld+=<span class="hljs-number">1</span>;<br>        &#125;<br>        InventoryManger.RefreshItem();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>先修改背包的数据，然后调用RefreshItem重新生成每一个背包槽</p><p>在一开始游戏初始化的时候，我们需要预先生成一些空槽位来填充grid panel，方便之后实现拖拽功能。空槽位的大小需要我们预先在Inventory对象中定义。修改myBag的itemList大小即可。<br><br>InventoryManger.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> TMPro;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InventoryManger</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">static</span> InventoryManger instance;<br>    <span class="hljs-keyword">public</span> Inventory myBag;<br>    <span class="hljs-keyword">public</span> GameObject slotGrid;<br>    <span class="hljs-comment">// public Slot slotPrefab;</span><br>    <span class="hljs-keyword">public</span> GameObject emptySlot;<br>    <span class="hljs-keyword">public</span> TMP_Text itemInformation;<br>    <span class="hljs-keyword">public</span> List&lt;GameObject&gt; slots=<span class="hljs-keyword">new</span> List&lt;GameObject&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">null</span>)<br>            Destroy(<span class="hljs-keyword">this</span>);<br>        instance = <span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span><br>    &#123;<br>        RefreshItem();<br>        itemInformation.text = <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateItemInformation</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> itemDescription</span>)</span><br>    &#123;<br>        instance.itemInformation.text = itemDescription;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RefreshItem</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; instance.slotGrid.transform.childCount; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (instance.slotGrid.transform.childCount == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            Destroy(instance.slotGrid.transform.GetChild(i).gameObject);<br>            instance.slots.Clear();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; instance.myBag.itemList.Count; i++)<br>        &#123;<br>            instance.slots.Add(Instantiate(instance.emptySlot));<br>            instance.slots[i].transform.SetParent(instance.slotGrid.transform);<br>            instance.slots[i].GetComponent&lt;Slot&gt;().slotID=i;<br>            instance.slots[i].GetComponent&lt;Slot&gt;().SetupSlot(instance.myBag.itemList[i]);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到这个背包管理脚本的核心就是控制销毁或实例化slot物体。<br>slot是什么呢？<br><br>Slot本身不再承载装备的素材图片，仅呈现出背包栏背景图片样式，实际的图片以及数字由Slot下的相关子物体承载。这样在没有物品时，只需将子物体的active属性设置为false即可正常显示背包栏背景，而对于物品的移动和交换，只需要将两个Slot下的子物体交换即可。<br><br>Slot.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.UI;<br><span class="hljs-keyword">using</span> TMPro;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Slot</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> slotID; <span class="hljs-comment">//空格ID=物体ID</span><br>    <span class="hljs-keyword">public</span> Item slotItem;<br>    <span class="hljs-keyword">public</span> Image slotImage;<br>    <span class="hljs-keyword">public</span> TMP_Text slotNum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> slotInfo;<br>    <span class="hljs-keyword">public</span> GameObject itemInSlot;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ItemOnClicked</span>()</span><br>    &#123;<br>        InventoryManger.UpdateItemInformation(slotInfo);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetupSlot</span>(<span class="hljs-params">Item item</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(item==<span class="hljs-literal">null</span>)&#123;<br>            itemInSlot.SetActive(<span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            slotImage.sprite=item.itemImage;<br>            slotNum.text=item.itemHeld.ToString();<br>            slotInfo=item.itemInfo;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里的绑定关系如图所示:</p><!-- ![](Unity实现简易背包系统/slot.png) --><p><img src="/2023/03/25/Unity%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F/slot.png"><br>当调用SetupSlot的时候就会显示当前类型物品的图片和数量，并更新描述信息。<br></p><p>实现拖拽功能，主要靠交换slot下的item来实现，因此需要创建ItemOnDrag脚本并赋给item对象。<br><br>注意点：</p><ol><li>拖拽的时候解除item和slot的父子关系，但是此时它还是位于Gird布局下，因此会“溢出”，所以要给item添加组件，忽略布局<img src="/2023/03/25/Unity%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F/ingorelayout.png"></li><li>如何判读拖拽后的位置可以放物体进去。使用UI射线检测，为了避免item挡住检测，要给它添加CanvasGroup组件，通过设置blocksRaycasts来控制是否阻止射线检测。</li><li>如果只是交换item的位置并不能实际改变数据，下次调用RefreshItem()又会重置会原来的样子，所以需要实际交换背包的itemList对应的内容才行。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.EventSystems;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ItemOnDrag</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IBeginDragHandler</span>, <span class="hljs-title">IDragHandler</span>, <span class="hljs-title">IEndDragHandler</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Transform originalParent;<br>    <span class="hljs-keyword">public</span> Inventory myBag;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> currentItemID; <span class="hljs-comment">//当前物品ID</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnBeginDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span><br>    &#123;<br>        originalParent=transform.parent;<br>        currentItemID=originalParent.GetComponent&lt;Slot&gt;().slotID;<br>        transform.SetParent(transform.parent.parent);<br>        transform.position=eventData.position;<br>        GetComponent&lt;CanvasGroup&gt;().blocksRaycasts=<span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span><br>    &#123;<br>        transform.position=eventData.position;<br>        Debug.Log(eventData.pointerCurrentRaycast.gameObject.name);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEndDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(eventData.pointerCurrentRaycast.gameObject!=<span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">if</span>(eventData.pointerCurrentRaycast.gameObject.name==<span class="hljs-string">&quot;ItemImage&quot;</span>)&#123;<br>                transform.SetParent(eventData.pointerCurrentRaycast.gameObject.transform.parent.parent);<br>                transform.position=eventData.pointerCurrentRaycast.gameObject.transform.parent.parent.position;<br><br>                <span class="hljs-comment">//实际数据改变</span><br>                <span class="hljs-keyword">var</span> tmp=myBag.itemList[currentItemID];<br>                myBag.itemList[currentItemID]=myBag.itemList[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID];<br>                myBag.itemList[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID]=tmp;<br><br><br>                eventData.pointerCurrentRaycast.gameObject.transform.parent.position=originalParent.position;<br>                eventData.pointerCurrentRaycast.gameObject.transform.parent.SetParent(originalParent);<br>                GetComponent&lt;CanvasGroup&gt;().blocksRaycasts=<span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(eventData.pointerCurrentRaycast.gameObject.name==<span class="hljs-string">&quot;slot(Clone)&quot;</span>)<br>            &#123;<br>                transform.SetParent(eventData.pointerCurrentRaycast.gameObject.transform);<br>                transform.position=eventData.pointerCurrentRaycast.gameObject.transform.position;<br>                myBag.itemList[eventData.pointerCurrentRaycast.gameObject.GetComponentInParent&lt;Slot&gt;().slotID]=myBag.itemList[currentItemID];<br>                <span class="hljs-keyword">if</span>(eventData.pointerCurrentRaycast.gameObject.GetComponent&lt;Slot&gt;().slotID!=currentItemID)<br>                    myBag.itemList[currentItemID]=<span class="hljs-literal">null</span>;<br>                GetComponent&lt;CanvasGroup&gt;().blocksRaycasts=<span class="hljs-literal">true</span>;    <br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        <span class="hljs-comment">//其他任何位置都归位</span><br>        transform.SetParent(originalParent);<br>        transform.position=originalParent.position;<br>        GetComponent&lt;CanvasGroup&gt;().blocksRaycasts=<span class="hljs-literal">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="移动背包"><a href="#移动背包" class="headerlink" title="移动背包"></a>移动背包</h1><p>最后需要做是移动背包整体界面的功能，通过在一个简单的脚本实现</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.EventSystems;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MoveBag</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IDragHandler</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Canvas canvas;<br>    RectTransform currentRect;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span><br>    &#123;<br>        currentRect = GetComponent&lt;RectTransform&gt;();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span><br>    &#123;<br>        currentRect.anchoredPosition+=eventData.delta;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="保存背包数据到本地，下次加载"><a href="#保存背包数据到本地，下次加载" class="headerlink" title="保存背包数据到本地，下次加载"></a>保存背包数据到本地，下次加载</h1><p>在场景中新建空物体，挂载GameSaveManger脚本，绑定想保存的背包</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">using</span> System.Runtime.Serialization.Formatters.Binary;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameSaveManger</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Inventory myInventory;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SaveGame</span>()</span>&#123;<br>        <span class="hljs-keyword">if</span>(!Directory.Exists(Application.persistentDataPath+<span class="hljs-string">&quot;/game_SaveData&quot;</span>))&#123;&#125;<br>            Directory.CreateDirectory(Application.persistentDataPath+<span class="hljs-string">&quot;/game_SaveData&quot;</span>);<br>        BinaryFormatter formatter=<span class="hljs-keyword">new</span> BinaryFormatter(); <span class="hljs-comment">//二进制转换</span><br>        FileStream file=File.Create(Application.persistentDataPath+<span class="hljs-string">&quot;/game_SaveData/inventory.txt&quot;</span>);<br>        <span class="hljs-keyword">var</span> json=JsonUtility.ToJson(myInventory);<br>        formatter.Serialize(file,json);<br>        file.Close();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadGame</span>()</span>&#123;<br>        BinaryFormatter binaryFormatter=<span class="hljs-keyword">new</span> BinaryFormatter();<br>        <span class="hljs-keyword">if</span>(File.Exists(Application.persistentDataPath+<span class="hljs-string">&quot;/game_SaveData/inventory.txt&quot;</span>))&#123;<br>            FileStream file=File.Open(Application.persistentDataPath+<span class="hljs-string">&quot;/game_SaveData/inventory.txt&quot;</span>,FileMode.Open);<br>            JsonUtility.FromJsonOverwrite((<span class="hljs-built_in">string</span>)binaryFormatter.Deserialize(file),myInventory);<br>            file.Close();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chatglm_with_vits本地部署</title>
      <link href="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>实现前端live2D交互对话，后端chatglm提供语言生成，vits模型onnx导出版实现文字转语音<br><br>项目地址：<a href="https://github.com/shanhainanhua/vits_with_chatgpt-gpt3">vits_with_chatgpt-gpt3</a></p><span id="more"></span><h1 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h1><h2 id="下载项目及相关模型"><a href="#下载项目及相关模型" class="headerlink" title="下载项目及相关模型"></a>下载项目及相关模型</h2><ol><li>首先从github仓库下载项目到本地，然后打开moe文件夹</li><li>下载语音模型<a href="https://huggingface.co/Mahiruoshi/vits_onnx_model/tree/main">vits_onnx_model</a>到moe文件夹中</li><li>下载开源<a href="https://github.com/THUDM/ChatGLM-6B">ChatGLM-6B模型</a>，注意下载完整的模型，然后之后会使用INT4量化等级来加载模型，最低GPU显存要求为6G。如果下载过慢可以在<a href="https://cloud.tsinghua.edu.cn/d/fb9f16d6dc8f482596c2/">这里</a>下载</li></ol><h2 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h2><ol><li>下载FFmpeg，按照<a href="https://zhuanlan.zhihu.com/p/572201206">教程</a>安装</li><li>确保cmake路径添加到系统变量中，比如用的vs2022下自带cmke<!-- ![](chatglm-with-vits本地部署/cmake.png) --><img src="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/cmake.png"></li><li>安装pyopenjtalk<!-- ![](chatglm-with-vits本地部署/pyopenjdk.png) --><img src="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/pyopenjdk.png"></li><li>项目运行需要gcc和openmp，因此需要安装TDM-GCC，这里按照网上教程按照并添加路径即可，初次安装点击create没有openmp选项，需要安装后再次运行exe文件，选择mange，双击目前安装的路径进行管理，额外安装<!-- ![](chatglm-with-vits本地部署/mange.png)![](chatglm-with-vits本地部署/mange2.png)![](chatglm-with-vits本地部署/mange3.png) --><img src="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/mange.png"><br><img src="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/mange2.png"><br><img src="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/mange3.png"></li><li>新建conda环境，python3.9，3.10都可以，然后安装符合自己电脑版本的torch-gpu</li><li>安装其他需要的包</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">aiofiles</span>==<span class="hljs-number">23</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">aiohttp</span>==<span class="hljs-number">3</span>.<span class="hljs-number">8</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">aiosignal</span>==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">altair</span>==<span class="hljs-number">4</span>.<span class="hljs-number">2</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">anyio</span>==<span class="hljs-number">3</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">appdirs</span>==<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">async</span>-timeout==<span class="hljs-number">4</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">attrs</span>==<span class="hljs-number">22</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">audioread</span>==<span class="hljs-number">3</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">certifi</span>==<span class="hljs-number">2022</span>.<span class="hljs-number">12</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">cffi</span>==<span class="hljs-number">1</span>.<span class="hljs-number">15</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">charset</span>-normalizer==<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">click</span>==<span class="hljs-number">8</span>.<span class="hljs-number">1</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">cn2an</span>==<span class="hljs-number">0</span>.<span class="hljs-number">5</span>.<span class="hljs-number">19</span><br><span class="hljs-attribute">colorama</span>==<span class="hljs-number">0</span>.<span class="hljs-number">4</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">coloredlogs</span>==<span class="hljs-number">15</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">contourpy</span>==<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">cpm</span>-kernels==<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">11</span><br><span class="hljs-attribute">cycler</span>==<span class="hljs-number">0</span>.<span class="hljs-number">11</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">Cython</span>==<span class="hljs-number">0</span>.<span class="hljs-number">29</span>.<span class="hljs-number">33</span><br><span class="hljs-attribute">decorator</span>==<span class="hljs-number">5</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">eng</span>-to-ipa==<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">entrypoints</span>==<span class="hljs-number">0</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">fastapi</span>==<span class="hljs-number">0</span>.<span class="hljs-number">95</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">ffmpy</span>==<span class="hljs-number">0</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">filelock</span>==<span class="hljs-number">3</span>.<span class="hljs-number">10</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">Flask</span>==<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">flatbuffers</span>==<span class="hljs-number">23</span>.<span class="hljs-number">3</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">fonttools</span>==<span class="hljs-number">4</span>.<span class="hljs-number">39</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">frozenlist</span>==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">fsspec</span>==<span class="hljs-number">2023</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">gradio</span>==<span class="hljs-number">3</span>.<span class="hljs-number">23</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">h11</span>==<span class="hljs-number">0</span>.<span class="hljs-number">14</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">httpcore</span>==<span class="hljs-number">0</span>.<span class="hljs-number">16</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">httpx</span>==<span class="hljs-number">0</span>.<span class="hljs-number">23</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">huggingface</span>-hub==<span class="hljs-number">0</span>.<span class="hljs-number">13</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">humanfriendly</span>==<span class="hljs-number">10</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">icetk</span>==<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">idna</span>==<span class="hljs-number">3</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">importlib</span>-metadata==<span class="hljs-number">6</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">importlib</span>-resources==<span class="hljs-number">5</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">inflect</span>==<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">itsdangerous</span>==<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">jamo</span>==<span class="hljs-number">0</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">jieba</span>==<span class="hljs-number">0</span>.<span class="hljs-number">42</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Jinja2</span>==<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">joblib</span>==<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">jsonschema</span>==<span class="hljs-number">4</span>.<span class="hljs-number">17</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">kiwisolver</span>==<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">lazy_loader</span>==<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">librosa</span>==<span class="hljs-number">0</span>.<span class="hljs-number">10</span>.<span class="hljs-number">0</span>.post2<br><span class="hljs-attribute">linkify</span>-it-py==<span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">llvmlite</span>==<span class="hljs-number">0</span>.<span class="hljs-number">39</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">markdown</span>-it-py==<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">MarkupSafe</span>==<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">matplotlib</span>==<span class="hljs-number">3</span>.<span class="hljs-number">7</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">mdit</span>-py-plugins==<span class="hljs-number">0</span>.<span class="hljs-number">3</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">mdurl</span>==<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">mpmath</span>==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">msgpack</span>==<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">multidict</span>==<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">networkx</span>==<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">numba</span>==<span class="hljs-number">0</span>.<span class="hljs-number">56</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">numpy</span>==<span class="hljs-number">1</span>.<span class="hljs-number">23</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">onnxruntime</span>==<span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">openai</span>==<span class="hljs-number">0</span>.<span class="hljs-number">27</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">orjson</span>==<span class="hljs-number">3</span>.<span class="hljs-number">8</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">packaging</span>==<span class="hljs-number">23</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">pandas</span>==<span class="hljs-number">1</span>.<span class="hljs-number">5</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">Pillow</span>==<span class="hljs-number">9</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">pooch</span>==<span class="hljs-number">1</span>.<span class="hljs-number">6</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">proces</span>==<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">protobuf</span>==<span class="hljs-number">3</span>.<span class="hljs-number">18</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">pycparser</span>==<span class="hljs-number">2</span>.<span class="hljs-number">21</span><br><span class="hljs-attribute">pydantic</span>==<span class="hljs-number">1</span>.<span class="hljs-number">10</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">pydub</span>==<span class="hljs-number">0</span>.<span class="hljs-number">25</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">pyopenjtalk</span>==<span class="hljs-number">0</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">pyparsing</span>==<span class="hljs-number">3</span>.<span class="hljs-number">0</span>.<span class="hljs-number">9</span><br><span class="hljs-attribute">pypinyin</span>==<span class="hljs-number">0</span>.<span class="hljs-number">48</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">pyreadline3</span>==<span class="hljs-number">3</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">pyrsistent</span>==<span class="hljs-number">0</span>.<span class="hljs-number">19</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">python</span>-dateutil==<span class="hljs-number">2</span>.<span class="hljs-number">8</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">python</span>-multipart==<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">pytz</span>==<span class="hljs-number">2022</span>.<span class="hljs-number">7</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">PyYAML</span>==<span class="hljs-number">6</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">regex</span>==<span class="hljs-number">2023</span>.<span class="hljs-number">3</span>.<span class="hljs-number">22</span><br><span class="hljs-attribute">requests</span>==<span class="hljs-number">2</span>.<span class="hljs-number">28</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">rfc3986</span>==<span class="hljs-number">1</span>.<span class="hljs-number">5</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">scikit</span>-learn==<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">scipy</span>==<span class="hljs-number">1</span>.<span class="hljs-number">10</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">semantic</span>-version==<span class="hljs-number">2</span>.<span class="hljs-number">10</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">sentencepiece</span>==<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">97</span><br><span class="hljs-attribute">six</span>==<span class="hljs-number">1</span>.<span class="hljs-number">16</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">sniffio</span>==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">soundfile</span>==<span class="hljs-number">0</span>.<span class="hljs-number">12</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">soxr</span>==<span class="hljs-number">0</span>.<span class="hljs-number">3</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">starlette</span>==<span class="hljs-number">0</span>.<span class="hljs-number">26</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">sympy</span>==<span class="hljs-number">1</span>.<span class="hljs-number">11</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">threadpoolctl</span>==<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">tokenizers</span>==<span class="hljs-number">0</span>.<span class="hljs-number">13</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">toolz</span>==<span class="hljs-number">0</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">torch</span>==<span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>+cu117<br><span class="hljs-attribute">torchaudio</span>==<span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>+cu117<br><span class="hljs-attribute">torchvision</span>==<span class="hljs-number">0</span>.<span class="hljs-number">15</span>.<span class="hljs-number">1</span>+cu117<br><span class="hljs-attribute">tqdm</span>==<span class="hljs-number">4</span>.<span class="hljs-number">65</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">transformers</span>==<span class="hljs-number">4</span>.<span class="hljs-number">26</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">typing_extensions</span>==<span class="hljs-number">4</span>.<span class="hljs-number">5</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">uc</span>-micro-py==<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Unidecode</span>==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">urllib3</span>==<span class="hljs-number">1</span>.<span class="hljs-number">26</span>.<span class="hljs-number">15</span><br><span class="hljs-attribute">uvicorn</span>==<span class="hljs-number">0</span>.<span class="hljs-number">21</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">websockets</span>==<span class="hljs-number">10</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">Werkzeug</span>==<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">yarl</span>==<span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">zipp</span>==<span class="hljs-number">3</span>.<span class="hljs-number">15</span>.<span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><p>可以复制进txt文件中批量安装，但是实际我用原项目中的requirement.txt的时候会出现错误，无法批量安装，手动安装后无问题。所以这里可以试试我的行不行，不行的话可以手动安装主要的包。记得transformers&#x3D;&#x3D;4.26.1,版本过过低都有可能出错。<br></p><ol start="7"><li>激活环境运行localchat.py<!-- ![](chatglm-with-vits本地部署/run1.png) --><img src="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/run1.png"><br>前面步骤没有问题的话，就可以运行文件，这里加载模型等待的时间会有些长<br><br>成功后，服务就运行在相应端口了。<!-- ![](chatglm-with-vits本地部署/run2.png) --><img src="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/run2.png"></li></ol><h2 id="部署前端"><a href="#部署前端" class="headerlink" title="部署前端"></a>部署前端</h2><p>下载<a href="https://github.com/Arkueid/Live2DMascot">Live2D项目</a><br>解压后，进入项目的x86文件夹下，修改config.json文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;ChatAPI&quot;</span> : <br>&#123;<br><span class="hljs-string">&quot;ChatSavePath&quot;</span> : <span class="hljs-string">&quot;chat&quot;</span>,  <span class="hljs-regexp">//</span>聊天音频和文本保存路径<br><span class="hljs-string">&quot;CustomChatServer&quot;</span> : <br>&#123;<br>        <span class="hljs-regexp">//</span>服务器地址，端口默认<span class="hljs-number">8080</span> 本地部署就是<span class="hljs-string">&quot;http://127.0.0.1:8080&quot;</span><br><span class="hljs-string">&quot;HostPort&quot;</span> : <span class="hljs-string">&quot;http://yourhost:8080&quot;</span>,  <br><span class="hljs-string">&quot;On&quot;</span> : true,  <span class="hljs-regexp">//</span>开启自定义聊天接口<br><span class="hljs-string">&quot;ReadTimeOut&quot;</span> : <span class="hljs-number">114</span>,  <span class="hljs-regexp">//</span>等待响应时间(s)<br><span class="hljs-string">&quot;Route&quot;</span> : <span class="hljs-string">&quot;/chat&quot;</span>  <span class="hljs-regexp">//</span>路径<br>&#125;,<br></code></pre></td></tr></table></figure><!-- ![](chatglm-with-vits本地部署/live2d.png) --><p><img src="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/live2d.png"></p><p>双击Live2D-x86.exe启动程序，然后桌面上就会显示人物了，通过任务栏中程序图标右击可以更改程序设置。</p><!-- ![](chatglm-with-vits本地部署/renwu.png) --><p><img src="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/renwu.png"></p><p>如何对话？<br>鼠标右键双击人物，会出现对话框，输入文字后回车等待回应即可。</p><!-- ![](chatglm-with-vits本地部署/renwu2.png) --><p><img src="/2023/03/23/chatglm-with-vits%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/renwu2.png"></p>]]></content>
      
      
      <categories>
          
          <category> chatgpt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chatgpt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ai绘画本地部署使用</title>
      <link href="/2023/03/23/Ai%E7%BB%98%E7%94%BB%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/03/23/Ai%E7%BB%98%E7%94%BB%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>本篇主要介绍stable_diffsion的本地部署过程以及有哪些坑。</p><span id="more"></span><p>AI部署参考的主要教程是<a href="https://space.bilibili.com/12566101?spm_id_from=333.337.0.0">B站秋葉aaaki</a><br><br>下载他的最终版整合包，然后自己配置环境，没有使用启动器<br><br>首先anaconda创建一个新的环境（推荐创建新的，免去包冲突的问题）<br></p><p><img src="/2023/03/23/Ai%E7%BB%98%E7%94%BB%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8/1.png"></p><p>然后进入解压后的项目目录下，激活创建的环境，使用pip命令安装依赖包</p><p><img src="/2023/03/23/Ai%E7%BB%98%E7%94%BB%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8/2.png"><br>注意：这里的requirements.txt文件可能会有冲突，因此我导出了我配置好环境的依赖文件，复制进去替换掉原来的内容，torch的版本需要根据自己显卡环境调整</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">absl</span>-py==<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">accelerate</span>==<span class="hljs-number">0</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">addict</span>==<span class="hljs-number">2</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">aenum</span>==<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">11</span><br><span class="hljs-attribute">aiofiles</span>==<span class="hljs-number">23</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">aiohttp</span>==<span class="hljs-number">3</span>.<span class="hljs-number">8</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">aiosignal</span>==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">altair</span>==<span class="hljs-number">4</span>.<span class="hljs-number">2</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">antlr4</span>-python3-runtime==<span class="hljs-number">4</span>.<span class="hljs-number">9</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">anyio</span>==<span class="hljs-number">3</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">async</span>-timeout==<span class="hljs-number">4</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">attrs</span>==<span class="hljs-number">22</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">basicsr</span>==<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">beautifulsoup4</span>==<span class="hljs-number">4</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">blendmodes</span>==<span class="hljs-number">2022</span><br><span class="hljs-attribute">boltons</span>==<span class="hljs-number">23</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">cachetools</span>==<span class="hljs-number">5</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">certifi</span>==<span class="hljs-number">2022</span>.<span class="hljs-number">12</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">chardet</span>==<span class="hljs-number">4</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">charset</span>-normalizer==<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">clean</span>-fid==<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">29</span><br><span class="hljs-attribute">click</span>==<span class="hljs-number">8</span>.<span class="hljs-number">1</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">clip</span> @ git+https://github.com/openai/clip.git@a9b1bf5920416aaeaec965c25dd9e8f98c864f16<br><span class="hljs-attribute">colorama</span>==<span class="hljs-number">0</span>.<span class="hljs-number">4</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">coloredlogs</span>==<span class="hljs-number">15</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">contourpy</span>==<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">cssselect2</span>==<span class="hljs-number">0</span>.<span class="hljs-number">7</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">cycler</span>==<span class="hljs-number">0</span>.<span class="hljs-number">11</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">deprecation</span>==<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">docopt</span>==<span class="hljs-number">0</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">einops</span>==<span class="hljs-number">0</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">entrypoints</span>==<span class="hljs-number">0</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">facexlib</span>==<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">fastapi</span>==<span class="hljs-number">0</span>.<span class="hljs-number">90</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">ffmpy</span>==<span class="hljs-number">0</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">filelock</span>==<span class="hljs-number">3</span>.<span class="hljs-number">10</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">filterpy</span>==<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">flatbuffers</span>==<span class="hljs-number">23</span>.<span class="hljs-number">3</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">font</span>-roboto==<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">fonts</span>==<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">fonttools</span>==<span class="hljs-number">4</span>.<span class="hljs-number">39</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">frozenlist</span>==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">fsspec</span>==<span class="hljs-number">2023</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">ftfy</span>==<span class="hljs-number">6</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">future</span>==<span class="hljs-number">0</span>.<span class="hljs-number">18</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">gdown</span>==<span class="hljs-number">4</span>.<span class="hljs-number">6</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">gfpgan</span>==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">gitdb</span>==<span class="hljs-number">4</span>.<span class="hljs-number">0</span>.<span class="hljs-number">10</span><br><span class="hljs-attribute">GitPython</span>==<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">27</span><br><span class="hljs-attribute">google</span>-auth==<span class="hljs-number">2</span>.<span class="hljs-number">16</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">google</span>-auth-oauthlib==<span class="hljs-number">0</span>.<span class="hljs-number">4</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">gradio</span>==<span class="hljs-number">3</span>.<span class="hljs-number">16</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">grpcio</span>==<span class="hljs-number">1</span>.<span class="hljs-number">51</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">h11</span>==<span class="hljs-number">0</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">httpcore</span>==<span class="hljs-number">0</span>.<span class="hljs-number">15</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">httpx</span>==<span class="hljs-number">0</span>.<span class="hljs-number">23</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">huggingface</span>-hub==<span class="hljs-number">0</span>.<span class="hljs-number">13</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">humanfriendly</span>==<span class="hljs-number">10</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">idna</span>==<span class="hljs-number">2</span>.<span class="hljs-number">10</span><br><span class="hljs-attribute">imageio</span>==<span class="hljs-number">2</span>.<span class="hljs-number">26</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">inflection</span>==<span class="hljs-number">0</span>.<span class="hljs-number">5</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">invisible</span>-watermark==<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">Jinja2</span>==<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">jsonmerge</span>==<span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">jsonschema</span>==<span class="hljs-number">4</span>.<span class="hljs-number">17</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">kiwisolver</span>==<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">kornia</span>==<span class="hljs-number">0</span>.<span class="hljs-number">6</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">lark</span>==<span class="hljs-number">1</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">lazy_loader</span>==<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">linkify</span>-it-py==<span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">llvmlite</span>==<span class="hljs-number">0</span>.<span class="hljs-number">39</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">lmdb</span>==<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">lpips</span>==<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">lxml</span>==<span class="hljs-number">4</span>.<span class="hljs-number">9</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">Markdown</span>==<span class="hljs-number">3</span>.<span class="hljs-number">4</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">markdown</span>-it-py==<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">MarkupSafe</span>==<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">matplotlib</span>==<span class="hljs-number">3</span>.<span class="hljs-number">7</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">mdit</span>-py-plugins==<span class="hljs-number">0</span>.<span class="hljs-number">3</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">mdurl</span>==<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">mpmath</span>==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">multidict</span>==<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">networkx</span>==<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">numba</span>==<span class="hljs-number">0</span>.<span class="hljs-number">56</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">numpy</span>==<span class="hljs-number">1</span>.<span class="hljs-number">23</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">oauthlib</span>==<span class="hljs-number">3</span>.<span class="hljs-number">2</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">omegaconf</span>==<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">onnx</span>==<span class="hljs-number">1</span>.<span class="hljs-number">13</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">onnxruntime</span>==<span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">open</span>-clip-torch @ git+https://gitee.com/ufhy/open_clip.git@bb6e834e9c70d9c27d0dc3ecedeebeaeb1ffad6b<br><span class="hljs-attribute">opencv</span>-contrib-python==<span class="hljs-number">4.7.0.72</span><br><span class="hljs-attribute">opencv</span>-python==<span class="hljs-number">4.7.0.72</span><br><span class="hljs-attribute">orjson</span>==<span class="hljs-number">3</span>.<span class="hljs-number">8</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">packaging</span>==<span class="hljs-number">23</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">pandas</span>==<span class="hljs-number">1</span>.<span class="hljs-number">5</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">piexif</span>==<span class="hljs-number">1</span>.<span class="hljs-number">1</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">Pillow</span>==<span class="hljs-number">9</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">pipreqs</span>==<span class="hljs-number">0</span>.<span class="hljs-number">4</span>.<span class="hljs-number">11</span><br><span class="hljs-attribute">protobuf</span>==<span class="hljs-number">3</span>.<span class="hljs-number">20</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">psutil</span>==<span class="hljs-number">5</span>.<span class="hljs-number">9</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">pyasn1</span>==<span class="hljs-number">0</span>.<span class="hljs-number">4</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">pyasn1</span>-modules==<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">pycryptodome</span>==<span class="hljs-number">3</span>.<span class="hljs-number">17</span><br><span class="hljs-attribute">pydantic</span>==<span class="hljs-number">1</span>.<span class="hljs-number">10</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">pyDeprecate</span>==<span class="hljs-number">0</span>.<span class="hljs-number">3</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">pydub</span>==<span class="hljs-number">0</span>.<span class="hljs-number">25</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">pyparsing</span>==<span class="hljs-number">3</span>.<span class="hljs-number">0</span>.<span class="hljs-number">9</span><br><span class="hljs-attribute">pyreadline3</span>==<span class="hljs-number">3</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">pyrsistent</span>==<span class="hljs-number">0</span>.<span class="hljs-number">19</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">PySocks</span>==<span class="hljs-number">1</span>.<span class="hljs-number">7</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">python</span>-dateutil==<span class="hljs-number">2</span>.<span class="hljs-number">8</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">python</span>-multipart==<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">pytorch</span>-lightning==<span class="hljs-number">1</span>.<span class="hljs-number">7</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">pytz</span>==<span class="hljs-number">2022</span>.<span class="hljs-number">7</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">PyWavelets</span>==<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">PyYAML</span>==<span class="hljs-number">6</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">realesrgan</span>==<span class="hljs-number">0</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">regex</span>==<span class="hljs-number">2023</span>.<span class="hljs-number">3</span>.<span class="hljs-number">22</span><br><span class="hljs-attribute">reportlab</span>==<span class="hljs-number">3</span>.<span class="hljs-number">6</span>.<span class="hljs-number">12</span><br><span class="hljs-attribute">requests</span>==<span class="hljs-number">2</span>.<span class="hljs-number">25</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">requests</span>-oauthlib==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">resize</span>-right==<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">rfc3986</span>==<span class="hljs-number">1</span>.<span class="hljs-number">5</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">rsa</span>==<span class="hljs-number">4</span>.<span class="hljs-number">9</span><br><span class="hljs-attribute">safetensors</span>==<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">scikit</span>-image==<span class="hljs-number">0</span>.<span class="hljs-number">19</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">scipy</span>==<span class="hljs-number">1</span>.<span class="hljs-number">10</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">sentencepiece</span>==<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">97</span><br><span class="hljs-attribute">six</span>==<span class="hljs-number">1</span>.<span class="hljs-number">16</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">smmap</span>==<span class="hljs-number">5</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">sniffio</span>==<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">soupsieve</span>==<span class="hljs-number">2</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">starlette</span>==<span class="hljs-number">0</span>.<span class="hljs-number">23</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">svglib</span>==<span class="hljs-number">1</span>.<span class="hljs-number">5</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">sympy</span>==<span class="hljs-number">1</span>.<span class="hljs-number">11</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">tb</span>-nightly==<span class="hljs-number">2</span>.<span class="hljs-number">13</span>.<span class="hljs-number">0</span>a20230317<br><span class="hljs-attribute">tensorboard</span>==<span class="hljs-number">2</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">tensorboard</span>-data-server==<span class="hljs-number">0</span>.<span class="hljs-number">7</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">tensorboard</span>-plugin-wit==<span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">tifffile</span>==<span class="hljs-number">2023</span>.<span class="hljs-number">3</span>.<span class="hljs-number">21</span><br><span class="hljs-attribute">timm</span>==<span class="hljs-number">0</span>.<span class="hljs-number">6</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">tinycss2</span>==<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">tokenizers</span>==<span class="hljs-number">0</span>.<span class="hljs-number">13</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">toolz</span>==<span class="hljs-number">0</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">torch</span>==<span class="hljs-number">1</span>.<span class="hljs-number">13</span>.<span class="hljs-number">1</span>+cu117<br><span class="hljs-attribute">torchaudio</span>==<span class="hljs-number">0</span>.<span class="hljs-number">13</span>.<span class="hljs-number">1</span>+cu117<br><span class="hljs-attribute">torchdiffeq</span>==<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">torchmetrics</span>==<span class="hljs-number">0</span>.<span class="hljs-number">11</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">torchsde</span>==<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">torchvision</span>==<span class="hljs-number">0</span>.<span class="hljs-number">14</span>.<span class="hljs-number">1</span>+cu117<br><span class="hljs-attribute">tqdm</span>==<span class="hljs-number">4</span>.<span class="hljs-number">65</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">trampoline</span>==<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">transformers</span>==<span class="hljs-number">4</span>.<span class="hljs-number">25</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">typing_extensions</span>==<span class="hljs-number">4</span>.<span class="hljs-number">5</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">uc</span>-micro-py==<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">urllib3</span>==<span class="hljs-number">1</span>.<span class="hljs-number">26</span>.<span class="hljs-number">15</span><br><span class="hljs-attribute">uvicorn</span>==<span class="hljs-number">0</span>.<span class="hljs-number">21</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">wcwidth</span>==<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">webencodings</span>==<span class="hljs-number">0</span>.<span class="hljs-number">5</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">websockets</span>==<span class="hljs-number">10</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">Werkzeug</span>==<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">yapf</span>==<span class="hljs-number">0</span>.<span class="hljs-number">32</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">yarg</span>==<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">9</span><br><span class="hljs-attribute">yarl</span>==<span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>在配置好环境后需要启动launch.py文件</p><p><img src="/2023/03/23/Ai%E7%BB%98%E7%94%BB%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8/3.png"></p><p>启动时还可以配置参数：如python launch.py –no-half –no-half-vae –disable-nan-check</p><p>具体说明可以参见up主的教程和其他资料</p><p>下面是几张生成图的示例：</p><p>positive tags:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">(((masterpiece))),<span class="hljs-keyword">best </span>quality, illustration,(<span class="hljs-keyword">beautiful </span>detailed girl),<span class="hljs-keyword">beautiful </span>detailed glow,detailed ice,<span class="hljs-keyword">beautiful </span>detailed water,(<span class="hljs-keyword">beautiful </span>detailed eyes),expressionless,(floating palaces),azure hair,<span class="hljs-keyword">disheveled </span>hair,long <span class="hljs-keyword">bangs, </span>hairs <span class="hljs-keyword">between </span>eyes,(skyblue dress),<span class="hljs-keyword">black </span>ribbon,white <span class="hljs-keyword">bowties,midriff,&#123;&#123;&#123;half </span><span class="hljs-keyword">closed </span>eyes&#125;&#125;&#125;,<span class="hljs-keyword">big </span>forhead,<span class="hljs-keyword">blank </span>stare,flower,large top sleeves<br></code></pre></td></tr></table></figure><p>negative tags:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">owres,<span class="hljs-keyword">bad </span>anatomy,<span class="hljs-keyword">bad </span>hands,text,error,missing fingers,<span class="hljs-keyword">extra </span><span class="hljs-keyword">digit,fewer </span><span class="hljs-keyword">digits,cropped,worst </span>quality,low quality,<span class="hljs-keyword">normal </span>quality,<span class="hljs-keyword">jpeg </span>artifacts,signature,watermark,username,<span class="hljs-keyword">blurry,missing </span>fingers,<span class="hljs-keyword">bad </span>hands,missing arms,large <span class="hljs-keyword">breasts</span><br></code></pre></td></tr></table></figure><p><img src="/2023/03/23/Ai%E7%BB%98%E7%94%BB%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8/4.png"></p><p><img src="/2023/03/23/Ai%E7%BB%98%E7%94%BB%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8/6.png"></p><p><img src="/2023/03/23/Ai%E7%BB%98%E7%94%BB%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8/i5.png"></p><p><img src="/2023/03/23/Ai%E7%BB%98%E7%94%BB%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8/7.png"></p>]]></content>
      
      
      <categories>
          
          <category> AI绘画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stable_diffusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shader基础</title>
      <link href="/2023/02/09/shader%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/02/09/shader%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>shader：着色器<br></p><ul><li>GPU流水线上一些可高度编程的阶段，而由着色器编译出来的最终代码是会在 GPU上运行的（对于固定管线的渲染来说，着色器有时等同于一些特定的渲染设置);</li><li>有一些特定类型的着色器，如顶点着色器、片元着色器等;</li><li>依靠着色器我们可以控制流水线中的渲染细节,例如用顶点着色器来进行顶点变换以及传递数据，用片元着色器来进行逐像素的渲染。</li></ul><h1 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线: "></a>渲染流水线: <br></h1><ul><li>输入是一个虚拟摄像机、一些光源、一些shader以及纹理</li><li>输出渲染一张二维纹理</li><li>分为三个阶段：<strong>应用阶段(Application Stage)<strong>、</strong>几何阶段(Geometry Stage)<strong>、</strong>光栅化阶段(Rasterizer Stage)</strong><!-- ![流水线]() --><img src="/2023/02/09/shader%E5%9F%BA%E7%A1%80/%E6%B5%81%E6%B0%B4%E7%BA%BF.png"></li></ul><p><strong>应用阶段</strong>：</p><ol><li>准备好场景数据</li><li>粗粒度剔除(culling)工作，以把那些不可见的物体剔除出去</li><li>设置好每个模型的渲染状态。<br><br><strong>输出</strong>：渲染所需的几何信息，即**渲染图元（rendering primitives)**。通俗来讲，渲染图元可以是点、线、三角面等。这些渲染图元将会被传递给下一个阶段——几何阶段。</li></ol><p>应用阶段大致可分为下面3个阶段:</p><ol><li>把数据加载到显存中。</li><li>设置渲染状态。</li><li>调用Draw Call</li></ol><p><strong>渲染状态</strong>：<br><br>定义了场景中的网格是怎样被渲染的。例如，使用哪个顶点着色器（Vertex Shader)&#x2F;片元着色器(Fragment Shader)、光源属性、材质等。如果我们没有更改渲染状态，那么所有的网格都将使用同一种渲染状态。</p><p><strong>Draw Call</strong>:<br><br>实际上，Draw Call就是一个命令，它的发起方是 CPU，接收方是GPU。这个命令仅仅会指向一个需要被渲染的图元(primitives)列表,而不会再包含任何材质信息——这是因为我们已经在上一个阶段中完成了</p><p><strong>几何阶段</strong></p><ul><li>通常在GPU上进行</li><li>几何阶段负责和每个渲染图元打交道，进行逐顶点、逐多边形的操作</li><li>几何阶段的一个重要任务就是把顶点坐标变换到屏幕空间中，再交给光栅器进行处理<br><strong>输出</strong>：屏幕空间的二维顶点坐标、每个顶点对应的深度值、着色等相关信息，并传递给下一个阶段。</li></ul><p><strong>光栅化阶段</strong></p><ul><li>GPU 上运行</li><li>光栅化的任务主要是决定每个渲染图元中的哪些像素应该被绘制在屏幕上。</li><li>它需要对上一个阶段得到的逐顶点数据（例如纹理坐标、顶点颜色等)进行插值，然后再进行逐像素处理。</li></ul><h1 id="GPU流水线"><a href="#GPU流水线" class="headerlink" title="GPU流水线"></a>GPU流水线</h1><p><img src="/2023/02/09/shader%E5%9F%BA%E7%A1%80/gpu%E6%B5%81%E6%B0%B4%E7%BA%BF.png"><br>GPU的渲染流水线实现。颜色表示了不同阶段的可配置性或可编程性:绿色表示该流水线阶段是完全可编程控制的，黄色表示该流水线阶段可以配置但不是可编程的，蓝色表示该流水线阶段是由GPU固定实现的，开发者没有任何控制权。实线表示该Shader必须由开发者编程实现，虚线表示该Shader是可选的</p>]]></content>
      
      
      
        <tags>
            
            <tag> shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习</title>
      <link href="/2021/03/12/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/03/12/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>记录相关文章链接</p><span id="more"></span><p><a href="https://blog.csdn.net/qq_34372112/article/details/100526785">强化学习系列之Policy Gradient</a></p>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>动态规划</p><span id="more"></span><h1 id="递推求解"><a href="#递推求解" class="headerlink" title="递推求解"></a>递推求解</h1><h2 id="错排公式"><a href="#错排公式" class="headerlink" title="错排公式"></a>错排公式</h2><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%94%99%E6%8E%92.png"></p><p>我们按照 n 的取值顺序将所有的错装方式数量排 列为一个数列，同样用 F[n]表示数列里第 n 个数的取值，F[n]同时代表 n 个信封 的错装方式总数，我们确定该数列的递推关系。当 n 大于 3 时，我们考虑 n 封信 全部装错的情况。将信封按顺序由 1 到 n 编号。在任意一种错装方案中，假设 n 号信封里装的是 k 号信封的信，而 n 号信封里的信则装在 m 号信封里。按照k和m的等值与否将总的错误方式分为两类。</p><p>若 k 不等于m，交换 n 号信封和m号信封的信后，n 号信封里装的恰好是对<br>应的信，而 m 号信封中错装 k 号信封里的信，即除 n 号信封外其余 n-1 个信封 全部错装，其错装方式等于 F[n - 1]，又由于m的 n-1 个可能取值，这类错装方 式总数为（n - 1）* F[n - 1]。也可以理解为，在 n-1 个信封错装的 F[n - 1]种方式 的基础上，将 n 号信封所装的信与n - 1个信封中任意一个信封（共有 n-1 中选 择）所装的信做交换后，得到所有信封全部错装的方式数。 </p><p>另一种情况，若 k 等于m，交换 n 号信封和m号信封的信后，n 号信封和m 号信封里装的恰好是对应的信，这样除它们之外剩余的 n-2 个信封全部错装，其 错装方式为 F[n - 2]，又由于m的 n-1 个取值，这类错装方式总数为（n - 1）* F[n - 2]。也可以理解为，在 n - 2 个信封全部错装的基础上，交换最后两个信封中的 信(n 号信封和 1 到 n-1 号信封中任意一个，共有 n-1 种选择)，使所有的信封全部 错装的方式数。 </p><p>综上所述，F[n] &#x3D; (n - 1) * F[n - 1] + (n - 1) * F[n - 2]。这就是有名的错排公式</p><p>主要代码</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">F<span class="hljs-comment">[1]</span>=0;<br>F<span class="hljs-comment">[2]</span>=1;<br>for(int i=3;i&lt;=20;i++)<br>    F<span class="hljs-comment">[i]</span>=(i-1)*F<span class="hljs-comment">[i-1]</span>+(i-1)*F<span class="hljs-comment">[i-2]</span>;<br>    //递推求得数列的每一个数字<br></code></pre></td></tr></table></figure><h1 id="最长递增子序列-LIS"><a href="#最长递增子序列-LIS" class="headerlink" title="最长递增子序列 LIS"></a>最长递增子序列 LIS</h1><p>原理</p><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.png"></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AF%BC%E5%BC%B9.png"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;iostream&gt;</span><br><span class="hljs-comment">#include&lt;cmath&gt;</span><br>using namespace std;<br>int dp[26];<br>int a[26];<br>int main()<br>&#123;<br>    int k;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;k&amp;&amp;k)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;=k;i++)<br>        cin&gt;&gt;a[i];<br>        <br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;=k;i++)<br>        &#123;<br>            int <span class="hljs-attribute">tmax</span>=1;<br>            <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=1;j&lt;i;j++)<br>                <span class="hljs-keyword">if</span>(a[j]&gt;=a[i])<br>                    <span class="hljs-attribute">tmax</span>=max(tmax, dp[j]+1);<br>            dp[i]=tmax; <br>        &#125;<br><br>        int <span class="hljs-attribute">ans</span>=1;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;=k;i++)<br>        &#123;<br>            <span class="hljs-attribute">ans</span>=max(ans,dp[i]);<br>        &#125;<br>        cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%90%88%E5%94%B1%E9%98%9F%E5%BD%A2.png"></p><p>思路：<br><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%80%9D%E8%B7%AF.png"></p><p>代码</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include&lt;iostream&gt;</span><br><span class="hljs-meta">#include&lt;cmath&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br><span class="hljs-type">int</span> dp1[<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> dp2[<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> a[<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> main()<br>&#123;<br>    <span class="hljs-type">int</span> N;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;N)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)<br>            cin&gt;&gt;a[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)<br>        &#123;<br>            dp1[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(a[i]&gt;a[j])<br>                    dp1[i]=max(dp1[i],dp1[j]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=N;i&gt;=<span class="hljs-number">1</span>;i<span class="hljs-comment">--)</span><br>        &#123;<br>            dp2[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=N;j&gt;i;j<span class="hljs-comment">--)</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(a[i]&gt;a[j])<br>                   dp2[i]=max(dp2[i],dp2[j]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)<br>        &#123;<br>            ans=max(ans,dp1[i]+dp2[i]);<br>        &#125;<br>        cout&lt;&lt;N-ans+<span class="hljs-number">1</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(LCS)</h1><p>有两个字符串 S1 和 S2，求一个最长公共子串，即求字符串 S3，它同时为<br>S1 和 S2 的子串，且要求它的长度最长，并确定这个长度。这个问题被我们称为 最长公共子序列问题</p><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2.png"></p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<span class="hljs-comment">//dp[i][j]  i,j代表长度为i，j的字符串</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a,b;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;a&gt;&gt;b)<br>    &#123;<br>        <span class="hljs-type">int</span> lena=a.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> lenb=b.<span class="hljs-built_in">length</span>();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=lena;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=lenb;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>||j==<span class="hljs-number">0</span>) &#123;<br>                    dp[i][j]=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(a[i<span class="hljs-number">-1</span>]==b[j<span class="hljs-number">-1</span>]) dp[i][j]=dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> dp[i][j]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]);<br>               <br>            &#125;<br>        cout&lt;&lt;dp[lena][lenb]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="动态规划问题分析举例"><a href="#动态规划问题分析举例" class="headerlink" title="动态规划问题分析举例"></a>动态规划问题分析举例</h1><h2 id="搬寝室"><a href="#搬寝室" class="headerlink" title="搬寝室"></a>搬寝室</h2><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%90%AC%E5%AF%9D%E5%AE%A4.png"><br><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%90%AC%E5%AF%9D%E5%AE%A42.png"></p><p>示例代码</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br>const int INF = 0x7fffffff; //预定义最大的int取值为无穷<br>int list<span class="hljs-comment">[2001]</span>;             //保存每个物品重量<br>int dp<span class="hljs-comment">[1001]</span><span class="hljs-comment">[2001]</span>;         //保存每个状态<br>int main()<br>&#123;<br>    int n, k;<br>    while (cin &gt;&gt; n &gt;&gt; k &amp;&amp; n &amp;&amp; k)<br>    &#123;<br>        for (int i = 1; i &lt;= n; i++)<br>            cin &gt;&gt; list<span class="hljs-comment">[i]</span>;<br>        sort(list + 1, list + 1 + n); //使所有物品按照重量递增排序<br>        for (int i = 1; i &lt;= n; i++)<br>            dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span> = 0;<br>        for (int i = 1; i &lt;= k; i++)<br>        &#123;<br>            //递推求得每个状态<br>            for (int j = 2 * i; j &lt;= n; j++)<br>            &#123;<br>                if (j &gt; 2 * i)<br>                    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span>;<br>                //j&gt;2*i表明，最后两个物品可以不配对，即前j-1件物品足够配成i对<br>                //dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>可以由dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span>转移而来，其值先被设置为dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span><br>                else<br>                    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = INF;<br>                //若j==2*i，说明最后两件物品必须配对，否则前j件物品配不成i对，<br>                //所有其状态不能由dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>转移而来，dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>先设置为正无穷<br>                if(  dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>&gt; (dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-2]</span>+(list<span class="hljs-comment">[j]</span>-list<span class="hljs-comment">[j-1]</span>)*(list<span class="hljs-comment">[j]</span>-list<span class="hljs-comment">[j-1]</span>))  )<br>                &#123;<br>                    //若dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>从dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-2]</span>转移而来时，其值优于之前确定的正无穷<br>                    //或者由dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>转移而来的值时，更新该状态<br>                    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j - 2]</span> + (list<span class="hljs-comment">[j]</span> - list<span class="hljs-comment">[j - 1]</span>) * (list<span class="hljs-comment">[j]</span> - list<span class="hljs-comment">[j - 1]</span>); //更新<br>        <br>                &#125;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; dp<span class="hljs-comment">[k]</span><span class="hljs-comment">[n]</span> &lt;&lt; endl;<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p>主要讨论0-1背包，完全背包和多重背包三类问题</p><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p>采药<br><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%87%87%E8%8D%AF.png"></p><p>首先我们将这个问题抽象：有一个容量为 V 的背包，和一些物品。<br>这些物品分别有两个属性，体积w和价值 v，每种物品只有一个。<br>要求用这个背包装下价值尽可能多的物品，求该最大价值，背包可以不被装满。<br>因为最优解中，每个物品都有两种可能的情况，即在背包中或者不存在（背<br>包中有 0 个该物品或者 1 个），所以我们把这个问题称为 0-1 背包问题。在该例 中，背包的容积和物品的体积等效为总共可用的时间和采摘每个草药所需的时间。</p><p>在众多方案中求解最优解，是典型的动态规划问题。为了用动态规划来解决<br>该问题，我们用 dp[i][j]表示在总体积不超过 j 的情况下，前 i 个物品所能达到的 最大价值。</p><p>初始时，dp[0][j] (0&lt;&#x3D;j&lt;&#x3D;V)为 0。依据每种物品是否被放入背包，每个状态有两个状态转移的来源。</p><p>若物品 i 被放入背包，设其体积为w，价值为 v， 则 dp[i][j] &#x3D; dp[i - 1][j - w] + v。即在总体积不超过 j-w 时前 i-1 件物品可组成的最大价值的基础上再加上i物品的价值v；</p><p>若物品不加入背包，则dp[i][j] &#x3D; dp[i-1][j]， 即此时与总体积不超过 j 的前 i-1 件物品组成的价值最大值等价。</p><p>选择它们之中 较大的值成为状态 dp[i][j]的值。</p><p>综上所述，0-1 背包的状态转移方程为：<br><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%87%87%E8%8D%AF%E6%96%B9%E7%A8%8B.png"></p><p>代码</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#include&lt;iostream&gt;<br>#include&lt;cmath&gt;<br>using namespace std;<br>struct Node&#123;<br>    int w;<br>    int v;<br>&#125;a<span class="hljs-comment">[101]</span>;<br>int dp<span class="hljs-comment">[101]</span><span class="hljs-comment">[1001]</span>;//dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>表示前i个物品组成的总体积不大于j的最大价值和<br>int main()<br>&#123;<br>    int V,M;<br>    while(cin&gt;&gt;V&gt;&gt;M)<br>    &#123;<br>        for(int i=1;i&lt;=M;i++)<br>            cin&gt;&gt;a<span class="hljs-comment">[i]</span>.v&gt;&gt;a<span class="hljs-comment">[i]</span>.w;<br>        for(int i=1;i&lt;=V;i++) //初始化<br>            dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span>=0;<br>        for(int i=1;i&lt;=M;i++) //循环遍历每个物品<br>        &#123;<br>            for(int j=V;j&gt;=a<span class="hljs-comment">[i]</span>.v;j--)<br>            &#123;<br>                dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>,dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-a<span class="hljs-comment">[i]</span>.v]</span>+a<span class="hljs-comment">[i]</span>.w);<br>            &#125;<br>            for(int j=a<span class="hljs-comment">[i]</span>.v-1;j&gt;=0;j--)<br>                dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>;<br>        &#125;<br>        cout&lt;&lt;dp<span class="hljs-comment">[M]</span><span class="hljs-comment">[V]</span>&lt;&lt;endl;<br>    &#125;<br>    return 0;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%87%87%E8%8D%AF%E4%BC%98%E5%8C%96.png"></p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b?a:b;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">E</span>&#123;<br>    <span class="hljs-type">int</span> w;<span class="hljs-comment">//物品的体积</span><br>    <span class="hljs-type">int</span> v;<span class="hljs-comment">//物品的总价值</span><br>&#125;list[<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1001</span>];<span class="hljs-comment">//dp[i][j]表示前i个物品组成的总体积不大于j的最大价值和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> s,n;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;s&gt;&gt;n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>          cin&gt;&gt;list[i].w&gt;&gt;list[i].v;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=s;i++)&#123;<br>            dp[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始化状态</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-comment">//循环每一个物品</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=s;j&gt;=list[i].w;j--)&#123;<br>                <span class="hljs-comment">//对s到list[i].w的每个j，状态转移来源为dp[i-1][j]</span><br>                <span class="hljs-comment">//或dp[i-1][j-list[i].w]+list[i].v,选择其中较大的值</span><br>                dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-list[i].w]+list[i].v);<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;dp[s]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E5%8F%98%E5%8C%96.png"></p><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.png"></p><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%A4%BA%E4%BE%8B.png"></p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x7fffffff</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">E</span>&#123;<span class="hljs-comment">//钱币结构体</span><br>    <span class="hljs-type">int</span> w;<span class="hljs-comment">//重量</span><br>    <span class="hljs-type">int</span> v;<span class="hljs-comment">//价值</span><br>&#125;list[<span class="hljs-number">501</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">10001</span>];<span class="hljs-comment">//状态</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin&gt;&gt;T;<span class="hljs-comment">//输入测试数据组数</span><br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-comment">//T次循环，处理T组数据</span><br>        <span class="hljs-type">int</span> s,tmp;<br>        cin&gt;&gt;tmp&gt;&gt;s;<span class="hljs-comment">//输入空储蓄罐重量和装满钱币的储蓄罐重量</span><br>        s-=tmp;<span class="hljs-comment">//计算钱币所占重量</span><br>        <span class="hljs-type">int</span> n;<br>        cin&gt;&gt;n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            cin&gt;&gt;list[i].v&gt;&gt;list[i].w;<span class="hljs-comment">//输入不同种类钱币的价值和重量</span><br>        &#125;<br>        <span class="hljs-comment">//因为是要求正好相等  所以初始时，除dp[0]外，其余dp[j]设置初始值为无穷或不存在</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=s;i++)<br>            dp[i]=INF;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//遍历所有物品</span><br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=list[i].w;j&lt;=s;j++)&#123;<br>               <span class="hljs-comment">//完全背包，顺序遍历所有可能转移的状态</span><br>               <span class="hljs-keyword">if</span>(dp[j-list[i].w]!=INF) <span class="hljs-comment">//若不为无穷，就可以由此状态转移而来</span><br>                   dp[j]=<span class="hljs-built_in">min</span>(dp[j],dp[j-list[i].w]+list[i].v);<span class="hljs-comment">//取转移值和原值的较小值</span><br>           &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(dp[s]!=INF) <span class="hljs-comment">//若存在一种方案使背包恰好装满，输出其最小值</span><br>            cout&lt;&lt;dp[s]&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span><br>            cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B9%B0%E5%A4%A7%E7%B1%B3.png"><br>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">2</span> <br><span class="hljs-symbol">2 </span><span class="hljs-number">100</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">100</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">400<br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">E</span>&#123;<span class="hljs-comment">//大米</span><br>   <span class="hljs-type">int</span> w;<span class="hljs-comment">//价格</span><br>   <span class="hljs-type">int</span> v;<span class="hljs-comment">//重量</span><br>&#125;list[<span class="hljs-number">2001</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">101</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--) <span class="hljs-comment">//T组测试用例</span><br>    &#123;<br>        <span class="hljs-type">int</span> s,n;   <span class="hljs-comment">//经费和大米种类</span><br>        cin&gt;&gt;s&gt;&gt;n;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> v,w,k;<span class="hljs-comment">//价格，重量，袋数</span><br>            cin&gt;&gt;v&gt;&gt;w&gt;&gt;k;<br>            <span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(k-c&gt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//对输入的数字k，拆分成1,2,4，..k-2^c+1,其中c为使最后一项大于0的最大整数</span><br>                k-=c;<br>                list[++cnt].w=c*w;<br>                list[cnt].v=c*v;<span class="hljs-comment">//拆分后的大米重量和价格均为组成该物品的大米的重量价格和</span><br>                c*=<span class="hljs-number">2</span>;<br>            &#125;<br>            list[++cnt].w=w*k;<br>            list[cnt].v=v*k;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=s;i++) dp[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)&#123;<br>            <span class="hljs-comment">//对拆分后的所有物品进行0-1背包</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=s;j&gt;=list[i].v;j--)&#123;<br>                dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-list[i].v]+list[i].w);<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;dp[s]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%A4%9A%E9%87%8D.png"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索</title>
      <link href="/2021/03/08/%E6%90%9C%E7%B4%A2/"/>
      <url>/2021/03/08/%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>总结算法常见问题中关于搜索的相关方法和注意要点</p><span id="more"></span><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>找准条件即可</p><h1 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h1><p>主要完成状态的转移，不断拓展状态</p><h2 id="基础模版例题"><a href="#基础模版例题" class="headerlink" title="基础模版例题"></a>基础模版例题</h2><p><img src="/2021/03/08/%E6%90%9C%E7%B4%A2/%E8%83%9C%E5%88%A9%E9%80%83%E4%BA%A1.png"><br><img src="/2021/03/08/%E6%90%9C%E7%B4%A2/%E8%83%9C%E5%88%A9%E9%80%83%E4%BA%A1%E8%BE%93%E5%85%A5.png"><br><img src="/2021/03/08/%E6%90%9C%E7%B4%A2/%E8%83%9C%E5%88%A9%E9%80%83%E4%BA%A1%E8%BE%93%E5%87%BA.png"></p><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">bool</span> mark[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>][<span class="hljs-number">50</span>];<span class="hljs-comment">//标记数组</span><br><span class="hljs-type">int</span> maze[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>][<span class="hljs-number">50</span>];<span class="hljs-comment">//保存立方体信息</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">N</span>&#123;<br>    <span class="hljs-type">int</span> x,y,z;<span class="hljs-comment">//位置坐标</span><br>    <span class="hljs-type">int</span> t;<span class="hljs-comment">//所需时间</span><br>&#125;;<br>queue&lt;N&gt; Q; <span class="hljs-comment">//队列，队列中的元素为状态</span><br><span class="hljs-type">int</span> go[][<span class="hljs-number">3</span>]=&#123;<br>    <span class="hljs-comment">//用于坐标变换，六个方向</span><br>    <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<br>    <span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<br>    <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())&#123;<br>      N now=Q.<span class="hljs-built_in">front</span>();<br>      Q.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;<br>        <span class="hljs-comment">//依次扩展其六个相邻结点</span><br>        <span class="hljs-type">int</span> nx=now.x+go[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ny=now.y+go[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> nz=now.z+go[i][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span>(nx&lt;<span class="hljs-number">0</span>||nx&gt;=a||ny&lt;<span class="hljs-number">0</span>||ny&gt;=b||nz&lt;<span class="hljs-number">0</span>||nz&gt;=c)  <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//若新坐标在立方体外，则丢弃该坐标</span><br>        <span class="hljs-keyword">if</span>(maze[nx][ny][nz]==<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//若该位置为墙，则丢弃该坐标</span><br>        <span class="hljs-keyword">if</span>(mark[nx][ny][nz]==<span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//已经标记过，丢弃该坐标</span><br>        <span class="hljs-comment">//队列中放入新结点</span><br>        N tmp;<br>        tmp.x=nx;<br>        tmp.y=ny;<br>        tmp.z=nz;<br>        tmp.t=now.t+<span class="hljs-number">1</span>;<span class="hljs-comment">//耗时</span><br>        Q.<span class="hljs-built_in">push</span>(tmp);<br>        mark[nx][ny][nz]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//标记该结点</span><br>        <span class="hljs-keyword">if</span>(nx==a<span class="hljs-number">-1</span>&amp;&amp;ny==b<span class="hljs-number">-1</span>&amp;&amp;nz==c<span class="hljs-number">-1</span>)<br>           <span class="hljs-keyword">return</span> tmp.t;<br>        <span class="hljs-comment">//若该坐标即为终点，可直接返回其耗时</span><br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//若所有状态查找完后，仍得不到所需坐标，则返回-1</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)&#123;<br>        <span class="hljs-type">int</span> a,b,c,t;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;t;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;b;j++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;c;k++)&#123;<br>            cin&gt;&gt;maze[i][j][k];<span class="hljs-comment">//输入立方体信息</span><br>            mark[i][j][k]=<span class="hljs-literal">false</span>;<span class="hljs-comment">//初始化标记数组</span><br>        &#125;<br>        <span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())  Q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//清空队列</span><br>        mark[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//标记起点</span><br>        N tmp;<br>        tmp.t=tmp.x=tmp.y=tmp.z=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始状态</span><br>        Q.<span class="hljs-built_in">push</span>(tmp);<span class="hljs-comment">//将初始状态放入队列</span><br>        <span class="hljs-type">int</span> res=<span class="hljs-built_in">BFS</span>(a,b,c);<span class="hljs-comment">//广度优先搜索</span><br>        <span class="hljs-keyword">if</span>(res&lt;=t)  cout&lt;&lt;res;<span class="hljs-comment">//若所需时间符合条件，则输出</span><br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;-1&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例题2，注重状态转移<br><img src="/2021/03/08/%E6%90%9C%E7%B4%A2/%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90.png"></p><p>示例代码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#include&lt;iostream&gt;</span><br><span class="hljs-comment">#include &lt;queue&gt;</span><br>using namespace std;<br>struct N&#123;<br>    int a,b,c;<span class="hljs-regexp">//</span>每个杯子中可乐的体积<br>    int t;<span class="hljs-regexp">//</span>得到该体积组倾倒次数<br>&#125;;<br>queue&lt;N&gt; Q;<span class="hljs-regexp">//</span>队列<br>bool mark[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<br>void AtoB(int &amp;a,int sa,int &amp;b,int sb)<br>&#123;<br>    <span class="hljs-regexp">//</span>倾倒函数，由容积为sa的杯子倒往容积为sb的杯子<br>    <span class="hljs-regexp">//</span>a，b，初始时为原始杯子中可乐的体积，<br>    <span class="hljs-regexp">//</span>函数调用完毕后，为各自杯子中可乐的新体积<br>    <span class="hljs-keyword">if</span>(sb-b&gt;=a) <br>    &#123;<br>        <span class="hljs-regexp">//</span>若a可以全部倒到b中<br>        b+=a;<br>        a=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        a-=sb-b;<br>        b=sb;<br>    &#125;<br>&#125;<br><br>int BFS(int s,int n,int m)<br>&#123;<br>    <span class="hljs-keyword">while</span>(!Q.empty())<br>    &#123;<br>        N now=Q.front();<span class="hljs-regexp">//</span>拿出队头状态<br>        Q.pop();<br>        int a,b,c;<span class="hljs-regexp">//</span>a,b,c临时保存三个杯子中可乐体积<br><br><br>        <span class="hljs-regexp">//</span>可能的状态 a-&gt;b<br>        a=now.a;<br>        b=now.b;<br>        c=now.c;<br>        AtoB(a,s,b,n);<span class="hljs-regexp">//</span>由a倾倒向b<br>        <span class="hljs-keyword">if</span>(mark[a][b][c]==false)<br>        &#123;<br>            <span class="hljs-regexp">//</span>若该体积组尚未出现<br>            mark[a][b][c]=true;<span class="hljs-regexp">//</span>标记该体积组<br>            N tmp;<br>            tmp.a=a;<br>            tmp.b=b;<br>            tmp.c=c;<br>            tmp.t=now.t+<span class="hljs-number">1</span>;<span class="hljs-regexp">//</span>生成新的状态<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(c==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;c==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-regexp">//</span>若该状态已经为平分状态，则直接返回该状态的耗时<br>            Q.push(tmp);<span class="hljs-regexp">//</span>否则放入队列<br>        &#125;<br><br><br>        <span class="hljs-regexp">//</span>可能的状态b-&gt;a<br>        a=now.a;<br>        b=now.b;<br>        c=now.c;<br>        AtoB(b,n,a,s);<span class="hljs-regexp">//</span>由b倾倒向a<br>        <span class="hljs-keyword">if</span>(mark[a][b][c]==false)<br>        &#123;<br>            <span class="hljs-regexp">//</span>若该体积组尚未出现<br>            mark[a][b][c]=true;<span class="hljs-regexp">//</span>标记该体积组<br>            N tmp;<br>            tmp.a=a;<br>            tmp.b=b;<br>            tmp.c=c;<br>            tmp.t=now.t+<span class="hljs-number">1</span>;<span class="hljs-regexp">//</span>生成新的状态<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(c==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;c==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-regexp">//</span>若该状态已经为平分状态，则直接返回该状态的耗时<br>            Q.push(tmp);<span class="hljs-regexp">//</span>否则放入队列<br>        &#125;<br><br><br>        <span class="hljs-regexp">//</span>可能的状态a-&gt;c<br>        a=now.a;<br>        b=now.b;<br>        c=now.c;<br>        AtoB(a,s,c,m);<span class="hljs-regexp">//</span>由a倾倒向c<br>        <span class="hljs-keyword">if</span>(mark[a][b][c]==false)<br>        &#123;<br>            <span class="hljs-regexp">//</span>若该体积组尚未出现<br>            mark[a][b][c]=true;<span class="hljs-regexp">//</span>标记该体积组<br>            N tmp;<br>            tmp.a=a;<br>            tmp.b=b;<br>            tmp.c=c;<br>            tmp.t=now.t+<span class="hljs-number">1</span>;<span class="hljs-regexp">//</span>生成新的状态<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(c==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;c==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-regexp">//</span>若该状态已经为平分状态，则直接返回该状态的耗时<br>            Q.push(tmp);<span class="hljs-regexp">//</span>否则放入队列<br>        &#125;<br><br><br>        <span class="hljs-regexp">//</span>可能的状态 c-&gt;a<br>        a=now.a;<br>        b=now.b;<br>        c=now.c;<br>        AtoB(c,m,a,s);<span class="hljs-regexp">//</span>由c倾倒向a<br>        <span class="hljs-keyword">if</span>(mark[a][b][c]==false)<br>        &#123;<br>            <span class="hljs-regexp">//</span>若该体积组尚未出现<br>            mark[a][b][c]=true;<span class="hljs-regexp">//</span>标记该体积组<br>            N tmp;<br>            tmp.a=a;<br>            tmp.b=b;<br>            tmp.c=c;<br>            tmp.t=now.t+<span class="hljs-number">1</span>;<span class="hljs-regexp">//</span>生成新的状态<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(c==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;c==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-regexp">//</span>若该状态已经为平分状态，则直接返回该状态的耗时<br>            Q.push(tmp);<span class="hljs-regexp">//</span>否则放入队列<br>        &#125;<br><br><br>        <span class="hljs-regexp">//</span>可能的状态 b-&gt;c<br>        a=now.a;<br>        b=now.b;<br>        c=now.c;<br>        AtoB(b,n,c,m);<span class="hljs-regexp">//</span>由b倾倒向c<br>        <span class="hljs-keyword">if</span>(mark[a][b][c]==false)<br>        &#123;<br>            <span class="hljs-regexp">//</span>若该体积组尚未出现<br>            mark[a][b][c]=true;<span class="hljs-regexp">//</span>标记该体积组<br>            N tmp;<br>            tmp.a=a;<br>            tmp.b=b;<br>            tmp.c=c;<br>            tmp.t=now.t+<span class="hljs-number">1</span>;<span class="hljs-regexp">//</span>生成新的状态<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(c==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;c==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-regexp">//</span>若该状态已经为平分状态，则直接返回该状态的耗时<br>            Q.push(tmp);<span class="hljs-regexp">//</span>否则放入队列<br>        &#125;<br><br><br>        <span class="hljs-regexp">//</span>可能的状态c-&gt;b<br>        a=now.a;<br>        b=now.b;<br>        c=now.c;<br>        AtoB(c,m,b,n);<span class="hljs-regexp">//</span>由c倾倒向b<br>        <span class="hljs-keyword">if</span>(mark[a][b][c]==false)<br>        &#123;<br>            <span class="hljs-regexp">//</span>若该体积组尚未出现<br>            mark[a][b][c]=true;<span class="hljs-regexp">//</span>标记该体积组<br>            N tmp;<br>            tmp.a=a;<br>            tmp.b=b;<br>            tmp.c=c;<br>            tmp.t=now.t+<span class="hljs-number">1</span>;<span class="hljs-regexp">//</span>生成新的状态<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(c==s<span class="hljs-regexp">/2&amp;&amp;b==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-keyword">if</span>(a==s<span class="hljs-regexp">/2&amp;&amp;c==s/</span><span class="hljs-number">2</span>) return tmp.t;<br>            <span class="hljs-regexp">//</span>若该状态已经为平分状态，则直接返回该状态的耗时<br>            Q.push(tmp);<span class="hljs-regexp">//</span>否则放入队列<br>        &#125;<br>    &#125;<br>    return -<span class="hljs-number">1</span>;<br>&#125;<br><br>int main()<br>&#123;<br>    int s,n,m;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;s&gt;&gt;n&gt;&gt;m&amp;&amp;s&amp;&amp;n&amp;&amp;m)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(s%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-regexp">//</span>若s为奇数不可能平分，直接输出NO<br>            cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;=s;i++)<br>         <span class="hljs-keyword">for</span>(int j=<span class="hljs-number">0</span>;j&lt;=n;j++)<br>          <span class="hljs-keyword">for</span>(int k=<span class="hljs-number">0</span>;k&lt;=m;k++)<br>             mark[i][j][k]=false;<br>             <span class="hljs-regexp">//</span>初始化状态<br>        N tmp;<br>        tmp.a=s;<br>        tmp.b=<span class="hljs-number">0</span>;<br>        tmp.c=<span class="hljs-number">0</span>;<br>        tmp.t=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!Q.empty()) Q.pop();<br>        Q.push(tmp);<span class="hljs-regexp">//</span>将初始状态放入队列<br>        mark[s][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=true;<span class="hljs-regexp">//</span>标记初始状态<br>        int rec=BFS(s,n,m);<span class="hljs-regexp">//</span>广度优先搜索<br>        <span class="hljs-keyword">if</span>(rec==-<span class="hljs-number">1</span>) cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;rec&lt;&lt;endl;<br>    &#125;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归是一种十分常用的编码技巧，所谓即递归即函数调用<br>函数本身，调用的方式按照问题的不同人为定义，这种调用方式被称为递归方式。<br>同时，为了不使这样的递归无限的发生，我们必须设定递归的出口，即当函数到达某种条件时停止递归。</p><h2 id="模版例题："><a href="#模版例题：" class="headerlink" title="模版例题："></a>模版例题：</h2><p><img src="/2021/03/08/%E6%90%9C%E7%B4%A2/%E6%B1%89%E8%AF%BA%E5%A1%94.png"><br><img src="/2021/03/08/%E6%90%9C%E7%B4%A2/han.png"><br>主要代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart">Long Long F(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span>)&#123;<br>   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">num</span>==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>*F(<span class="hljs-built_in">num</span><span class="hljs-number">-1</span>)+<span class="hljs-number">2</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="示例1：素数环"><a href="#示例1：素数环" class="headerlink" title="示例1：素数环"></a>示例1：素数环</h2><p>题目大意为由给定的 1 到 n 数字中，将数字依次填入环中，使得环中任意两 个相邻的数字间的和为素数。</p><p>对于给定的 n，按字典序由小到大输出所有符合条 件的解（第一个数恒定为 1）<br><img src="/2021/03/08/%E6%90%9C%E7%B4%A2/%E7%B4%A0%E8%BE%93.png"></p><p>为了解决该问题，我们可以采用回溯法枚举每一个值。当第一个数位为 1<br>确定时，我们尝试放入第二个数，使其和 1 的和为素数，放入后再尝试放入第三 个数，使其与第二个数的和为素数，直到所有的数全部被放入环中，且最后一个 数与 1 的和也是素数，那么这个方案即为答案，输出；若在尝试放数的过程中， 发现当前位置无论放置任何之前未被使用的数均不可能满足条件，那么我们回溯 改变其上一个数，直到产生我们所需要的答案，或者确实不再存在更多的解。 为了实现这一回溯枚举的过程，我们采用递归的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> ans[<span class="hljs-number">22</span>];<span class="hljs-comment">//保存环中每一个被放入的数</span><br><span class="hljs-type">bool</span> hashnum[<span class="hljs-number">22</span>];<span class="hljs-comment">//标记之前已经被放入环中的数</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> prime[]=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">17</span>,<span class="hljs-number">19</span>,<span class="hljs-number">23</span>,<span class="hljs-number">29</span>,<span class="hljs-number">31</span>,<span class="hljs-number">37</span>,<span class="hljs-number">41</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//判断是否是素数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">13</span>;i++)<br>      <span class="hljs-keyword">if</span>(prime[i]==x) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//检查输出由回溯枚举得到的解</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(ans[n]+ans[<span class="hljs-number">1</span>])==<span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//判读最后一个数和第一个数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">1</span>) cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        cout&lt;&lt;ans[i];<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//递归枚举，num为当前已经放入环中的数字</span><br>    <span class="hljs-keyword">if</span>(num&gt;<span class="hljs-number">1</span>) <span class="hljs-comment">//当放入的数字大于一个时</span><br>      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(ans[num]+ans[num<span class="hljs-number">-1</span>])==<span class="hljs-literal">false</span>)<br>         <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//判断最后两个数字的和是否为素数，若不是则返回枚举第num个数</span><br>    <span class="hljs-keyword">if</span>(num==n)&#123;<br>        <span class="hljs-comment">//若已经放入了n个数</span><br>        <span class="hljs-built_in">check</span>();<span class="hljs-comment">//检查输出</span><br>        <span class="hljs-keyword">return</span>;<span class="hljs-comment">//返回，继续枚举下一组解</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-comment">//放入一个数</span><br>        <span class="hljs-keyword">if</span>(hashnum[i]==<span class="hljs-literal">false</span>)&#123;<br>            hashnum[i]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//标记i为已使用</span><br>            ans[num+<span class="hljs-number">1</span>]=i;<span class="hljs-comment">//将这个数字放入ans数组中</span><br>            <span class="hljs-built_in">DFS</span>(num+<span class="hljs-number">1</span>);<span class="hljs-comment">//继续尝试放入下一个数</span><br>            hashnum[i]=<span class="hljs-literal">false</span>;<span class="hljs-comment">//当回溯回枚举该位数字时，将i标记为未使用</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cas=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录Case数</span><br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&amp;&amp;n)<br>    &#123;<br>        cas++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">22</span>;i++)<br>           hashnum[i]=<span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//初始化</span><br>        ans[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//第一个数字恒定为1</span><br>        cout&lt;&lt;cas&lt;&lt;endl;<br>        hashnum[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//标记1被使用</span><br>        <span class="hljs-built_in">DFS</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//继续尝试放入下一个数字</span><br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="示例2-洪泛-遍历图"><a href="#示例2-洪泛-遍历图" class="headerlink" title="示例2  洪泛 遍历图"></a>示例2  洪泛 遍历图</h2><p>题目大意：在给定的 n*m 图中，确定有几个@的块。块符合以下条件，其<br>中的任意对@均互相直接或间接连通，两个@直接相邻或者对角相邻即被视为连通。<br>计算最后总共有几个连通块</p><p>输入</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mel">The input <span class="hljs-keyword">file</span> contains one or more grids. Each <span class="hljs-keyword">grid</span> begins with a line containing<br>m and n, the number of rows and columns <span class="hljs-keyword">in</span> the <span class="hljs-keyword">grid</span>, separated by a single space. If m = <span class="hljs-number">0</span> it signals the end of the input; otherwise <span class="hljs-number">1</span> &lt;= m &lt;= <span class="hljs-number">100</span> and <span class="hljs-number">1</span> &lt;= n &lt;= <span class="hljs-number">100.</span> Following this are m lines of n characters each (not counting the end-of-line characters). Each <span class="hljs-keyword">character</span> corresponds to one plot, and is either <span class="hljs-string">`*&#x27;, representing the absence of oil, or `</span>@&#x27;, representing an oil pocket.<br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <br>*<br><span class="hljs-number">3</span> <span class="hljs-number">5</span><br>*@*@* <br>**@** <br>*@*@* <br><span class="hljs-number">1</span> <span class="hljs-number">8</span><br>@@****@* <br><span class="hljs-number">5</span> <span class="hljs-number">5</span><br>****@ <br>*@@*@ <br>*@**@ <br>@@@*@ <br>@@**@ <br><span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">For <span class="hljs-keyword">each</span> grid, output <span class="hljs-keyword">the</span> <span class="hljs-built_in">number</span> <span class="hljs-keyword">of</span> distinct oil deposits. Two different pockets are part <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> same oil deposit <span class="hljs-keyword">if</span> they are adjacent horizontally, vertically, <span class="hljs-keyword">or</span> diagonally. An oil deposit will <span class="hljs-keyword">not</span> contain more than <span class="hljs-number">100</span> pockets.For <span class="hljs-keyword">each</span> grid, output <span class="hljs-keyword">the</span> <span class="hljs-built_in">number</span> <span class="hljs-keyword">of</span> distinct oil deposits. Two different pockets are part <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> same oil deposit <span class="hljs-keyword">if</span> they are adjacent horizontally, vertically, <span class="hljs-keyword">or</span> diagonally. An oil deposit will <span class="hljs-keyword">not</span> contain more than <span class="hljs-number">100</span> pockets.<br><span class="hljs-number">0</span> <br><span class="hljs-number">1</span> <br><span class="hljs-number">2</span> <br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br>char a[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<br>bool mark[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<br>int n, m;<br>void init()<br>&#123;<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">101</span>; i++)<br>        <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">101</span>; j++)<br>        &#123;<br>            a[i][j] = <span class="hljs-number">0</span>;<br>            mark[i][j] = <span class="hljs-literal">false</span>;<br>        &#125;<br>&#125;<br>void DFS(int h, int l)<br>&#123;<br>    <span class="hljs-keyword">if</span> (h &gt; n || l &gt; m)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">-1</span>; i &lt;= <span class="hljs-number">1</span>; i++)<br>        <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">-1</span>; j &lt;= <span class="hljs-number">1</span>; j++)<br>        &#123;<br><br>            int <span class="hljs-keyword">new</span><span class="hljs-type">h</span> = h + i;<br>            int <span class="hljs-keyword">new</span><span class="hljs-type">l</span> = l + j;<br>    <br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">h</span> &lt; <span class="hljs-number">1</span> || <span class="hljs-keyword">new</span><span class="hljs-type">h</span> &gt; n || <span class="hljs-keyword">new</span><span class="hljs-type">l</span> &lt; <span class="hljs-number">1</span> || <span class="hljs-keyword">new</span><span class="hljs-type">l</span> &gt; m || mark[<span class="hljs-keyword">new</span><span class="hljs-type">h</span>][<span class="hljs-keyword">new</span><span class="hljs-type">l</span>] == <span class="hljs-literal">true</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (a[<span class="hljs-keyword">new</span><span class="hljs-type">h</span>][<span class="hljs-keyword">new</span><span class="hljs-type">l</span>] == <span class="hljs-string">&#x27;*&#x27;</span>)<br>                <span class="hljs-keyword">continue</span>;<br><br>            mark[<span class="hljs-keyword">new</span><span class="hljs-type">h</span>][<span class="hljs-keyword">new</span><span class="hljs-type">l</span>] = <span class="hljs-literal">true</span>;<br>            DFS(<span class="hljs-keyword">new</span><span class="hljs-type">h</span>, <span class="hljs-keyword">new</span><span class="hljs-type">l</span>);<br>        &#125;<br>&#125;<br><br>int main()<br>&#123;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &amp;&amp; n)<br>    &#123;<br>        cin &gt;&gt; m;<br>        init();<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>                cin &gt;&gt; a[i][j];<br>        int ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (!mark[i][j] &amp;&amp; a[i][j] == <span class="hljs-string">&#x27;@&#x27;</span>)<br>                &#123;<br>                    mark[i][j] = <span class="hljs-literal">true</span>;<br>                    DFS(i, j);<br>                    ans++;<br>                &#125;<br>            &#125;<br><br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h1><p>首先回顾之前已经介绍过的广度优先搜索。在由状态的转移和扩展构成的解答树中，<br>广度优先搜索按照层次遍历所有的状态，直到找到我们需要的状态。 与其相对的，假如我们改变对解答树的遍历方式，改为优先遍历层次更深的状态，直到遇到一个状态结点，其不再拥有子树，则返回上一层，<br>访问其未被访 问过的子树，直至解答树中所有的状态都被遍历完毕。<br>这个过程，类似于树的前序遍历。<br><br>由于其缺少了广度搜索中按层次递增顺序遍历的特性。<br>所以当深度优先搜索 搜索到我们需要的状态时，其不再具有某种最优的特性。<br>所以，在使用深度优先 搜索时，我们更多的求解有或者没有的问题，即对解答树是否有我们需要的答案 进行判定，<br>而一般不使用深度优先搜索求解最优解问题</p><h2 id="示例-迷宫-经典问题"><a href="#示例-迷宫-经典问题" class="headerlink" title="示例  迷宫 经典问题"></a>示例  迷宫 经典问题</h2><p>题目大意：有一个 N*M 的迷宫，包括起点 S，终点 D，墙 X，和地面，0<br>秒时主人公从 S 出发，每秒能走到四个与其相邻的位置中的一个，且每个位置被 行走之后都不能再次走入，问是否存在这样一条路径使主人公在 T 秒时刚好走 到D。</p><p>样例输入输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus">第一行代表N，M，T，接下来N行M列就是数组，也就是此题迷宫的地图<br><br><span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <br>S<span class="hljs-selector-class">.X</span>. <br>.<span class="hljs-selector-class">.X</span>. <br>.<span class="hljs-selector-class">.XD</span> <br>....<br><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <br>S<span class="hljs-selector-class">.X</span>. <br>.<span class="hljs-selector-class">.X</span>. <br>..<span class="hljs-selector-class">.D</span> <br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><br>输出：<br>NO <br>YES<br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br>int N, M, T;<br>char a[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>];<br>int dir[][<span class="hljs-number">2</span>] = &#123;<br>    <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<br>    <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>bool mark[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>];<br>bool flag;<br>void DFS(int x, int y, int t)<br>&#123;<br>    <span class="hljs-keyword">if</span> (a[x][y] == <span class="hljs-string">&#x27;D&#x27;</span>)<br>    &#123;<br>        flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t &gt; T)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        &#123;<br>            int <span class="hljs-keyword">new</span><span class="hljs-type">x</span> = x + dir[i][<span class="hljs-number">0</span>];<br>            int <span class="hljs-keyword">new</span><span class="hljs-type">y</span> = y + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">x</span> &lt; <span class="hljs-number">1</span> || <span class="hljs-keyword">new</span><span class="hljs-type">x</span> &gt; N || <span class="hljs-keyword">new</span><span class="hljs-type">y</span> &lt; <span class="hljs-number">1</span> || <span class="hljs-keyword">new</span><span class="hljs-type">y</span> &gt; M)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (a[<span class="hljs-keyword">new</span><span class="hljs-type">x</span>][<span class="hljs-keyword">new</span><span class="hljs-type">y</span>] == <span class="hljs-string">&#x27;X&#x27;</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (!mark[<span class="hljs-keyword">new</span><span class="hljs-type">x</span>][<span class="hljs-keyword">new</span><span class="hljs-type">y</span>])<br>            &#123;<br>                mark[<span class="hljs-keyword">new</span><span class="hljs-type">x</span>][<span class="hljs-keyword">new</span><span class="hljs-type">y</span>] = <span class="hljs-literal">true</span>;<br>                DFS(<span class="hljs-keyword">new</span><span class="hljs-type">x</span>, <span class="hljs-keyword">new</span><span class="hljs-type">y</span>, t + <span class="hljs-number">1</span>);<br>                mark[<span class="hljs-keyword">new</span><span class="hljs-type">x</span>][<span class="hljs-keyword">new</span><span class="hljs-type">y</span>] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br>int main()<br>&#123;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; N &gt;&gt; M &gt;&gt; T &amp;&amp; N &amp;&amp; M &amp;&amp; T)<br>    &#123;<br>        flag = <span class="hljs-literal">false</span>;<br>        int marki, markj;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>            <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">1</span>; j &lt;= M; j++)<br>            &#123;<br>                mark[i][j] = <span class="hljs-literal">false</span>;<br>                cin &gt;&gt; a[i][j];<br>                <span class="hljs-keyword">if</span> (a[i][j] == <span class="hljs-string">&#x27;S&#x27;</span>)<br>                &#123;<br>                    marki = i;<br>                    markj = j;<br>                &#125;<br>            &#125;<br>        mark[marki][markj] = <span class="hljs-literal">true</span>;<br>        DFS(marki, markj, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">if</span> (flag)<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p>八皇后</p><p><img src="/2021/03/08/%E6%90%9C%E7%B4%A2/%E5%85%AB%E7%9A%87%E5%90%8E.png"></p><p>主要在于判断对角线是否相同</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/*非常朴素的八皇后问题，问题规模也已经框定好了，只要把每次得到的列号转化成要比较的十进制数字即可*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; solut;            <span class="hljs-comment">//用来放最终的结果</span><br><span class="hljs-type">int</span> position[<span class="hljs-number">9</span>];            <span class="hljs-comment">//行号从1开始，其中下标代表行号，其中存放的内容代表列号</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">DFS</span>(<span class="hljs-number">1</span>);                    <span class="hljs-comment">//直接从第一行开始放</span><br>    <span class="hljs-built_in">sort</span>(solut.<span class="hljs-built_in">begin</span>(), solut.<span class="hljs-built_in">end</span>());    <span class="hljs-comment">//这里应该不用sort因为得到的solution应该都是从小到大</span><br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n) != EOF)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, solut[n - <span class="hljs-number">1</span>]);    <span class="hljs-comment">//因为vector是从0开始的    </span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span>            <span class="hljs-comment">//row代表要放入的行号,逐行放入，因为要用的是列号，而且按照习惯都是一列一列计算的</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (row == <span class="hljs-number">9</span>)            <span class="hljs-comment">//row==9意味着从1~8行全都放入,已完成解</span><br>    &#123;<br>        <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">8</span>; i++)<br>        &#123;<br>            temp += position[i] * <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-number">8</span> - i);    <br>        &#125;<br>        solut.<span class="hljs-built_in">push_back</span>(temp);                        <span class="hljs-comment">//把得到的solution放进vector</span><br>    &#125;<br><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">8</span>; i++)<br>        &#123;<br>            position[row] = i;        <span class="hljs-comment">//i在这里代表列号</span><br>            <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;        <span class="hljs-comment">//用一个标志位来标记，是否冲突</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;  row; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (position[row] == position[j] || row - position[row] == j - position[j] || row + position[row] == j + position[j])<br>                &#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;        <span class="hljs-comment">//这里的判断条件j - position[j]会把同一主对角线标记为同一个数字，与row - position[row]同时计算就能判断是否冲突</span><br>            &#125;<span class="hljs-comment">//for</span><br>            <span class="hljs-keyword">if</span> (flag)<br>                <span class="hljs-built_in">DFS</span>(row + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<span class="hljs-comment">//endif</span><br>&#125;<span class="hljs-comment">//DFS</span><br><br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法之数学问题</title>
      <link href="/2021/03/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/"/>
      <url>/2021/03/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>涉及机试中涉及的一系列数学问题，包括数位拆解、分解素因数等高频知识点，以及最小公倍数，最大公约数的基本方法，高精度整数运算的实现。</p><span id="more"></span><h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><p><img src="/2021/03/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include &lt;bits/stdc++.h&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> a,b;<br>    <span class="hljs-built_in">string</span> n;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;a&gt;&gt;n&gt;&gt;b)<br>    &#123;<br>        <span class="hljs-built_in">long</span> num=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">string</span> result=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(n[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>            n=n.substr(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">int</span> k=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=n.length()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(n[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;n[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>                num+=(n[i]-<span class="hljs-string">&#x27;0&#x27;</span>)*k;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n[i]&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;n[i]&lt;=<span class="hljs-string">&#x27;z&#x27;</span>)<br>                num+=(n[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">10</span>)*k;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n[i]&gt;=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;n[i]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)<br>                num+=(n[i]-<span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-number">10</span>)*k;<br>            k*=a;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(num%b&lt;=<span class="hljs-number">9</span>)<br>                result=to_string(num%b)+result;<br>            <span class="hljs-keyword">else</span><br>                result=<span class="hljs-built_in">string</span>(<span class="hljs-number">1</span>,num%b<span class="hljs-number">-10</span>+<span class="hljs-string">&#x27;A&#x27;</span>)+result;<br>            num/=b;<br>        &#125;<br>        cout&lt;&lt;result&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最大公约数-GCD"><a href="#最大公约数-GCD" class="headerlink" title="最大公约数 GCD"></a>最大公约数 GCD</h1><p>求a,b的最大公约数：</p><ol><li>如果a,b全为0，则它们的最大公约数不存在</li><li>若a,b其中之一为零，它们的最大公约数为a,b中非0的那个</li><li>若a,b都不为0  则使a&#x3D;b;b&#x3D;a%b;  然后重复该过程</li></ol><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">else</span> <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">gcd</span><span class="hljs-params">(b,a%b)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最小公倍数-LCM"><a href="#最小公倍数-LCM" class="headerlink" title="最小公倍数 LCM"></a>最小公倍数 LCM</h1><p>a,b两数的最小公倍数为两数的乘积除以它们的最大公约数</p><h1 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h1><p>合数是指在大于1的整数中除了能被1和本身整除外，还能被其他数（0除外）整除的数。与之相对的是质数（素数），而1既不属于质数也不属于合数。最小的合数是4。其中，完全数与相亲数是以它为基础的。</p><h2 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h2><p>若一个数不是素数，则必存在一个小于它的素数为其的因数。在我们获得一个素数时，将它的所有倍数均标记为非素数，这样当我们遍历到一个数时，它没有被任何小于它的素数标记为非素数，则确定其为素数。</p><p><img src="/2021/03/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/%E7%B4%A0%E6%95%B0%E7%AD%9B.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-meta">#include&lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-built_in">int</span> prime[<span class="hljs-number">10000</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">int</span> primesize=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">bool</span> mark[<span class="hljs-number">10001</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span>()</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">10001</span>;i++)<br>        mark[i]=<span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">10000</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(mark[i]==<span class="hljs-literal">true</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        prime[primesize++]=i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=i*i;j&lt;=<span class="hljs-number">10000</span>;j+=i)<br>            mark[j]=<span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-keyword">init</span>();<br>    <span class="hljs-built_in">int</span> n;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n)<br>    &#123;<br>        <span class="hljs-built_in">bool</span> flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;primesize;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(prime[i]&lt;n&amp;&amp;prime[i]%<span class="hljs-number">10</span>==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(flag==<span class="hljs-literal">false</span>)<br>                &#123;<br>                    flag=<span class="hljs-literal">true</span>;<br>                    cout&lt;&lt;prime[i];<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;prime[i];<br>                &#125;<br>            &#125; <br>        &#125;<br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="分解素因数"><a href="#分解素因数" class="headerlink" title="分解素因数"></a>分解素因数</h2><p><img src="/2021/03/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/%E5%88%86%E8%A7%A3%E7%B4%A0%E5%9B%A0%E6%95%B0.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include&lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-built_in">int</span> prime[<span class="hljs-number">100000</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">int</span> primesize;<br><span class="hljs-built_in">bool</span> mark[<span class="hljs-number">100001</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span>()</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100001</span>;i++)<br>        mark[i]=<span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">100000</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(mark[i])<br>            <span class="hljs-keyword">continue</span>;<br>        prime[primesize++]=i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=i*i;j&lt;=<span class="hljs-number">100000</span>;j+=i)<br>            mark[j]=<span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-keyword">init</span>();<br>    <span class="hljs-built_in">int</span> N;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;N)<br>    &#123;<br>         <span class="hljs-built_in">int</span> ansPrime[<span class="hljs-number">30</span>];<span class="hljs-comment">//按顺序保存分解出的素因数</span><br>         <span class="hljs-built_in">int</span> ansSize=<span class="hljs-number">0</span>;<span class="hljs-comment">//分解出素因数的个数</span><br>         <span class="hljs-built_in">int</span> ansNum[<span class="hljs-number">30</span>]; <span class="hljs-comment">//保存分解出的素因数对应的幂指数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;primesize;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(N%prime[i]==<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//若该素数能整除分解数</span><br>                ansPrime[ansSize]=prime[i];<span class="hljs-comment">//则该素数为其素因数</span><br>                ansNum[ansSize]=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始化幂指数为0</span><br>                <span class="hljs-keyword">while</span>(N%prime[i]==<span class="hljs-number">0</span>)<br>                &#123;<br>                    ansNum[ansSize]++;<br>                    N/=prime[i];<br>                &#125;<br>                ansSize++;<br>                <span class="hljs-keyword">if</span>(N==<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(N!=<span class="hljs-number">1</span>)&#123;<br>            ansPrime[ansSize]=N;<span class="hljs-comment">//若测试所有素因数，n仍未被分解至1，则剩余的因数一定是N一个大于100000的素因数</span><br>            ansNum[ansSize++]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;ansSize;i++)&#123;<br>            ans+=ansNum[i]; <br>        &#125;<br>        cout&lt;&lt;ans&lt;&lt;endl;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="阶乘的素因数分解"><a href="#阶乘的素因数分解" class="headerlink" title="阶乘的素因数分解"></a>阶乘的素因数分解</h2><p><img src="/2021/03/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/%E6%95%B4%E9%99%A4%E9%97%AE%E9%A2%98.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a,n;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;a)!=EOF)&#123;<br>        <span class="hljs-type">int</span> count1[<span class="hljs-number">1010</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> count2[<span class="hljs-number">1010</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> t=n;<br>            <span class="hljs-keyword">while</span>(t)&#123;<br>                count1[i]+=t/i;<br>                t=t/i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">233333333</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=a;i++)&#123;<br>            <span class="hljs-keyword">while</span>(a%i==<span class="hljs-number">0</span>)&#123;<br>                count2[i]++;<br>                a/=i;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count2[i]==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(count1[i]/count2[i]&lt;ans)<br>                ans=count1[i]/count2[i];<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><br></code></pre></td></tr></table></figure><p>使用素数筛</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1010</span><br><span class="hljs-type">int</span> prime[N];<br><span class="hljs-type">int</span> primesize;<br><span class="hljs-type">bool</span> mark[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)<br>        mark[i]=<span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;N;i++)&#123;<br>        <span class="hljs-keyword">if</span>(mark[i]==<span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            prime[primesize++]=i;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i*i;j&lt;N;j+=i)<br>                mark[j]=<span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> a,n;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;a)!=EOF)&#123;<br>        <span class="hljs-type">int</span> count1[N]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> count2[N]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;primesize;i++)&#123;<br>            <span class="hljs-type">int</span> t=n;<br>            <span class="hljs-keyword">while</span>(t)&#123;<br>                count1[i]+=t/prime[i];<br>                t/=prime[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">233333333</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;primesize;i++)&#123;<br>            <span class="hljs-keyword">while</span>(a%prime[i]==<span class="hljs-number">0</span>)&#123;<br>                count2[i]++;<br>                a/=prime[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count2[i]==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(count1[i]/count2[i]&lt;ans)<br>                ans=count1[i]/count2[i];<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="二分求幂"><a href="#二分求幂" class="headerlink" title="二分求幂"></a>二分求幂</h1><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p><a href="https://blog.csdn.net/harington/article/details/87602682">csdn相关介绍博客</a></p><p><img src="/2021/03/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/%E5%BF%AB%E9%80%9F%E5%B9%82.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binaryPow</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)  <span class="hljs-comment">//对应二进制位为1  可以写成b&amp;1 取二进制最后一位</span><br>           ans*=a;  <span class="hljs-comment">//累乘至结果</span><br>        a*=a;       <span class="hljs-comment">//准备</span><br>        b/=<span class="hljs-number">2</span>;       <span class="hljs-comment">//可以写成b&gt;&gt;1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a,b;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;a&gt;&gt;b)<br>    &#123;<br>       cout&lt;&lt;<span class="hljs-built_in">binaryPow</span>(a,b)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> N=<span class="hljs-number">10</span>;<br><span class="hljs-built_in">int</span> tmp[N][N];<br><span class="hljs-built_in">void</span> multi(<span class="hljs-built_in">int</span> a[][N],<span class="hljs-built_in">int</span> b[][N],<span class="hljs-built_in">int</span> n)<br>&#123;<br>    memset(tmp,<span class="hljs-number">0</span>,sizeof tmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)<br>        tmp[i][j]+=a[i][k]*b[k][j];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>        a[i][j]=tmp[i][j];<br>&#125;<br><span class="hljs-built_in">int</span> res[N][N];<br><span class="hljs-built_in">void</span> Pow(<span class="hljs-built_in">int</span> a[][N],<span class="hljs-built_in">int</span> n)<br>&#123;<br>    memset(res,<span class="hljs-number">0</span>,sizeof res);<span class="hljs-comment">//n是幂，N是矩阵大小</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++) res[i][i]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(n)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>)<br>            multi(res,a,N);<span class="hljs-comment">//res=res*a;复制直接在multi里面实现了；</span><br>        multi(a,a,N);<span class="hljs-comment">//a=a*a</span><br>        n&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br><br>————————————————<br>版权声明：本文为CSDN博主「wust_wenhao」的原创文章，遵循CC <span class="hljs-number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：https:<span class="hljs-comment">//blog.csdn.net/wust_zzwh/article/details/52058209</span><br><br></code></pre></td></tr></table></figure><h1 id="高精度整数"><a href="#高精度整数" class="headerlink" title="高精度整数"></a>高精度整数</h1><p>计算n的阶乘</p><p><img src="/2021/03/01/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/n%E7%9A%84%E9%98%B6%E4%B9%98.png"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> res[<span class="hljs-number">3000</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> N;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;N)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3000</span>;i++) res[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> size=<span class="hljs-number">0</span>;res[size++]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=N;i++)<br>        &#123;<br>            <span class="hljs-type">int</span> jinwei=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;size;j++)<br>            &#123;<br>                res[j]=(res[j]*i+jinwei);<br>                <span class="hljs-keyword">if</span>(res[j]&gt;<span class="hljs-number">9</span>)<br>                &#123;<br>                    jinwei=res[j]/<span class="hljs-number">10</span>;<br>                    res[j]%=<span class="hljs-number">10</span>;<br>                &#125;     <br>                <span class="hljs-keyword">else</span> jinwei=<span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(jinwei)&#123;<br>                res[size++]=jinwei%<span class="hljs-number">10</span>;<br>                jinwei/=<span class="hljs-number">10</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=size<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>            cout&lt;&lt;res[i];<br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构相关算法</title>
      <link href="/2021/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
      <url>/2021/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>包含树，图，bfs，dfs，最短路径，最小生成树等常用模版代码</p><span id="more"></span><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="题目1：遍历二叉树"><a href="#题目1：遍历二叉树" class="headerlink" title="题目1：遍历二叉树"></a>题目1：遍历二叉树</h2><p><img src="/2021/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E5%8D%95.png"></p><ol><li>利用结论：二叉树的先序遍历入栈，那么出栈顺序就是他的中序遍历</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string pre;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; pre)<br>    &#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : pre)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (it != <span class="hljs-string">&#x27;#&#x27;</span>)<br>                s.<span class="hljs-built_in">push</span>(it);<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (!s.<span class="hljs-built_in">empty</span>())<br>                &#123;<br>                    cout &lt;&lt; s.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>                    s.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>使用数组模拟二叉树</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N1=<span class="hljs-number">1e8</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N2=<span class="hljs-number">1e2</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> pos,len,t;<br><span class="hljs-type">char</span> tree[N1];<br><span class="hljs-type">char</span> str[N2];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span><span class="hljs-comment">//建立二叉树</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> c = str[t++];<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;#&#x27;</span>)<span class="hljs-comment">//若是‘#’，说明该节点为空返回上一级节点</span><br>        <span class="hljs-keyword">return</span>;<br>    tree[pos] = c;<span class="hljs-comment">//若不是‘#’，为本节点赋值</span><br>    <span class="hljs-built_in">create</span>(pos*<span class="hljs-number">2</span>);<span class="hljs-comment">//递归创建左子树</span><br>    <span class="hljs-built_in">create</span>(pos*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);<span class="hljs-comment">//递归创建右子树</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span><span class="hljs-comment">//中序遍历二叉树</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(tree[root]==<span class="hljs-number">0</span>)<span class="hljs-comment">//如果该节点为0，说明该节点为空，返回上一级</span><br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traverse</span>(<span class="hljs-number">2</span>*root);<span class="hljs-comment">//先遍历左子树</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>,tree[root]);<span class="hljs-comment">//遍历完左子树后，访问本节点</span><br>    <span class="hljs-built_in">traverse</span>(<span class="hljs-number">2</span>*root+<span class="hljs-number">1</span>);<span class="hljs-comment">//再遍历右子树</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str)!=EOF)<br>    &#123;<br>        t=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">create</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">traverse</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>通过指针创建二叉树</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 101</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    Node *lchild;<br>    Node *rchild;<br>    <span class="hljs-type">char</span> c;<br>&#125;;<br><br><span class="hljs-function">Node *<span class="hljs-title">CreateNode</span><span class="hljs-params">()</span><span class="hljs-comment">//创建新节点，返回结点指针</span></span><br><span class="hljs-function"></span>&#123;<br>    Node *ret=(Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Node));<br>    ret-&gt;lchild=<span class="hljs-literal">NULL</span>;<br>    ret-&gt;rchild=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">(Node *T)</span><span class="hljs-comment">//中序遍历</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T-&gt;lchild!=<span class="hljs-literal">NULL</span>) <span class="hljs-built_in">InOrder</span>(T-&gt;lchild);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, T-&gt;c);<br>    <span class="hljs-keyword">if</span>(T-&gt;rchild!=<span class="hljs-literal">NULL</span>) <span class="hljs-built_in">InOrder</span>(T-&gt;rchild);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Del</span><span class="hljs-params">(Node *T)</span><span class="hljs-comment">//删除树</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T-&gt;lchild!=<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//删除左子树</span><br>    &#123;<br>        <span class="hljs-built_in">Del</span>(T-&gt;lchild);<br>        T-&gt;lchild=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(T-&gt;rchild!=<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//删除右子树</span><br>    &#123;<br>        <span class="hljs-built_in">Del</span>(T-&gt;rchild);<br>        T-&gt;rchild=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(T);<span class="hljs-comment">//删除根节点</span><br>&#125;<br><br><span class="hljs-type">unsigned</span> pos;<span class="hljs-comment">//标记字符串处理到哪了</span><br><span class="hljs-type">char</span> str[N];<span class="hljs-comment">//读取的字符串</span><br><br><span class="hljs-function">Node *<span class="hljs-title">BuildTree</span><span class="hljs-params">()</span><span class="hljs-comment">//根据字符串创立二叉树，并返回根节点指针</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(pos&gt;=<span class="hljs-built_in">strlen</span>(str)) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//字符串处理完了就歇着吧</span><br>    <span class="hljs-keyword">if</span>(str[pos]==<span class="hljs-string">&#x27;#&#x27;</span>)<span class="hljs-comment">//创建空树，即返回空指针</span><br>    &#123;<br>        pos++;<span class="hljs-comment">//准备处理下一个字符</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    Node *p=<span class="hljs-built_in">CreateNode</span>();<span class="hljs-comment">//创建一个空节点</span><br>    p-&gt;c=str[pos++];<span class="hljs-comment">//先序，先获取根节点的字符信息</span><br>    p-&gt;lchild=<span class="hljs-built_in">BuildTree</span>();<span class="hljs-comment">//创建左子树</span><br>    p-&gt;rchild=<span class="hljs-built_in">BuildTree</span>();<span class="hljs-comment">//创建右子树</span><br>    <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//完事，返回根节点指针</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">gets</span>(str))<br>    &#123;<br>        pos=<span class="hljs-number">0</span>;<span class="hljs-comment">//标记字符串处理到哪了</span><br>        Node *T=<span class="hljs-built_in">BuildTree</span>();<span class="hljs-comment">//根据字符串构建整棵树</span><br>        <span class="hljs-built_in">InOrder</span>(T);<span class="hljs-comment">//中序遍历并输出</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-built_in">Del</span>(T);<span class="hljs-comment">//贴心的删除树，释放内存空间</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题目二：给定先序中序求后序"><a href="#题目二：给定先序中序求后序" class="headerlink" title="题目二：给定先序中序求后序"></a>题目二：给定先序中序求后序</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span>&lt;iostream&gt;<br>#<span class="hljs-keyword">include</span>&lt;algorithm&gt;<br>using namespace std;<br>void <span class="hljs-constructor">Post(<span class="hljs-params">string</span> <span class="hljs-params">str1</span>,<span class="hljs-params">string</span> <span class="hljs-params">str2</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(str1.length<span class="hljs-literal">()</span>==<span class="hljs-number">0</span>)    return;<br>    <span class="hljs-built_in">int</span> root=str2.find(str1<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>);<br>    <span class="hljs-constructor">Post(<span class="hljs-params">str1</span>.<span class="hljs-params">substr</span>(1,<span class="hljs-params">root</span>)</span>,str2.substr(<span class="hljs-number">0</span>,root));<br>    <span class="hljs-constructor">Post(<span class="hljs-params">str1</span>.<span class="hljs-params">substr</span>(<span class="hljs-params">root</span>+1)</span>,str2.substr(root+<span class="hljs-number">1</span>));<br>    cout&lt;&lt;str1<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;<br>&#125;<br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span><br>&#123;<br>    <span class="hljs-built_in">string</span> str1,str2;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;str1&gt;&gt;str2)<br>    &#123;<br>        <span class="hljs-constructor">Post(<span class="hljs-params">str1</span>,<span class="hljs-params">str2</span>)</span>;<br>        cout&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>代码二</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;                <span class="hljs-comment">//树结点结构体</span><br>   Node *lchild; <span class="hljs-comment">//左儿子指针</span><br>   Node *rchild; <span class="hljs-comment">//右儿子指针</span><br>   <span class="hljs-type">char</span> c;       <span class="hljs-comment">//结点字符信息</span><br>&#125; Tree[<span class="hljs-number">50</span>];      <span class="hljs-comment">//静态内存分配数组</span><br><span class="hljs-type">int</span> loc;         <span class="hljs-comment">//静态数组中已经分配的结点个数</span><br><span class="hljs-function">Node *<span class="hljs-title">creat</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-comment">//申请一个结点空间,返回指向其的指针</span><br>   Tree[loc].lchild = Tree[loc].rchild = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//初始化左右儿子为空</span><br>   <span class="hljs-keyword">return</span> &amp;Tree[loc++];                        <span class="hljs-comment">//返回指针,且loc累加</span><br>&#125;<br><span class="hljs-type">char</span> str1[<span class="hljs-number">30</span>], str2[<span class="hljs-number">30</span>]; <span class="hljs-comment">//保存前序和中序遍历结果字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(Node *T)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">//后序遍历</span><br>   <span class="hljs-keyword">if</span> (T-&gt;lchild != <span class="hljs-literal">NULL</span>)<br>   &#123;                        <span class="hljs-comment">//若左子树不为空</span><br>      <span class="hljs-built_in">postOrder</span>(T-&gt;lchild); <span class="hljs-comment">//递归遍历其左子树</span><br>   &#125;<br>   <span class="hljs-keyword">if</span> (T-&gt;rchild != <span class="hljs-literal">NULL</span>)<br>   &#123;                        <span class="hljs-comment">//若右子树不为空</span><br>      <span class="hljs-built_in">postOrder</span>(T-&gt;rchild); <span class="hljs-comment">//递归遍历其右子树</span><br>   &#125;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, T-&gt;c); <span class="hljs-comment">//遍历该结点,输出其字符信息</span><br>&#125;<br><span class="hljs-function">Node *<span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> s1, <span class="hljs-type">int</span> e1, <span class="hljs-type">int</span> s2, <span class="hljs-type">int</span> e2)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-comment">//由字符串的前序遍历和中序遍历还原树, 并返回其根节点, </span><br>   <span class="hljs-comment">//其中前序遍历结果为由str1[s1] 到str2[e1] ，中序遍历结果为str2[s2] 到str2[e2]</span><br>   Node *ret = <span class="hljs-built_in">creat</span>(); <span class="hljs-comment">//为该树根节点申请空间</span><br>   ret-&gt;c = str1[s1];   <span class="hljs-comment">//该结点字符为前序遍历中第一个字符</span><br>   <span class="hljs-type">int</span> rootIdx;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s2; i &lt;= e2; i++)<br>   &#123; <span class="hljs-comment">//查找该根节点字符在中序遍历中的位置</span><br>      <span class="hljs-keyword">if</span> (str2[i] == str1[s1])<br>      &#123;<br>         rootIdx = i;<br>         <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (rootIdx != s2)<br>   &#123;  <span class="hljs-comment">//若左子树不为空,递归还原其左子树</span><br>      ret-&gt;lchild = <span class="hljs-built_in">build</span>(s1 + <span class="hljs-number">1</span>, s1 + (rootIdx - s2), s2, rootIdx - <span class="hljs-number">1</span>); <br>   &#125;<br>   <span class="hljs-keyword">if</span> (rootIdx != e2)<br>   &#123;  <span class="hljs-comment">//若右子树不为空,递归还原其右子树</span><br>      ret-&gt;rchild = <span class="hljs-built_in">build</span>(s1 + (rootIdx - s2) + <span class="hljs-number">1</span>, e1, rootIdx + <span class="hljs-number">1</span>, e2); <br>   &#125;<br>   <span class="hljs-keyword">return</span> ret; <span class="hljs-comment">//返回根节点指针</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str1) != EOF)<br>   &#123;<br>      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str2); <span class="hljs-comment">//输入</span><br>      loc = <span class="hljs-number">0</span>;    <span class="hljs-comment">//初始化静态内存空间中已经使用结点个数为0</span><br>      <span class="hljs-type">int</span> L1 = <span class="hljs-built_in">strlen</span>(str1);<br>      <span class="hljs-type">int</span> L2 = <span class="hljs-built_in">strlen</span>(str2);          <span class="hljs-comment">//计算两个字符串长度</span><br>      Node *T = <span class="hljs-built_in">build</span>(<span class="hljs-number">0</span>, L1 - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, L2 - <span class="hljs-number">1</span>); <span class="hljs-comment">//还原整棵树,其根结点指针保存在T中</span><br>      <span class="hljs-built_in">postOrder</span>(T);                   <span class="hljs-comment">//后序遍历</span><br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);                   <span class="hljs-comment">//输出换行</span><br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="vector在邻接链表中的应用"><a href="#vector在邻接链表中的应用" class="headerlink" title="vector在邻接链表中的应用"></a>vector在邻接链表中的应用</h2><p>首先定义一个结构体</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> Struct Edge&#123;<br>    <span class="hljs-built_in">int</span> nextNode;<span class="hljs-comment">//下一个结点编号</span><br>    <span class="hljs-built_in">int</span> cost;<span class="hljs-comment">//该边的权重</span><br>&#125;Edge;<br></code></pre></td></tr></table></figure><p>为每一个结点建立一个单链表来保存与其相邻的边权值和结点的信息。使用vector来模拟这些单链表。结点数量为N</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;Edge&gt; edge[N];<br></code></pre></td></tr></table></figure><p>利用</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">for</span>(int i=<span class="hljs-number">0</span>;i&lt;N;i++)  &#123;<br>    edge<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.clear</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>来实现对这些单链表的初始化<br><br><br>要添加信息时使用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Edge tmp<span class="hljs-comment">;//准备一个Edge结构体</span><br>tmp.nextNode<span class="hljs-operator">=</span><span class="hljs-number">3</span><span class="hljs-comment">;//下一结点编号为3</span><br>tmp.cost<span class="hljs-operator">=</span><span class="hljs-number">38</span><span class="hljs-comment">;</span><br>edge[<span class="hljs-number">1</span>].push_back(tmp)<span class="hljs-comment">;//将该边加入结点1的单链表中</span><br></code></pre></td></tr></table></figure><p>当需要查询某个结点的所有邻接信息时，对vector进行遍历</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-keyword">edge</span>[<span class="hljs-number">2</span>]<span class="hljs-variable">.size</span>();i++)&#123;<br>    <span class="hljs-keyword">int</span> nextNode=<span class="hljs-keyword">edge</span>[<span class="hljs-number">2</span>][i]<span class="hljs-variable">.nextNode</span>;  <span class="hljs-comment">//读出邻接结点</span><br>    <span class="hljs-keyword">int</span> cost=<span class="hljs-keyword">edge</span>[<span class="hljs-number">2</span>][i]<span class="hljs-variable">.cost</span>;  <span class="hljs-comment">//读出权值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当需要删除某个单链表中的某些边信息时，调用vector::erase<br><br>例如，删除结点1的单链表中edge[1][i]所对应的边信息时，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">edge<span class="hljs-selector-attr">[1]</span><span class="hljs-selector-class">.erase</span>(edge<span class="hljs-selector-attr">[1]</span><span class="hljs-selector-class">.begin</span>()+<span class="hljs-selector-tag">i</span>,edge<span class="hljs-selector-attr">[1]</span><span class="hljs-selector-class">.begin</span>())+<span class="hljs-selector-tag">i</span>+<span class="hljs-number">1</span>);<br>//即vector<span class="hljs-selector-class">.erase</span>(vector<span class="hljs-selector-class">.begin</span>()+第一个要删除的元素编号，vector<span class="hljs-selector-class">.begin</span>()+最后一个要删除元素的编号+<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>首先，定义一个数组，用双亲表示法来表示各棵树（所有的集合元素个数总和为N）：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> Tree[<span class="hljs-built_in">N</span>];<br></code></pre></td></tr></table></figure><p>用Tree[i]来表示结点i的双亲结点，若Tree[i]为 <strong>-1</strong> 则表示该结点不存在双亲结点，即结点i为其所在树的根节点.<br><br><br>为了查找结点x所在树的根节点，定义以下函数</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRoot</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(Tree[x]==<span class="hljs-number">-1</span>)  <span class="hljs-keyword">return</span> x;<span class="hljs-comment">//若当前结点为根节点则返回该结点号</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">findRoot</span><span class="hljs-params">(Tree[x])</span></span>; <span class="hljs-comment">//否则递归查找其双钱结点的根节点</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>为了优化路径压缩</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> find<span class="hljs-constructor">Root(<span class="hljs-params">int</span> <span class="hljs-params">x</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(Tree<span class="hljs-literal">[<span class="hljs-identifier">x</span>]</span>==-<span class="hljs-number">1</span>)  return x;<span class="hljs-comment">//若当前结点为根节点则返回该结点号</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">int</span> tmp=find<span class="hljs-constructor">Root(Tree[<span class="hljs-params">x</span>])</span>;<br>        Tree<span class="hljs-literal">[<span class="hljs-identifier">x</span>]</span>=tmp; <span class="hljs-comment">//将当前结点的双亲设置为查找返回的根节点编号</span><br>        return tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例1-畅通工程-求解图上连通分量个数"><a href="#例1-畅通工程-求解图上连通分量个数" class="headerlink" title="例1 畅通工程 求解图上连通分量个数"></a>例1 畅通工程 求解图上连通分量个数</h3><p><img src="/2021/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include&lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-built_in">int</span> Tree[<span class="hljs-number">1010</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span>()</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1010</span>;i++)<br>        Tree[i]=<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">findRoot</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(Tree[x]==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> tmp=findRoot(Tree[x]);<br>        Tree[x]=tmp;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> N,M;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;N&amp;&amp;N)<br>    &#123;<br>        cin&gt;&gt;M;<br>        <span class="hljs-keyword">init</span>();<br>        <span class="hljs-keyword">while</span>(M--)<br>        &#123;<br>            <span class="hljs-built_in">int</span> a,b;<br>            cin&gt;&gt;a&gt;&gt;b;<br>            <br>            <span class="hljs-built_in">int</span> roota=findRoot(a);<br>            <span class="hljs-built_in">int</span> rootb=findRoot(b);<br>            <span class="hljs-keyword">if</span>(roota!=rootb)<br>                Tree[roota]=rootb;<br>        &#125;<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(Tree[i]==<span class="hljs-number">-1</span>)  ans++;<br>        &#125;<br>        cout&lt;&lt;ans<span class="hljs-number">-1</span>&lt;&lt;endl; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例2-More-is-better"><a href="#例2-More-is-better" class="headerlink" title="例2 More is better"></a>例2 More is better</h3><p>题目大意：有10000000个人，其中有n个好朋友，朋友关系具有传递性，找出最大的集合，集合中都是朋友关系或者只有一个人，输出集合中最多少人。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> N = <span class="hljs-number">10000001</span>;<br><span class="hljs-built_in">int</span> Tree[N] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">int</span> Sum[N] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span>()</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    &#123;<br>        Tree[i] = <span class="hljs-number">-1</span>;<br>        Sum[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getRoot</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (Tree[x] == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> tmp = getRoot(Tree[x]);<br>        Tree[x] = tmp;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> n;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &amp;&amp; n)<br>    &#123;<br>        <span class="hljs-built_in">int</span> a, b;<br>        <span class="hljs-keyword">init</span>();<br>        <span class="hljs-keyword">while</span> (n--)<br>        &#123;<br>            cin &gt;&gt; a &gt;&gt; b;<br>            a=getRoot(a);<br>            b=getRoot(b);<br>            <span class="hljs-keyword">if</span> (a!=b)<br>            &#123;<br>                Tree[a] = b;<br>                Sum[b] += Sum[a];<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (Tree[i] == <span class="hljs-number">-1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (Sum[i] &gt; ans)<br>                &#123;<br>                    ans = Sum[i];<br>                &#125;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以用来判断连通图</p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>定义：在一个无向连通图中，如果存在一个连通子图包含原图中所有的结点合萼部分边，且这个子图中不存在回路，那么我们称这个子图为原图的一颗生成树。在带权图中，所有的生成树中边权的和最小的那颗（或几颗）被称为最小生成树。</p><h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>原理：</p><ol><li>初始时所有结点属于孤立的集合</li><li>按照边权递增顺序遍历所有的边，若遍历到的边两个顶点仍分属不同的集合（该边即为连通这两个集合的边中权值最小的那条）则确定该边为最小生成树上的一条边，并将这两个顶点分属的集合合并。</li><li>遍历完所有边后，原图上所有结点属于同一个集合则被选取的边和原图中所有结点构成最小生成树；否则原图不连通，最小生成树不存在。。</li></ol><p>例题1  还是畅通工程，利用并查集<br><img src="/2021/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/%E8%BF%98%E6%98%AF%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-type">int</span> cost;<br>&#125;;<span class="hljs-comment">//定义边数据结构</span><br>Edge edge[<span class="hljs-number">5000</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> Tree[<span class="hljs-number">101</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">101</span>;i++)<br>        Tree[i]=<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFather</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(Tree[x]==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> tmp=<span class="hljs-built_in">findFather</span>(Tree[x]);<br>        Tree[x]=tmp;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Edge x,Edge y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x.cost&lt;y.cost;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> N;<span class="hljs-comment">//村庄数目 &lt;100;</span><br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;N&amp;&amp;N)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5000</span>;i++)<br>            edge[i].a=edge[i].b=edge[i].cost=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> M=N*(N<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<span class="hljs-comment">//边的数量;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;M;i++)<br>           cin&gt;&gt;edge[i].a&gt;&gt;edge[i].b&gt;&gt;edge[i].cost;<br>        <span class="hljs-built_in">sort</span>(edge,edge+M,cmp);<span class="hljs-comment">//按边排好序后，选边加入</span><br>        <span class="hljs-built_in">init</span>();<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录总长度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;M;i++)<br>        &#123;<br>            <span class="hljs-type">int</span> a=<span class="hljs-built_in">findFather</span>(edge[i].a);<br>            <span class="hljs-type">int</span> b=<span class="hljs-built_in">findFather</span>(edge[i].b);<br>            <span class="hljs-keyword">if</span>(a!=b)  <span class="hljs-comment">//不属于一个集合</span><br>            &#123;<br>                Tree[a]=b;<br>                ans+=edge[i].cost;<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最短路径-自己到自己设为0-其他一开始设为-1-不可达"><a href="#最短路径-自己到自己设为0-其他一开始设为-1-不可达" class="headerlink" title="最短路径  自己到自己设为0  其他一开始设为-1  不可达"></a>最短路径  自己到自己设为0  其他一开始设为-1  不可达</h2><h3 id="Floyd-弗洛伊德算法"><a href="#Floyd-弗洛伊德算法" class="headerlink" title="Floyd 弗洛伊德算法"></a>Floyd 弗洛伊德算法</h3><p>全源最短路   三重循环</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">for(int k=1;k&lt;=n;k++) //k从1到N循环，依次代表允许经过的中间结点编号小于等于k<br>for(int i=1;i&lt;=n;i++)<br>    for(int j=1;j&lt;=n;j++)&#123;<br>        if(ans<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span>==-1||ans<span class="hljs-comment">[k]</span><span class="hljs-comment">[j]</span>==-1)  continue;<br>        if(ans<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>==-1||ans<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span>+ans<span class="hljs-comment">[k]</span><span class="hljs-comment">[j]</span>&lt;ans<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>)<br>            ans<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=ans<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span>+ans<span class="hljs-comment">[k]</span><span class="hljs-comment">[j]</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>算法特点：最好图的大小不超过200个结点，当两个结点间有多余一条边时，选择长度最小的边权值存入邻接矩阵。</p><h3 id="Dijkstra-迪杰斯特拉算法"><a href="#Dijkstra-迪杰斯特拉算法" class="headerlink" title="Dijkstra 迪杰斯特拉算法"></a>Dijkstra 迪杰斯特拉算法</h3><p>单源最短路</p><p>算法流程：</p><ol><li>初始化，集合K中加入结点1，结点1到结点1最短距离为0，到其他结点为无穷（或不确定）</li><li>遍历与集合K中结点直接相邻的边（U，V，C），其中U属于集合K，V不属于集合K，计算由结点1出发按照已经得到的最短路径到达U，再由U经过该边到达V时的路径长度。比较所有与集合K中结点直接相邻的非集合K结点该路径长度，其中路径长度最小的结点被确定为下一个最短路径确定的结点，其最短路径长度即为这个路径长度，最后将该结点加入集合K</li><li>若集合K中已经包含所有的点，算法结束；否则重复步骤2</li></ol><p>例题<br>采用vector模拟链表</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">E</span>&#123;<br>    <span class="hljs-type">int</span> next;  <span class="hljs-comment">//代表直接相邻的结点</span><br>    <span class="hljs-type">int</span> c;     <span class="hljs-comment">//代表该边的权值</span><br>&#125;;<br>vector&lt;E&gt; edge[<span class="hljs-number">101</span>];<span class="hljs-comment">//邻接链表</span><br><span class="hljs-type">bool</span> mark[<span class="hljs-number">101</span>];<span class="hljs-comment">//标记是否得到最短路径</span><br><span class="hljs-type">int</span> Dis[<span class="hljs-number">101</span>];<span class="hljs-comment">//标记开始点距离各个结点距离</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n&amp;&amp;m)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)  <br>            edge[i].<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">//初始化邻接链表</span><br>        <span class="hljs-keyword">while</span>(m--)<br>        &#123;<br>            <span class="hljs-type">int</span> a,b,c;<br>            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>            E tmp;<br>            tmp.c=c;<br>            tmp.next=b;<br>            edge[a].<span class="hljs-built_in">push_back</span>(tmp);<br>            tmp.next=a;<br>            edge[b].<span class="hljs-built_in">push_back</span>(tmp);<br>            <span class="hljs-comment">//将邻接信息加入邻接链表，无向图 两遍</span><br>        &#125;<br>        <span class="hljs-comment">//初始化mark和dis数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            Dis[i]=<span class="hljs-number">-1</span>;<span class="hljs-comment">//代表不可达</span><br>            mark[i]=<span class="hljs-literal">false</span>;<span class="hljs-comment">//所有结点不属于集合K</span><br>        &#125;<br>        Dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>; <span class="hljs-comment">//得到最近的结点为自己 结点1，长度为0</span><br>        mark[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//将结点1加入集合K</span><br>        <span class="hljs-type">int</span> newP=<span class="hljs-number">1</span>;<span class="hljs-comment">//集合中新加入的点为结点1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<span class="hljs-comment">//循环n-1次</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;edge[newP].<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-type">int</span> t=edge[newP][j].next;<br>                <span class="hljs-type">int</span> c=edge[newP][j].c;<br>                <span class="hljs-comment">//看是否可通过newP这个点 缩短相关结点的最短距离</span><br>                <span class="hljs-keyword">if</span>(mark[t]==<span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(Dis[t]==<span class="hljs-number">-1</span>||Dis[t]&gt;Dis[newP]+c)<br>                &#123;<br>                    Dis[t]=Dis[newP]+c;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//找下一个最小点   之前的标记为true</span><br>            <span class="hljs-type">int</span> min=<span class="hljs-number">123123123</span>;<span class="hljs-comment">//最小值初始化为一个大整数，为找最小值作准备</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(mark[j]==<span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(Dis[j]==<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(Dis[j]&lt;min)&#123;<br>                    min=Dis[j]; <span class="hljs-comment">//更新其为最小值</span><br>                    newP=j; <span class="hljs-comment">//以此为中介 更新</span><br>                &#125;<br>            &#125;<br>            mark[newP]=<span class="hljs-literal">true</span>;<br>        &#125;<br>        cout&lt;&lt;Dis[n]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>采用矩阵</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs stata">需要一个辅助数组<span class="hljs-keyword">dis</span>来存储起点到其他所有点的距离<br>将<span class="hljs-keyword">dis</span>数组中的值称为最短路程的<span class="hljs-string">&quot;估计值&quot;</span><br>核心思想:通过边来松弛起点到其他各个点的距离<br>代码;<br><span class="hljs-comment">//初始化dis数组</span><br> <span class="hljs-keyword">for</span>(int i=1;i&lt;=<span class="hljs-keyword">n</span>;i++)<br>  <span class="hljs-keyword">dis</span>[i]=a[1][i](假设起点为1)<br><span class="hljs-comment">//标记数组初始化visted</span><br> <span class="hljs-keyword">for</span>(int i=1;i&lt;=<span class="hljs-keyword">n</span>;i++)<br>   visted[i]=0;<br> visted[1]=1;<br><span class="hljs-comment">//接下来重复过程</span><br>在<span class="hljs-keyword">dis</span>数组中找当前离起点最近的点<br>然后访问这个点的所有边看是否能通过<span class="hljs-keyword">dis</span>数组更新起点到那些边的距离<br>能的话就更新<br>代码:(部分是伪代码)<br> int min=<span class="hljs-keyword">Inf</span>;<br> <span class="hljs-keyword">for</span>(int i=1;i&lt;=<span class="hljs-keyword">dis</span>.size();i++)<br>  &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">dis</span>[i]&lt;min)<br>     &#123;<br>        min=<span class="hljs-keyword">dis</span>[i];<br>        <span class="hljs-keyword">mark</span>=i  ;<span class="hljs-comment">//mark用来记录这一点</span><br>     &#125; <br>&#125;<br>然后更新：<br> <span class="hljs-keyword">for</span>(int v=1；v&lt;=<span class="hljs-keyword">n</span>;v++)<br>   &#123;<br>      <span class="hljs-keyword">if</span>(a[<span class="hljs-keyword">mark</span>][v]&lt;<span class="hljs-keyword">inf</span>)<br>        &#123;<br>             <span class="hljs-keyword">if</span>(<span class="hljs-keyword">dis</span>[v]&gt;<span class="hljs-keyword">dis</span>[<span class="hljs-keyword">mark</span>]+a[<span class="hljs-keyword">mark</span>][v])<br>                <span class="hljs-keyword">dis</span>[v]=<span class="hljs-keyword">dis</span>[<span class="hljs-keyword">mark</span>]+a[<span class="hljs-keyword">mark</span>][v];<br>        &#125;<br>   &#125;<br><br>这个过程持续<span class="hljs-keyword">n</span>-1所以最外层还要加上循环<br> <span class="hljs-keyword">for</span>(int k=1;k&lt;=<span class="hljs-keyword">n</span>-1;k++)<br>&#123;<br> ….<br>&#125;<br><br>时间复杂度O(<span class="hljs-keyword">n</span>^2)<br><br><br></code></pre></td></tr></table></figure><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>使用标准模版：std：：queue</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">queue&lt;<span class="hljs-type">int</span>&gt; Q;<br></code></pre></td></tr></table></figure><p>Q.push(x);将元素x放入队尾</p><p>x&#x3D;Q.front();&#x2F;&#x2F;读取队头元素，将其值赋值给x</p><p>Q.pop();&#x2F;&#x2F;弹出队头元素</p><p>Q.empty();&#x2F;&#x2F;判断队列是否为空，若返回值为true代表队列为空</p><p>为了保存在拓扑排序中不断出现的和之前已经出现的入度为 0 的结点，我们 使用一个队列。每当出现一个入度为 0 的结点，我们将其放入队列；若需要找到 一个入度为 0 的结点，就从队头取出。</p><p>示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 在一个 qq 群里有着许多师徒关系，如 A 是 B 的师父，同时 B<br><span class="hljs-regexp">//</span> 是A的徒弟，一个师父可能有许多徒弟，一个徒弟也可能会有许多不同的师父。 <br><span class="hljs-regexp">//</span> 输入给出该群里所有的师徒关系，问是否存在这样一种非法的情况：<br><span class="hljs-regexp">//</span> 以三个人为 例，即A是B的师父，B是C 的师父，C又反过来是A的师父。<br><span class="hljs-regexp">//</span> 若我们将该群 里的所有人都抽象成图上的结点，将所有的师徒关系都抽象成有向边（由师父指 向徒弟），<br><span class="hljs-regexp">//</span> 该实际问题就转化 图是否为有向无环图。为一个数学问题——该图上是否存在一个环，<br><span class="hljs-regexp">//</span> 即判断是否属于有向无环图时。若一个图，存在符合拓扑次序的结点序列，则该图为有向无环图<br><span class="hljs-comment">#include&lt;iostream&gt;</span><br><span class="hljs-comment">#include&lt;vector&gt;</span><br><span class="hljs-comment">#include&lt;queue&gt;</span><br>using namespace std;<br>vector&lt;int&gt; edge[<span class="hljs-number">501</span>];<span class="hljs-regexp">//</span>邻接链表，此边无权值，只需保存编号<br>queue&lt;int&gt; Q;<span class="hljs-regexp">//</span>保存入度为<span class="hljs-number">0</span>的结点的队列<br>int main()<br>&#123;<br>    int inDegree[<span class="hljs-number">501</span>];<span class="hljs-regexp">//</span>统计每个结点的入度<br>    int n,m;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n&amp;&amp;m)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-regexp">//</span>初始化所有结点，编号<span class="hljs-number">0</span>~n-<span class="hljs-number">1</span><br>        &#123;<br>            inDegree[i]=<span class="hljs-number">0</span>; <span class="hljs-regexp">//</span>初始化入度信息，所有结点入度均为<span class="hljs-number">0</span><br>            edge[i].clear();<span class="hljs-regexp">//</span>清空邻接链表<br>        &#125;<br>        <span class="hljs-keyword">while</span> (m--)<br>        &#123;<br>            int a,b;<br>            cin&gt;&gt;a&gt;&gt;b;<span class="hljs-regexp">//</span>读入一条由a指向b的有向边<br>            inDegree[b]++;<br>            edge[a].push_back(b);<span class="hljs-regexp">//</span>将b加入a的邻接链表<br>        &#125;<br>        <span class="hljs-keyword">while</span>(Q.empty()==false) Q.pop();<span class="hljs-regexp">//</span>清空队列<br>        <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(inDegree[i]==<span class="hljs-number">0</span>)<br>            Q.push(i);<span class="hljs-regexp">//</span>若结点入度为<span class="hljs-number">0</span>，则将其放入队列<br>        &#125;<br>        int cnt=<span class="hljs-number">0</span>;<span class="hljs-regexp">//</span>累加已经确定拓扑序列的结点个数<br>        <span class="hljs-keyword">while</span>(Q.empty()==false)&#123;<br>            int nowP=Q.front();<span class="hljs-regexp">//</span>取出队头结点编号<br>            Q.pop();<span class="hljs-regexp">//</span>弹出队头元素<br>            cnt++;<br>            <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;edge[nowP].size();i++)&#123;<br>                <span class="hljs-regexp">//</span>将该结点以及以其为弧尾的所有边去除<br>                inDegree[edge[nowP][i]]--;<br>                <span class="hljs-regexp">//</span>去除某条边后，该边所指后继结点入度减一<br>                <span class="hljs-keyword">if</span>(inDegree[edge[nowP][i]]==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-regexp">//</span>若该结点入度变为<span class="hljs-number">0</span><br>                Q.push(edge[nowP][i]);<span class="hljs-regexp">//</span>将其放到队列中<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-regexp">//</span>若所有结点都能被确定拓扑序列，则原图为有向无环图<br>        <span class="hljs-regexp">//</span>否则，原图为非有向无环图<br>        <span class="hljs-keyword">if</span>(cnt==n) cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>;<br>        cout&lt;&lt;endl;<br>    &#125;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mlagent学习记录</title>
      <link href="/2021/02/23/mlagent%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/02/23/mlagent%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>记录mlagent相关知识</p><!---more--><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>ML-Agents Academy类按如下方式安排代理模拟循环：</p><p>1.调用学院的<code>OnEnvironmentReset</code>委托。<br>2.为场景中的每个Agent调用<code>OnEpisodeBegin()</code>函数。<br>3.为场景中的每个Agent调用 <code>CollectObservations(VectorSensor sensor)</code>函数。<br>4.使用每个Agent的策略来决定Agent的下一个动作。<br>5.为场景中的每个Agent调用<code>OnActionReceived()</code>函数，并传入代理商策略选择的操作。<br>6.如果代理已达到其 <code>MaxStep</code> ，则调用代理的<code>OnEpisodeBegin()</code>函数。</p><h2 id="命令行相关"><a href="#命令行相关" class="headerlink" title="命令行相关"></a>命令行相关</h2><p>使用mlagents-learn进行训练<br><br>相应参数：<br><img src="/2021/02/23/mlagent%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E5%91%BD%E4%BB%A41.png"><br><img src="/2021/02/23/mlagent%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E5%91%BD%E4%BB%A42.png"><br><img src="/2021/02/23/mlagent%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E5%91%BD%E4%BB%A43.png"></p><h2 id="设计Agent"><a href="#设计Agent" class="headerlink" title="设计Agent"></a>设计Agent</h2><h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h3><p>代理扮演这观察周围环境，并决定最好的使用这些观察的行动方针的角色。通过在unity中继承Agent类来创建Agent。创建Agent的关键是你根据Agent完成任务并给予的奖励。<br><br>一个Agent将它观察到的信息传给它的Policy。之后，Policy会做出决定并且反馈相应的动作给Agent。你的Agent代码必须执行这个动作并对每个动作评估奖励值，奖励值用来探索最优的决策。<br><br>Policy从代理本身抽象出决策逻辑，因此您可以在多个代理中使用相同的策略。政策如何制定决策取决于它是什么样的政策。您可以更改策略<br>通过更改其”行为参数(Behavior Parameters)”来代理。如果您将”行为类型(Behavior Type)”设置为”仅限启发式(Heuristic Only)”，代理将使用其”启发式”方法做出决策它可以允许您手动控制代理或编写自己的策略。如果代理有一个”模型(Model)”文件，它的政策将使用神经网络”模型”作出决定。</p><h3 id="Decisons"><a href="#Decisons" class="headerlink" title="Decisons"></a>Decisons</h3><p>每次代理请求时，观察-决策-行动-奖励周期都会重复一个决定。当”Agent.RequestDecision()”被调用时，代理将请求决策。如果您需要代理定期请求自行决策，添加代理游戏对象的”Decision Requester”组件。定期决策<br>间隔通常最适合基于物理的模拟。例如，机器人模拟器中的代理，必须提供关节扭矩的精细控制应该在模拟的每一步都做出决定。另一方面，一个代理，只需要作出决定时，某些游戏或模拟事件发生，应手动调用”Agent.RequestDecision()”。</p><h3 id="Observations"><a href="#Observations" class="headerlink" title="Observations"></a>Observations</h3><p>要做出决策，代理必须观察其环境才能推断世界的状态。状态观察可以采取以下形式：<br></p><ul><li>Vector Observation :  由浮点数组成的数组</li><li>Visual Observation :  一个或多个摄像机图像或者渲染纹理</li></ul><p>当你使用vector Observation时，要继承<code>Agent.CollectObservations(VectorSensor sensor)</code>方法来创建功能矢量<br><br>当你使用visual Observation时，你只需要确定哪些Unity的相机对象或渲染将提供图像，基础代理类将处理剩下的东西。你不需要使用<code>CollectObservations(VectorSensor sensor)</code>方法，除非你也同时使用了vector observation。</p><h4 id="Vector-Observation-Space-Feature-Vectors"><a href="#Vector-Observation-Space-Feature-Vectors" class="headerlink" title="Vector Observation Space: Feature Vectors"></a>Vector Observation Space: Feature Vectors</h4><p>使用<code>CollectObservations(VectorSensor sensor)</code>方法来收集信息在这个函数里面使用<code>VectorSensor.AddObservation</code> 来手动添加信息。<br>例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> GameObject ball;<br><br><span class="hljs-keyword">private</span> List&lt;<span class="hljs-built_in">float</span>&gt; state = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">float</span>&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CollectObservations</span>(<span class="hljs-params">VectorSensor sensor</span>)</span><br>&#123;<br>    sensor.AddObservation(gameObject.transform.rotation.z);<br>    sensor.AddObservation(gameObject.transform.rotation.x);<br>    sensor.AddObservation((ball.transform.position.x - gameObject.transform.position.x));<br>    sensor.AddObservation((ball.transform.position.y - gameObject.transform.position.y));<br>    sensor.AddObservation((ball.transform.position.z - gameObject.transform.position.z));<br>    sensor.AddObservation(ball.transform.GetComponent&lt;Rigidbody&gt;().velocity.x);<br>    sensor.AddObservation(ball.transform.GetComponent&lt;Rigidbody&gt;().velocity.y);<br>    sensor.AddObservation(ball.transform.GetComponent&lt;Rigidbody&gt;().velocity.z);<br>&#125;<br></code></pre></td></tr></table></figure><p>当设置Agent的<code>Behavior Parameters</code>时，可以设置下面这些属性：</p><ul><li>Space Size： 状态大小必须匹配你之前添加信息构成的功能矢量的长度，<br>观测特征向量是浮点数列表，这意味着<br>您必须将任何其他数据类型转换为浮点数或浮点数列表。<br><br><code>VectorSensor.AddObservation</code>方法提供许多通用类型的数据载入，你可以添加整数和布尔类型的数据，也可以添加unity中的数据类型<code>Vector2</code>,<br><code>Vector3</code>, and <code>Quaternion</code>.<br></li></ul><p>类型列举应以_one hot_样式进行编码。即，添加一个每个列举元素的功能载体的元素，设置将观察到的成员代表为一个的元素，并将其余部分设置为零。</p><h5 id="Normalization"><a href="#Normalization" class="headerlink" title="Normalization"></a>Normalization</h5><p>为了在培训时取得最佳效果，您应该使培训的组件规范化。<br>功能矢量的范围[-1，+1]或[0，1]。当您使值规范化时，PPO神经网络通常可以更快地融合到解决方案。请注意，并不一定总是要的归一画到这些推荐的范围，但它是在使用神经网络时被认为是最佳实践。在您的观察组件之间的范围内变化越大，培训将更有可能受到影响。<br>为了归一化数值到值[o,1]，可以使用下面的公式</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">normalizedValue = (currentValue - minValue)/(maxValue - minValue)<br></code></pre></td></tr></table></figure><p>旋转和角度也同样要归一化，当角度位于0到360度之间时，可以使用下面的公式</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Quaternion rotation = transform.rotation;<br>Vector3 normalized = rotation.eulerAngles / <span class="hljs-number">180.0f</span> - Vector3.one;  <span class="hljs-comment">// [-1,1]</span><br>Vector3 normalized = rotation.eulerAngles / <span class="hljs-number">360.0f</span>;  <span class="hljs-comment">// [0,1]</span><br></code></pre></td></tr></table></figure><p>对于可能超出[0,360]范围的角度，您可以减小角度，或者，如果转数很大，则增加最大值(maximum value).</p><h4 id="Multiple-Visual-Observations"><a href="#Multiple-Visual-Observations" class="headerlink" title="Multiple Visual Observations"></a>Multiple Visual Observations</h4><p>视觉观察直接或从一个或多个中使用渲染的纹理场景中的摄影机。 该策略将纹理矢量化为3D张量可以馈入卷积神经网络（CNN）。可以将视觉观察与辅助向量观察一起使用。使用视觉观察的代理可以捕获任意复杂度的状态，并且当状态难以用数字描述时，此功能很有用。 但是，他们通常也效率较低，训练较慢，有时甚至不<br>完全成功。<br><br>视觉观察结果可以从场景中的Cameras或RenderTextures中获取。要将视觉观察添加到代理，请添加“摄像机传感器”组件或将RenderTextures传感器组件添加到代理。<br>然后拖动相机或渲染要添加到<code>Camera</code>或<code>RenderTexture</code>字段的纹理。您可以拥有多个摄像头或渲染纹理，甚至可以结合使用都附加到代理。 对于每个视觉观察，设置宽度和高度<br>图像的像素数（以像素为单位）以及观察结果是彩色还是灰度。<br><br>使用相同策略的每个代理程序必须具有相同数量的视觉观察结果，并且它们都必须具有相同的分辨率（包括它们是否为灰度）。此外，代理上的每个传感器组件都必须具有唯一的名称，以便它们可以确定性地排序（该名称对于该Agent必须是唯一的，但是多个Agent可以<br>具有相同名称的传感器组件）。<br><br>当使用<code>RenderTexture</code>视觉观察时，方便的调试功能是<br>添加一个“画布”，然后添加一个“原始图像”，并将其纹理设置为代理的<br><code>RenderTexture</code>。 这将在游戏屏幕上呈现Agent观察图像。<br><br>可以参考 <strong>GridWord</strong> 项目使用情况(官方案例)，目的是到达指定地点同时避免碰撞。</p><h4 id="Raycast-Observations"><a href="#Raycast-Observations" class="headerlink" title="Raycast Observations"></a>Raycast Observations</h4><p>只需添加一个RayPerceptionSensorComponent3D（RayPerceptionSensorComponent2D）在观察过程中，几条光线（或球体，取决于设置）被投射到物理世界，被击中的物体决定了生成的观察向量。<br><br>Both sensor components have several settings:</p><ul><li><em>Detectable Tags</em>  对应于代理应该能够区分的对象类型的字符串列表。 例如，在WallJump示例中，我们使用“墙”，“目标”和“块”作为要检测的对象列表。</li><li><em>Rays Per Direction</em> 确定投射的光线数。一缕是总是向前投射，多的光线向左右投射。</li><li><em>Max Ray Degrees</em> 最外面的光线的角度（以度为单位）。 90度对应代理的左侧和右侧。.</li><li><em>Sphere Cast Radius</em> 用于球体铸造的球体的大小。 如果设置到0，将使用射线代替球体。 光线可能更有效，特别是在复杂的场景中。</li><li><em>Ray Length</em> 射线长度</li><li><em>Observation Stacks</em>  要与转换结果“堆叠”的先前结果数。 请注意，这可以独立于“行为参数”中的“堆叠矢量”设置。</li><li><em>Start Vertical Offset</em> (3D only) 射线起点的垂直偏移。</li><li><em>End Vertical Offset</em> (3D only) 射线终点的垂直偏移.<br> 创建的观测值的总大小为</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">（观测堆栈）*（<span class="hljs-number">1</span> + <span class="hljs-number">2</span> *每个方向的光线）*（可检测的标签数量+ <span class="hljs-number">2</span>）<br><span class="hljs-comment">(Observation Stacks)</span> * <span class="hljs-comment">(1 + 2 * Rays Per Direction)</span> * <span class="hljs-comment">(Num Detectable Tags + 2)</span><br><br></code></pre></td></tr></table></figure><p>因此，应尽量减少射线和标签的数量，以减少使用的数据量。 请注意，这与在<br><code>Behavior Parameters</code>中状态大小无关。</p><h3 id="Vector-Actions"><a href="#Vector-Actions" class="headerlink" title="Vector Actions"></a>Vector Actions</h3><p>动作是代理执行的来自策略的指令。 当学院调用时，会将操作作为参数传递给代理。使用OnActionReceived()。当您指定矢量动作空间时<br>是 <strong>Continuous</strong>，则传递给Agent的action参数是一个数组<br>长度等于<code>Vector Action Space Size</code>属性的控制信号。当您指定<strong>Discrete</strong>向量动作空间类型时，该动作参数是包含整数的数组。 每个整数都是列表或表的索引<br>命令。<br>在<strong>Discrete</strong>向量动作空间类型中，动作参数是一个索引数组。 数组中的索引数由<br>在<code>Branches Size</code>属性中定义的数决定。每个分支对应于一个动作表，您可以通过指定每个表的大小修改<code>Branches</code>属性。<br>Policy和培训算法都不知道有关该采取的行动本身的意思。训练算法只是尝试<br>动作列表中不同的值并观察随着时间的推移这些值对累积奖励的影响。因此，为Agent定义的唯一位置动作是在OnActionReceived()函数中。<br><br>例如，如果您设计了一个可以在两个维度上移动的代理，则可以使用连续或离散矢量动作。 在连续的情况下，您会将向量动作大小设置为2（每个维度一个），并且代理的策略将创建一个具有两个浮点值的操作。在离散情况下，您将使用一个大小为4的分支（每个分支一个）<br>方向），该策略将创建一个包含单个值范围从零到三的元素。 或者，您可以创建大小为2的两个分支（一个用于水平移动，一个用于垂直移动），并且该策略将创建一个包含两个元素的操作数组,值范围从零到一。<br><br>请注意，在为代理编程操作时，通常有助于使用代理的<code>Heuristic()</code>方法测试您的操作逻辑，让您映射键盘行动命令。<br>The 3DBall and Area  example environments are set up to use either the continuous or the discrete vector action spaces.</p><h4 id="Continuous-Action-Space"><a href="#Continuous-Action-Space" class="headerlink" title="Continuous Action Space"></a>Continuous Action Space</h4><p>当代理使用设置为“连续”向量操作空间的策略时，传递给代理的OnActionReceived（）函数的操作参数是一个数组长度等于“矢量操作空间大小”属性值。数组中的各个值具有您赋予的任何含义.<br><br>默认情况下，我们提供的PPO算法的输出会预先钳制<code>vectorAction</code>进入[-1，1]范围。 最佳做法是手动剪辑如果您打算在您的环境中使用第三方算法，则也需要这些。</p><h4 id="Discrete-Action-Space"><a href="#Discrete-Action-Space" class="headerlink" title="Discrete Action Space"></a>Discrete Action Space</h4><p>如果Agent使用 <strong>Discrete</strong>向量操作空间，则传递给代理的OnActionReceived()函数的操作参数是一个包含索引的数组。在离散向量作用空间中，<code>Branches</code>是一个<br>整数数组，每个值对应于每个分支。<br>例如，如果我们想要一个可以在平台上移动并跳跃的Agent，我们可以<br>定义两个分支（一个代表运动，一个代表跳跃），因为我们想要<br>代理能够同时移动 <strong>和</strong> 跳。 我们定义第一个分支有5种可能的动作（不要移动，左移，右移，后退，前进），第二个动作有2种可能的动作（不要跳，跳）。 这<br>OnActionReceived（）方法类似于：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Get the action index for movement</span><br><span class="hljs-built_in">int</span> movement = Mathf.FloorToInt(act[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">// Get the action index for jumping</span><br><span class="hljs-built_in">int</span> jump = Mathf.FloorToInt(act[<span class="hljs-number">1</span>]);<br><br><span class="hljs-comment">// Look up the index in the movement action list:</span><br><span class="hljs-keyword">if</span> (movement == <span class="hljs-number">1</span>) &#123; directionX = <span class="hljs-number">-1</span>; &#125;<br><span class="hljs-keyword">if</span> (movement == <span class="hljs-number">2</span>) &#123; directionX = <span class="hljs-number">1</span>; &#125;<br><span class="hljs-keyword">if</span> (movement == <span class="hljs-number">3</span>) &#123; directionZ = <span class="hljs-number">-1</span>; &#125;<br><span class="hljs-keyword">if</span> (movement == <span class="hljs-number">4</span>) &#123; directionZ = <span class="hljs-number">1</span>; &#125;<br><span class="hljs-comment">// Look up the index in the jump action list:</span><br><span class="hljs-keyword">if</span> (jump == <span class="hljs-number">1</span> &amp;&amp; IsGrounded()) &#123; directionY = <span class="hljs-number">1</span>; &#125;<br><br><span class="hljs-comment">// Apply the action results to move the Agent</span><br>gameObject.GetComponent&lt;Rigidbody&gt;().AddForce(<br>    <span class="hljs-keyword">new</span> Vector3(<br>        directionX * <span class="hljs-number">40f</span>, directionY * <span class="hljs-number">300f</span>, directionZ * <span class="hljs-number">40f</span>));<br></code></pre></td></tr></table></figure><p>以上代码示例是AreaAgent的简化摘录类，离散量和连续动作空间都有。</p><h5 id="Masking-Discrete-Actions"><a href="#Masking-Discrete-Actions" class="headerlink" title="Masking Discrete Actions"></a>Masking Discrete Actions</h5><p>使用离散动作时，可以指定某些动作为下一个决定是不可能采用的。 当代理受<br>神经网络控制时，代理将无法执行指定的操作。 注意当代理受Heuristic启发式控制时，代理将仍然能够决定执行屏蔽操作。 为了掩盖动作，请覆盖<code>Agent.CollectDiscreteActionMasks（）</code>虚拟方法，并在其中调用<code>DiscreteActionMasker.SetMask（）</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CollectDiscreteActionMasks</span>(<span class="hljs-params">DiscreteActionMasker actionMasker</span>)</span>&#123;<br>    actionMasker.SetMask(branch, actionIndices)<br>&#125;<br></code></pre></td></tr></table></figure><p>Where:</p><ul><li><code>branch</code> is the index (starting at 0) of the branch on which you want to mask the action</li><li><code>actionIndices</code> is a list of <code>int</code> corresponding to the<br>indices of the actions that the Agent cannot perform.</li></ul><p>例如，如果您有一个具有2个分支的代理，并且在第一个分支<br>（分支0）有4种可能的操作：_“什么都不做” _，_“跳转” _，_“拍摄” _<br>和_“更换武器” _。 然后使用下面的代码，代理将_“ do<br>对于他的下一个决定，无“ _”或“更换武器” _（因为动作索引1和2<br>被遮罩）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">SetMask(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">2</span>]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;)<br></code></pre></td></tr></table></figure><p>注意:</p><ul><li>You can call <code>SetMask</code> multiple times if you want to put masks on<br>multiple branches.</li><li>You cannot mask all the actions of a branch.</li><li>You cannot mask actions in continuous control.</li></ul><h3 id="Rewards"><a href="#Rewards" class="headerlink" title="Rewards"></a>Rewards</h3><p>在强化学习中，奖励是Agent做正确事情的信号。 PPO强化学习算法通过优化代理做出的选择来工作，以使代理随时间获得最高的累积奖励。 您的奖励机制越好，您的代理商将学得越好。<br><br><strong>注意:</strong><br>奖励在Agent使用经过训练的模型进行推理时不会使用，在模仿学习中也不会使用。<br>也许最好的建议是从简单开始，仅在需要时增加复杂性。 通常，您应该奖励结果，而不是您认为会导致期望结果的行动。 为了帮助您获得奖励，您可以使用Monitor类显示代理收到的累积奖励。 您甚至可以在观察代理如何累积奖励的同时，使用代理的启发式方法来控制代理。<br><br>通过调用OnActionReceived（）函数中的AddReward（）方法向代理分配奖励。 每个决策之间分配的奖励应在[-1,1]范围内。 超出此范围的值可能导致训练不稳定。 当Agent收到新决定时，<code>reward</code>值将重置为零。 如果对一个代理决策有多个对<code>AddReward（）</code>的调用，则将这些奖励加起来以评估前一个决策的质量。 有一种名为<code>SetReward()</code> ”的方法，该方法将覆盖自上一个决定以来给予代理的所有先前奖励。</p><h3 id="Agent-Properties"><a href="#Agent-Properties" class="headerlink" title="Agent Properties"></a>Agent Properties</h3><ul><li><code>Behavior Parameters</code> - The parameters dictating what Policy the Agent will<br>receive.<ul><li><code>Behavior Name</code> - 行为的标识符。 具有相同行为名称的代理将学习相同的政策. </li><li><code>Vector Observation</code><ul><li><code>Space Size</code> - Agent的向量观测值的长度。</li><li><code>Stacked Vectors</code> - 将被堆叠并一起用于决策的先前矢量观测的数量。 这导致矢量观察的有效大小被传递给策略为：<em>Space Size</em> x _Stacked Vectors_。</li></ul></li><li><code>Vector Action</code><ul><li><code>Space Type</code> - 对应于动作矢量是否包含单个整数（离散）或一系列实值浮点（连续）.</li><li><code>Space Size</code> (Continuous) - 动作向量的长度.</li><li><code>Branches</code> (Discrete) - 整数数组，定义多个并发的离散操作。 “分支”数组中的值对应于每个操作分支的可能离散值的数量。</li></ul></li><li><code>Model</code> - 用于推理的神经网络模型（训练后获得）</li><li><code>Inference Device</code> - 在推理期间使用CPU还是GPU运行模型</li><li><code>Behavior Type</code> - Determines whether the Agent will do training, inference, or use its<br>Heuristic() method:<ul><li><code>Default</code> - the Agent will train if they connect to a python trainer, otherwise they will perform inference.</li><li><code>Heuristic Only</code> - the Agent will always use the <code>Heuristic()</code> method.</li><li><code>Inference Only</code> - the Agent will always perform inference.</li></ul></li><li><code>Team ID</code> - Used to define the team for <a href="Training-Self-Play.md">self-play</a></li><li><code>Use Child Sensors</code> - Whether to use all Sensor components attached to child GameObjects of this Agent.</li></ul></li><li><code>Max Step</code> - 每个代理的最大步骤数。 一旦这个数字到达后，代理将被重置.</li></ul><h2 id="训练-Agent"><a href="#训练-Agent" class="headerlink" title="训练 Agent"></a>训练 Agent</h2><p>训练过程的输出是一个包含优化后的模型文件政策。 该模型文件是TensorFlow数据图，其中包含数学训练过程中选择的最佳操作和最佳权重。 使用命令<code>mlagents-learn</code> 来训练您的代理。 此命令已安装在<code>mlagents</code>软件包。可在以下位置找到ml-agents &#x2F; mlagents &#x2F; trainers &#x2F; learn.py。<br>可以像<code>config / trainer_config.yaml</code>这样编辑配置文件指定训练期间使用的超参数。您可以使用文本编辑器编辑此文件，以添加特定的配置<br>每个行为。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mlagents-learn &lt;trainer-config-file&gt; --<span class="hljs-built_in">env</span>=&lt;env_name&gt; --run-id=&lt;run-identifier&gt; --train<br></code></pre></td></tr></table></figure><p>在训练过程中，训练程序会定期间隔（由<code>summary_freq</code>选项指定）打印和保存更新。 保存的信息按<code>run-id</code>值分组，因此您应该为每个ID分配一个唯一的ID。<br><br>您可以在训练期间或之后通过运行以下命令使用TensorBoard查看这些统计信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tensorboard --logdir=summaries --port 6006<br></code></pre></td></tr></table></figure><p>之后本地浏览器打开 <code>http://localhost:6006</code>.<br><strong>注意：</strong><br>TensorBoard使用的默认端口是6006。如果存在现有会话在端口6006上运行，可以使用–port在开放的端口上启动新会话选项。<br><br>训练结束后，您可以在<code>models</code> 文件夹中在指定的运行ID下找到保存的模型</p><h3 id="Training-Config-File"><a href="#Training-Config-File" class="headerlink" title="Training Config File"></a>Training Config File</h3><table><thead><tr><th align="left"><strong>Setting</strong></th><th align="left"><strong>Description</strong></th><th align="left"><strong>Applies To Trainer*</strong></th></tr></thead><tbody><tr><td align="left">batch_size</td><td align="left">The number of experiences in each iteration of gradient descent.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">batches_per_epoch</td><td align="left">In imitation learning, the number of batches of training examples to collect before training the model.</td><td align="left"></td></tr><tr><td align="left">beta</td><td align="left">The strength of entropy regularization.</td><td align="left">PPO</td></tr><tr><td align="left">buffer_size</td><td align="left">The number of experiences to collect before updating the policy model. In SAC, the max size of the experience buffer.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">buffer_init_steps</td><td align="left">The number of experiences to collect into the buffer before updating the policy model.</td><td align="left">SAC</td></tr><tr><td align="left">epsilon</td><td align="left">Influences how rapidly the policy can evolve during training.</td><td align="left">PPO</td></tr><tr><td align="left">hidden_units</td><td align="left">The number of units in the hidden layers of the neural network.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">init_entcoef</td><td align="left">How much the agent should explore in the beginning of training.</td><td align="left">SAC</td></tr><tr><td align="left">lambd</td><td align="left">The regularization parameter.</td><td align="left">PPO</td></tr><tr><td align="left">learning_rate</td><td align="left">The initial learning rate for gradient descent.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">learning_rate_schedule</td><td align="left">Determines how learning rate changes over time.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">max_steps</td><td align="left">The maximum number of simulation steps to run during a training session.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">memory_size</td><td align="left">The size of the memory an agent must keep. Used for training with a recurrent neural network. See <a href="Feature-Memory.md">Using Recurrent Neural Networks</a>.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">normalize</td><td align="left">Whether to automatically normalize observations.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">num_epoch</td><td align="left">The number of passes to make through the experience buffer when performing gradient descent optimization.</td><td align="left">PPO</td></tr><tr><td align="left">num_layers</td><td align="left">The number of hidden layers in the neural network.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">behavioral_cloning</td><td align="left">Use demonstrations to bootstrap the policy neural network. See <a href="Training-PPO.md#optional-behavioral-cloning-using-demonstrations">Pretraining Using Demonstrations</a>.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">reward_signals</td><td align="left">The reward signals used to train the policy. Enable Curiosity and GAIL here. See <a href="Reward-Signals.md">Reward Signals</a> for configuration options.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">save_replay_buffer</td><td align="left">Saves the replay buffer when exiting training, and loads it on resume.</td><td align="left">SAC</td></tr><tr><td align="left">sequence_length</td><td align="left">Defines how long the sequences of experiences must be while training. Only used for training with a recurrent neural network. See <a href="Feature-Memory.md">Using Recurrent Neural Networks</a>.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">summary_freq</td><td align="left">How often, in steps, to save training statistics. This determines the number of data points shown by TensorBoard.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">tau</td><td align="left">How aggressively to update the target network used for bootstrapping value estimation in SAC.</td><td align="left">SAC</td></tr><tr><td align="left">time_horizon</td><td align="left">How many steps of experience to collect per-agent before adding it to the experience buffer.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">trainer</td><td align="left">The type of training to perform: “ppo”, “sac”, “offline_bc” or “online_bc”.</td><td align="left">PPO, SAC</td></tr><tr><td align="left">train_interval</td><td align="left">How often to update the agent.</td><td align="left">SAC</td></tr><tr><td align="left">num_update</td><td align="left">Number of mini-batches to update the agent with during each update.</td><td align="left">SAC</td></tr><tr><td align="left">use_recurrent</td><td align="left">Train using a recurrent neural network. See <a href="Feature-Memory.md">Using Recurrent Neural Networks</a>.</td><td align="left">PPO, SAC</td></tr></tbody></table><h2 id="Training-with-Proximal-Policy-Optimization"><a href="#Training-with-Proximal-Policy-Optimization" class="headerlink" title="Training with Proximal Policy Optimization"></a>Training with Proximal Policy Optimization</h2><p>ML-Agents提供一种称为近端策略优化（PPO）的强化学习算法的实现。 PPO使用神经网络来逼近理想功能，该理想功能将代理的观察结果映射到代理在给定状态下可以采取的最佳操作。 ML-Agents PPO算法在TensorFlow中实现，并在单独的Python进程中运行（通过套接字与正在运行的Unity应用程序进行通信）。成功训练强化学习模型通常涉及调整训练超参数。 本指南包含一些最佳实践，用于在默认参数似乎无法达到您想要的性能水平时调整培训过程。</p><h3 id="Hyperparameters"><a href="#Hyperparameters" class="headerlink" title="Hyperparameters"></a>Hyperparameters</h3><h4 id="Reward-Signals"><a href="#Reward-Signals" class="headerlink" title="Reward Signals"></a>Reward Signals</h4><p>在强化学习中，目标是学习使奖励最大化的策略。在基础级别上，奖励是由环境给予的。 但是，我们可以想象奖励代理商各种不同的行为。 例如，我们可以奖励代理商探索新状态，而不仅仅是给出明确的奖励。 此外，我们可以混合奖励信号来帮助学习过程。<br>ML-Agents工具箱默认提供三个奖励信号：外部（环境）奖励信号，好奇心奖励信号（可用于鼓励在稀疏外部奖励环境中进行探索）和GAIL奖励信号。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">reward_signals:</span><br>    <span class="hljs-attr">extrinsic:</span><br>        <span class="hljs-attr">strength:</span> <span class="hljs-number">1.0</span><br>        <span class="hljs-attr">gamma:</span> <span class="hljs-number">0.99</span><br>    <span class="hljs-attr">curiosity:</span><br>        <span class="hljs-attr">strength:</span> <span class="hljs-number">0.02</span><br>        <span class="hljs-attr">gamma:</span> <span class="hljs-number">0.99</span><br>        <span class="hljs-attr">encoding_size:</span> <span class="hljs-number">256</span><br>    <span class="hljs-attr">gail:</span><br>        <span class="hljs-attr">strength:</span> <span class="hljs-number">0.01</span><br>        <span class="hljs-attr">gamma:</span> <span class="hljs-number">0.99</span><br>        <span class="hljs-attr">encoding_size:</span> <span class="hljs-number">128</span><br>        <span class="hljs-attr">demo_path:</span> <span class="hljs-string">Project/Assets/ML-Agents/Examples/Pyramids/Demos/ExpertPyramid.demo</span><br></code></pre></td></tr></table></figure><p>除了任何特定于类的超参数之外，每个奖励信号还应至少定义两个参数“ strength”和“ gamma”。 请注意，要删除奖励信号，您应该从“ reward_signals”中完全删除其条目。 任何时候都应至少定义一个奖励信号。</p><ul><li><p>Reward Signal Types: <br><br>  Strength：Typical Range: <code>1.0</code><br><br>  Gamma：   Typical Range: <code>0.8</code> - <code>0.995</code></p></li><li><p>Curiosity Reward Signal: <br><br>  Strength：Typical Range: <code>0.001</code> - <code>0.1</code><br><br>  Gamma：   Typical Range: <code>0.8</code> - <code>0.995</code><br>  encoding_size:  <code>encoding_size</code>对应于固有好奇心模型使用的编码大小。此值应足够小以鼓励ICM压缩原始观察结果，但也不能太小以防止其学习区分已演示和实际行为。Default Value: <code>64</code>   。Typical Range: <code>64</code> - <code>256</code></p></li><li><p>GAIL Reward Signal: <br><br>  Strength：Typical Range: <code>0.01</code> - <code>1.0</code><br><br>  Gamma：   Typical Range: <code>0.8</code> - <code>0.9</code><br>  demo_path:   <code>demo_path</code>是您的.demo文件或.demo文件目录的路径。<br>  encoding_size:encoding_size对应于鉴别器使用的隐藏层的大小，该值应足够小以鼓励鉴别器压缩原始观测值，但也不能太小以防止其学习区分已证明的行为和实际行为。 大幅增加此大小也会对训练时间产生负面影响。 Default Value: <code>64</code>     Typical Range: <code>64</code> - <code>256</code></p></li></ul><h4 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h4><p><code>lambd</code>对应于计算通用优势估算值（[GAE]（<a href="https://arxiv.org/abs/1506.02438%EF%BC%89%EF%BC%89%E6%97%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E2%80%9C">https://arxiv.org/abs/1506.02438））时使用的“</a> lambda”参数。 这可以认为代理在计算更新的价值估算时多少依赖于其当前价值估算。 低值对应于更多地依赖于当前值估计（可能是高偏差），而高值对应于更多地依赖于在环境中接收到的实际奖励（可能是高方差）。 参数提供了两者之间的折衷，正确的值可以导致更稳定的训练过程。</p><p>Typical Range: <code>0.9</code> - <code>0.95</code></p><h4 id="Buffer-Size"><a href="#Buffer-Size" class="headerlink" title="Buffer Size"></a>Buffer Size</h4><p><code>buffer_size</code>对应于我们进行任何模型学习或更新之前应收集的经验（代理商的观察，行动和获得的奖励）的数量。 **这应该是<code>batch_size</code>**的倍数。 通常，较大的<code>buffer_size</code>对应于更稳定的训练更新。</p><p>Typical Range: <code>2048</code> - <code>409600</code></p><h4 id="Batch-Size"><a href="#Batch-Size" class="headerlink" title="Batch Size"></a>Batch Size</h4><p><code>batch_size</code>是用于梯度下降更新的一次迭代的经验数量。 **这应该始终是<code>buffer_size</code>**的一小部分。 如果您使用的是连续动作空间，则该值应较大（大约1000s）。 如果您使用的是离散操作空间，则该值应较小（约10s）。</p><p>Typical Range (Continuous): <code>512</code> - <code>5120</code></p><p>Typical Range (Discrete): <code>32</code> - <code>512</code></p><h4 id="Number-of-Epochs"><a href="#Number-of-Epochs" class="headerlink" title="Number of Epochs"></a>Number of Epochs</h4><p>num_epoch是梯度下降过程中通过experience buffer的次数。 <code>batch_size</code>越大，可以接受的越大。 减少此设置将确保更新更稳定，但会降低学习速度。</p><p>Typical Range: <code>3</code> - <code>10</code></p><h4 id="Learning-Rate"><a href="#Learning-Rate" class="headerlink" title="Learning Rate"></a>Learning Rate</h4><p><code>learning_rate</code>对应于每个梯度下降更新步骤的强度。 如果训练不稳定，则通常应减少该奖励，并且奖励不能持续增加。</p><p>Typical Range: <code>1e-5</code> - <code>1e-3</code></p><h4 id="Optional-Learning-Rate-Schedule"><a href="#Optional-Learning-Rate-Schedule" class="headerlink" title="(Optional) Learning Rate Schedule"></a>(Optional) Learning Rate Schedule</h4><p>learning_rate_schedule对应于学习率随时间的变化。对于PPO，我们建议递减学习率直到max_steps以便学习更稳定地收敛。 但是，在某些情况下（例如，训练时间未知），可以禁用此功能。</p><p>Options:</p><ul><li><code>linear</code> (default): 线性衰减<code>learning_rate</code>，在<code>max_steps</code>处达到0。</li><li><code>constant</code>: 在整个训练过程中保持学习率恒定.</li></ul><p>Options: <code>linear</code>, <code>constant</code></p><h4 id="Time-Horizon"><a href="#Time-Horizon" class="headerlink" title="Time Horizon"></a>Time Horizon</h4><p><code>time_horizon</code>对应于将每个代理添加到体验缓冲区之前收集多少个体验步骤。 在episode结束之前达到此限制时，将使用价值估算值来预测业务代表当前状态的总体预期回报。 因此，此参数在偏见程度较小但方差估计较高（较长时间范围）与偏倚较大但变化较少的估计值（较短时间范围）之间进行权衡。 如果情节中频繁获得奖励，或者情节过长，<br>数字越小越理想。 此数字应足够大，以捕获代理程序动作序列中的所有重要行为。</p><p>Typical Range: <code>32</code> - <code>2048</code></p><h4 id="Max-Steps"><a href="#Max-Steps" class="headerlink" title="Max Steps"></a>Max Steps</h4><p><code>max_steps</code>对应于训练过程中运行了多少步仿真（乘以跳帧）。 对于更复杂的问题，应该增加该值。</p><p>Typical Range: <code>5e5</code> - <code>1e7</code></p><h4 id="Beta"><a href="#Beta" class="headerlink" title="Beta"></a>Beta</h4><p><code>beta</code>对应于熵正则化的强度，这使策略“更加随机”。 这样可以确保座席在训练过程中正确探索动作空间。 增加此数量将确保采取更多随机动作。 应当对此进行调整，以使熵（可从TensorBoard测量）随着奖励的增加而缓慢减小。 如果熵下降太快，则增加<code>beta</code>。 如果熵下降太慢，则降低<code>beta</code>。.</p><p>Typical Range: <code>1e-4</code> - <code>1e-2</code></p><h4 id="Epsilon"><a href="#Epsilon" class="headerlink" title="Epsilon"></a>Epsilon</h4><p><code>epsilon</code> 对应于梯度下降更新期间新旧策略之间可接受的差异阈值。 将此值设置得较小将导致更稳定的更新，但也会减慢训练过程。</p><p>Typical Range: <code>0.1</code> - <code>0.3</code></p><h4 id="Normalize"><a href="#Normalize" class="headerlink" title="Normalize"></a>Normalize</h4><p><code>normalize</code> 对应于是否对矢量观测输入应用了归一化。 该归一化基于矢量观测值的移动平均值和方差。 规范化对于复杂的连续控制问题很有用，但对于较简单的离散控制问题则可能有害。</p><h4 id="Number-of-Layers"><a href="#Number-of-Layers" class="headerlink" title="Number of Layers"></a>Number of Layers</h4><p><code>num_layers</code>对应于观察输入之后或视觉观察的CNN编码之后存在多少个隐藏层。 对于简单的问题，较少的层可能会更快更有效地进行训练。 对于更复杂的控制问题，可能需要更多的层。</p><h4 id="Hidden-Units"><a href="#Hidden-Units" class="headerlink" title="Hidden Units"></a>Hidden Units</h4><p><code>hidden_units</code> 对应于神经网络的每个完全连接层中有多少个单元。 对于简单的问题，其中正确的操作是观察输入的直接组合，这应该很小。 对于动作是观察变量之间非常复杂的相互作用的问题，此值应该更大。</p><p>Typical Range: <code>32</code> - <code>512</code></p><h4 id="Optional-Visual-Encoder-Type"><a href="#Optional-Visual-Encoder-Type" class="headerlink" title="(Optional) Visual Encoder Type"></a>(Optional) Visual Encoder Type</h4><p><code>vis_encode_type</code>对应于用于对视觉观察进行编码的编码器类型。<br>有效选项包括：</p><ul><li><code>simple</code>（默认）：一个简单的编码器，由两个卷积层组成</li><li><code>nature_cnn</code>：[Mnih等人提出的CNN实现]（<a href="https://www.nature.com/articles/nature14236%EF%BC%89%EF%BC%8C">https://www.nature.com/articles/nature14236），</a><br>由三个卷积层组成</li><li><code>resnet</code>：[IMPALA Resnet实施]（<a href="https://arxiv.org/abs/1802.01561%EF%BC%89%EF%BC%8C">https://arxiv.org/abs/1802.01561），</a><br>由三层堆叠的层组成，每层有两个残余块，<br>比其他两个更大的网络。</li></ul><p>选项：<code>simple</code>，<code>nature_cnn</code>，<code>resnet</code></p><h3 id="Optional-Recurrent-Neural-Network-Hyperparameters"><a href="#Optional-Recurrent-Neural-Network-Hyperparameters" class="headerlink" title="(Optional) Recurrent Neural Network Hyperparameters"></a>(Optional) Recurrent Neural Network Hyperparameters</h3><p>以下超参数仅在<code>use_recurrent</code>设置为true时使用</p><h4 id="Sequence-Length"><a href="#Sequence-Length" class="headerlink" title="Sequence Length"></a>Sequence Length</h4><p><code>sequence_length</code> 对应于训练期间通过网络传递的经验序列的长度。 该时间应足够长，以捕获代理随时间推移可能需要记住的任何信息。 例如，如果您的Agent需要记住物体的速度，则此值可能很小。 如果您的经纪人只需要记住一集开始时只给出一次的信息，则该值应该更大。</p><p>Typical Range: <code>4</code> - <code>128</code></p><h4 id="Memory-Size"><a href="#Memory-Size" class="headerlink" title="Memory Size"></a>Memory Size</h4><p><code>memory_size</code>对应于用于存储策略循环神经网络隐藏状态的浮点数数组的大小。 该值必须是2的倍数，并且应该与您期望代理成功完成任务所需记住的信息量成比例。</p><p>Typical Range: <code>32</code> - <code>256</code></p><h3 id="Optional-Behavioral-Cloning-Using-Demonstrations"><a href="#Optional-Behavioral-Cloning-Using-Demonstrations" class="headerlink" title="(Optional) Behavioral Cloning Using Demonstrations"></a>(Optional) Behavioral Cloning Using Demonstrations</h3><p>在某些情况下，您可能想使用播放器记录的行为来引导代理策略。 这可以帮助指导代理商获得奖励。 行为克隆（BC）增加了模仿示范的训练操作，而不是试图使报酬最大化。<br>要使用BC，请在trainer_config中添加一个“ behavioral_cloning”部分。 例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">behavioral_cloning:<br>    demo_path: .<span class="hljs-regexp">/Project/</span>Assets<span class="hljs-regexp">/ML-Agents/</span>Examples<span class="hljs-regexp">/Pyramids/</span>Demos/ExpertPyramid.demo<br>    strength: <span class="hljs-number">0.5</span><br>    steps: <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><p>以下是BC可用的超参数。</p><h4 id="Strength"><a href="#Strength" class="headerlink" title="Strength"></a>Strength</h4><p><code>strength</code>对应于模仿的学习率相对于PPO的学习率，大致对应于我们允许BC影响政策的强度。</p><p>Typical Range: <code>0.1</code> - <code>0.5</code></p><h4 id="Demo-Path"><a href="#Demo-Path" class="headerlink" title="Demo Path"></a>Demo Path</h4><p><code>demo_path</code>是您的.demo文件或.demo文件目录的路径。 有关<code>.demo</code>文件的更多信息，请参见Training-Imitation-Learning.md（官方文档）。</p><h4 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h4><p>在BC期间，通常希望代理在“看到”奖励后停止使用演示，并允许其优化过去的可用演示和&#x2F;或泛化所提供的演示之外的内容。<br> <code>steps</code>对应于BC有效的训练步骤。 BC的学习率将逐步逐步提高。 将步骤设置为0，以在整个训练过程中持续模仿。</p><h4 id="Optional-Batch-Size"><a href="#Optional-Batch-Size" class="headerlink" title="(Optional) Batch Size"></a>(Optional) Batch Size</h4><p><code>batch_size</code>是用于梯度下降更新的一次迭代的演示经验的数量。 如果未指定，则默认为为PPO定义的<code>batch_size</code>。</p><p>Typical Range (Continuous): <code>512</code> - <code>5120</code></p><p>Typical Range (Discrete): <code>32</code> - <code>512</code></p><h4 id="Optional-Number-of-Epochs"><a href="#Optional-Number-of-Epochs" class="headerlink" title="(Optional) Number of Epochs"></a>(Optional) Number of Epochs</h4><p><code>num_epoch</code>是梯度下降过程中通过体验缓冲区的次数。 如果未指定，则默认为PPO设置的时期数。</p><p>Typical Range: <code>3</code> - <code>10</code></p><h4 id="Optional-Samples-Per-Update"><a href="#Optional-Samples-Per-Update" class="headerlink" title="(Optional) Samples Per Update"></a>(Optional) Samples Per Update</h4><p><code>samples_per_update</code> 是最大样本数<br>在每次模仿更新期间使用。 如果您的演示数据集非常大，则可能需要降低此值，以避免过分适合演示策略。 设置为0可在每个更新步骤训练所有演示。</p><p>Default Value: <code>0</code> (all)</p><p>Typical Range: Approximately equal to PPO’s <code>buffer_size</code></p><h3 id="Training-Statistics"><a href="#Training-Statistics" class="headerlink" title="Training Statistics"></a>Training Statistics</h3><p>要查看训练统计信息，请使用TensorBoard。 </p><h4 id="Cumulative-Reward"><a href="#Cumulative-Reward" class="headerlink" title="Cumulative Reward"></a>Cumulative Reward</h4><p>随着时间的流逝，奖励的总体趋势应持续增加。 预计会有小起起落。 根据任务的复杂性，奖励可能不会显着增加，直到进入培训过程的数百万步为止。</p><h4 id="Entropy"><a href="#Entropy" class="headerlink" title="Entropy"></a>Entropy</h4><p>这对应于决策的随机性。 在训练期间，这应该持续减少。 如果它减小得太快或根本没有减小，则应调整<code>beta</code>（使用离散动作空间时）。</p><h4 id="Learning-Rate-1"><a href="#Learning-Rate-1" class="headerlink" title="Learning Rate"></a>Learning Rate</h4><p>默认情况下，这会随着时间的流逝而减少，除非将<code>learning_rate_schedule</code>设置为<code>constant</code>。</p><h4 id="Policy-Loss"><a href="#Policy-Loss" class="headerlink" title="Policy Loss"></a>Policy Loss</h4><p>这些值会在训练过程中振荡。 通常，它们应小于1.0。</p><h4 id="Value-Estimate"><a href="#Value-Estimate" class="headerlink" title="Value Estimate"></a>Value Estimate</h4><p>这些值应随着累积奖励的增加而增加。 它们对应于Agent预测自己在任何给定时间点会收到多少奖励。</p><h4 id="Value-Loss"><a href="#Value-Loss" class="headerlink" title="Value Loss"></a>Value Loss</h4><p>这些价值将随着奖励的增加而增加，一旦奖励稳定就应减少。</p><h2 id="实例-Gridworld"><a href="#实例-Gridworld" class="headerlink" title="实例 Gridworld"></a>实例 Gridworld</h2><p><a href="https://youtu.be/gu8HE9WKEVI">GridWorld</a></p><p><img src="/2021/02/23/mlagent%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/gridworld.png"></p><ul><li>设置：经典网格世界任务的版本。场景包含代理商，目标，<br>和障碍。</li><li>目标：代理商必须在网格上导航至目标，同时避免<br>障碍。</li><li>代理：环境包含九个具有相同行为参数的代理。</li><li>Agent奖励功能：<ul><li>-0.01每一步。</li><li>+1.0，如果座席导航到网格的目标位置（情节结束）。</li><li>-1.0，如果特工导航到障碍物（情节结束）。</li></ul></li><li>行为参数：<ul><li>向量观察空间：无</li><li>向量动作空间：（离散）大小为4，对应于运动<br>基本方向。请注意，对于这种环境，<br>[动作遮罩]（Learning-Environment-Design-Agents.md＃masking-discrete-actions）<br>默认情况下处于打开状态（此选项可以切换<br>使用“ trueAgent” GameObject中的“屏蔽动作”复选框。<br>提供的经过训练的模型文件是在启用操作屏蔽的情况下生成的。</li><li>视觉观察：对应于GridWorld的自顶向下视图。</li></ul></li><li>浮动属性：三个，分别对应于网格大小，障碍物数量和<br>目标数。</li><li>基准平均奖励：0.8</li></ul>]]></content>
      
      
      <categories>
          
          <category> mlagent </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp常用函数</title>
      <link href="/2021/02/08/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2021/02/08/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>本篇旨在记录算法学习过程中所遇所用到的c&#x2F;c++函数及技巧 以备复习</p><!---more--><h2 id="C-String类"><a href="#C-String类" class="headerlink" title="C++ String类"></a>C++ String类</h2><h3 id="常见函数："><a href="#常见函数：" class="headerlink" title="常见函数："></a>常见函数：</h3><ul><li><p>插入： insert(位置，待插入字符串)</p></li><li><p>删除： erase(pos , len) pos  <br>表示要删除的子字符串的起始下标，len 表示要删除子字符串的长度。如果不指明 len 的话，那么直接删除从 pos 到字符串结束处的所有字符（此时 len &#x3D; str.length - pos）。</p></li><li><p>提取字符串：string substr (size_t pos &#x3D; 0, size_t len &#x3D; npos) const; <br><br>pos 为要提取的子字符串的起始下标，len 为要提取的子字符串的长度。</p></li><li><p>字符串查找<br></p><ol><li>find()：第一个参数为待查找的子字符串，它可以是 string 字符串，也可以是C风格的字符串。第二个参数为开始查找的位置（下标）；如果不指明，则从第0个字符开始查找。</li><li>rfind()：rfind() 和 find() 很类似，同样是在字符串中查找子字符串，不同的是 find() 函数从第二个参数开始往后查找，而 rfind() 函数则最多查找到第二个参数处，如果到了第二个参数所指定的下标还没有找到子字符串，则返回一个无穷大值4294967295。</li><li>find_first_of():find_first_of() 函数用于查找子字符串和字符串共同具有的字符在字符串中首次出现的位置<br><br>例:<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">string <span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;first second second third&quot;</span>;<br>string <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;asecond&quot;</span>;<br>int index = <span class="hljs-built_in">s1</span>.find_first_of(<span class="hljs-built_in">s2</span>);<br><br>运行结果：<br>Found <span class="hljs-built_in">at</span> index : <span class="hljs-number">3</span><br>本例中 <span class="hljs-built_in">s1</span> 和 <span class="hljs-built_in">s2</span> 共同具有的字符是 ’s’，该字符在 <span class="hljs-built_in">s1</span> 中首次出现的下标是<span class="hljs-number">3</span>，故查找结果返回<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p>数值转换 <a href="https://blog.csdn.net/tengfei461807914/article/details/52203202">链接</a></p></li><li><p>其他用法 <a href="https://blog.csdn.net/fdqw_sph/article/details/54233971">链接</a></p></li></ul><p>string数值转换<br><img src="/2021/02/08/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2.png"><br>char转string<br><img src="/2021/02/08/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/char%E8%BD%ACstring.png"></p><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><p>格式字符有d,o,x,u,c,s,f,e,g等。 </p><ul><li><p>%d：就是普通的输出</p></li><li><p>%2d：是将数字按宽度为2，采用右对齐方式输出，若数据位数不到2位，则左边补空格</p></li><li><p>%02d：和%2d差不多，只不过左边补0</p></li><li><p>％d: 整型输出，％ld长整型输出，</p></li><li><p>％o: 以八进制数形式输出整数，</p></li><li><p>％x: 以十六进制数形式输出整数，或输出字符串的地址。</p></li><li><p>％u: 以十进制数输出unsigned型数据(无符号数)。注意：%d与%u有无符号的数值范围，也就是极限的值，不然数值打印出来会有误。</p></li><li><p>％c: 用来输出一个字符，</p></li><li><p>％s: 用来输出一个字符串，</p></li><li><p>％f: 用来输出实数，以小数形式输出，默认情况下保留小数点6位。</p></li><li><p>%.100f: 用来输出实数，保留小数点100位。</p></li><li><p>％e:以指数形式输出实数，</p></li><li><p>％g:根据大小自动选f格式或e格式，且不输出无意义的零</p></li></ul><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="判断素数"><a href="#判断素数" class="headerlink" title="判断素数"></a>判断素数</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs abnf">bool IsPrime(int n)<br>&#123;<br>if(n &lt;<span class="hljs-operator">=</span> <span class="hljs-number">1</span>)&#123;<br>cout&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot;不是素数&quot;</span>&lt;&lt;endl<span class="hljs-comment">; </span><br>return false<span class="hljs-comment">;</span><br>&#125;<br>    for (int i <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">; i &lt; n; i++)</span><br>    &#123;<br>        if ((n % i) <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span>)&#123;<br>            cout&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot;不是素数&quot;</span>&lt;&lt;endl<span class="hljs-comment">;</span><br>            return false<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>    cout&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot;是素数&quot;</span>&lt;&lt;endl<span class="hljs-comment">;</span><br>    return true<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断闰年"><a href="#判断闰年" class="headerlink" title="判断闰年"></a>判断闰年</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">int</span> isRunyear(<span class="hljs-keyword">int</span> x)<br>&#123;<br>    <span class="hljs-keyword">if</span>(x%100!=<span class="hljs-number">0</span>&amp;&amp;x%4==<span class="hljs-number">0</span>||x%400==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="日期模版"><a href="#日期模版" class="headerlink" title="日期模版"></a>日期模版</h3><p>题目描述：有两个日期，求两个日期之间的天数，如果两个日期是连续的我们规定他们之间的天数为两天</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isRunyear</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span>&amp;&amp;x%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>||x%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//0代表不是闰年 28天  1   29天 </span><br><span class="hljs-type">int</span> month[<span class="hljs-number">2</span>][<span class="hljs-number">13</span>]=&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;,<br>                  &#123;<span class="hljs-number">0</span>,<span class="hljs-number">31</span>,<span class="hljs-number">29</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Date</span>&#123;<br>    <span class="hljs-type">int</span> Day;<br>    <span class="hljs-type">int</span> Month;<br>    <span class="hljs-type">int</span> Year;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nextDay</span><span class="hljs-params">()</span></span>&#123;<br>        Day++;<br>        <span class="hljs-type">int</span> isrun=<span class="hljs-built_in">isRunyear</span>(Year);<br>        <span class="hljs-keyword">if</span>(Day&gt;month[isrun][Month])<br>        &#123;<br>            Day=<span class="hljs-number">1</span>;<br>            Month++;<br>            <span class="hljs-keyword">if</span>(Month&gt;<span class="hljs-number">12</span>)<br>            &#123;<br>               Month=<span class="hljs-number">1</span>;<br>               Year++;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>&#125;;<br><span class="hljs-type">int</span> buf[<span class="hljs-number">5001</span>][<span class="hljs-number">13</span>][<span class="hljs-number">32</span>]; <span class="hljs-comment">//保存预处理的天数</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Date tmp;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录天数插值</span><br>    tmp.Year=<span class="hljs-number">0</span>;<br>    tmp.Month=<span class="hljs-number">1</span>;<br>    tmp.Day=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(tmp.Year!=<span class="hljs-number">5000</span>)<br>    &#123;<br>        buf[tmp.Year][tmp.Month][tmp.Day]=cnt;<br>        tmp.<span class="hljs-built_in">nextDay</span>();<br>        cnt++;<br>    &#125;<br>    <span class="hljs-type">int</span> Y1,M1,D1;<br>    <span class="hljs-type">int</span> Y2,M2,D2;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%4d%2d%2d&quot;</span>,&amp;Y1,&amp;M1,&amp;D1)!=EOF)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%4d%2d%2d&quot;</span>,&amp;Y2,&amp;M2,&amp;D2);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">abs</span>(buf[Y2][M2][D2]-buf[Y1][M1][D1])+<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断星期几"><a href="#判断星期几" class="headerlink" title="判断星期几"></a>判断星期几</h3><p>利用基姆拉尔森计算日期公式  w&#x3D;(d+2<em>m+3</em>(m+1)&#x2F;5+y+y&#x2F;4-y&#x2F;100+y&#x2F;400)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">getWeekdayByYearday</span><span class="hljs-params">(<span class="hljs-type">int</span> iY, <span class="hljs-type">int</span> iM, <span class="hljs-type">int</span> iD)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> iWeekDay = <span class="hljs-number">-1</span>; <br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == iM || <span class="hljs-number">2</span> == iM) <br>    &#123;   <br>        iM += <span class="hljs-number">12</span>; <br>        iY--;<br>    &#125;   <br>    iWeekDay = (iD + <span class="hljs-number">1</span> + <span class="hljs-number">2</span> * iM + <span class="hljs-number">3</span> * (iM + <span class="hljs-number">1</span>) / <span class="hljs-number">5</span> + iY + iY / <span class="hljs-number">4</span> - iY / <span class="hljs-number">100</span> + iY / <span class="hljs-number">400</span>) % <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">switch</span>(iWeekDay)<br>    &#123;   <br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> : <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Sunday&quot;</span>; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> : <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Monday&quot;</span>; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> : <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Tuesday&quot;</span>; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span> : <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Wednesday&quot;</span>; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span> : <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Thursday&quot;</span>; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span> : <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Friday&quot;</span>; <span class="hljs-keyword">break</span>;                                                             <br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span> : <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Saturday&quot;</span>; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span> : <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-keyword">break</span>;<br>    &#125;   <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> year,month,day;<br>    <span class="hljs-type">char</span> ch=<span class="hljs-string">&#x27;1&#x27;</span>;<br>    <span class="hljs-keyword">while</span>(ch != <span class="hljs-string">&#x27;\033&#x27;</span>)<br>    &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n请输入日期：\n格式为：1900,1,1\n&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d,%d,%d&quot;</span>,&amp;year,&amp;month,&amp;day);<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> * p = <span class="hljs-built_in">getWeekdayByYearday</span>(year, month, day);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WeekDay : %s\n&quot;</span>, p);<br>        ch = <span class="hljs-built_in">getchar</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Repeater"><a href="#Repeater" class="headerlink" title="Repeater"></a>Repeater</h3><p><img src="/2021/02/08/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/Repeater1.png"><br><img src="/2021/02/08/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/%E8%BE%93%E5%85%A5.png"><br><img src="/2021/02/08/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/%E8%BE%93%E5%87%BA.png"></p><p>代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">char</span> map[<span class="hljs-number">3003</span>][<span class="hljs-number">3003</span>];<br><span class="hljs-type">char</span> str[<span class="hljs-number">6</span>][<span class="hljs-number">6</span>];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)<br>                map[x + i][y + j] = str[i][j];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> size = (<span class="hljs-type">int</span>)<span class="hljs-built_in">pow</span>(n*<span class="hljs-number">1.0</span>, m - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>            <span class="hljs-keyword">if</span> (str[i][j] != <span class="hljs-string">&#x27; &#x27;</span>)<br>                <span class="hljs-built_in">dfs</span>(m - <span class="hljs-number">1</span>, x + i*size, y + j*size);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    n = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n)&#123;<br>        cin &gt;&gt; n;<br>        <span class="hljs-built_in">getchar</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            cin.<span class="hljs-built_in">getline</span>(str[i],<span class="hljs-number">6</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> m;<br>        cin &gt;&gt; m;<br>        <span class="hljs-type">int</span> size = (<span class="hljs-type">int</span>)<span class="hljs-built_in">pow</span>(n*<span class="hljs-number">1.0</span>, m);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;size; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;size; j++)<br>                map[i][j] = <span class="hljs-string">&#x27; &#x27;</span>;<br>            map[i][size] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(m, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;size; i++)<br>            cout&lt;&lt;map[i]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><br></code></pre></td></tr></table></figure><h3 id="二分搜索模版"><a href="#二分搜索模版" class="headerlink" title="二分搜索模版"></a>二分搜索模版</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">while</span>(base&lt;=<span class="hljs-built_in">top</span>)<br>&#123;<br>    int <span class="hljs-built_in">mid</span>=(base+<span class="hljs-built_in">top</span>)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(a[<span class="hljs-built_in">mid</span>].xuehao==x)<br>    &#123;<br>        flag=<span class="hljs-number">1</span>;<br>        cout&lt;&lt;a[<span class="hljs-built_in">mid</span>].xuehao&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;a[<span class="hljs-built_in">mid</span>].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;a[<span class="hljs-built_in">mid</span>].xingbie&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;a[<span class="hljs-built_in">mid</span>].age&lt;&lt;endl;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(a[<span class="hljs-built_in">mid</span>].xuehao&gt;x)<br>        &#123;<br>            <span class="hljs-built_in">top</span>=<span class="hljs-built_in">mid</span><span class="hljs-number">-1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            base=<span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="矩阵旋转"><a href="#矩阵旋转" class="headerlink" title="矩阵旋转"></a>矩阵旋转</h3><p><img src="/2021/02/08/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/%E7%9F%A9%E9%98%B5%E6%97%8B%E8%BD%AC.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span><br>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> *a;<br>    *a = *b;<br>    *b = t;<br>&#125;<br><br><span class="hljs-comment">// 逆时针旋转</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">transpose</span><span class="hljs-params">(<span class="hljs-type">int</span> a[][<span class="hljs-number">4</span>], <span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; j &lt; n; j++)<br>            swap(a[i][j], a[j][i]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)<br>            swap(a[i][j], a[n - <span class="hljs-number">1</span> - i][j]);<br>&#125;<br><br><span class="hljs-comment">// 顺时针旋转</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">clockwise</span><span class="hljs-params">(<span class="hljs-type">int</span> a[][<span class="hljs-number">4</span>], <span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n - i; j++)<br>            swap(a[i][j], a[n - <span class="hljs-number">1</span> - j][n - <span class="hljs-number">1</span> - i]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)<br>            swap(a[i][j], a[n - <span class="hljs-number">1</span> - i][j]);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL常见用法总结</title>
      <link href="/2021/02/07/STL%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2021/02/07/STL%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本篇旨在记载STL一些常见函数及用法以备记忆</p><span id="more"></span><h1 id="栈容器-stack"><a href="#栈容器-stack" class="headerlink" title="栈容器 stack"></a>栈容器 stack</h1><p>用法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">头文件：<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>empty() 堆栈为空则返回真</li><li>pop() 移除栈顶元素</li><li>push() 在栈顶增加元素</li><li>size() 返回栈中元素数目</li><li>top() 返回栈顶元素</li></ul><p>初始化：    <code>stack&lt;int&gt;  s</code></p><p>示例：简单计算器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>stack&lt;<span class="hljs-type">char</span>&gt; op; <span class="hljs-comment">//符号栈</span><br>stack&lt;<span class="hljs-type">float</span>&gt; num; <span class="hljs-comment">//数字栈</span><br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-type">float</span> num1, <span class="hljs-type">float</span> num2, <span class="hljs-type">char</span> op)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span>)<br>        <span class="hljs-keyword">return</span> num1 + num2;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;-&#x27;</span>)<br>        <span class="hljs-keyword">return</span> num2 - num1;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span>)<br>        <span class="hljs-keyword">return</span> num2 * num1;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;/&#x27;</span>)<br>        <span class="hljs-keyword">return</span> num2 / num1;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; s &amp;&amp; s != <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">//读入一行表达式</span><br>    &#123;<br>        <span class="hljs-comment">//cout&lt;&lt;&quot;开始处理&quot;&lt;&lt;endl;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">float</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;+&#x27;</span> || s[i] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>            &#123;<br>                <span class="hljs-comment">// cout&lt;&lt;s[i]&lt;&lt;endl;</span><br>                <span class="hljs-keyword">while</span> (!op.<span class="hljs-built_in">empty</span>())<br>                &#123;<br>                    <span class="hljs-type">char</span> tmpop = op.<span class="hljs-built_in">top</span>();<br>                    op.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-type">float</span> num1 = num.<span class="hljs-built_in">top</span>();<br>                    num.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-type">float</span> num2 = num.<span class="hljs-built_in">top</span>();<br>                    num.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-type">float</span> calnum = <span class="hljs-built_in">cal</span>(num1, num2, tmpop);<br>                    num.<span class="hljs-built_in">push</span>(calnum);<br>                &#125;<br><br>                op.<span class="hljs-built_in">push</span>(s[i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;*&#x27;</span> || s[i] == <span class="hljs-string">&#x27;/&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (!op.<span class="hljs-built_in">empty</span>())<br>                &#123;<br>                    <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;+&#x27;</span> &amp;&amp; op.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;-&#x27;</span>)<br>                    &#123;<br>                        <span class="hljs-type">char</span> tmpop = op.<span class="hljs-built_in">top</span>();<br>                        op.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-type">float</span> num1 = num.<span class="hljs-built_in">top</span>();<br>                        num.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-type">float</span> num2 = num.<span class="hljs-built_in">top</span>();<br>                        num.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-type">float</span> calnum = <span class="hljs-built_in">cal</span>(num1, num2, tmpop);<br>                        num.<span class="hljs-built_in">push</span>(calnum);<br>                    &#125;<br>                &#125;<br><br>                op.<span class="hljs-built_in">push</span>(s[i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// cout&lt;&lt;&quot;处理数字&quot;&lt;&lt;s[i]&lt;&lt;endl;</span><br>                <span class="hljs-comment">//输入字符  转数字</span><br><br>                <span class="hljs-type">float</span> sum = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (s[i] != <span class="hljs-string">&#x27;+&#x27;</span> &amp;&amp; s[i] != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; s[i] != <span class="hljs-string">&#x27;*&#x27;</span> &amp;&amp; s[i] != <span class="hljs-string">&#x27;/&#x27;</span> &amp;&amp; i &lt; s.<span class="hljs-built_in">length</span>())<br>                &#123;<br>                    sum = sum * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                    <span class="hljs-comment">//  cout&lt;&lt;sum&lt;&lt;endl;</span><br>                    i++;<br>                &#125;<br>                i--;<br>                <span class="hljs-comment">//cout &lt;&lt; &quot;sum=&quot; &lt;&lt; sum &lt;&lt; &quot; &quot;&lt;&lt;endl;</span><br>                num.<span class="hljs-built_in">push</span>(sum); <span class="hljs-comment">//存数字</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// cout&lt;&lt;&quot;op栈大小&quot;&lt;&lt;op.size()&lt;&lt;endl;</span><br>        <span class="hljs-comment">//根据op栈处理num栈</span><br>        <span class="hljs-keyword">while</span> (!op.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">char</span> tmpop = op.<span class="hljs-built_in">top</span>();<br>            op.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">float</span> num1 = num.<span class="hljs-built_in">top</span>(); cout&lt;&lt;<span class="hljs-string">&quot;num1=&quot;</span>&lt;&lt;num1&lt;&lt;endl;<br>            num.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">float</span> num2 = num.<span class="hljs-built_in">top</span>(); cout&lt;&lt;<span class="hljs-string">&quot;num2=&quot;</span>&lt;&lt;num2&lt;&lt;endl;<br>            num.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">float</span> calnum = <span class="hljs-built_in">cal</span>(num1, num2, tmpop);<br>            num.<span class="hljs-built_in">push</span>(calnum);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2f\n&quot;</span>,num.<span class="hljs-built_in">top</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="优先队列-实现堆-（应用：哈夫曼树）"><a href="#优先队列-实现堆-（应用：哈夫曼树）" class="headerlink" title="优先队列-实现堆 （应用：哈夫曼树）"></a>优先队列-实现堆 （应用：哈夫曼树）</h1><p>使用之前的预处理：<br><code>include&lt;queue&gt;</code></p><p>利用语句：<code>priority_queue&lt;int&gt; Q; </code>   建立一个保存元素为int的堆Q，默认为大根堆</p><p>利用语句：<code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; Q; </code>定义小根堆</p><p>关于堆的操作如下：</p><p><code>Q.push(x); </code> 将元素x放入堆Q中</p><p><code>Q.top(); </code> 取出堆顶元素</p><p><code>Q.pop(); </code> 弹出堆顶元素，取出后堆会自动调整为一个新的小顶堆</p><p>例：<br><img src="/2021/02/07/STL%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt; &gt; Q;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>())<br>            Q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> a;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            cin &gt;&gt; a;<br>            Q.<span class="hljs-built_in">push</span>(a);<br>        &#125;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(Q.<span class="hljs-built_in">size</span>() &gt;<span class="hljs-number">1</span>)  <span class="hljs-comment">//不算入根节点，最后一个节点为根节点</span><br>        &#123;<br>            <span class="hljs-type">int</span> a1=Q.<span class="hljs-built_in">top</span>();<br>            Q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> a2=Q.<span class="hljs-built_in">top</span>();<br>            Q.<span class="hljs-built_in">pop</span>();<br>            ans+=a1+a2;<br>            Q.<span class="hljs-built_in">push</span>(a1+a2);<br>        &#125;<br>        cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">map</span>&lt;string,<span class="hljs-keyword">int</span>&gt; M;<span class="hljs-regexp">//</span>定义一个完成从string到<span class="hljs-keyword">int</span>映射的<span class="hljs-keyword">map</span><br>M.clear();<span class="hljs-regexp">//</span>清空一个<span class="hljs-keyword">map</span><br>M.find(b);<span class="hljs-regexp">//</span>确定<span class="hljs-keyword">map</span>中是否保存string对象b的映射，若没有函数返回M.end()<br>M[b]=idx;<span class="hljs-regexp">//</span>若<span class="hljs-keyword">map</span>中不存在string对象b的映射，则定义其映射为b映射为idx<br>idxb=M[b];<span class="hljs-regexp">//</span>若<span class="hljs-keyword">map</span>中存在string对象b的映射，则读出该映射<br></code></pre></td></tr></table></figure><p><img src="/2021/02/07/STL%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/%E6%98%A0%E5%B0%84.png"></p><p>样例输入</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">3</span><br>Alice Bob Smith John Alice Smith<br><span class="hljs-number">5</span><br><span class="hljs-selector-tag">a</span> c c d d e <span class="hljs-selector-tag">b</span> e <span class="hljs-selector-tag">a</span> d <br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">Yes</span> <br><span class="hljs-keyword">No</span><br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>map&lt;string, <span class="hljs-type">int</span>&gt; arr;<br><span class="hljs-type">int</span> in[<span class="hljs-number">2002</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &amp;&amp; n)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n; i++) <span class="hljs-comment">//n组胜负关系，至多存在n个队伍</span><br>            in[i] = <span class="hljs-number">0</span>;<br>        string a, b;<br>        arr.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//对map中的映射关系清空</span><br>        <span class="hljs-type">int</span> idx=<span class="hljs-number">0</span>;<span class="hljs-comment">//下一个被映射的数字</span><br>        <span class="hljs-keyword">while</span> (n--)<br>        &#123;<br>            cin &gt;&gt; a &gt;&gt; b;<br>            <span class="hljs-type">int</span> idxa,idxb;<br>            <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">find</span>(a) == arr.<span class="hljs-built_in">end</span>())<span class="hljs-comment">//若尚无对a的映射</span><br>            &#123;<br>               idxa=idx;<br>               arr[a]=idx++;<span class="hljs-comment">//设定其映射为idx，并递增idx</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> idxa=arr[a];<span class="hljs-comment">//否则直接读出该映射</span><br>            <span class="hljs-keyword">if</span>(arr.<span class="hljs-built_in">find</span>(b)==arr.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                idxb=idx;<br>                arr[b]=idx++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> idxb=arr[b];<br>            in[idxb]++;<span class="hljs-comment">//b的入度递增</span><br>        &#125;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;idx;i++)<br>        &#123;<br>            <span class="hljs-comment">//确定所有映射数字的入度，统计入度为0的个数</span><br>            <span class="hljs-keyword">if</span>(in[i]==<span class="hljs-number">0</span>)<br>              cnt++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">1</span>) cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关联规则挖掘系统</title>
      <link href="/2020/01/13/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/01/13/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>这学期的大数据课设由三部分组成，记录自己负责的关联规则挖掘系统部分内容。<br><br>环境：代码由python实现，版本为3.7版本，界面设计采用tkinter，采用两种算法：Apriori和fpgrowth<br></p><span id="more"></span><p>Apriori算法使用python的模块<strong>efficient-apriori</strong>，<br><img src="/Apriori.png"><br>fpgrowth算法采用<strong>orange-associate</strong>模块，其实fpgrowth算法在python中有更好地封装：pyfpgrowth<br><img src="/2020/01/13/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98%E7%B3%BB%E7%BB%9F/pyfpgrowth.png"><br>系统的主界面如下图：<br><img src="/2020/01/13/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98%E7%B3%BB%E7%BB%9F/%E4%B8%BB%E7%95%8C%E9%9D%A2.png"></p><p>在做课设的时候，有一个要求的画出fp树，查阅网上资料后发现并没有好的实现方法，至少我试过了没有得到理想的效果<br><br>但是在github上找到一个html+js编写的画fptree的网页,<a href="https://github.com/janithl/FPTreeSimulator/blob/master/index.html">点此跳转</a></p><p>于是就想着将这个网页嵌入python中，如果是pyqt实现的页面的话是比较好解决的，但是tkinter的话，最后找到唯一的一个方法就是使用cefpython3模块，可以内嵌浏览器。<br><br>此系统读入数据可放入txt文件中，格式如下:<br><img src="/2020/01/13/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE.png" alt="读入数据格式"><br><br>数据可以是汉字，字母，数字。</p><p>本系统所有代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Created on Thu Dec 19 22:15:06 2019</span><br><span class="hljs-string"></span><br><span class="hljs-string">@author: shanhainanhua</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> filedialog<br><span class="hljs-comment">#from fptree import *</span><br><span class="hljs-comment">#from pymining import itemmining,assocrules</span><br><span class="hljs-keyword">from</span> orangecontrib.associate.fpgrowth <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> efficient_apriori <span class="hljs-keyword">import</span> apriori<br><span class="hljs-keyword">from</span> orangecontrib.associate.fpgrowth <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> functools<br><br><br><span class="hljs-keyword">global</span> minsupport<br><span class="hljs-keyword">global</span> minconfidence<br><br>data=[]<br><span class="hljs-comment">#事件函数</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">LoadData</span>():<br>    <span class="hljs-keyword">global</span> data<br>    data=[]<br>    file_path=filedialog.askopenfilename(title=<span class="hljs-string">&#x27;打开单个文件&#x27;</span>,<br>    filetypes=[(<span class="hljs-string">&#x27;All Files&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>),(<span class="hljs-string">&quot;文本文件&quot;</span>, <span class="hljs-string">&#x27;*.txt&#x27;</span>)], <span class="hljs-comment"># 只处理的文件类型</span><br>    initialdir=<span class="hljs-string">&#x27;g:/&#x27;</span>) <span class="hljs-comment"># 初始目录</span><br>    <span class="hljs-built_in">print</span>(file_path)<br>    e1_value=file_path<br>    <span class="hljs-comment">#e1.delete(1,END)</span><br>    e1.insert(END,e1_value)<br>    e1.grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">1</span>,pady=<span class="hljs-number">18</span>,padx=<span class="hljs-number">10</span>)<br>    f=<span class="hljs-built_in">open</span>(file_path,<span class="hljs-string">&#x27;rb&#x27;</span>).readlines()<br>   <br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>        <span class="hljs-comment">#line = line.decode(&#x27;gbk&#x27;).strip()</span><br>        line = line.decode(<span class="hljs-string">&#x27;UTF-8&#x27;</span>).strip()<br>        tmp=[]<br>        <span class="hljs-comment">#line=line.split(&quot;,&quot;)</span><br>        line=line.split(<span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> line:<br>            tmp.append(<span class="hljs-built_in">str</span>(item))<br>        data.append(tmp)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入的数据为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(data))<br><br>   <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Start</span>():<br>    <span class="hljs-comment">#先获取组件的值</span><br>    <span class="hljs-keyword">global</span> minsupport<br>    <span class="hljs-keyword">global</span> minconfidence<br>    minsupport=<span class="hljs-built_in">float</span>(e2.get())<br>    minconfidence=<span class="hljs-built_in">float</span>(e3.get())<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;minsupport=&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(minsupport))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;minconfidence=&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(minconfidence))<br>    choice=<span class="hljs-built_in">int</span>(r.get())<br>    <span class="hljs-keyword">if</span> choice==<span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;选择了Apriori算法&quot;</span>)<br>        DoApriori()<br>        <br>    <span class="hljs-keyword">if</span> choice==<span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;选择了fp-growth算法&quot;</span>)<br>        DoFpGrowth()<br>    <br>    <br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">DoApriori</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    datalen=len(data)</span><br><span class="hljs-string">    thisminsupport=minsupport/datalen</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    itemsets, rules = apriori(data, minsupport,  minconfidence)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;频繁项集为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(itemsets))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;关联规则为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(rules))<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> itemsets:<br>        <span class="hljs-built_in">print</span>(item)<br>    <span class="hljs-keyword">for</span> rule <span class="hljs-keyword">in</span> rules:<br>        <span class="hljs-built_in">print</span>(rule)<br>    text_result.insert(END,<span class="hljs-string">&quot;使用Apriori算法生成频繁项集和关联规则\n&quot;</span>)<br>    text_result.insert(END,(<span class="hljs-string">&quot;频繁项集为：\n&quot;</span>+<span class="hljs-built_in">str</span>(itemsets)+<span class="hljs-string">&quot;\n&quot;</span>))<br>    text_result.insert(END,(<span class="hljs-string">&quot;关联规则为：\n&quot;</span>+<span class="hljs-built_in">str</span>(rules)+<span class="hljs-string">&quot;\n&quot;</span>))<br>   <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">DoFpGrowth</span>():<br>    strSet = <span class="hljs-built_in">set</span>(functools.reduce(<span class="hljs-keyword">lambda</span> a,b:a+b, data))<br>    strEncode = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(strSet,<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(strSet)))) <span class="hljs-comment">#编码字典，即:&#123;&#x27;ArticleTag_BS&#x27;: 6,&#x27;Country_Argentina&#x27;: 53,etc...&#125;</span><br>    strDecode = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(strEncode.values(), strEncode.keys()))  <span class="hljs-comment">#解码字典，即:&#123;6:&#x27;ArticleTag_BS&#x27;,53:&#x27;Country_Argentina&#x27;,etc...&#125;</span><br>    data_int = [<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> item:strEncode[item],row)) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> data]   <span class="hljs-comment">#编码后的输入数据       </span><br>    itemsets=frequent_itemsets(data_int,<span class="hljs-number">.4</span>)<br>    itemsets=<span class="hljs-built_in">dict</span>(itemsets)<br>    <span class="hljs-comment">#print(itemsets)</span><br>    rules = association_rules(itemsets, <span class="hljs-number">.5</span>)   <span class="hljs-comment">#这里设置置信度</span><br>    rules = <span class="hljs-built_in">list</span>(rules)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;关联规则\n&quot;</span>)<br>    <span class="hljs-built_in">print</span>(rules)<br>    start=<span class="hljs-number">0</span><br>    tmpitem=[]<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> itemsets:<br>        tmpj=[]<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> item:<br>          j=strDecode[j]<br>          tmpj.append(j)<br>        tmpitem.append(<span class="hljs-built_in">set</span>(tmpj))<br>    tmprules=[]<br>    <span class="hljs-keyword">for</span> rule <span class="hljs-keyword">in</span> rules:<br>        tmpj=[]<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> rule[:-<span class="hljs-number">2</span>]:<br>           j=strDecode[<span class="hljs-built_in">list</span>(j)[<span class="hljs-number">0</span>]]<br>           tmpj.append(j)<br>        tmprules.append(tmpj)<br>    text_result.insert(END,<span class="hljs-string">&quot;使用fp-growth算法生成频繁项集和关联规则\n&quot;</span>)<br>    text_result.insert(END,(<span class="hljs-string">&quot;频繁项集为：\n&quot;</span>+<span class="hljs-built_in">str</span>(tmpitem)+<span class="hljs-string">&quot;\n&quot;</span>))<br>    text_result.insert(END,(<span class="hljs-string">&quot;关联规则为：\n&quot;</span>+<span class="hljs-built_in">str</span>(tmprules)+<span class="hljs-string">&quot;\n&quot;</span>))<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Clear</span>():<br>    text_result.delete(<span class="hljs-number">1.0</span>,<span class="hljs-string">&#x27;end&#x27;</span>)<br>    e1.delete(<span class="hljs-number">2.0</span>,END)<br>    e2.delete(<span class="hljs-number">0</span>, END)<br>    e3.delete(<span class="hljs-number">0</span>, END)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Close</span>():<br>    root.quit()<br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">showtree</span>():<br>    root.deiconify()<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">save_file</span>():<br>  file_path = filedialog.asksaveasfilename(title=<span class="hljs-string">u&#x27;保存文件&#x27;</span>)<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;保存文件：&#x27;</span>, file_path)<br>  file_text = text_result.get(<span class="hljs-string">&#x27;1.0&#x27;</span>,END)<br>  <span class="hljs-keyword">if</span> file_path <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file=file_path, mode=<span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>      file.write(file_text)<br>    dialog.Dialog(<span class="hljs-literal">None</span>, &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;File Modified&#x27;</span>, <span class="hljs-string">&#x27;text&#x27;</span>: <span class="hljs-string">&#x27;保存完成&#x27;</span>, <span class="hljs-string">&#x27;bitmap&#x27;</span>: <span class="hljs-string">&#x27;warning&#x27;</span>, <span class="hljs-string">&#x27;default&#x27;</span>: <span class="hljs-number">0</span>,<br>               <span class="hljs-string">&#x27;strings&#x27;</span>: (<span class="hljs-string">&#x27;OK&#x27;</span>, <span class="hljs-string">&#x27;Cancle&#x27;</span>)&#125;)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;保存完成&#x27;</span>)<br><br><span class="hljs-comment">#创建界面，进行事件绑定</span><br>root1 = Tk()<br>root1.geometry(<span class="hljs-string">&quot;850x450&quot;</span>)<br>root1.title(<span class="hljs-string">&quot;关联规则挖掘系统&quot;</span>)<br>root1.resizable=(<span class="hljs-literal">False</span>,<span class="hljs-literal">False</span>)<br>root1[<span class="hljs-string">&quot;background&quot;</span>] = <span class="hljs-string">&quot;SkyBlue&quot;</span><br>root1.attributes(<span class="hljs-string">&quot;-alpha&quot;</span>, <span class="hljs-number">0.9</span>)<br><br> <br><span class="hljs-comment"># Thinker总共提供了三种布局组件的方法：pack(),grid()和place()</span><br><span class="hljs-comment"># grid()方法允许你用表格的形式来管理组件的位置</span><br><span class="hljs-comment"># row选项代表行，column选项代表列</span><br><span class="hljs-comment"># 例如row=1，column=2表示第二行第三列(0表示第一行)</span><br><br>fram1=Frame(root1)<br>Label(fram1,text=<span class="hljs-string">&quot;频繁项集和关联规则&quot;</span>,font=(<span class="hljs-string">&quot;华文行楷&quot;</span>, <span class="hljs-number">20</span>), fg=<span class="hljs-string">&quot;green&quot;</span>).grid(row=<span class="hljs-number">0</span>,column=<span class="hljs-number">0</span>)<br>text_result=Text(fram1)<br>text_result.grid(row=<span class="hljs-number">2</span>,column=<span class="hljs-number">0</span>)<br>fram1.grid(row=<span class="hljs-number">0</span>,rowspan=<span class="hljs-number">4</span>,column=<span class="hljs-number">4</span>)<br><br>fram2=Frame(root1,width=<span class="hljs-number">300</span>,height=<span class="hljs-number">500</span>)<br><br>btnloaddata=Button(fram2, text=<span class="hljs-string">&quot;导入数据&quot;</span>,command=LoadData)<br>btnloaddata.grid(row=<span class="hljs-number">0</span>,column=<span class="hljs-number">0</span>,pady=<span class="hljs-number">18</span>)<br>Label(fram2, text=<span class="hljs-string">&quot;最小支持度&quot;</span>).grid(row=<span class="hljs-number">1</span>,column=<span class="hljs-number">0</span>,pady=<span class="hljs-number">18</span>)<br>Label(fram2, text=<span class="hljs-string">&quot;最小置信度&quot;</span>).grid(row=<span class="hljs-number">2</span>,column=<span class="hljs-number">0</span>,pady=<span class="hljs-number">18</span>)<br><br>e1_value=<span class="hljs-string">&quot;导入文件的路径:\n&quot;</span><br>e1 = Text(fram2,width=<span class="hljs-number">20</span>,height=<span class="hljs-number">3</span>)<br>e1.insert(<span class="hljs-number">1.0</span>,e1_value)<br><br><br>e2 = Entry(fram2)<br>e3 = Entry(fram2)<br><br><br>e1.grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">1</span>,pady=<span class="hljs-number">18</span>,padx=<span class="hljs-number">10</span>)<br>e2.grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">1</span>,pady=<span class="hljs-number">18</span>,padx=<span class="hljs-number">10</span>)<br>e3.grid(row=<span class="hljs-number">2</span>, column=<span class="hljs-number">1</span>,pady=<span class="hljs-number">18</span>,padx=<span class="hljs-number">10</span>)<br><br>fram2.grid(row=<span class="hljs-number">0</span>,column=<span class="hljs-number">0</span>,rowspan=<span class="hljs-number">4</span>,columnspan=<span class="hljs-number">3</span>,pady=<span class="hljs-number">18</span>)<br><br><span class="hljs-comment"># 创建单选项</span><br>r = IntVar()<br>male_select = Radiobutton(root1,text=<span class="hljs-string">&quot;Apriori&quot;</span>,value=<span class="hljs-number">1</span>,variable=r)<br>male_select.grid(row=<span class="hljs-number">3</span>,column=<span class="hljs-number">0</span>)<br>female_select = Radiobutton(root1,text=<span class="hljs-string">&quot;Fp-growth&quot;</span>,value=<span class="hljs-number">2</span>,variable=r)<br>female_select.grid(row=<span class="hljs-number">3</span>,column=<span class="hljs-number">1</span>)<br><br>fram3=Frame(root1,width=<span class="hljs-number">100</span>,height=<span class="hljs-number">10</span>)<br><br>btnstart=Button(fram3,text=<span class="hljs-string">&quot;开始&quot;</span>,command=Start)<br>btnclear=Button(fram3,text=<span class="hljs-string">&quot;清空&quot;</span>,command=Clear)<br>btnshowtree=Button(fram3,text=<span class="hljs-string">&quot;显示Fptree&quot;</span>,command=showtree)<br>btnsave=Button(fram3,text=<span class="hljs-string">&quot;保存结果&quot;</span>,command=save_file)<br><span class="hljs-comment">#btnclose=Button(fram3,text=&quot;结束&quot;,command=&quot;&quot;)</span><br>btnstart.grid(row=<span class="hljs-number">0</span>,column=<span class="hljs-number">0</span>,padx=<span class="hljs-number">10</span>,pady=<span class="hljs-number">10</span>)<br>btnclear.grid(row=<span class="hljs-number">0</span>,column=<span class="hljs-number">1</span>,padx=<span class="hljs-number">10</span>,pady=<span class="hljs-number">10</span>)<br>btnshowtree.grid(row=<span class="hljs-number">0</span>,column=<span class="hljs-number">2</span>,padx=<span class="hljs-number">10</span>,pady=<span class="hljs-number">10</span>)<br>btnsave.grid(row=<span class="hljs-number">0</span>,column=<span class="hljs-number">3</span>,padx=<span class="hljs-number">10</span>,pady=<span class="hljs-number">10</span>)<br><span class="hljs-comment">#btnclose.grid(row=0,column=2,padx=10,pady=10)</span><br><br>fram3.grid(row=<span class="hljs-number">4</span>,column=<span class="hljs-number">0</span>,columnspan=<span class="hljs-number">3</span>)<br><br>fram1[<span class="hljs-string">&quot;background&quot;</span>] = <span class="hljs-string">&quot;white&quot;</span><br>fram2[<span class="hljs-string">&quot;background&quot;</span>] = <span class="hljs-string">&quot;SkyBlue&quot;</span><br>fram3[<span class="hljs-string">&quot;background&quot;</span>] = <span class="hljs-string">&quot;SkyBlue&quot;</span><br><br><br><span class="hljs-comment">######################################################################################</span><br><span class="hljs-comment"># Example of embedding CEF Python browser using Tkinter toolkit.</span><br><span class="hljs-comment"># This example has two widgets: a navigation bar and a browser.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> This example often crashes on Mac (Python 2.7, Tk 8.5/8.6)</span><br><span class="hljs-comment">#       during initial app loading with such message:</span><br><span class="hljs-comment">#       &quot;Segmentation fault: 11&quot;. Reported as Issue #309.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Tested configurations:</span><br><span class="hljs-comment"># - Tk 8.5 on Windows/Mac</span><br><span class="hljs-comment"># - Tk 8.6 on Linux</span><br><span class="hljs-comment"># - CEF Python v55.3+</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Known issue on Linux: When typing url, mouse must be over url</span><br><span class="hljs-comment"># entry widget otherwise keyboard focus is lost (Issue #255</span><br><span class="hljs-comment"># and Issue #284).</span><br><br><span class="hljs-comment">#以下代码为了嵌入html页面，具体代码没有仔细研究过，只是为了应用，只要修改embed_browser的url路径即可</span><br><span class="hljs-keyword">from</span> cefpython3 <span class="hljs-keyword">import</span> cefpython <span class="hljs-keyword">as</span> cef<br><span class="hljs-keyword">import</span> ctypes<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk<br><span class="hljs-keyword">except</span> ImportError:<br>    <span class="hljs-keyword">import</span> Tkinter <span class="hljs-keyword">as</span> tk<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> platform<br><span class="hljs-keyword">import</span> logging <span class="hljs-keyword">as</span> _logging<br><br><span class="hljs-keyword">global</span> root<br>root = tk.Tk()<br><br><span class="hljs-comment"># Fix for PyCharm hints warnings</span><br>WindowUtils = cef.WindowUtils()<br><br><span class="hljs-comment"># Platforms</span><br>WINDOWS = (platform.system() == <span class="hljs-string">&quot;Windows&quot;</span>)<br>LINUX = (platform.system() == <span class="hljs-string">&quot;Linux&quot;</span>)<br>MAC = (platform.system() == <span class="hljs-string">&quot;Darwin&quot;</span>)<br><br><span class="hljs-comment"># Globals</span><br>logger = _logging.getLogger(<span class="hljs-string">&quot;tkinter_.py&quot;</span>)<br><br><span class="hljs-comment"># Constants</span><br><span class="hljs-comment"># Tk 8.5 doesn&#x27;t support png images</span><br>IMAGE_EXT = <span class="hljs-string">&quot;.png&quot;</span> <span class="hljs-keyword">if</span> tk.TkVersion &gt; <span class="hljs-number">8.5</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;.gif&quot;</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainFrame</span>(tk.Frame):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, root</span>):<br>        self.browser_frame = <span class="hljs-literal">None</span><br>        self.navigation_bar = <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># Root</span><br>        root.geometry(<span class="hljs-string">&quot;900x640+300+200&quot;</span>)<br>        tk.Grid.rowconfigure(root, <span class="hljs-number">0</span>, weight=<span class="hljs-number">1</span>)<br>        tk.Grid.columnconfigure(root, <span class="hljs-number">0</span>, weight=<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># MainFrame</span><br>        tk.Frame.__init__(self, root)<br>        self.master.title(<span class="hljs-string">&quot;FpTree&quot;</span>)<br>        self.master.protocol(<span class="hljs-string">&quot;WM_DELETE_WINDOW&quot;</span>, self.on_close)<br>        self.master.bind(<span class="hljs-string">&quot;&lt;Configure&gt;&quot;</span>, self.on_root_configure)<br>        self.setup_icon()<br>        self.bind(<span class="hljs-string">&quot;&lt;Configure&gt;&quot;</span>, self.on_configure)<br>        self.bind(<span class="hljs-string">&quot;&lt;FocusIn&gt;&quot;</span>, self.on_focus_in)<br>        self.bind(<span class="hljs-string">&quot;&lt;FocusOut&gt;&quot;</span>, self.on_focus_out)<br><br>        <span class="hljs-comment"># NavigationBar</span><br>        self.navigation_bar = NavigationBar(self)<br>        self.navigation_bar.grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">0</span>,<br>                                 sticky=(tk.N + tk.S + tk.E + tk.W))<br>        tk.Grid.rowconfigure(self, <span class="hljs-number">0</span>, weight=<span class="hljs-number">0</span>)<br>        tk.Grid.columnconfigure(self, <span class="hljs-number">0</span>, weight=<span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># BrowserFrame</span><br>        self.browser_frame = BrowserFrame(self, self.navigation_bar)<br>        self.browser_frame.grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">0</span>,<br>                                sticky=(tk.N + tk.S + tk.E + tk.W))<br>        tk.Grid.rowconfigure(self, <span class="hljs-number">1</span>, weight=<span class="hljs-number">1</span>)<br>        tk.Grid.columnconfigure(self, <span class="hljs-number">0</span>, weight=<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># Pack MainFrame</span><br>        self.pack(fill=tk.BOTH, expand=tk.YES)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_root_configure</span>(<span class="hljs-params">self, _</span>):<br>        logger.debug(<span class="hljs-string">&quot;MainFrame.on_root_configure&quot;</span>)<br>        <span class="hljs-keyword">if</span> self.browser_frame:<br>            self.browser_frame.on_root_configure()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_configure</span>(<span class="hljs-params">self, event</span>):<br>        logger.debug(<span class="hljs-string">&quot;MainFrame.on_configure&quot;</span>)<br>        <span class="hljs-keyword">if</span> self.browser_frame:<br>            width = event.width<br>            height = event.height<br>            <span class="hljs-keyword">if</span> self.navigation_bar:<br>                height = height - self.navigation_bar.winfo_height()<br>            self.browser_frame.on_mainframe_configure(width, height)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_focus_in</span>(<span class="hljs-params">self, _</span>):<br>        logger.debug(<span class="hljs-string">&quot;MainFrame.on_focus_in&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_focus_out</span>(<span class="hljs-params">self, _</span>):<br>        logger.debug(<span class="hljs-string">&quot;MainFrame.on_focus_out&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_close</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.browser_frame:<br>            self.browser_frame.on_root_close()<br>        self.master.destroy()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_browser</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.browser_frame:<br>            <span class="hljs-keyword">return</span> self.browser_frame.browser<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_browser_frame</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.browser_frame:<br>            <span class="hljs-keyword">return</span> self.browser_frame<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setup_icon</span>(<span class="hljs-params">self</span>):<br>        resources = os.path.join(os.path.dirname(__file__), <span class="hljs-string">&quot;resources&quot;</span>)<br>        icon_path = os.path.join(resources, <span class="hljs-string">&quot;tkinter&quot;</span>+IMAGE_EXT)<br>        <span class="hljs-keyword">if</span> os.path.exists(icon_path):<br>            self.icon = tk.PhotoImage(file=icon_path)<br>            <span class="hljs-comment"># noinspection PyProtectedMember</span><br>            self.master.call(<span class="hljs-string">&quot;wm&quot;</span>, <span class="hljs-string">&quot;iconphoto&quot;</span>, self.master._w, self.icon)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BrowserFrame</span>(tk.Frame):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, master, navigation_bar=<span class="hljs-literal">None</span></span>):<br>        self.navigation_bar = navigation_bar<br>        self.closing = <span class="hljs-literal">False</span><br>        self.browser = <span class="hljs-literal">None</span><br>        tk.Frame.__init__(self, master)<br>        self.bind(<span class="hljs-string">&quot;&lt;FocusIn&gt;&quot;</span>, self.on_focus_in)<br>        self.bind(<span class="hljs-string">&quot;&lt;FocusOut&gt;&quot;</span>, self.on_focus_out)<br>        self.bind(<span class="hljs-string">&quot;&lt;Configure&gt;&quot;</span>, self.on_configure)<br>        self.focus_set()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">embed_browser</span>(<span class="hljs-params">self</span>):<br>        window_info = cef.WindowInfo()<br>        rect = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, self.winfo_width(), self.winfo_height()]<br>        window_info.SetAsChild(self.get_window_handle(), rect)<br>        self.browser = cef.CreateBrowserSync(window_info,<br>                                             url=<span class="hljs-string">&quot;file:///fptree.html&quot;</span>) <span class="hljs-comment">#todo  </span><br>        <span class="hljs-comment">#只需要修改url中的内容，嵌入本地html</span><br>        <span class="hljs-keyword">assert</span> self.browser<br>        self.browser.SetClientHandler(LoadHandler(self))<br>        self.browser.SetClientHandler(FocusHandler(self))<br>        self.message_loop_work()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_window_handle</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.winfo_id() &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> self.winfo_id()<br>        <span class="hljs-keyword">elif</span> MAC:<br>            <span class="hljs-comment"># On Mac window id is an invalid negative value (Issue #308).</span><br>            <span class="hljs-comment"># This is kind of a dirty hack to get window handle using</span><br>            <span class="hljs-comment"># PyObjC package. If you change structure of windows then you</span><br>            <span class="hljs-comment"># need to do modifications here as well.</span><br>            <span class="hljs-comment"># noinspection PyUnresolvedReferences</span><br>            <span class="hljs-keyword">from</span> AppKit <span class="hljs-keyword">import</span> NSApp<br>            <span class="hljs-comment"># noinspection PyUnresolvedReferences</span><br>            <span class="hljs-keyword">import</span> objc<br>            <span class="hljs-comment"># Sometimes there is more than one window, when application</span><br>            <span class="hljs-comment"># didn&#x27;t close cleanly last time Python displays an NSAlert</span><br>            <span class="hljs-comment"># window asking whether to Reopen that window.</span><br>            <span class="hljs-comment"># noinspection PyUnresolvedReferences</span><br>            <span class="hljs-keyword">return</span> objc.pyobjc_id(NSApp.windows()[-<span class="hljs-number">1</span>].contentView())<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;Couldn&#x27;t obtain window handle&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">message_loop_work</span>(<span class="hljs-params">self</span>):<br>        cef.MessageLoopWork()<br>        self.after(<span class="hljs-number">10</span>, self.message_loop_work)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_configure</span>(<span class="hljs-params">self, _</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.browser:<br>            self.embed_browser()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_root_configure</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># Root &lt;Configure&gt; event will be called when top window is moved</span><br>        <span class="hljs-keyword">if</span> self.browser:<br>            self.browser.NotifyMoveOrResizeStarted()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_mainframe_configure</span>(<span class="hljs-params">self, width, height</span>):<br>        <span class="hljs-keyword">if</span> self.browser:<br>            <span class="hljs-keyword">if</span> WINDOWS:<br>                ctypes.windll.user32.SetWindowPos(<br>                    self.browser.GetWindowHandle(), <span class="hljs-number">0</span>,<br>                    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height, <span class="hljs-number">0x0002</span>)<br>            <span class="hljs-keyword">elif</span> LINUX:<br>                self.browser.SetBounds(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height)<br>            self.browser.NotifyMoveOrResizeStarted()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_focus_in</span>(<span class="hljs-params">self, _</span>):<br>        logger.debug(<span class="hljs-string">&quot;BrowserFrame.on_focus_in&quot;</span>)<br>        <span class="hljs-keyword">if</span> self.browser:<br>            self.browser.SetFocus(<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_focus_out</span>(<span class="hljs-params">self, _</span>):<br>        logger.debug(<span class="hljs-string">&quot;BrowserFrame.on_focus_out&quot;</span>)<br>        <span class="hljs-keyword">if</span> self.browser:<br>            self.browser.SetFocus(<span class="hljs-literal">False</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_root_close</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.browser:<br>            self.browser.CloseBrowser(<span class="hljs-literal">True</span>)<br>            self.clear_browser_references()<br>        self.destroy()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clear_browser_references</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># Clear browser references that you keep anywhere in your</span><br>        <span class="hljs-comment"># code. All references must be cleared for CEF to shutdown cleanly.</span><br>        self.browser = <span class="hljs-literal">None</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoadHandler</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, browser_frame</span>):<br>        self.browser_frame = browser_frame<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">OnLoadStart</span>(<span class="hljs-params">self, browser, **_</span>):<br>        <span class="hljs-keyword">if</span> self.browser_frame.master.navigation_bar:<br>            self.browser_frame.master.navigation_bar.set_url(browser.GetUrl())<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FocusHandler</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, browser_frame</span>):<br>        self.browser_frame = browser_frame<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">OnTakeFocus</span>(<span class="hljs-params">self, next_component, **_</span>):<br>        logger.debug(<span class="hljs-string">&quot;FocusHandler.OnTakeFocus, next=&#123;next&#125;&quot;</span><br>                     .<span class="hljs-built_in">format</span>(<span class="hljs-built_in">next</span>=next_component))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">OnSetFocus</span>(<span class="hljs-params">self, source, **_</span>):<br>        logger.debug(<span class="hljs-string">&quot;FocusHandler.OnSetFocus, source=&#123;source&#125;&quot;</span><br>                     .<span class="hljs-built_in">format</span>(source=source))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">OnGotFocus</span>(<span class="hljs-params">self, **_</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Fix CEF focus issues (#255). Call browser frame&#x27;s focus_set</span><br><span class="hljs-string">           to get rid of type cursor in url entry widget.&quot;&quot;&quot;</span><br>        logger.debug(<span class="hljs-string">&quot;FocusHandler.OnGotFocus&quot;</span>)<br>        self.browser_frame.focus_set()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NavigationBar</span>(tk.Frame):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, master</span>):<br>        self.back_state = tk.NONE<br>        self.forward_state = tk.NONE<br>        self.back_image = <span class="hljs-literal">None</span><br>        self.forward_image = <span class="hljs-literal">None</span><br>        self.reload_image = <span class="hljs-literal">None</span><br><br>        tk.Frame.__init__(self, master)<br>        resources = os.path.join(os.path.dirname(__file__), <span class="hljs-string">&quot;resources&quot;</span>)<br><br>        <span class="hljs-comment"># Back button</span><br>        back_png = os.path.join(resources, <span class="hljs-string">&quot;back&quot;</span>+IMAGE_EXT)<br>        <span class="hljs-keyword">if</span> os.path.exists(back_png):<br>            self.back_image = tk.PhotoImage(file=back_png)<br>        self.back_button = tk.Button(self, image=self.back_image,<br>                                     command=self.go_back)<br>        self.back_button.grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># Forward button</span><br>        forward_png = os.path.join(resources, <span class="hljs-string">&quot;forward&quot;</span>+IMAGE_EXT)<br>        <span class="hljs-keyword">if</span> os.path.exists(forward_png):<br>            self.forward_image = tk.PhotoImage(file=forward_png)<br>        self.forward_button = tk.Button(self, image=self.forward_image,<br>                                        command=self.go_forward)<br>        self.forward_button.grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># Reload button</span><br>        reload_png = os.path.join(resources, <span class="hljs-string">&quot;reload&quot;</span>+IMAGE_EXT)<br>        <span class="hljs-keyword">if</span> os.path.exists(reload_png):<br>            self.reload_image = tk.PhotoImage(file=reload_png)<br>        self.reload_button = tk.Button(self, image=self.reload_image,<br>                                       command=self.reload)<br>        self.reload_button.grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">2</span>)<br><br>        <span class="hljs-comment"># Url entry</span><br>        self.url_entry = tk.Entry(self)<br>        self.url_entry.bind(<span class="hljs-string">&quot;&lt;FocusIn&gt;&quot;</span>, self.on_url_focus_in)<br>        self.url_entry.bind(<span class="hljs-string">&quot;&lt;FocusOut&gt;&quot;</span>, self.on_url_focus_out)<br>        self.url_entry.bind(<span class="hljs-string">&quot;&lt;Return&gt;&quot;</span>, self.on_load_url)<br>        self.url_entry.bind(<span class="hljs-string">&quot;&lt;Button-1&gt;&quot;</span>, self.on_button1)<br>        self.url_entry.grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">3</span>,<br>                            sticky=(tk.N + tk.S + tk.E + tk.W))<br>        tk.Grid.rowconfigure(self, <span class="hljs-number">0</span>, weight=<span class="hljs-number">100</span>)<br>        tk.Grid.columnconfigure(self, <span class="hljs-number">3</span>, weight=<span class="hljs-number">100</span>)<br><br>        <span class="hljs-comment"># Update state of buttons</span><br>        self.update_state()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">go_back</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.master.get_browser():<br>            self.master.get_browser().GoBack()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">go_forward</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.master.get_browser():<br>            self.master.get_browser().GoForward()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reload</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.master.get_browser():<br>            self.master.get_browser().Reload()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_url</span>(<span class="hljs-params">self, url</span>):<br>        self.url_entry.delete(<span class="hljs-number">0</span>, tk.END)<br>        self.url_entry.insert(<span class="hljs-number">0</span>, url)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_url_focus_in</span>(<span class="hljs-params">self, _</span>):<br>        logger.debug(<span class="hljs-string">&quot;NavigationBar.on_url_focus_in&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_url_focus_out</span>(<span class="hljs-params">self, _</span>):<br>        logger.debug(<span class="hljs-string">&quot;NavigationBar.on_url_focus_out&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_load_url</span>(<span class="hljs-params">self, _</span>):<br>        <span class="hljs-keyword">if</span> self.master.get_browser():<br>            self.master.get_browser().StopLoad()<br>            self.master.get_browser().LoadUrl(self.url_entry.get())<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_button1</span>(<span class="hljs-params">self, _</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Fix CEF focus issues (#255). See also FocusHandler.OnGotFocus.&quot;&quot;&quot;</span><br>        logger.debug(<span class="hljs-string">&quot;NavigationBar.on_button1&quot;</span>)<br>        self.master.master.focus_force()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_state</span>(<span class="hljs-params">self</span>):<br>        browser = self.master.get_browser()<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> browser:<br>            <span class="hljs-keyword">if</span> self.back_state != tk.DISABLED:<br>                self.back_button.config(state=tk.DISABLED)<br>                self.back_state = tk.DISABLED<br>            <span class="hljs-keyword">if</span> self.forward_state != tk.DISABLED:<br>                self.forward_button.config(state=tk.DISABLED)<br>                self.forward_state = tk.DISABLED<br>            self.after(<span class="hljs-number">100</span>, self.update_state)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> browser.CanGoBack():<br>            <span class="hljs-keyword">if</span> self.back_state != tk.NORMAL:<br>                self.back_button.config(state=tk.NORMAL)<br>                self.back_state = tk.NORMAL<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> self.back_state != tk.DISABLED:<br>                self.back_button.config(state=tk.DISABLED)<br>                self.back_state = tk.DISABLED<br>        <span class="hljs-keyword">if</span> browser.CanGoForward():<br>            <span class="hljs-keyword">if</span> self.forward_state != tk.NORMAL:<br>                self.forward_button.config(state=tk.NORMAL)<br>                self.forward_state = tk.NORMAL<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> self.forward_state != tk.DISABLED:<br>                self.forward_button.config(state=tk.DISABLED)<br>                self.forward_state = tk.DISABLED<br>        self.after(<span class="hljs-number">100</span>, self.update_state)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Click1</span>():<br>    root.deiconify()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    logger.setLevel(_logging.INFO)<br>    stream_handler = _logging.StreamHandler()<br>    formatter = _logging.Formatter(<span class="hljs-string">&quot;[%(filename)s] %(message)s&quot;</span>)<br>    stream_handler.setFormatter(formatter)<br>    logger.addHandler(stream_handler)<br>    logger.info(<span class="hljs-string">&quot;CEF Python &#123;ver&#125;&quot;</span>.<span class="hljs-built_in">format</span>(ver=cef.__version__))<br>    logger.info(<span class="hljs-string">&quot;Python &#123;ver&#125; &#123;arch&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>            ver=platform.python_version(), arch=platform.architecture()[<span class="hljs-number">0</span>]))<br>    logger.info(<span class="hljs-string">&quot;Tk &#123;ver&#125;&quot;</span>.<span class="hljs-built_in">format</span>(ver=tk.Tcl().<span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;info patchlevel&#x27;</span>)))<br>    <span class="hljs-keyword">assert</span> cef.__version__ &gt;= <span class="hljs-string">&quot;55.3&quot;</span>, <span class="hljs-string">&quot;CEF Python v55.3+ required to run this&quot;</span><br>    sys.excepthook = cef.ExceptHook  <span class="hljs-comment"># To shutdown all CEF processes on error</span><br>    root.withdraw()<br>    <span class="hljs-comment">#root = tk.Tk()</span><br>   <br>    app = MainFrame(root)<br>    <span class="hljs-comment"># Tk must be initialized before CEF otherwise fatal error (Issue #306)</span><br>    cef.Initialize()<br>    root1.mainloop()<br>    app.mainloop()<br>    cef.Shutdown()<br>    <br><br><br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据挖掘及应用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计组上机总结</title>
      <link href="/2019/11/03/%E8%AE%A1%E7%BB%84%E4%B8%8A%E6%9C%BA%E6%80%BB%E7%BB%93/"/>
      <url>/2019/11/03/%E8%AE%A1%E7%BB%84%E4%B8%8A%E6%9C%BA%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>记录计组的一次上机实验，内容是存储器设计方面，考试设计题</p><span id="more"></span>  <h1 id="实验名称：模型机的总体设计-存储器设计"><a href="#实验名称：模型机的总体设计-存储器设计" class="headerlink" title="实验名称：模型机的总体设计-存储器设计"></a>实验名称：模型机的总体设计-存储器设计</h1><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>熟练掌握存储器的设计<br></p><h2 id="二、实验要求"><a href="#二、实验要求" class="headerlink" title="二、实验要求"></a>二、实验要求</h2><p>某机器中，已知ROM区域的地址空间起始地址为4000H开始，地址空间为8K * 16位（用8K * 8位的ROM芯片构成）。RAM采用最后地址8K*16位空间（用8K *8位的RAM芯片构成）。CPU采用8086、地址锁存器采用8282，数据缓冲器采用8286，译码器采用74ALS138。进行设计并用网络标签法完成要求：</p><ol><li>画出地址译码方案 </li><li>画出存储器与CPU等元件的连接图</li></ol><h2 id="三、实习步骤"><a href="#三、实习步骤" class="headerlink" title="三、实习步骤"></a>三、实习步骤</h2><p>首先分析题目所给的电路，题目中给的ROM地址空间起始地址为4000H，地址空间为8K<em>16为，8k即2^13，即A0~A12<br><br>再分析RAM，由于RAM采用的是最后地址8K</em>16为空间，因此同样是A0<del>A12<br><br>题目中给定使用8086CPU，8086是16位微处理器芯片，相关信号如下：<br><br><strong>CPU相关信号:</strong><br><br>ALE：ALE 地址锁存允许信号（输出），高电平有效，不能被浮空。<br>一般用它来控制地址锁存器，它在下降沿会把地址锁存器的输入信号锁定，然后地址锁存器的输出用于提供地址。<br><br>一般在T1时刻出现ALE有效的信号，将地址送人地址锁存器。<br><br>RD 读信号引脚（输出），执行一个对内存货I&#x2F;O端口的读操作，到底是读取内存中的单元数据还是I&#x2F;O端口中的数据，取决于M&#x2F;IO信号。<br><br>WR写信号（输出），低电平有效，对存储器或I&#x2F;O写操作，具体哪种操作取决于M&#x2F;IO信号。<br>M&#x2F;IO存储器&#x2F;输入&#x2F;输出控制信号（输出）若此信号为高电平，表示CPU和存储器之间进行数据传输；<br><br>若为低电平，表示CPU和输入输出设备之间进行数据传输。<br><br>DEN信号：8086 CPU中，控制信号DEN的作用是.CPU发出的数据传输有效控制信号<br><br>DT&#x2F;R信号：用来控制数据传送方向，在8086系统中，通常采用8286或8287作为数据总线的驱动器，用DT&#x2F;R* 信号来控制数据驱动器的数据传送方向，当DT&#x2F;R* &#x3D;1时，数据驱动器进行数据发送；DT&#x2F;R*&#x3D;0时，数据驱动器进行数据接收。<br><br>因为是16位，所以地址为A0</del>A15,因此可以先画出地址译码方案<br><img src="/2019/11/03/%E8%AE%A1%E7%BB%84%E4%B8%8A%E6%9C%BA%E6%80%BB%E7%BB%93/%E5%9C%B0%E5%9D%80%E8%AF%91%E7%A0%81%E6%96%B9%E6%A1%88.png"></p><!-- <img src="计组上机总结/地址译码方案.png"> --><p>A0<del>A12为真正的地址，而A15</del>A13对应于译码器的A，B，C</p><p>由于ROM地址空间为8k * 16位，所以依据题意需要采用2片8k * 8为的ROM芯片构成，在此选用两片2764芯片，基本参数如下：<br><br>A0到A12为13条地址信号输入线，说明芯片容量为2的13次方，即8K<br><br>D0到D7为数据线，表示芯片的每个存储单元存放一个字节（8位二进制数）。对芯片读数时，作为输出线，对芯片编程时，作为输入线。<br><br>CE为输入信号，低电平有效。（有称作片选信号）<br><br>OE为输出允许信号，低电平有效<br><br><img src="/2019/11/03/%E8%AE%A1%E7%BB%84%E4%B8%8A%E6%9C%BA%E6%80%BB%E7%BB%93/%E5%9C%B0%E5%9D%80%E8%AF%91%E7%A0%81%E6%96%B9%E6%A1%88.png"></p><!-- <img src="计组上机总结/地址译码方案.png"> --><p>接着分析RAM芯片，同样是采用两个芯片进行片选，选择的芯片为SRAM6164芯片：<br>为8K×8bit的CMOSRAM芯片。<br><br>WE为写信号，CS为片选信号，OE为输出允许信号，D0<del>D7为8位数据线，A0</del>A12为13根地址线<br><img src="/2019/11/03/%E8%AE%A1%E7%BB%84%E4%B8%8A%E6%9C%BA%E6%80%BB%E7%BB%93/RAM%E8%8A%AF%E7%89%87.png"></p><!-- <img src="计组上机总结/RAM芯片.png"> --><p>之后按照题目说的地址锁存器采用8282，关于地址锁存器相关概念不是很清楚，查阅后发现基本概念如下：<br><br>地址锁存器是一个暂存器，它根据控制信号的状态，将总线上地址代码暂存起来。8086&#x2F;8088数据和地址总线采用分时复用操作方法，即用同一总线既传输数据又传输地址。当微处理器与存储器交换信号时，首先由CPU发出存储器地址，同时发出允许锁存信号ALE给锁存器，当锁存器接到该信号后将地址&#x2F;数据总线上的地址锁存在总线上，随后才能传输数据。</p><!-- <img src="计组上机总结/地址锁存器.png"> --><p><img src="/2019/11/03/%E8%AE%A1%E7%BB%84%E4%B8%8A%E6%9C%BA%E6%80%BB%E7%BB%93/%E5%9C%B0%E5%9D%80%E9%94%81%E5%AD%98%E5%99%A8.png"></p><p>数据缓冲器采用8286，数据缓冲器相关概念如下：<br><br>数据缓冲器是一款具有不同传输能力元件之间通过时用来暂存这些数据的存储器。<br></p><!-- <img src="计组上机总结/数据缓冲器.png"> --><p><img src="/2019/11/03/%E8%AE%A1%E7%BB%84%E4%B8%8A%E6%9C%BA%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BC%93%E5%86%B2%E5%99%A8.png"></p><p>译码器采用74ALS138，根据输入的数字量在多个输出端中选一个有效，由之前的地址译码方案可知的当Y15，Y14，Y13分别为0, 1，0时，对应ROM地址，此时译码器的Y2端有效<br>同理RAM对应111，即Y7端有效</p><!-- <img src="计组上机总结/译码器.png"> --><p> <img src="/2019/11/03/%E8%AE%A1%E7%BB%84%E4%B8%8A%E6%9C%BA%E6%80%BB%E7%BB%93/%E8%AF%91%E7%A0%81%E5%99%A8.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ID3实现决策树</title>
      <link href="/2019/10/23/ID3%E5%AE%9E%E7%8E%B0%E5%86%B3%E7%AD%96%E6%A0%91/"/>
      <url>/2019/10/23/ID3%E5%AE%9E%E7%8E%B0%E5%86%B3%E7%AD%96%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>总结课上讲的决策树基本概念以及采用ID3算法实现决策树</p><span id="more"></span><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>决策树是一种类似于流程图的数结构，其中每个内部节点表示在一个属性上的测试，每个分支代表该测试的一个输出，每一个叶节点存放一个类标号，最顶层是根节点。</p><h2 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h2><p><a href="https://blog.csdn.net/qq_39521554/article/details/80559531">此段原文链接</a></p><blockquote><p>事实上，熵的英文原文为entropy，最初由德国物理学家鲁道夫·克劳修斯提出，其表达式为：entropy,它表示一个系系统在不受外部干扰时，其内部最稳定的状态。后来一中国学者翻译entropy时，考虑到entropy是能量Q跟温度T的商，且跟火有关，便把entropy形象的翻译成“熵”。我们知道，任何粒子的常态都是随机运动，也就是”无序运动”，如果让粒子呈现”有序化”，必须耗费能量。所以，温度（热能）可以被看作”有序化”的一种度量，而”熵”可以看作是”无序化”的度量。如果没有外部能量输入，封闭系统趋向越来越混乱（熵越来越大）。比如，如果房间无人打扫，不可能越来越干净（有序化），只可能越来越乱（无序化）。而要让一个系统变得更有序，必须有外部能量的输入。1948年，香农Claude E. Shannon引入信息（熵），将其定义为离散随机事件的出现概率。一个系统越是有序，信息熵就越低；反之，一个系统越是混乱，信息熵就越高。所以说，信息熵可以被认为是系统有序化程度的一个度量。</p></blockquote><p>熵越大，就意味着混杂度越大，越难以区分，因此决策树要选取熵小的作为根节点</p><p>公式：<br>entropy(S)&#x3D;$\sum_{i&#x3D;0}^N {Pi*\log_2 Pi}$<br><br><br>Pi为概率</p><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>用来衡量熵的期望减少值<br>分类前的信息熵减去分类后的信息熵<br><br>公式：gain(S,A)&#x3D;entropy(S)-entropy(S,A)<br><br>信息增益越大，熵的减小量越大，节点更纯</p><p>entropy(S,A)含义：<br><br>设属性A将S划分为m份，根据A划分的子集的熵或期望信息<br><br>entropy(S,A)&#x3D;$\sum_{i&#x3D;0}^m {|Si| \over |S|}*entropy(Si)$ <br><br>(Si表示根据属性A划分的S的第i个字集,|S|和|Si|分别表示S中，Si中的样本数目)</p><h1 id="构建决策树"><a href="#构建决策树" class="headerlink" title="构建决策树"></a>构建决策树</h1><p>代码实现(<a href="https://blog.csdn.net/leaf_zizi/article/details/82848682">原文链接</a>)</p><p><img src="/2019/10/23/ID3%E5%AE%9E%E7%8E%B0%E5%86%B3%E7%AD%96%E6%A0%91/%E5%86%B3%E7%AD%96%E6%A0%91.png"></p><p>建树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> log<br><span class="hljs-keyword">import</span> operator<br> <br><span class="hljs-comment"># 计算信息熵</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calcShannonEnt</span>(<span class="hljs-params">dataSet</span>):<br>    numEntries = <span class="hljs-built_in">len</span>(dataSet)  <span class="hljs-comment"># 样本数</span><br>    labelCounts = &#123;&#125;<br>    <span class="hljs-keyword">for</span> featVec <span class="hljs-keyword">in</span> dataSet:  <span class="hljs-comment"># 遍历每个样本</span><br>        currentLabel = featVec[-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 当前样本的类别</span><br>        <span class="hljs-keyword">if</span> currentLabel <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> labelCounts.keys():  <span class="hljs-comment"># 生成类别字典</span><br>            labelCounts[currentLabel] = <span class="hljs-number">0</span><br>        labelCounts[currentLabel] += <span class="hljs-number">1</span><br>    shannonEnt = <span class="hljs-number">0.0</span><br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> labelCounts:  <span class="hljs-comment"># 计算信息熵</span><br>        prob = <span class="hljs-built_in">float</span>(labelCounts[key]) / numEntries<br>        shannonEnt = shannonEnt - prob * log(prob, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> shannonEnt<br> <br> <br><span class="hljs-comment"># 划分数据集，axis:按第几个属性划分，value:要返回的子集对应的属性值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">splitDataSet</span>(<span class="hljs-params">dataSet, axis, value</span>):<br>    retDataSet = []<br>    featVec = []<br>    <span class="hljs-keyword">for</span> featVec <span class="hljs-keyword">in</span> dataSet:<br>        <span class="hljs-keyword">if</span> featVec[axis] == value:<br>            reducedFeatVec = featVec[:axis]<br>            reducedFeatVec.extend(featVec[axis + <span class="hljs-number">1</span>:])<br>            retDataSet.append(reducedFeatVec)<br>    <span class="hljs-keyword">return</span> retDataSet<br> <br> <br><span class="hljs-comment"># 选择最好的数据集划分方式</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">chooseBestFeatureToSplit</span>(<span class="hljs-params">dataSet</span>):<br>    numFeatures = <span class="hljs-built_in">len</span>(dataSet[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>  <span class="hljs-comment"># 属性的个数</span><br>    baseEntropy = calcShannonEnt(dataSet)<br>    bestInfoGain = <span class="hljs-number">0.0</span><br>    bestFeature = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numFeatures):  <span class="hljs-comment"># 对每个属性技术信息增益</span><br>        featList = [example[i] <span class="hljs-keyword">for</span> example <span class="hljs-keyword">in</span> dataSet]<br>        uniqueVals = <span class="hljs-built_in">set</span>(featList)  <span class="hljs-comment"># 该属性的取值集合</span><br>        newEntropy = <span class="hljs-number">0.0</span><br>        <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> uniqueVals: <span class="hljs-comment"># 对每一种取值计算信息增益</span><br>            subDataSet = splitDataSet(dataSet, i, value)<br>            prob = <span class="hljs-built_in">len</span>(subDataSet) / <span class="hljs-built_in">float</span>(<span class="hljs-built_in">len</span>(dataSet))<br>            newEntropy += prob * calcShannonEnt(subDataSet)<br>        infoGain = baseEntropy - newEntropy<br>        <span class="hljs-keyword">if</span> (infoGain &gt; bestInfoGain):  <span class="hljs-comment"># 选择信息增益最大的属性</span><br>            bestInfoGain = infoGain<br>            bestFeature = i<br>    <span class="hljs-keyword">return</span> bestFeature<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">majorityCnt</span>(<span class="hljs-params">classList</span>):<br>    classCount = &#123;&#125;<br>    <span class="hljs-keyword">for</span> vote <span class="hljs-keyword">in</span> classList:<br>        <span class="hljs-keyword">if</span> vote <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> classCount.keys(): classCount[vote] = <span class="hljs-number">0</span><br>        classCount[vote] += <span class="hljs-number">1</span><br>    sortedClassCount = <span class="hljs-built_in">sorted</span>(classCount.iteritems(),<br>                              key=operator.itemgetter(<span class="hljs-number">1</span>), reverse=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> sortedClassCount[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br> <br> <br><span class="hljs-comment"># 递归构建决策树</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">createTree</span>(<span class="hljs-params">dataSet, labels</span>):<br>    classList = [example[-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> example <span class="hljs-keyword">in</span> dataSet]  <span class="hljs-comment"># 类别向量</span><br>    <span class="hljs-keyword">if</span> classList.count(classList[<span class="hljs-number">0</span>]) == <span class="hljs-built_in">len</span>(classList):  <span class="hljs-comment"># 如果只有一个类别，返回</span><br>        <span class="hljs-keyword">return</span> classList[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(dataSet[<span class="hljs-number">0</span>]) == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 如果所有特征都被遍历完了，返回出现次数最多的类别</span><br>        <span class="hljs-keyword">return</span> majorityCnt(classList)<br>    bestFeat = chooseBestFeatureToSplit(dataSet)  <span class="hljs-comment"># 最优划分属性的索引</span><br>    bestFeatLabel = labels[bestFeat]  <span class="hljs-comment"># 最优划分属性的标签</span><br>    myTree = &#123;bestFeatLabel: &#123;&#125;&#125;<br>    <span class="hljs-keyword">del</span> (labels[bestFeat])  <span class="hljs-comment"># 已经选择的特征不再参与分类</span><br>    featValues = [example[bestFeat] <span class="hljs-keyword">for</span> example <span class="hljs-keyword">in</span> dataSet]<br>    uniqueValue = <span class="hljs-built_in">set</span>(featValues)  <span class="hljs-comment"># 该属性所有可能取值，也就是节点的分支</span><br>    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> uniqueValue:  <span class="hljs-comment"># 对每个分支，递归构建树</span><br>        subLabels = labels[:]<br>        myTree[bestFeatLabel][value] = createTree(<br>            splitDataSet(dataSet, bestFeat, value), subLabels)<br>    <span class="hljs-keyword">return</span> myTree<br></code></pre></td></tr></table></figure><p>画图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 定义文本框和箭头格式</span><br>decisionNode = <span class="hljs-built_in">dict</span>(boxstyle=<span class="hljs-string">&quot;round4&quot;</span>, color=<span class="hljs-string">&#x27;#3366FF&#x27;</span>)  <span class="hljs-comment">#定义判断结点形态</span><br>leafNode = <span class="hljs-built_in">dict</span>(boxstyle=<span class="hljs-string">&quot;circle&quot;</span>, color=<span class="hljs-string">&#x27;#FF6633&#x27;</span>)  <span class="hljs-comment">#定义叶结点形态</span><br>arrow_args = <span class="hljs-built_in">dict</span>(arrowstyle=<span class="hljs-string">&quot;&lt;-&quot;</span>, color=<span class="hljs-string">&#x27;g&#x27;</span>)  <span class="hljs-comment">#定义箭头</span><br><br><span class="hljs-comment">#绘制带箭头的注释</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plotNode</span>(<span class="hljs-params">nodeTxt, centerPt, parentPt, nodeType</span>):<br>    createPlot.ax1.annotate(nodeTxt, xy=parentPt, xycoords=<span class="hljs-string">&#x27;axes fraction&#x27;</span>,<br>                            xytext=centerPt, textcoords=<span class="hljs-string">&#x27;axes fraction&#x27;</span>,<br>                            va=<span class="hljs-string">&quot;center&quot;</span>, ha=<span class="hljs-string">&quot;center&quot;</span>, bbox=nodeType, arrowprops=arrow_args)<br><br><br><span class="hljs-comment">#计算叶结点数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getNumLeafs</span>(<span class="hljs-params">myTree</span>):<br>    numLeafs = <span class="hljs-number">0</span><br>    firstStr = <span class="hljs-built_in">list</span>(myTree.keys())[<span class="hljs-number">0</span>]<br>    secondDict = myTree[firstStr]<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> secondDict.keys():<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(secondDict[key]).__name__ == <span class="hljs-string">&#x27;dict&#x27;</span>:<br>            numLeafs += getNumLeafs(secondDict[key])<br>        <span class="hljs-keyword">else</span>:<br>            numLeafs += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> numLeafs<br><br><br><span class="hljs-comment">#计算树的层数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getTreeDepth</span>(<span class="hljs-params">myTree</span>):<br>    maxDepth = <span class="hljs-number">0</span><br>    firstStr = <span class="hljs-built_in">list</span>(myTree.keys())[<span class="hljs-number">0</span>]<br>    secondDict = myTree[firstStr]<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> secondDict.keys():<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(secondDict[key]).__name__ == <span class="hljs-string">&#x27;dict&#x27;</span>:<br>            thisDepth = <span class="hljs-number">1</span> + getTreeDepth(secondDict[key])<br>        <span class="hljs-keyword">else</span>:<br>            thisDepth = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> thisDepth &gt; maxDepth:<br>            maxDepth = thisDepth<br>    <span class="hljs-keyword">return</span> maxDepth<br><br><br><span class="hljs-comment">#在父子结点间填充文本信息</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plotMidText</span>(<span class="hljs-params">cntrPt, parentPt, txtString</span>):<br>    xMid = (parentPt[<span class="hljs-number">0</span>] - cntrPt[<span class="hljs-number">0</span>]) / <span class="hljs-number">2.0</span> + cntrPt[<span class="hljs-number">0</span>]<br>    yMid = (parentPt[<span class="hljs-number">1</span>] - cntrPt[<span class="hljs-number">1</span>]) / <span class="hljs-number">2.0</span> + cntrPt[<span class="hljs-number">1</span>]<br>    createPlot.ax1.text(xMid, yMid, txtString, va=<span class="hljs-string">&quot;center&quot;</span>, ha=<span class="hljs-string">&quot;center&quot;</span>, rotation=<span class="hljs-number">30</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plotTree</span>(<span class="hljs-params">myTree, parentPt, nodeTxt</span>):<br>    numLeafs = getNumLeafs(myTree)<br>    depth = getTreeDepth(myTree)<br>    firstStr = <span class="hljs-built_in">list</span>(myTree.keys())[<span class="hljs-number">0</span>]<br>    cntrPt = (plotTree.xOff + (<span class="hljs-number">1.0</span> + <span class="hljs-built_in">float</span>(numLeafs)) / <span class="hljs-number">2.0</span> / plotTree.totalW, plotTree.yOff)<br>    plotMidText(cntrPt, parentPt, nodeTxt)  <span class="hljs-comment">#在父子结点间填充文本信息</span><br>    plotNode(firstStr, cntrPt, parentPt, decisionNode)  <span class="hljs-comment">#绘制带箭头的注释</span><br>    secondDict = myTree[firstStr]<br>    plotTree.yOff = plotTree.yOff - <span class="hljs-number">1.0</span> / plotTree.totalD<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> secondDict.keys():<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(secondDict[key]).__name__ == <span class="hljs-string">&#x27;dict&#x27;</span>:<br>            plotTree(secondDict[key], cntrPt, <span class="hljs-built_in">str</span>(key))<br>        <span class="hljs-keyword">else</span>:<br>            plotTree.xOff = plotTree.xOff + <span class="hljs-number">1.0</span> / plotTree.totalW<br>            plotNode(secondDict[key], (plotTree.xOff, plotTree.yOff), cntrPt, leafNode)<br>            plotMidText((plotTree.xOff, plotTree.yOff), cntrPt, <span class="hljs-built_in">str</span>(key))<br>    plotTree.yOff = plotTree.yOff + <span class="hljs-number">1.0</span> / plotTree.totalD<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">createPlot</span>(<span class="hljs-params">inTree</span>):<br>    fig = plt.figure(<span class="hljs-number">1</span>, facecolor=<span class="hljs-string">&#x27;white&#x27;</span>)<br>    fig.clf()<br>    axprops = <span class="hljs-built_in">dict</span>(xticks=[], yticks=[])<br>    createPlot.ax1 = plt.subplot(<span class="hljs-number">111</span>, frameon=<span class="hljs-literal">False</span>, **axprops)<br>    plotTree.totalW = <span class="hljs-built_in">float</span>(getNumLeafs(inTree))<br>    plotTree.totalD = <span class="hljs-built_in">float</span>(getTreeDepth(inTree))<br>    plotTree.xOff = -<span class="hljs-number">0.5</span> / plotTree.totalW;<br>    plotTree.yOff = <span class="hljs-number">1.0</span>;<br>    plotTree(inTree, (<span class="hljs-number">0.5</span>, <span class="hljs-number">1.0</span>), <span class="hljs-string">&#x27;&#x27;</span>)<br>    plt.show()<br><br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">classify</span>(<span class="hljs-params">inputTree, featLabels, testVec</span>):<br>    firstStr = <span class="hljs-built_in">list</span>(inputTree.keys())[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 根节点</span><br>    secondDict = inputTree[firstStr]<br>    featIndex = featLabels.index(firstStr)  <span class="hljs-comment"># 跟节点对应的属性</span><br>    classLabel = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> secondDict.keys():  <span class="hljs-comment"># 对每个分支循环</span><br>        <span class="hljs-keyword">if</span> testVec[featIndex] == key:  <span class="hljs-comment"># 测试样本进入某个分支</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(secondDict[key]).__name__ == <span class="hljs-string">&#x27;dict&#x27;</span>:  <span class="hljs-comment"># 该分支不是叶子节点，递归</span><br>                classLabel = classify(secondDict[key], featLabels, testVec)<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 如果是叶子， 返回结果</span><br>                classLabel = secondDict[key]<br>    <span class="hljs-keyword">return</span> classLabel<br></code></pre></td></tr></table></figure><p>主函数执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> csv<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data</span>(<span class="hljs-params">filename</span>):<br>    lines = csv.reader(<span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&quot;rt&quot;</span>,encoding=<span class="hljs-string">&#x27;utf-8-sig&#x27;</span>))<br>    dataset = <span class="hljs-built_in">list</span>(lines)<br>    <span class="hljs-keyword">return</span> dataset<br><br>filename=<span class="hljs-string">&quot;G:/学习/课程相关/大三/大数据挖掘/上机/4/thisdata.csv&quot;</span> <br>listWm = load_data(filename)<br>labels = [<span class="hljs-string">&#x27;Outlook&#x27;</span>, <span class="hljs-string">&#x27;Temperature&#x27;</span>, <span class="hljs-string">&#x27;Humidity&#x27;</span>, <span class="hljs-string">&#x27;Windy&#x27;</span>]<br>Trees = createTree(listWm, labels)<br>createPlot(Trees)<br>labels = [<span class="hljs-string">&#x27;Outlook&#x27;</span>, <span class="hljs-string">&#x27;Temperature&#x27;</span>, <span class="hljs-string">&#x27;Humidity&#x27;</span>, <span class="hljs-string">&#x27;Windy&#x27;</span>]<br>testData = [<span class="hljs-string">&#x27;Rain&#x27;</span>, <span class="hljs-string">&#x27;Cool&#x27;</span>, <span class="hljs-string">&#x27;High&#x27;</span>, <span class="hljs-string">&#x27;Not&#x27;</span>]<br>testClass = classify(Trees, labels, testData)<br><span class="hljs-built_in">print</span>(testClass)<br><br></code></pre></td></tr></table></figure><p><img src="/2019/10/23/ID3%E5%AE%9E%E7%8E%B0%E5%86%B3%E7%AD%96%E6%A0%91/output.png"><br>输出结果:No</p>]]></content>
      
      
      <categories>
          
          <category> 大数据挖掘及应用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python日常问题总结</title>
      <link href="/2019/10/23/Python%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2019/10/23/Python%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>总结平时学习遇到的python使用中出现的问题以及python的一些用法，注意事项</p><span id="more"></span><h1 id="使用问题"><a href="#使用问题" class="headerlink" title="使用问题"></a>使用问题</h1><h2 id="python读取csv文件出现’-ufeff’乱码的解决方法"><a href="#python读取csv文件出现’-ufeff’乱码的解决方法" class="headerlink" title="python读取csv文件出现’\ufeff’乱码的解决方法"></a>python读取csv文件出现’\ufeff’乱码的解决方法</h2><p><a href="https://www.jianshu.com/p/4eef0b44da58">原文链接</a><br><br>使用python中的csv模块读取文件的时候使用encoding&#x3D;’utf-8’解码，会在读取了列表的一个位出现‘‘\ufeff’’，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">csv_reader</span>():<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;2.csv&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        reader=csv.reader(f)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(reader)<br><br>list1=csv_reader()<br><span class="hljs-built_in">print</span>(list1)<br></code></pre></td></tr></table></figure><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#输出结果<br>[[<span class="hljs-string">&#x27;\ufeff2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>], [<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>], [<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>], [<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>], [<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>], [<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>], [<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>], <br>[<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;10&#x27;</span>],[<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-string">&#x27;11&#x27;</span>], [<span class="hljs-string">&#x27;11&#x27;</span>, <span class="hljs-string">&#x27;12&#x27;</span>], [<span class="hljs-string">&#x27;12&#x27;</span>, <span class="hljs-string">&#x27;13&#x27;</span>], [<span class="hljs-string">&#x27;13&#x27;</span>, <span class="hljs-string">&#x27;14&#x27;</span>], [<span class="hljs-string">&#x27;14&#x27;</span>, <span class="hljs-string">&#x27;15&#x27;</span>]]<br></code></pre></td></tr></table></figure><p>要去掉这个字符，只需要在读取的时候使用encoding&#x3D;’utf-8-sig’格式就好,代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">csv_reader</span>():<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;2.csv&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8-sig&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        reader=csv.reader(f)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(reader)<br><br>list1=csv_reader()<br><span class="hljs-built_in">print</span>(list1)<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">#输出结果<br><span class="hljs-selector-attr">[[<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>]</span>, <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>]</span>, <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>]</span>, <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>]</span>, <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>]</span>, <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>]</span>, <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>]</span>, <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;10&#x27;</span>]</span>, <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;1</span></span><br></code></pre></td></tr></table></figure><h2 id="在java中调用cmd-运行python程序，其实是通过cmd调用，本代码是在网上找到的代码修改而来，忘记具体地址了，抱歉。"><a href="#在java中调用cmd-运行python程序，其实是通过cmd调用，本代码是在网上找到的代码修改而来，忘记具体地址了，抱歉。" class="headerlink" title="在java中调用cmd,运行python程序，其实是通过cmd调用，本代码是在网上找到的代码修改而来，忘记具体地址了，抱歉。"></a>在java中调用cmd,运行python程序，其实是通过cmd调用，本代码是在网上找到的代码修改而来，忘记具体地址了，抱歉。</h2><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">doimagecaption</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//System.out.print(&quot;开始运行&quot;);</span><br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D://temp.tmp&quot;</span>);<span class="hljs-comment">//新建一个用来存储结果的缓存文件</span><br><span class="hljs-keyword">if</span>(!file.exists()) &#123;<br>file.createNewFile();<br>System.out.print(<span class="hljs-string">&quot;创建文件&quot;</span>);<br><span class="hljs-type">ProcessBuilder</span> <span class="hljs-variable">pb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessBuilder</span>().command(<span class="hljs-string">&quot;cmd.exe&quot;</span>, <span class="hljs-string">&quot;/c&quot;</span>, <span class="hljs-string">&quot;g:&amp;cd imgcp&amp;activate&amp;python main.py --phase=test --model_file=\&quot;./models/289999.npy\&quot; --beam_size=3&quot;</span>).inheritIO();<br>    <span class="hljs-comment">//ProcessBuilder pb = new ProcessBuilder().command(&quot;cmd.exe&quot;, &quot;/c&quot;, &quot;ipconfig&quot;).inheritIO();</span><br>System.out.print(<span class="hljs-string">&quot;创建pb&quot;</span>);<br>pb.redirectErrorStream(<span class="hljs-literal">true</span>);<span class="hljs-comment">//这里是把控制台中的红字变成了黑字，用通常的方法其实获取不到，控制台的结果是pb.start()方法内部输出的</span><br>pb.redirectOutput(file);<span class="hljs-comment">//把执行结果输出。</span><br>pb.start().waitFor();<span class="hljs-comment">//等待语句执行完成，否则可能会读不到结果。</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>br= <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(in));<br><span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">while</span>((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>System.out.println(line);<br>&#125;<br>br.close();<br>br = <span class="hljs-literal">null</span>;<br>file.delete();<br>&#125;  <br><span class="hljs-keyword">if</span>(br != <span class="hljs-literal">null</span>) <br>br.close();<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>如果使用的话只需要按如下示意修改即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">command(<span class="hljs-string">&quot;cmd.exe&quot;</span>, <span class="hljs-string">&quot;/c&quot;</span>, <span class="hljs-string">&quot;填入本应在cmd里输入的内容，多条语句可以使用&amp;拼接&quot;</span>).inheritIO();<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单个神经元</title>
      <link href="/2019/10/20/%E5%8D%95%E4%B8%AA%E7%A5%9E%E7%BB%8F%E5%85%83/"/>
      <url>/2019/10/20/%E5%8D%95%E4%B8%AA%E7%A5%9E%E7%BB%8F%E5%85%83/</url>
      
        <content type="html"><![CDATA[<ul><li>单个神经元</li><li>激活函数</li><li>损失函数</li><li>优化器</li><li>Maxout<span id="more"></span></li></ul><h1 id="单个神经元"><a href="#单个神经元" class="headerlink" title="单个神经元"></a>单个神经元</h1><p>一个神经元由以下几个关键知识点组成：</p><ul><li>激活函数</li><li>损失函数</li><li>梯度下降</li></ul><p>将所有输入的信号经过w变换后，再添加一个额外的偏执量b，把它们加载一起求和，然后在选择一个模拟细胞体处理的函数来实现整个过程的仿真。这个函数称为激活函数。<br><br>把w和b赋予合适的值时，配合合适的激活函数，就会发现可以产生很好的拟合效果，这个过程叫做正向传播<br><br>实际过程中无法得知w和b的值具体是多少才是正常的，因此加入训练过程来让模型自动修正，最终产生一个合适的权重,这叫做反向传播<br><br>而如何将输出的误差转化为权重的误差，使用BP算法(误差反向传播算法)<br></p><p>激活函数主要作用是用来加入非线性因素的，以解决线性模型表达能力不足的缺陷<br><br>神经网络里常用的激活函数有Sigmoid，Tanh和Relu等<br><br>Sigmoid函数：把输入的值压缩到0到1之间，TensorFlow中对应函数为tf.nn.sigmoid(x,name&#x3D;None)<br><br>Tanh函数：将值域扩展到-1到1之间，TensorFlow对应函数tf.nn.tanh(x,name&#x3D;None)<br><br>ReLU函数(也称为Rectifier)，max(0,x) ，仅在正向传播方面在信号响应上有优势，<br>TensorFlow中对应函数：</p><ul><li>tf.nn.relu(features,name&#x3D;None)：一般的ReLU函数，max(features,0)</li><li>tf.nn.relu6(features,name&#x3D;None):是以6位阈值的ReLU函数，即min(max(features,0),6)</li></ul><p>relu6存在的原因是防止梯度爆炸， 当节点和层数特别多<br>而且输出都为正时， 它们的加和会是一个很大的值， 尤其在经历几层变<br>换之后， 最终的值可能会离目标值相差太远。 误差太大， 会导致对参数<br>调整修正值过大， 这会导致网络抖动得较厉害， 最终很难收敛。</p><p>其他变种：</p><ul><li>tf.nn.softplus(features,name&#x3D;None)</li><li>tf.nn.elu(features,name&#x3D;None)</li><li>tf.maximum(x,leak*x,name&#x3D;name) #leak为传入的参数，可以设为0.01等</li></ul><p>还可以手动封装Swish函数，要优于ReLU函数<br></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Swish</span>(<span class="hljs-params">x,beta=<span class="hljs-number">1</span></span>):<br><span class="hljs-keyword">return</span> x*tf.nn.sigmoid(x*beta)<br></code></pre></td></tr></table></figure><p>softmax算法-处理分类问题<br><br>tf.nn.softmax(logits,name&#x3D;None) 计算softmax<br><br>tf.nn.log_softmax(logits,name&#x3D;None) 对softmax取对数<br><br>实际使用中，softmax伴随的分类标签都为one_hot编码，在softmax时，需要将目标分成几类，就在最后这层放几个节点</p><p>损失函数<br><br>两种比较常见的损失函数:</p><ul><li>均值平方差</li><li>交叉熵</li></ul><p>损失函数的选取取决于输入标签数据的类型<br><br>如果输入的是实数、无界的值，损失函数使用平方差<br><br>如果输入的标签是位矢量(分类标志)，使用交叉熵会更合适<br></p><p>TensorFlow中的梯度下降函数<br><br>在TensorFlow中是通过一个叫做Optimizer的优化器类进行训练优化的，对于不同算法的优化器，在TensorFlow中有不同的类<br><br>在训练过程中，先实例化一个优化函数如tf.train.GradientDescentOptimizer,并基于一定的学习率进行梯度优化训练</p><p>optimizer&#x3D;tf.train.GradentDescentOptimizer(learning_rate)<br><br>接着使用一个minimize()的操作，里面传入损失值节点loss，再启动一个外层的循环，优化器就会按照循环的次数一次次沿着loss最小值的方向优化参数<br><br>目前比较常用的优化器为Adam优化器</p><p>每个优化器的第一个参数learning_rate代表学习率，设置学习率的方法：退化学习率，又叫学习率衰减<br><br>例如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">learning_rate</span>=tf.train.exponential_decay(starter_learning_rate,global_step,<span class="hljs-number">100000</span>,<span class="hljs-number">0</span>.<span class="hljs-number">96</span>)<br></code></pre></td></tr></table></figure><p>这种方式定义的学习率就是退化学习率，它的意思是当前迭代到global_step步，学习率每一步都按照每10万步缩小到0.96%的速度衰退<br><br>通过增大批次处理样本的数量也可以起到退化学习率的效果。但是这种方法要求训练时的最小批次要与实际应用中的最小批次一致</p><h1 id="单个神经元的扩展——Maxout网络"><a href="#单个神经元的扩展——Maxout网络" class="headerlink" title="单个神经元的扩展——Maxout网络"></a>单个神经元的扩展——Maxout网络</h1><p>将激活函数变成一个网络选择器，原理就是将多个神经元并列地放在一起，从它们的输出结果找到最大的那个，代表对特征响应最敏感，然后取这个神尽管的结果参与后面的运算。这样的网络会有更好的拟合效果<br><br>Maxout的拟合功能很强大，但是也有节点过多，参数过多，训练过慢的缺点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tensorflow.examples.tutorials.mnist <span class="hljs-keyword">import</span> input_data<br>mnist = input_data.read_data_sets(<span class="hljs-string">&quot;MNIST_data/&quot;</span>)<br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf <span class="hljs-comment">#导入tensorflow库</span><br><br>tf.reset_default_graph()<br><span class="hljs-comment"># tf Graph Input</span><br>x = tf.placeholder(tf.float32, [<span class="hljs-literal">None</span>, <span class="hljs-number">784</span>]) <span class="hljs-comment"># mnist data维度 28*28=784</span><br>y = tf.placeholder(tf.int32, [<span class="hljs-literal">None</span>]) <span class="hljs-comment"># 0-9 数字=&gt; 10 classes</span><br><br><span class="hljs-comment"># Set model weights</span><br>W = tf.Variable(tf.random_normal([<span class="hljs-number">784</span>, <span class="hljs-number">10</span>]))<br>b = tf.Variable(tf.zeros([<span class="hljs-number">10</span>]))<br><br><br>z= tf.matmul(x, W) + b<br><br><br>maxout = tf.reduce_max(z,axis= <span class="hljs-number">1</span>,keep_dims=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># Set model weights</span><br>W2 = tf.Variable(tf.truncated_normal([<span class="hljs-number">1</span>, <span class="hljs-number">10</span>], stddev=<span class="hljs-number">0.1</span>))<br>b2 = tf.Variable(tf.zeros([<span class="hljs-number">1</span>]))<br><span class="hljs-comment"># 构建模型</span><br>pred = tf.nn.softmax(tf.matmul(maxout, W2) + b2)<br><br><span class="hljs-comment"># 构建模型</span><br><span class="hljs-comment">#pred = tf.nn.softmax(z) # Softmax分类</span><br><br><span class="hljs-comment"># Minimize error using cross entropy</span><br><span class="hljs-comment">#cost = tf.reduce_mean(-tf.reduce_sum(y*tf.log(pred), reduction_indices=1))</span><br>cost = tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y, logits=z))<br><span class="hljs-comment">#参数设置</span><br>learning_rate = <span class="hljs-number">0.04</span><br><span class="hljs-comment"># 使用梯度下降优化器</span><br>optimizer = tf.train.GradientDescentOptimizer(learning_rate).minimize(cost)<br><br>training_epochs = <span class="hljs-number">200</span><br>batch_size = <span class="hljs-number">100</span><br>display_step = <span class="hljs-number">1</span><br><br><br><span class="hljs-comment"># 启动session</span><br><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:<br>    sess.run(tf.global_variables_initializer())<span class="hljs-comment"># Initializing OP</span><br><br>    <span class="hljs-comment"># 启动循环开始训练</span><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(training_epochs):<br>        avg_cost = <span class="hljs-number">0.</span><br>        total_batch = <span class="hljs-built_in">int</span>(mnist.train.num_examples/batch_size)<br>        <span class="hljs-comment"># 遍历全部数据集</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(total_batch):<br>            batch_xs, batch_ys = mnist.train.next_batch(batch_size)<br>            <span class="hljs-comment"># Run optimization op (backprop) and cost op (to get loss value)</span><br>            _, c = sess.run([optimizer, cost], feed_dict=&#123;x: batch_xs,<br>                                                          y: batch_ys&#125;)<br>            <span class="hljs-comment"># Compute average loss</span><br>            avg_cost += c / total_batch<br>        <span class="hljs-comment"># 显示训练中的详细信息</span><br>        <span class="hljs-keyword">if</span> (epoch+<span class="hljs-number">1</span>) % display_step == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;Epoch:&quot;</span>, <span class="hljs-string">&#x27;%04d&#x27;</span> % (epoch+<span class="hljs-number">1</span>), <span class="hljs-string">&quot;cost=&quot;</span>, <span class="hljs-string">&quot;&#123;:.9f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(avg_cost))<br><br>    <span class="hljs-built_in">print</span>( <span class="hljs-string">&quot; Finished!&quot;</span>)<br><br><br></code></pre></td></tr></table></figure><pre><code class="hljs">Epoch: 0001 cost= 4.593184041Epoch: 0002 cost= 1.818854022Epoch: 0003 cost= 1.314909137、、、Epoch: 0197 cost= 0.289531484Epoch: 0198 cost= 0.289406507Epoch: 0199 cost= 0.289030269Epoch: 0200 cost= 0.288644536 Finished!</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础练习-mnist手写数据集识别</title>
      <link href="/2019/10/20/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-mnist%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%86%E5%88%AB/"/>
      <url>/2019/10/20/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-mnist%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>照着书实现了一下mnist手写数据集识别这个深度学习中的”hello,world”</p><span id="more"></span><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>第一层接收输入信号，最后一层返回输出信号，这些网络通常都是前馈神经网络<br><br>传递函数：最常用的一种传递函数就是sigmoid函数，值域为(0,1）<br><br>一般情况下，前馈神经网络的最后一层会采用一个softmax函数，这样可以方便地用后验概率解释网络的输出</p><h1 id="MNIST手写数字数据集"><a href="#MNIST手写数字数据集" class="headerlink" title="MNIST手写数字数据集"></a>MNIST手写数字数据集</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> tensorflow.examples.tutorials.mnist <span class="hljs-keyword">import</span> input_data<br>%matplotlib inline<br>mnist_data=input_data.read_data_sets(<span class="hljs-string">&quot;Data/data&quot;</span>,one_hot=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;输入数据:&#x27;</span>,mnist_data.train.images)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;输入数据的shape&#x27;</span>,mnist_data.train.images.shape)<br><span class="hljs-keyword">import</span> pylab<br>im=mnist_data.train.images[<span class="hljs-number">1</span>]<br>im=im.reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">28</span>)<br>pylab.imshow(im)<br>pylab.show()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Extracting Data/data\train-images-idx3-ubyte.gzExtracting Data/data\train-labels-idx1-ubyte.gzExtracting Data/data\t10k-images-idx3-ubyte.gzExtracting Data/data\t10k-labels-idx1-ubyte.gz输入数据: [[0. 0. 0. ... 0. 0. 0.] [0. 0. 0. ... 0. 0. 0.] [0. 0. 0. ... 0. 0. 0.] ... [0. 0. 0. ... 0. 0. 0.] [0. 0. 0. ... 0. 0. 0.] [0. 0. 0. ... 0. 0. 0.]]输入数据的shape (55000, 784)</code></pre><p><img src="/2019/10/20/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-mnist%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%86%E5%88%AB/output_3_1.png" alt="png"></p><p>mnist数据集 输入图片是个550000x784的矩阵，第一个维度代表图片索引，第二个<br>维度代表图像像素，28x28像素的图片，共有10个类别<br><br>所以先创建一个[None,784]的占位符x和一个[None,10]的占位符y</p><p>交叉熵可在神经网络(机器学习)中作为损失函数，p表示真实标记的分布，q则为训练后的模型的预测标记分布，交叉熵损失函数可以衡量p与q的相似性。交叉熵作为损失函数还有一个好处是使用sigmoid函数在梯度下降时能避免均方误差损失函数学习速率降低的问题，因为学习速率可以被输出的误差所控制。 [</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">from</span> tensorflow.examples.tutorials.mnist <span class="hljs-keyword">import</span> input_data<br>mnist=input_data.read_data_sets(<span class="hljs-string">&quot;Data/data/&quot;</span>,one_hot=<span class="hljs-literal">True</span>)<br><span class="hljs-keyword">import</span> pylab<br>tf.reset_default_graph()<br>x=tf.placeholder(tf.float32,[<span class="hljs-literal">None</span>,<span class="hljs-number">784</span>])<br>y=tf.placeholder(tf.float32,[<span class="hljs-literal">None</span>,<span class="hljs-number">10</span>])<br><span class="hljs-comment">#定义学习参数</span><br>W=tf.Variable(tf.random_normal([<span class="hljs-number">784</span>,<span class="hljs-number">10</span>])) <span class="hljs-comment">#W设为随机值</span><br>b=tf.Variable(tf.zeros([<span class="hljs-number">10</span>]))<span class="hljs-comment">#b设为0</span><br><span class="hljs-comment">#构建模型</span><br>pred=tf.nn.softmax(tf.matmul(x,W)+b)<span class="hljs-comment">#softmax分类</span><br><span class="hljs-comment">#定义反向传播结构，进行优化</span><br><span class="hljs-comment">#损失函数</span><br>cost=tf.reduce_mean(-tf.reduce_sum(y*tf.log(pred),reduction_indices=<span class="hljs-number">1</span>))<br><span class="hljs-comment">#定义参数</span><br>learning_rate=<span class="hljs-number">0.01</span><br><span class="hljs-comment">#使用梯度下降优化器</span><br>optimizer=tf.train.GradientDescentOptimizer(learning_rate).minimize(cost)<br><span class="hljs-comment">#开始训练模型</span><br><span class="hljs-comment">#定义训练迭代次数</span><br>training_epochs=<span class="hljs-number">25</span><br><span class="hljs-comment">#定义在训练过程中一次取100条数据进行训练</span><br>batch_size=<span class="hljs-number">100</span><br><span class="hljs-comment">#显示训练中间状态的间隔</span><br>display_step=<span class="hljs-number">1</span><br><br><span class="hljs-comment">#保存模型</span><br>saver=tf.train.Saver()<br>model_path=<span class="hljs-string">&quot;log/521model.ckpt&quot;</span><br><br><span class="hljs-comment">#启动session</span><br><span class="hljs-keyword">with</span> tf.Session(config=tf.ConfigProto(log_device_placement=<span class="hljs-literal">True</span>)) <span class="hljs-keyword">as</span> sess:<br>        sess.run(tf.global_variables_initializer())<br>        <span class="hljs-comment">#启动循环开始训练</span><br>        <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(training_epochs):<br>            avg_cost=<span class="hljs-number">0.0</span><br>            total_batch=<span class="hljs-built_in">int</span>(mnist.train.num_examples/batch_size)<br>            <span class="hljs-comment">#循环所有数据集</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(total_batch):<br>                batch_xs,batch_ys=mnist.train.next_batch(batch_size)<br>                <span class="hljs-comment">#运行优化器</span><br>                [opti,c]=sess.run([optimizer,cost],feed_dict=&#123;x:batch_xs,y:batch_ys&#125;)<br>                <span class="hljs-comment">#计算平均loss值</span><br>                avg_cost+=c/total_batch<br>                <span class="hljs-comment">#显示训练中的详细信息</span><br>            <span class="hljs-keyword">if</span> (epoch+<span class="hljs-number">1</span>)%display_step==<span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Epoch:&quot;</span>,<span class="hljs-string">&quot;%04d&quot;</span> % (epoch+<span class="hljs-number">1</span>),<span class="hljs-string">&quot;cost=&quot;</span>,<span class="hljs-string">&quot;&#123;:.9f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(avg_cost))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Finshed!&quot;</span>)<br>        <span class="hljs-comment">#保存模型</span><br>        save_path=saver.save(sess,model_path)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Model saved in file:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(save_path))<br><span class="hljs-keyword">if</span> tf.test.gpu_device_name():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Default GPU Device:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(tf.test.gpu_device_name()))<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Please install GPU version or TF&#x27;</span>)<br><br><span class="hljs-comment">#读取模型并将两张图片放进去让模型预测结果</span><br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Starting 2nd session...&quot;</span>)<br><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:<br>    <span class="hljs-comment">#初始化变量</span><br>    sess.run(tf.global_variables_initializer())<br>    <span class="hljs-comment">#恢复模型变量</span><br>    saver.restore(sess,model_path)<br>    <span class="hljs-comment">#测试 model</span><br>    correct_prediction=tf.equal(tf.arg_max(pred,<span class="hljs-number">1</span>),tf.arg_max(y,<span class="hljs-number">1</span>))<br>    <span class="hljs-comment">#计算准确率</span><br>    accuracy=tf.reduce_mean(tf.cast(correct_prediction,tf.float32))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy:&quot;</span>,accuracy.<span class="hljs-built_in">eval</span>(&#123;x:mnist.test.images,y:mnist.test.labels&#125;))<br>    output=tf.arg_max(pred,<span class="hljs-number">1</span>)<br>    output = tf.argmax(pred, <span class="hljs-number">1</span>)<br>    batch_xs, batch_ys = mnist.train.next_batch(<span class="hljs-number">2</span>)<br>    outputval,predv = sess.run([output,pred], feed_dict=&#123;x: batch_xs&#125;)<br>    <span class="hljs-built_in">print</span>(outputval,predv,batch_ys)<br>    im = batch_xs[<span class="hljs-number">0</span>]<br>    im = im.reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">28</span>)<br>    pylab.imshow(im)<br>    pylab.show()<br>    im = batch_xs[<span class="hljs-number">1</span>]<br>    im = im.reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">28</span>)<br>    pylab.imshow(im)<br>    pylab.show()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Extracting Data/data/train-images-idx3-ubyte.gzExtracting Data/data/train-labels-idx1-ubyte.gzExtracting Data/data/t10k-images-idx3-ubyte.gzExtracting Data/data/t10k-labels-idx1-ubyte.gzEpoch: 0001 cost= 8.901484704Epoch: 0002 cost= 4.491928911Epoch: 0003 cost= 3.105935341Epoch: 0004 cost= 2.460903181Epoch: 0005 cost= 2.088093793Epoch: 0006 cost= 1.843727299Epoch: 0007 cost= 1.670136872Epoch: 0008 cost= 1.539499564Epoch: 0009 cost= 1.437489002Epoch: 0010 cost= 1.355080850Epoch: 0011 cost= 1.287055298Epoch: 0012 cost= 1.229517875Epoch: 0013 cost= 1.180266858Epoch: 0014 cost= 1.137388955Epoch: 0015 cost= 1.099723647Epoch: 0016 cost= 1.066415745Epoch: 0017 cost= 1.036452132Epoch: 0018 cost= 1.009471819Epoch: 0019 cost= 0.985050059Epoch: 0020 cost= 0.962679997Epoch: 0021 cost= 0.942112822Epoch: 0022 cost= 0.923188624Epoch: 0023 cost= 0.905731321Epoch: 0024 cost= 0.889469135Epoch: 0025 cost= 0.874153477Finshed!Model saved in file:log/521model.ckptDefault GPU Device:/device:GPU:0Starting 2nd session...INFO:tensorflow:Restoring parameters from log/521model.ckptAccuracy: 0.8259[2 8] [[5.4470024e-06 1.0342207e-14 9.9999440e-01 8.0820775e-12 4.5177516e-12  3.1603236e-16 6.3706992e-08 3.8312063e-15 7.3337933e-11 3.1762011e-18] [2.8309601e-04 9.6081327e-05 1.4640624e-03 3.5183481e-10 1.6233769e-03  3.4435538e-03 1.4779908e-02 9.2782180e-08 9.7314465e-01 5.1651290e-03]] [[0. 0. 1. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 1. 0.]]</code></pre><p><img src="/2019/10/20/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-mnist%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%86%E5%88%AB/output_6_1.png" alt="png"></p><p><img src="/2019/10/20/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-mnist%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%86%E5%88%AB/output_6_2.png" alt="png"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TensorFlow编程基础</title>
      <link href="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>TensorFlow编程相关基础知识，会逐渐补充，以备复习</p><span id="more"></span><h1 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h1><p>一个TensorFlow程序的执行过程一般分为3个阶段：</p><ul><li>创建计算图</li><li>运行一个会话，以完成计算图中定义的操作</li><li>输出数据集合和分析</li></ul><p>用placeholder函数定义一个数据或张量需要3个参数。第一个是数据类型。第二个是占位<br>符 的形状,本例中为一个一维张量,含有一个条目,第三个是变量名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> session:  <span class="hljs-comment">#创建一个对象包含计算图</span><br>    x = tf.placeholder(tf.float32, [<span class="hljs-number">1</span>], name=<span class="hljs-string">&quot;x&quot;</span>) <span class="hljs-comment">#利用占位符概念定义变量</span><br>    y = tf.placeholder(tf.float32, [<span class="hljs-number">1</span>], name=<span class="hljs-string">&quot;y&quot;</span>)<br>    z = tf.constant(<span class="hljs-number">2.0</span>)<br>    y = x * z<br>    x_in = [<span class="hljs-number">100</span>]<span class="hljs-comment">#该程序可以处理非常大、非常复杂的x值，所以可以创建x_in列表，并使其指向占位符x。</span><br>    y_output = session.run(y, &#123;x: x_in&#125;) <span class="hljs-comment">#只有执行session.run()时，程序才会开始处理已定义的图元素</span><br>    <span class="hljs-built_in">print</span>(y_output)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[200.]</code></pre><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><p>TensorFlow的数据模型由张量表示。忽略那些复杂的数学定义，可以说（ TensorFlow中的）<br>“张量”指的是一个多维数值阵列。<br>这种数据结构由3个参数描述——阶（ rank）、 形状（ shape） 和数据类型（ type）</p><h2 id="阶"><a href="#阶" class="headerlink" title="阶"></a>阶</h2><p>每个张量的维度单位用阶来描述。它定义了张量的维数，因此，也被称为一个张量的量级或<br>张量的n个维。零阶张量是一个标量，一阶张量是一个向量，二阶张量是一个矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#定义TensorFlow中的标量，向量，矩阵，立方阵</span><br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br>scalar=tf.constant(<span class="hljs-number">100</span>)<br>vector=tf.constant([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br>matrix=tf.constant([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br>cube_matrix=tf.constant([[[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>]],[[<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>],[<span class="hljs-number">6</span>]],[[<span class="hljs-number">7</span>],[<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>]]])<br><span class="hljs-built_in">print</span>(scalar.get_shape())<br><span class="hljs-built_in">print</span>(vector.get_shape())<br><span class="hljs-built_in">print</span>(matrix.get_shape())<br><span class="hljs-built_in">print</span>(cube_matrix.get_shape())<br></code></pre></td></tr></table></figure><pre><code class="hljs">()(5,)(2, 3)(3, 3, 1)</code></pre><h2 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h2><p>张量的形状指的是其行数和列数<br>使用get_shape()函数</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>TensorFlow中数据的传递需要通过其API与NumPy数组的交互来完成<br><br>tf.constant()  定义常量<br><br>tf.variable()  定义变量</p><h2 id="取回"><a href="#取回" class="headerlink" title="取回"></a>取回</h2><p>同时取回多个操作的输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br>constant_A=tf.constant([<span class="hljs-number">100.0</span>])<br>constant_B=tf.constant([<span class="hljs-number">300.0</span>])<br>constant_C=tf.constant([<span class="hljs-number">3.0</span>])<br>sum_=tf.add(constant_A,constant_B)<br>mul_=tf.multiply(constant_A,constant_C)<br><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:<br>    result=sess.run([sum_,mul_])<br>    <span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[array([400.], dtype=float32), array([300.], dtype=float32)]</code></pre><h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p>注入机制将张量插入图节点，它用一个张量值暂时替代操作的输出。注入机制只用于在调用<br>run函数时，通过feed_dict传递参数。最常见的用法是使用tf.placeholder()创建feed操作，<br>并继承其他特定操作作为注入操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a=<span class="hljs-number">3</span><br>b=<span class="hljs-number">2</span><br>x=tf.placeholder(tf.float32,shape=(a,b))<br>y=tf.add(x,x)<br>data=np.random.rand(a,b)<br>sess=tf.Session()<br><span class="hljs-built_in">print</span>(sess.run(y,feed_dict=&#123;x:data&#125;))<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[1.1956241  0.17609641] [1.9851147  1.7567049 ] [0.4986568  0.8624873 ]]</code></pre><h1 id="TensorBoard"><a href="#TensorBoard" class="headerlink" title="TensorBoard"></a>TensorBoard</h1><p>训练神经网络时，有时会需要监控网络的参数，一般是节点的输入和输出。这样即可在每次<br>训练迭代后检查误差函数是否最小化，从而了解你的模型是否正确学习。<br><br>TensorFlow提供了TensorBoard框架，用于分析和调试神经网络模型。<br><br>TensorBoard采用所谓的汇总来查看模型的参数；一旦TensorFlow代码执行，我们就可以调用TensorBoard的图形用户界面来查看汇总数据。<br><br>此外， TensorBoard还可以显示并学习TensorFlow的计算图。一个深度神经网络模型的计算图<br>往往会非常复杂<br><br>工作流程如下：</p><ul><li>编译你的计算图&#x2F;代码；</li><li>添加汇总op到你需要分析的节点上；</li><li>照常运行你的计算图；</li><li>同时附带运行汇总op；</li><li>代码运行完成后， 启动TensorBoard；</li><li>可视化汇总输出。</li></ul><p>实例：实现一个单输入神经元<br><br>损失函数采用结果与期望值的差的平方，越小越好<br><br>优化函数采用梯度下降法<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br>input_value=tf.constant(<span class="hljs-number">0.5</span>,name=<span class="hljs-string">&quot;input_value&quot;</span>)  <span class="hljs-comment">#输入值，不变</span><br>weight=tf.Variable(<span class="hljs-number">1.0</span>,name=<span class="hljs-string">&quot;weight&quot;</span>)  <span class="hljs-comment">#权值，会更新</span><br>expected_output=tf.constant(<span class="hljs-number">0.0</span>,name=<span class="hljs-string">&quot;expected_output&quot;</span>) <span class="hljs-comment">#期望输出</span><br>model=tf.multiply(input_value,weight,<span class="hljs-string">&quot;model&quot;</span>) <span class="hljs-comment">#操作，模型</span><br>loss_function=tf.<span class="hljs-built_in">pow</span>(expected_output-model,<span class="hljs-number">2</span>) <span class="hljs-comment">#损失函数</span><br>optimizer=tf.train.GradientDescentOptimizer(<span class="hljs-number">0.025</span>).minimize(loss_function) <span class="hljs-comment">#优化函数</span><br><br><span class="hljs-comment">#接下来 tensorboard</span><br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> [input_value,weight,expected_output,model,loss_function]:<br>    tf.summary.scalar(value.op.name,value)<br>summaries=tf.summary.merge_all()  <span class="hljs-comment">#为每个运行的结点添加分析，然后总结</span><br>sess=tf.Session()<br>log_path=<span class="hljs-string">&quot;../Tensorboardlog\og_simple_stats&quot;</span><br>summary_writer=tf.summary.FileWriter(log_path,sess.graph) <span class="hljs-comment">#声明路径</span><br>sess.run(tf.global_variables_initializer())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    summary_writer.add_summary(sess.run(summaries),i) <span class="hljs-comment">#写入信息</span><br>    sess.run(optimizer)<br><br></code></pre></td></tr></table></figure><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>实例1：从一组看似混乱的数据中找出y&#x3D;2x的规律</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>%matplotlib inline<br>train_X=np.linspace(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)<br>train_Y=<span class="hljs-number">2</span>*train_X+np.random.randn(<span class="hljs-number">100</span>)*<span class="hljs-number">0.3</span><br><span class="hljs-comment">#显示模拟数据点</span><br>plt.plot(train_X,train_Y,<span class="hljs-string">&#x27;ro&#x27;</span>,label=<span class="hljs-string">&#x27;Original data&#x27;</span>)<br>plt.legend()<br>plt.show()<br><br></code></pre></td></tr></table></figure><p><img src="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/output_2_0.png" alt="png"></p><p>接下来进行模型搭建，正向和反向<br><br>创建模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">X=tf.placeholder(<span class="hljs-string">&quot;float&quot;</span>)<br>Y=tf.placeholder(<span class="hljs-string">&quot;float&quot;</span>)<br><span class="hljs-comment">#模型参数</span><br>W=tf.Variable(tf.random_normal([<span class="hljs-number">1</span>]),name=<span class="hljs-string">&quot;weight&quot;</span>)<br><span class="hljs-comment">#tf.random_normal()函数用于从服从指定正态分布的数值中取出指定个数的值</span><br>b=tf.Variable(tf.zeros([<span class="hljs-number">1</span>]),name=<span class="hljs-string">&quot;bias&quot;</span>)<br><span class="hljs-comment">#前向结构</span><br>z=tf.multiply(X,W)+b  <span class="hljs-comment">#乘以权值加上偏差</span><br><span class="hljs-comment">#反向优化</span><br>cost=tf.reduce_mean(tf.square(Y-z))<br><span class="hljs-comment">#学习率一般小于1，小而精确且慢</span><br>learning_rate=<span class="hljs-number">0.01</span><br><span class="hljs-comment">#梯度下降</span><br>optimizer=tf.train.GradientDescentOptimizer(learning_rate).minimize(cost)<br></code></pre></td></tr></table></figure><p>接下来迭代训练模型，先进行全局初始化，然后设置训练迭代的次数，启动session开始运行任务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python">init=tf.global_variables_initializer()<br><span class="hljs-comment">#定义参数</span><br>training_epochs=<span class="hljs-number">20</span> <span class="hljs-comment">#迭代次数</span><br>display_step=<span class="hljs-number">2</span><br>saver=tf.train.Saver()<br>savedir=<span class="hljs-string">&quot;log/&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">moving_average</span>(<span class="hljs-params">a,w=<span class="hljs-number">10</span></span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a)&lt;w:<br>        <span class="hljs-keyword">return</span> a[:]<br>    <span class="hljs-keyword">return</span> [val <span class="hljs-keyword">if</span> idx&lt;w <span class="hljs-keyword">else</span> <span class="hljs-built_in">sum</span>(a[(idx-w):idx])/w <span class="hljs-keyword">for</span> idx,val <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a)]<br><span class="hljs-comment">#启动session</span><br><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:<br>    sess.run(init)<br>    plotdata=&#123;<span class="hljs-string">&quot;batchsize&quot;</span>:[],<span class="hljs-string">&quot;loss&quot;</span>:[]&#125;  <span class="hljs-comment">#存放批次值和损失值</span><br>    <span class="hljs-comment">#向模型输入数据</span><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(training_epochs):<br>        <span class="hljs-keyword">for</span> (x,y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(train_X,train_Y):<br>            sess.run(optimizer,feed_dict=&#123;X:x,Y:y&#125;)<br>            <br>        <span class="hljs-comment">#显示训练中的详细信息</span><br>        <span class="hljs-keyword">if</span> epoch % display_step==<span class="hljs-number">0</span>:<br>            loss=sess.run(cost,feed_dict=&#123;X:train_X,Y:train_Y&#125;)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Epoch:&quot;</span>,epoch+<span class="hljs-number">1</span>,<span class="hljs-string">&quot;cost=&quot;</span>,loss,<span class="hljs-string">&quot;W=&quot;</span>,sess.run(W),<span class="hljs-string">&quot;b=&quot;</span>,sess.run(b))<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (loss==<span class="hljs-string">&quot;NA&quot;</span>):<br>                plotdata[<span class="hljs-string">&quot;batchsize&quot;</span>].append(epoch)<br>                plotdata[<span class="hljs-string">&quot;loss&quot;</span>].append(loss)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Finished!&quot;</span>)<br>    saver.save(sess,savedir+<span class="hljs-string">&quot;linermodel.cpkt&quot;</span>) <span class="hljs-comment">#保存模型</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;cost=&quot;</span>,sess.run(cost,feed_dict=&#123;X:train_X,Y:train_Y&#125;),<span class="hljs-string">&quot;W=&quot;</span>,sess.run(W),<br>         <span class="hljs-string">&quot;b=&quot;</span>,sess.run(b))<br><br>    <span class="hljs-comment">#训练模型可视化，可视化生成的模型和训练中的状态值</span><br>    plt.plot(train_X,train_Y,<span class="hljs-string">&#x27;ro&#x27;</span>,label=<span class="hljs-string">&#x27;Original data&#x27;</span>)<br>    plt.plot(train_X,sess.run(W)*train_X+sess.run(b),label=<span class="hljs-string">&#x27;Fittedline&#x27;</span>)<br>    plt.legend()<br>    plt.show()<br><br>    plotdata[<span class="hljs-string">&#x27;avgloss&#x27;</span>]=moving_average(plotdata[<span class="hljs-string">&quot;loss&quot;</span>])<br>    plt.figure(<span class="hljs-number">1</span>)<br>    plt.subplot(<span class="hljs-number">211</span>)<br>    plt.plot(plotdata[<span class="hljs-string">&quot;batchsize&quot;</span>],plotdata[<span class="hljs-string">&quot;avgloss&quot;</span>],<span class="hljs-string">&#x27;b--&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;Minibatch number&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;Loss&#x27;</span>)<br>    plt.title(<span class="hljs-string">&#x27;Minibatch run vs. Training loss&#x27;</span>)<br>    plt.show()<br><br>    <span class="hljs-comment">#模型训练后，使用模型</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x=0.2,z=&quot;</span>,sess.run(z,feed_dict=&#123;X:<span class="hljs-number">0.2</span>&#125;))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Epoch: 1 cost= 0.70816207 W= [0.75885475] b= [0.35309508]Epoch: 3 cost= 0.12805094 W= [1.649097] b= [0.11414018]Epoch: 5 cost= 0.08086114 W= [1.8904546] b= [0.02324806]Epoch: 7 cost= 0.0777822 W= [1.9530506] b= [-0.00074375]Epoch: 9 cost= 0.07760694 W= [1.9692401] b= [-0.00695578]Epoch: 11 cost= 0.0776032 W= [1.9734255] b= [-0.00856198]Epoch: 13 cost= 0.077605 W= [1.9745078] b= [-0.00897733]Epoch: 15 cost= 0.07760566 W= [1.9747877] b= [-0.0090847]Epoch: 17 cost= 0.077605836 W= [1.9748603] b= [-0.00911253]Epoch: 19 cost= 0.07760589 W= [1.9748794] b= [-0.00911988]Finished!cost= 0.077605896 W= [1.9748821] b= [-0.00912086]</code></pre><p><img src="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/output_6_1.png" alt="png"></p><p><img src="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/output_6_2.png" alt="png"></p><pre><code class="hljs">x=0.2,z= [0.3858556]</code></pre><p>Tensorflow将中间结点及结点间的运算关系定义在图上，图是静态的，会话是动态的，只有启动会话后才会将数据流向图中<br><br>定义数据时可以通过占位符，也可以通过字典方式，也可以直接定义</p><p>记得在session创建后初始化所有变量，而变量定义在此之前</p><br><p>TensorFlow模型构建的概念<br><img src="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%A8%A1%E5%9E%8B%E6%9E%84%E5%BB%BA%E6%A6%82%E5%BF%B5.png"></p><p>两个重要的机制：注入机制，取回机制</p><p>注入机制：占位符<br>placeholder，feed-dict<br><br>示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">a=tf.placeholder(tf.int32)<br>b=tf.placeholder(tf.int32)<br>add=tf.add(a,b)<br>multiply=tf.multiply(a,b)<br>mysess=tf.Session()<br><span class="hljs-built_in">print</span>(mysess.run(add,feed_dict=&#123;a:<span class="hljs-number">1</span>,b:<span class="hljs-number">2</span>&#125;))<br><span class="hljs-built_in">print</span>(mysess.run(multiply,feed_dict=&#123;a:<span class="hljs-number">1</span>,b:<span class="hljs-number">2</span>&#125;))<br><span class="hljs-comment">#一次取出多个结点</span><br><span class="hljs-built_in">print</span>(mysess.run([add,multiply],feed_dict=&#123;a:<span class="hljs-number">1</span>,b:<span class="hljs-number">2</span>&#125;))<br>mysess.close()<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">32[3, 2]</code></pre><p>建立session可以直接<br><br>也可以with tf.Session() as sess<br><br>然后还有方法是交换式session方式：<br><br>sess&#x3D;tf.InteractiveSession()<br><br>另一种是Supervisor方式：该方式会更高级一些， 使用起来也更加复<br>杂， 可以自动来管理session中的具体任务， 例如， 载入&#x2F;载出检查点文件、 写入TensorBoard等， 另外该方法还支持分布式训练的部署</p><br><p>保存和载入模型</p><p>保存模型<br><br>训练完模型后: tf.train.Saver().save(sess,”save_path&#x2F;file_name”)</p><p>载入模型<br><br>调用saver的restore函数</p><p>保存载入模型实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#保存模型见上文代码 中saver</span><br><span class="hljs-comment">#载入模型</span><br><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess2:<br>    sess2.run(tf.global_variables_initializer())<br>    saver.restore(sess2,savedir+<span class="hljs-string">&quot;linermodel.cpkt&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x=0.2,z=&quot;</span>,sess2.run(z,feed_dict=&#123;X:<span class="hljs-number">0.2</span>&#125;))<br></code></pre></td></tr></table></figure><pre><code class="hljs">WARNING:tensorflow:From E:\Python\Anaconda\lib\site-packages\tensorflow\python\training\saver.py:1276: checkpoint_exists (from tensorflow.python.training.checkpoint_management) is deprecated and will be removed in a future version.Instructions for updating:Use standard file APIs to check for files with this prefix.INFO:tensorflow:Restoring parameters from log/linermodel.cpktx=0.2,z= [0.3858556]</code></pre><p>打印模型内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tensorflow.python.tools.inspect_checkpoint <span class="hljs-keyword">import</span> print_tensors_in_checkpoint_file<br>savedir=<span class="hljs-string">&quot;log/&quot;</span><br>print_tensors_in_checkpoint_file(savedir+<span class="hljs-string">&quot;linermodel.cpkt&quot;</span>,<span class="hljs-literal">None</span>,<span class="hljs-literal">True</span>)<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">tensor_name:  bias[-0.00912086]tensor_name:  weight[1.9748821]# Total number of params: 2</code></pre><br><br><p>为模型添加保存检查点，继续修改原代码</p><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-comment">#定义生成loss可视化的函数</span><br>plotdata=&#123;<span class="hljs-string">&quot;batchsize&quot;</span>:[],<span class="hljs-string">&quot;loss&quot;</span>:[]&#125;<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">moving_average</span>(<span class="hljs-params">a,w=<span class="hljs-number">10</span></span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a)&lt;w:<br>        <span class="hljs-keyword">return</span> a[:]<br>    <span class="hljs-keyword">return</span> [val <span class="hljs-keyword">if</span> idx&lt;w <span class="hljs-keyword">else</span> <span class="hljs-built_in">sum</span>(a[(idx-w):idx])/w <span class="hljs-keyword">for</span> idx,val <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a)]<br><span class="hljs-comment">#生成模拟数据</span><br>train_X=np.linspace(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)<br>train_Y=<span class="hljs-number">2</span>*train_X+np.random.randn(<span class="hljs-number">100</span>)*<span class="hljs-number">0.3</span> <br><br>tf.reset_default_graph()<br><span class="hljs-comment">#创建模型</span><br><span class="hljs-comment">#占位符</span><br>X=tf.placeholder(<span class="hljs-string">&quot;float&quot;</span>)<br>Y=tf.placeholder(<span class="hljs-string">&quot;float&quot;</span>)<br><span class="hljs-comment">#模型参数</span><br>W=tf.Variable(tf.random_normal([<span class="hljs-number">1</span>]),name=<span class="hljs-string">&quot;weight&quot;</span>)<br>b=tf.Variable(tf.zeros([<span class="hljs-number">1</span>]),name=<span class="hljs-string">&quot;bias&quot;</span>)<br><span class="hljs-comment">#前向结构</span><br>z=tf.multiply(X,W)+b<br><br><span class="hljs-comment">#反向优化</span><br>cost=tf.reduce_mean(tf.square(Y-z))<br>learning_rate=<span class="hljs-number">0.01</span><br>optimizer=tf.train.GradientDescentOptimizer(learning_rate).minimize(cost)<br><span class="hljs-comment">#初始化所有变量</span><br>init=tf.global_variables_initializer()<br><span class="hljs-comment">#定义学习参数</span><br>training_epochs=<span class="hljs-number">20</span><br>display_step=<span class="hljs-number">2</span><br><span class="hljs-comment">#生成saver</span><br>saver=tf.train.Saver(max_to_keep=<span class="hljs-number">1</span>)<br>savedir=<span class="hljs-string">&quot;log/&quot;</span><br><span class="hljs-comment">#启动图</span><br><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:<br>    sess.run(init)<br>    <span class="hljs-comment">#向模型中输入数据</span><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(training_epochs):<br>        <span class="hljs-keyword">for</span> (x,y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(train_X,train_Y):<br>            sess.run(optimizer,feed_dict=&#123;X:x,Y:y&#125;)<br>        <span class="hljs-comment">#显示训练中的详细信息</span><br>        <span class="hljs-keyword">if</span> epoch % display_step==<span class="hljs-number">0</span>:<br>            loss=sess.run(cost,feed_dict=&#123;X:train_X,Y:train_Y&#125;)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Epoch:&quot;</span>,epoch+<span class="hljs-number">1</span>,<span class="hljs-string">&quot;cost=&quot;</span>,loss,<span class="hljs-string">&quot;W=&quot;</span>,sess.run(W),<span class="hljs-string">&quot;b=&quot;</span>,sess.run(b))<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (loss==<span class="hljs-string">&quot;NA&quot;</span>):<br>                plotdata[<span class="hljs-string">&quot;batchsize&quot;</span>].append(epoch)<br>                plotdata[<span class="hljs-string">&quot;loss&quot;</span>].append(loss)<br>            saver.save(sess,savedir+<span class="hljs-string">&quot;linermodel.cpkt&quot;</span>,global_step=epoch) <span class="hljs-comment">#保存模型</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Finished!&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;cost=&quot;</span>,sess.run(cost,feed_dict=&#123;X:train_X,Y:train_Y&#125;),<span class="hljs-string">&quot;W=&quot;</span>,sess.run(W),<br>         <span class="hljs-string">&quot;b=&quot;</span>,sess.run(b))<br><br>    <span class="hljs-comment">#训练模型可视化，可视化生成的模型和训练中的状态值</span><br>    plt.plot(train_X,train_Y,<span class="hljs-string">&#x27;ro&#x27;</span>,label=<span class="hljs-string">&#x27;Original data&#x27;</span>)<br>    plt.plot(train_X,sess.run(W)*train_X+sess.run(b),label=<span class="hljs-string">&#x27;Fittedline&#x27;</span>)<br>    plt.legend()<br>    plt.show()<br><br>    plotdata[<span class="hljs-string">&#x27;avgloss&#x27;</span>]=moving_average(plotdata[<span class="hljs-string">&quot;loss&quot;</span>])<br>    plt.figure(<span class="hljs-number">1</span>)<br>    plt.subplot(<span class="hljs-number">211</span>)<br>    plt.plot(plotdata[<span class="hljs-string">&quot;batchsize&quot;</span>],plotdata[<span class="hljs-string">&quot;avgloss&quot;</span>],<span class="hljs-string">&#x27;b--&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;Minibatch number&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;Loss&#x27;</span>)<br>    plt.title(<span class="hljs-string">&#x27;Minibatch run vs. Training loss&#x27;</span>)<br>    plt.show()<br><span class="hljs-comment">#重启session，载入检查点</span><br>load_epoch=<span class="hljs-number">18</span><br><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess2:<br>    sess2.run(tf.global_variables_initializer())<br>    saver.restore(sess2,savedir+<span class="hljs-string">&quot;linermodel.cpkt-&quot;</span>+<span class="hljs-built_in">str</span>(load_epoch))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x=0.2,z=&quot;</span>,sess2.run(z,feed_dict=&#123;X:<span class="hljs-number">0.2</span>&#125;))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Epoch: 1 cost= 1.4514498 W= [0.24221869] b= [0.5121559]Epoch: 3 cost= 0.18433338 W= [1.5415516] b= [0.16298366]Epoch: 5 cost= 0.07567732 W= [1.8937755] b= [0.03033424]Epoch: 7 cost= 0.067009285 W= [1.9851238] b= [-0.00467777]Epoch: 9 cost= 0.066090204 W= [2.0087478] b= [-0.01374275]Epoch: 11 cost= 0.06594107 W= [2.014856] b= [-0.0160868]Epoch: 13 cost= 0.06590843 W= [2.0164354] b= [-0.0166929]Epoch: 15 cost= 0.06590037 W= [2.016844] b= [-0.0168497]Epoch: 17 cost= 0.065898314 W= [2.0169504] b= [-0.01689044]Epoch: 19 cost= 0.0658978 W= [2.0169766] b= [-0.0169006]Finished!cost= 0.06589771 W= [2.0169811] b= [-0.01690225]</code></pre><p><img src="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/output_26_1.png" alt="png"></p><p><img src="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/output_26_2.png" alt="png"></p><br><br>模型操作相关函数<h1 id="常用函数总结（见pdf书籍）"><a href="#常用函数总结（见pdf书籍）" class="headerlink" title="常用函数总结（见pdf书籍）"></a>常用函数总结（见pdf书籍）</h1><h2 id="保存模型"><a href="#保存模型" class="headerlink" title="保存模型"></a>保存模型</h2><p><img src="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/hanshu1.png"></p><h2 id="数值操作相关函数"><a href="#数值操作相关函数" class="headerlink" title="数值操作相关函数"></a>数值操作相关函数</h2><p><img src="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/hanshu2.png"></p><p><img src="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/hanshu3.png"></p><h2 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h2><p><img src="/2019/10/20/TensorFlow%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E5%8F%98%E6%8D%A2.png"></p><h2 id="形状变换函数"><a href="#形状变换函数" class="headerlink" title="形状变换函数"></a>形状变换函数</h2><ul><li>tf.shape(input,name&#x3D;None)<br>返回一个张量，值为输入参数input的shape，input可以是个张量，也可以是一个数组或list</li><li>tf.size(input,name&#x3D;None)<br>返回一个张量，内容为输入数据的元素数量</li><li>tf.rank(input,name&#x3D;None)<br>返回一个张量，其内容为输入数据input的rank，此处的rank看的是中括号的层数</li><li>tf.reshape(input,shape,name&#x3D;None)<br>将原有数据的shape按照指定形状进行变换，生成一个新的张量</li><li>tf.expand_dims(input,dim,name&#x3D;None)<br>插入维度1进入一个tensor中</li><li>tf.squeeze(input,dim,name&#x3D;None)<br>将dim指定的维度去掉(dim所指定的维度必须为1，如果不为1则会报错)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编程实现KNN和朴素贝叶斯算法分类</title>
      <link href="/2019/10/19/%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0KNN%E5%92%8C%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/"/>
      <url>/2019/10/19/%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0KNN%E5%92%8C%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>大数据上机作业，编程实现K近邻和朴素贝叶斯算法</p><span id="more"></span><p>1、编程实现KNN算法对下表中两个未知类型的样本进行分类（冰川水或者湖泊水），其中K&#x3D;3，即选择最近的3个邻居。<br><img src="/2019/10/19/%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0KNN%E5%92%8C%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/KNN.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> math<br>a=np.array([[<span class="hljs-number">0.2</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">0.1</span>],[<span class="hljs-number">0.4</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.4</span>,<span class="hljs-number">0.3</span>],[<span class="hljs-number">0.3</span>,<span class="hljs-number">0.4</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">0.3</span>],[<span class="hljs-number">0.2</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.1</span>],[<span class="hljs-number">0.5</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0.3</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.4</span>,<span class="hljs-number">0.4</span>]])<br><span class="hljs-built_in">print</span>(a)<br>label=[<span class="hljs-string">&quot;冰川水&quot;</span>,<span class="hljs-string">&quot;湖泊水&quot;</span>,<span class="hljs-string">&quot;冰川水&quot;</span>,<span class="hljs-string">&quot;冰川水&quot;</span>,<span class="hljs-string">&quot;湖泊水&quot;</span>,<span class="hljs-string">&quot;湖泊水&quot;</span>]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">distance</span>(<span class="hljs-params">x,y</span>):<br>    <span class="hljs-built_in">sum</span>=<span class="hljs-number">0.0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x)):<br>        <span class="hljs-built_in">sum</span>+=math.<span class="hljs-built_in">pow</span>((x[i]-y[i]),<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> math.sqrt(<span class="hljs-built_in">sum</span>)<br><br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">classify</span>(<span class="hljs-params"><span class="hljs-built_in">input</span>,group,label,k</span>):<br>    mark=&#123;&#125;<br>    flag=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> group:<br>        tmpsum=distance(<span class="hljs-built_in">input</span>,i)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;计算两者之间距离为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(tmpsum))<br>        mark[flag]=tmpsum<br>        flag=flag+<span class="hljs-number">1</span><br>    sorted_mark = <span class="hljs-built_in">sorted</span>(mark.items(),key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])  <br>    after_mark=<span class="hljs-built_in">dict</span>(sorted_mark[:k])<br>    tmp=[]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> after_mark.keys():<br>        tmp.append(label[i])<br>    <span class="hljs-comment"># 直接统计</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(tmp, key=tmp.count))<br><br>    <br>Garr=np.array([<span class="hljs-number">0.3</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.2</span>])<br>Harr=np.array([<span class="hljs-number">0.1</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.2</span>])<br>classify(Garr,a,label,<span class="hljs-number">3</span>)<br>classify(Harr,a,label,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">计算两者之间距离为0.31622776601683794计算两者之间距离为0.17320508075688776计算两者之间距离为0.33166247903553997计算两者之间距离为0.34641016151377546计算两者之间距离为0.4计算两者之间距离为0.22360679774997902湖泊水计算两者之间距离为0.17320508075688776计算两者之间距离为0.42426406871192857计算两者之间距离为0.4690415759823429计算两者之间距离为0.17320508075688773计算两者之间距离为0.45825756949558405计算两者之间距离为0.4冰川水</code></pre><p><img src="/2019/10/19/%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0KNN%E5%92%8C%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF.png"></p><p>实现朴素贝叶斯算法预测是否适合户外活动</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data</span>(<span class="hljs-params">filename</span>):<br>    lines = csv.reader(<span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&quot;rt&quot;</span>))<br>    dataset = <span class="hljs-built_in">list</span>(lines)<br>    data=[]<br>   <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dataset:<br>        tmp=[]<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> i:<br>            j=j[:-<span class="hljs-number">1</span>]<br>            tmp.append(<span class="hljs-built_in">str</span>(j))<br>        data.append(tmp)<br>    <span class="hljs-keyword">return</span> data<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getSumOfC</span>(<span class="hljs-params">C,data</span>):<br>    c=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data:<br>        <span class="hljs-keyword">if</span>(i[<span class="hljs-built_in">len</span>(i)-<span class="hljs-number">1</span>]==C):<br>            c=c+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> c<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getPossibilityofCwhenData</span>(<span class="hljs-params">C,data</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;标签&#123;&#125;的概率为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(C,getSumOfC(C,data)/<span class="hljs-built_in">len</span>(data)))<br>    <span class="hljs-keyword">return</span> getSumOfC(C,data)/<span class="hljs-built_in">len</span>(data)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getPossibilityofXwhenC_Single</span>(<span class="hljs-params">X,C,data</span>):<br>    sum_X=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data:<br>        <span class="hljs-keyword">if</span> i[<span class="hljs-built_in">len</span>(i)-<span class="hljs-number">1</span>]==C:<br>            <span class="hljs-keyword">if</span> X <span class="hljs-keyword">in</span> i:<br>                sum_X=sum_X+<span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(sum_X)<br>    <br>    <span class="hljs-keyword">return</span> sum_X/getSumOfC(C,data)<br>                   <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getPossibilityofXwhenC_Summary</span>(<span class="hljs-params"><span class="hljs-built_in">input</span>,C,data</span>):<br>    sum_possibility=<span class="hljs-number">1.0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;传入的要检查的x值为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i))<br>        res=getPossibilityofXwhenC_Single(i,C,data)<br>        <span class="hljs-keyword">if</span> res!=<span class="hljs-number">0</span>:<br>            sum_possibility=sum_possibility*res<br>    <span class="hljs-keyword">return</span> sum_possibility<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getPossibility</span>(<span class="hljs-params"><span class="hljs-built_in">input</span>,C,data</span>):<br>    <span class="hljs-comment">#先获取标签总的概率</span><br>    a=getPossibilityofCwhenData(C,data)<br>    <span class="hljs-comment">#然后获取对应元素概率</span><br>    b=getPossibilityofXwhenC_Summary(<span class="hljs-built_in">input</span>,C,data)<br>    <span class="hljs-comment">#相乘获取结果概率</span><br>    result=a*b<br>    <span class="hljs-built_in">print</span>(result)<br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    filename=<span class="hljs-string">&quot;G:/学习/课程相关/大三/大数据挖掘/上机/3/thisdata.csv&quot;</span><br>    data=load_data(filename)<br>    <span class="hljs-built_in">input</span>=[<span class="hljs-string">&#x27;下雨&#x27;</span>,<span class="hljs-string">&#x27;低&#x27;</span>,<span class="hljs-string">&#x27;大&#x27;</span>,<span class="hljs-string">&#x27;微风&#x27;</span>]<br>    C1=getPossibility(<span class="hljs-built_in">input</span>,<span class="hljs-string">&#x27;适合&#x27;</span>,data)<br>    C2=getPossibility(<span class="hljs-built_in">input</span>,<span class="hljs-string">&#x27;不适合&#x27;</span>,data)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;概率为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;适合&quot;</span>,C1))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;概率为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;不适合&quot;</span>,C2))<br>    <span class="hljs-keyword">if</span> C1&lt;C2:<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最终答案为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;不适合&quot;</span>))<br>    <span class="hljs-keyword">else</span>:<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最终答案为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;适合&quot;</span>)) <br>               <br>main()<br></code></pre></td></tr></table></figure><pre><code class="hljs">标签适合的概率为0.6传入的要检查的x值为下雨3传入的要检查的x值为低3传入的要检查的x值为大2传入的要检查的x值为微风50.041666666666666664标签不适合的概率为0.4传入的要检查的x值为下雨1传入的要检查的x值为低1传入的要检查的x值为大3传入的要检查的x值为微风20.009375000000000001适合概率为0.041666666666666664不适合概率为0.009375000000000001最终答案为适合</code></pre>]]></content>
      
      
      <categories>
          
          <category> 大数据挖掘及应用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编程实现Apriori算法</title>
      <link href="/2019/10/19/%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0Apriori%E7%AE%97%E6%B3%95/"/>
      <url>/2019/10/19/%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0Apriori%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>大数据课程上机应用，作业，记录以备复习</p><span id="more"></span><p>编程应用Apriori算法输出教材P159 表4-16的所有频繁项集（设最小支持度计数为2）<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> copy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">init_pass</span>(<span class="hljs-params">T</span>):   <span class="hljs-comment">#统计所有元素各自出现的总次数</span><br>    C = &#123;&#125;  <span class="hljs-comment">#C为字典</span><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> T: <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> t:<br>            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> C.keys():<br>                C[i] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                C[i] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> C  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">F</span>):<span class="hljs-comment">#生成新的集合，好进行下一轮遍历，筛选，F是之前筛选出来的所有满足支持度的集合</span><br>    C = []<br>    <span class="hljs-comment">#print(&quot;F=&#123;&#125;&quot;.format(F))</span><br>    k = <span class="hljs-built_in">len</span>(F[<span class="hljs-number">0</span>]) + <span class="hljs-number">1</span> <span class="hljs-comment">#k此时代表这次要选的集合中每个集合由几个元素组成</span><br>    <span class="hljs-keyword">for</span> f1 <span class="hljs-keyword">in</span> F:<br>        <span class="hljs-keyword">for</span> f2 <span class="hljs-keyword">in</span> F:<br>            <span class="hljs-comment">#print(&quot;f1[k-2]=&#123;0&#125;,f2[k-2]=&#123;1&#125;&quot;.format(f1[k-2],f2[k-2]))</span><br>            <span class="hljs-keyword">if</span> f1[k-<span class="hljs-number">2</span>] &lt; f2[k-<span class="hljs-number">2</span>]: <span class="hljs-comment">#使用k-2的原因之前k+1，然后数组下标从0开始，所有k-2刚好，就比如第一次生成时正好从下标0，也就是第一个元素开始</span><br>                c = copy.copy(f1)<br>                c.append(f2[k-<span class="hljs-number">2</span>])<br>                <span class="hljs-comment">#print(&quot;c=&#123;&#125;&quot;.format(c))</span><br>                <span class="hljs-keyword">if</span> c <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> C:<br>                    C.append(c)<br>    <span class="hljs-keyword">return</span> C <span class="hljs-comment">#最返回</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compareList</span>(<span class="hljs-params">A,B</span>): <span class="hljs-comment">#比较两个列表是否相等</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(A) &lt;= <span class="hljs-built_in">len</span>(B):<br>        <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> A:<br>            <span class="hljs-keyword">if</span> a <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> B:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> B:<br>            <span class="hljs-keyword">if</span> b <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> A:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">apriori</span>(<span class="hljs-params">T,minSupport</span>):<br>    D=[]<span class="hljs-comment">#暂存生成的所有索引，供之后筛选，存入F[k]中</span><br>    C=init_pass(T)  <span class="hljs-comment">#先分析一项集</span><br>    keys=<span class="hljs-built_in">list</span>(C.keys());<span class="hljs-comment">#.keys()方法，求出字典中的索引</span><br>    keys.sort() <br>    D.append(keys)<span class="hljs-comment">#加入D集中</span><br>    F=[[]] <span class="hljs-comment">#二维列表  F[0]存的是所有满足条件的一项集</span><br>    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> D[<span class="hljs-number">0</span>]:<br>        <span class="hljs-keyword">if</span> C[f]&gt;=minSupport:<br>            F[<span class="hljs-number">0</span>].append([f])  <span class="hljs-comment">#筛选出所有满足最小支持度的一项集</span><br>    k=<span class="hljs-number">1</span> <span class="hljs-comment">#k代表的是几项集 第几次遍历</span><br><br>    <span class="hljs-keyword">while</span> F[k-<span class="hljs-number">1</span>]!=[]:  <span class="hljs-comment">#k-1是因为下标从0开始</span><br>        D.append(generate(F[k-<span class="hljs-number">1</span>]))<br>        F.append([])<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> D[k]:<br>            count = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> T:<br>                <span class="hljs-keyword">if</span> compareList(c,t):<br>                    count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> count&gt;= minSupport:<br>                F[k].append(c)<br>        k += <span class="hljs-number">1</span><br><br>    U = []<br>    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> F:<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> f:<br>            U.append(x)<br>    <span class="hljs-keyword">return</span> U<br><br><br>T = [[<span class="hljs-string">&#x27;面包&#x27;</span>,<span class="hljs-string">&#x27;甜酱&#x27;</span>,<span class="hljs-string">&#x27;芝麻酱&#x27;</span>],[<span class="hljs-string">&#x27;面包&#x27;</span>,<span class="hljs-string">&#x27;芝麻酱&#x27;</span>],[<span class="hljs-string">&#x27;面包&#x27;</span>,<span class="hljs-string">&#x27;芝麻酱&#x27;</span>,<span class="hljs-string">&#x27;牛奶&#x27;</span>],[<span class="hljs-string">&#x27;面包&#x27;</span>,<span class="hljs-string">&#x27;啤酒&#x27;</span>],[<span class="hljs-string">&#x27;牛奶&#x27;</span>,<span class="hljs-string">&#x27;啤酒&#x27;</span>]]<br><br>Z= apriori(T,<span class="hljs-number">2</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> Z:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">set</span>(i))<br></code></pre></td></tr></table></figure><pre><code class="hljs">&#123;&#39;啤酒&#39;&#125;&#123;&#39;牛奶&#39;&#125;&#123;&#39;芝麻酱&#39;&#125;&#123;&#39;面包&#39;&#125;&#123;&#39;面包&#39;, &#39;芝麻酱&#39;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 大数据挖掘及应用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA搭建web项目相关问题</title>
      <link href="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>本次主要是为了跑书上的代码，了解struts2框架的基本使用，因此代码都是直接复制粘贴，主要讨论的是配置问题</p><span id="more"></span><p>使用maven创建项目，好处是可以由maven下载相关包，无需自己导入下载<br></p><ol><li><p>首先创建项目：选择maven-勾选Create from archetype-选择底下的webapp-然后点击next<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE.png"></p></li><li><p>接着项目命名随意,点击next<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE2.png"> </p></li><li><p>然后注意修改setting.xml文件<br>笔者这里是自己的setting.xml文件<br>修改方法参见这里：<br><br>修改maven镜像：<br><a href="https://jiangyuesong.me/2016/11/07/maven-intellij-change-mirrors/">https://jiangyuesong.me/2016/11/07/maven-intellij-change-mirrors/</a><br><br>原因是之前提到了 maven会自己下载所需包，但是有些包下载过慢，因此需要换用国内镜像<br><br>至于local repository所选位置可自定义，或默认并无影响<br><br>最后点击next-finish即完成创建<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE3.png"></p></li><li><p>创建完后，显示如下：<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/kaishi1.png"><br>选择ok<br>然后会有提示出来，在右下角<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E5%BC%80%E5%A7%8B2.png"><br>选择enable auto import，这就是maven在帮我们自动配置<br><br>如果之前没有修改镜像的话，这一步会特别慢，因此要注意<br></p></li><li><p>auto import后文件目录显示如下<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E7%9B%AE%E5%BD%95.png"></p></li></ol><p>在此对文件夹进行相应说明：<br>(<a href="https://www.jianshu.com/p/bbc0640276cf">原文链接</a>)</p><ul><li>.idea：是IDEA自动生成 ，.idea文件夹来存放项目的配置信息。其中包括版本控制信息、历史记录等等。如果你不小心删除它，下次它还会自动生成。</li><li>src：项目的资源总目录，基本所有的操作都在这个文件夹里面进行。</li><li>main：和src基本作用差不多</li><li>webapp：这是前端部分，可以在这个目录下创建css、js等文件夹用于存放前端的一些静态文件。以及创建JSP等网页文件。</li><li>WEB-INF：WEB-INF是Java的WEB应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。</li><li>web.xml：web.xml的作用很大，是用来沟通后端的桥梁，这里可以配置一些信息，比如哪些是网站入口（index.jsp）,声明404网页等等，以及声明哪些是后端的配置文件。整个web项目就是这样像纽带一样构建起来的。</li><li>pom.xml：pom.xml主要描述了项目的maven坐标，包依赖关系。我们不需要在手动下载一些jar包，然后手动依赖。只要遵循它规则，他会自动帮我们下载依赖，是不是很方便！！！</li></ul><ol start="6"><li><p>修改pom.xml,web.xml<br>打开pom.xml文件，找到dependencies标签<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/pom.png"><br>在标签添加依赖，添加方法很简单，你的项目用到了什么jar包你就去这个网站上进行搜索：<br><a href="https://mvnrepository.com/">https://mvnrepository.com</a><br><br>进行搜索：<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E6%90%9C%E7%B4%A21.png"><br>选择相应包:<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E6%90%9C%E7%B4%A22.png"><br>复制框中代码：<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E6%90%9C%E7%B4%A23.png"><br>粘贴到dependencies标签下：<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96.png"><br>之后要等一会自动配置完后<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E5%AE%8C.png"><br>由于本次创建是为了跑项目，项目中用到了struts2框架，因此我们才用了struts2相关包，自己应该根据实际需求自己判断添加哪些dependency<br></p></li><li><p>创建文件夹<br>在WEB-INF下创建classes文件夹用来存放编译后输出的classes文件<br><br>在main下新建java用来存放java代码,并将这个java文件夹标记为Sources Root<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E6%A0%87%E8%AE%B0java.png"><br>关于idea不同文件夹标记及含义问题如下：</p></li></ol><ul><li>Source roots (or source folders)<br>通过将文件夹加入这种类别，来告诉IntelliJ IDEA，这个文件夹和它的子文件夹中包含源码，在构建工程时，需要作为一部分被编译进去。</li><li>Test source roots (or test source folders; shown as rootTest)<br>这个类型的文件夹也用于存放源码，不过是测试的源码（比如单元测试）。test source 文件夹可以帮助你将测试代码和产品代码分离开。</li><li>Resource roots<br>该类文件夹用于存放你的应用中需要用到的资源文件（如：图片、xml或者properties配置文件等）。<br>在构建过程中，resources文件夹中的内容均会按照原文件的样子被复制到输出文件夹。和sources文件夹一样，你可以定制你的resources文件夹的结构。你也可以指定你的resources文件夹中的文件被拷贝到输出文件的哪个文件夹中。</li></ul><p>ps：<br></p><ul><li>默认情况下，工程编译后，resources中的文件和文件夹会被放置在和源码编译后相同的文件夹中，所以如果在源码中以相对路径读取resources中的配置文件时，可认为src中的java文件夹和resources为同一个根目录。</li><li>Test resource roots<br>只有在java模式中可以使用）用于存放测试源码中关联的资源文件。除此之外，和resource文件夹没有区别。</li></ul><ol start="8"><li>之后在java文件中创建新的class文件，右击——New-Java Class<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E5%88%9B%E5%BB%BAjava%E4%BB%A3%E7%A0%81.png"> 如果没有java Class选项，那就是上一步没做对<br>根据要运行的项目，我创建了两个java文件<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/java%E6%96%87%E4%BB%B6.png"><br>代码如下：<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> com.opensymphony.xwork2.Action;<br><span class="hljs-keyword">import</span> com.opensymphony.xwork2.ActionInvocation;<br><span class="hljs-keyword">import</span> com.opensymphony.xwork2.interceptor.AbstractInterceptor;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">intercept</span><span class="hljs-params">(ActionInvocation arg0)</span> throws Exception</span>&#123;<br>        <span class="hljs-comment">//得到StrutsAction类对象</span><br>        StrutsAction action=(StrutsAction)arg0.<span class="hljs-built_in">getAction</span>();<br>        <span class="hljs-comment">//如果Action类中的name属性的值为&quot;hello&quot;，返回错误页面</span><br>        <span class="hljs-keyword">if</span>(action.<span class="hljs-built_in">getName</span>().<span class="hljs-built_in">equals</span>(<span class="hljs-string">&quot;hello&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> Action.ERROR;<br>        &#125;<br>        <span class="hljs-comment">//继续执行其他拦截器或Action类中的方法</span><br>        <span class="hljs-keyword">return</span> arg0.<span class="hljs-built_in">invoke</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Map</span>;<br><span class="hljs-keyword">import</span> com.<span class="hljs-property">opensymphony</span>.<span class="hljs-property">xwork2</span>.<span class="hljs-property">ActionContext</span>;<br><span class="hljs-keyword">import</span> com.<span class="hljs-property">opensymphony</span>.<span class="hljs-property">xwork2</span>.<span class="hljs-property">ActionSupport</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrutsAction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ActionSupport</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">execute</span>() throws <span class="hljs-title class_">Exception</span>&#123;<br>        <span class="hljs-keyword">if</span>(!name.<span class="hljs-title function_">equals</span>(<span class="hljs-string">&quot;HelloWorld&quot;</span>))&#123;<br>            <span class="hljs-title class_">Map</span> request=(<span class="hljs-title class_">Map</span>)<span class="hljs-title class_">ActionContext</span>.<span class="hljs-title function_">getContext</span>().<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;request&quot;</span>);<br>            request.<span class="hljs-title function_">put</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-title function_">getName</span>());<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">validate</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">//如果姓名为空，则把错误信息添加到Action类的fieldErrors</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getName</span>()==<span class="hljs-literal">null</span>||<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getName</span>().<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>            <span class="hljs-title function_">addFieldError</span>(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;姓名是必须的！&quot;</span>);           <span class="hljs-comment">//把错误信息保存起来</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="9"><li>配置web.xml<br>修改文本.xml内容如下：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;3.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>struts2<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.FilterDispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>struts2<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file-list</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>struts2_1<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>struts2_1<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.action<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="10"><li><p>在创建的classes文件夹下新建struts.xml<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E5%88%9B%E5%BB%BAstrutsxml.png"><br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E5%88%9B%E5%BB%BAstrutsxml2.png"><br>修改其中内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">struts</span> <span class="hljs-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">struts</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;default&quot;</span> <span class="hljs-attr">extends</span>=<span class="hljs-string">&quot;struts-default&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">interceptors</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">interceptor</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myInterceptor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;MyInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">interceptors</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">default-interceptor-ref</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">default-interceptor-ref</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;struts&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;StrutsAction&quot;</span> &gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;success&quot;</span>&gt;</span>/welcome.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span>/hello.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;input&quot;</span>&gt;</span>/hello.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">interceptor-ref</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultStack&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">interceptor-ref</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">interceptor-ref</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">interceptor-ref</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">action</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">struts</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在index.jsp的位置添加并修改文件<br>最后共有三个jsp文件 index.jsp,hello.jsp,welcome.jsp<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E6%B7%BB%E5%8A%A0jsp.png"><br>index.jsp不变<br><br>hello.jsp代码如下：</p><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs vbscript-html"><span class="language-vbscript">&lt;%@ page language=<span class="hljs-string">&quot;java&quot;</span> import=<span class="hljs-string">&quot;java.util.*&quot;</span> pageEncoding=<span class="hljs-string">&quot;utf-8&quot;</span>%&gt;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="language-vbscript">&lt;%</span><br><span class="language-vbscript">String path = <span class="hljs-built_in">request</span>.getContextPath();</span><br><span class="language-vbscript">String basePath = <span class="hljs-built_in">request</span>.getScheme()+<span class="hljs-string">&quot;://&quot;</span>+<span class="hljs-built_in">request</span>.getServerName()+<span class="hljs-string">&quot;:&quot;</span>+<span class="hljs-built_in">request</span>.getServerPort()+path+<span class="hljs-string">&quot;/&quot;</span>;</span><br><span class="language-vbscript">%&gt;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;</span></span></span><span class="language-vbscript">&lt;%=basePath%&gt;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>实例5-1：struts2应用<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;pragma&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;no-cache&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;cache-control&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;no-cache&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;expires&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span>    </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;keyword1,keyword2,keyword3&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;This is my page&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!--</span></span><br><span class="hljs-comment"><span class="language-xml">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;</span></span><br><span class="hljs-comment"><span class="language-xml">--&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;struts.action&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span></span><br><span class="language-xml">    请输入姓名:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><p>welcome.jsp代码如下：</p><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs vbscript-html"><span class="language-vbscript">&lt;%@ page language=<span class="hljs-string">&quot;java&quot;</span> import=<span class="hljs-string">&quot;java.util.*&quot;</span> pageEncoding=<span class="hljs-string">&quot;utf-8&quot;</span>%&gt;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="language-vbscript">&lt;%</span><br><span class="language-vbscript">String path = <span class="hljs-built_in">request</span>.getContextPath();</span><br><span class="language-vbscript">String basePath = <span class="hljs-built_in">request</span>.getScheme()+<span class="hljs-string">&quot;://&quot;</span>+<span class="hljs-built_in">request</span>.getServerName()+<span class="hljs-string">&quot;:&quot;</span>+<span class="hljs-built_in">request</span>.getServerPort()+path+<span class="hljs-string">&quot;/&quot;</span>;</span><br><span class="language-vbscript">%&gt;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="language-vbscript">&lt;%@ taglib prefix=<span class="hljs-string">&quot;s&quot;</span> uri=<span class="hljs-string">&quot;/struts-tags&quot;</span> %&gt;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;</span></span></span><span class="language-vbscript">&lt;%=basePath%&gt;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>实例5-1：struts2应用<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;pragma&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;no-cache&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;cache-control&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;no-cache&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;expires&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span>    </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;keyword1,keyword2,keyword3&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;This is my page&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!--</span></span><br><span class="hljs-comment"><span class="language-xml">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;</span></span><br><span class="hljs-comment"><span class="language-xml">--&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    hello<span class="hljs-tag">&lt;<span class="hljs-name">s:property</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;#request.name&quot;</span>/&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure></li><li><p>更改配置<br>点击File-Project Structure或者快捷键ctrl+alt+shift+s 来打开面板<br>点击module-path修改编译的class文件输出路径<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E4%BF%AE%E6%94%B9class%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%84.png"><br>修改为：<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E4%BF%AE%E6%94%B9class%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%842.png"><br>都输出到建立的classes文件下，同时struts.xml也在这个文件下</p></li><li><p>进行运行前的服务器配置<br>同样是打开structure面板<br>修改Artifacts,点击exploded的选项，然后在如图所示的位置上右击，put into Output Root<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/Artifactsputinto.png"><br>结果如下：<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/putinto%E5%90%8E.png"></p></li><li><p>添加tomcat服务器<br>首先点击右上角Add Configuration添加配置<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/AddConfiguration.png"><br>点击加号<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E7%82%B9%E5%87%BB%E5%8A%A0%E5%8F%B7.png"><br>选择tomcat-local(需要自己下载tomcat，本文不提)<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/tomcat.png"><br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/tomcat2.png"><br>采取默认设置，点击右下角的fix,添加exploded（也可以通过Deployment添加)<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/tomcat3.png"><br>这里说一下exploded和普通的区别：</p><blockquote><p>war模式：将web工程以war包的形式上传到服务器<br>war exploed模式：将web工程以当前文件夹的位置关系上传到服务器<br>war模式这种可以称之为是发布模式，看名字也知道，这是先打包war包，再发布；<br>war exploded模式是直接把文件夹，jsp页面，classes等等移到Tomcat部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。<br>在平时开发的时候，使用热部署的话，应该对Tomcat进行相应的设置，这样的话修改的jsp界面什么的东西才可以及时的显示出来</p></blockquote></li><li><p>运行<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E8%BF%90%E8%A1%8C2.png"><br>首先点击项目上的小锤按钮进行编译,<br>编译后classes文件夹下如下：<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/%E7%BC%96%E8%AF%91.png"><br>然后点击箭头进行运行<br>结果如下：<br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/1.png"><br><img src="/2019/10/19/IDEA%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/2.png"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python常用库总结</title>
      <link href="/2019/10/06/python%E5%B8%B8%E7%94%A8%E5%BA%93%E6%80%BB%E7%BB%93/"/>
      <url>/2019/10/06/python%E5%B8%B8%E7%94%A8%E5%BA%93%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>均转载自他人文章，以便学习之用<br><br>Numpy:<br><br><a href="https://www.cnblogs.com/WSX1994/articles/9061516.html">https://www.cnblogs.com/WSX1994/articles/9061516.html</a><br><br>Matplotlib:<br><br><a href="https://blog.csdn.net/qq_34859482/article/details/80617391">https://blog.csdn.net/qq_34859482/article/details/80617391</a><br><br>sklearn:<br><br><a href="https://www.cnblogs.com/wj-1314/p/10179741.html">https://www.cnblogs.com/wj-1314/p/10179741.html</a></p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习相关概念</title>
      <link href="/2019/10/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/10/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>转载<br><br>原文链接：<a href="https://blog.csdn.net/pangjiuzala/article/details/72630166">https://blog.csdn.net/pangjiuzala/article/details/72630166</a></p><h1 id="神经网络基础"><a href="#神经网络基础" class="headerlink" title="神经网络基础"></a>神经网络基础</h1><span id="more"></span><ol><li><p>神经元（Neuron）——就像形成我们大脑基本元素的神经元一样，神经元形成神经网络的基本结构。想象一下，当我们得到新信息时我们该怎么做。当我们获取信息时，我们一般会处理它，然后生成一个输出。类似地，在神经网络的情况下，神经元接收输入，处理它并产生输出，而这个输出被发送到其他神经元用于进一步处理，或者作为最终输出进行输出。</p></li><li><p>权重（Weights）——当输入进入神经元时，它会乘以一个权重。例如，如果一个神经元有两个输入，则每个输入将具有分配给它的一个关联权重。我们随机初始化权重，并在模型训练过程中更新这些权重。训练后的神经网络对其输入赋予较高的权重，这是它认为与不那么重要的输入相比更为重要的输入。为零的权重则表示特定的特征是微不足道的。<br><br>让我们假设输入为a，并且与其相关联的权重为W1，那么在通过节点之后，输入变为a * W1</p></li><li><p>偏差（Bias）——除了权重之外，另一个被应用于输入的线性分量被称为偏差。它被加到权重与输入相乘的结果中。基本上添加偏差的目的是来改变权重与输入相乘所得结果的范围的。添加偏差后，结果将看起来像a* W1 +偏差。这是输入变换的最终线性分量。</p></li><li><p>激活函数（Activation Function）——一旦将线性分量应用于输入，将会需要应用一个非线性函数。这通过将激活函数应用于线性组合来完成。激活函数将输入信号转换为输出信号。应用激活函数后的输出看起来像f（a * W1 + b），其中f（）就是激活函数。<br><br>在下图中，我们将“n”个输入给定为X1到Xn而与其相应的权重为Wk1到Wkn。我们有一个给定值为bk的偏差。权重首先乘以与其对应的输入，然后与偏差加在一起。而这个值叫做u。<br><br><img src="/2019/10/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/activate.png"><br><br>U &#x3D;ΣW* X+ b<br>激活函数被应用于u，即 f(u)，并且我们会从神经元接收最终输出，如yk &#x3D; f（u）。<br><br>最常用的激活函数就是Sigmoid，ReLU和softmax<br></p></li></ol><ul><li>Sigmoid——最常用的激活函数之一是Sigmoid，它被定义为：<br><br>sigmoid(x)&#x3D;$1 \over {1+e^{-x}}$<br><br>Sigmoid变换产生一个值为0到1之间更平滑的范围。我们可能需要观察在输入值略有变化时输出值中发生的变化。光滑的曲线使我们能够做到这一点，因此优于阶跃函数。</li><li>ReLU（整流线性单位）——与Sigmoid函数不同的是，最近的网络更喜欢使用ReLu激活函数来处理隐藏层。该函数定义为：<br><br>f(x)&#x3D;max(x,0)<br><br>当X&gt;0时，函数的输出值为X；当X&lt;&#x3D;0时，输出值为0。函数图如下图所示：<br>使用ReLU函数的最主要的好处是对于大于0的所有输入来说，它都有一个不变的导数值。常数导数值有助于网络训练进行得更快。</li><li>Softmax——Softmax激活函数通常用于输出层，用于分类问题。它与sigmoid函数是很类似的，唯一的区别就是输出被归一化为总和为1。<br>Sigmoid函数将发挥作用以防我们有一个二进制输出，但是如果我们有一个多类分类问题，softmax函数使为每个类分配值这种操作变得相当简单，而这可以将其解释为概率。<br><br>以这种方式来操作的话，我们很容易看到——假设你正在尝试识别一个可能看起来像8的6。该函数将为每个数字分配值如下。我们可以很容易地看出，最高概率被分配给6，而下一个最高概率分配给8，依此类推……</li></ul><ol start="5"><li><p>神经网络（Neural Network）——神经网络构成了深度学习的支柱。神经网络的目标是找到一个未知函数的近似值。它由相互联系的神经元形成。这些神经元具有权重和在网络训练期间根据错误来进行更新的偏差。激活函数将非线性变换置于线性组合，而这个线性组合稍后会生成输出。激活的神经元的组合会给出输出值。<br><br>一个很好的神经网络定义——<br>“神经网络由许多相互关联的概念化的人造神经元组成，它们之间传递相互数据，并且具有根据网络”经验“调整的相关权重。神经元具有激活阈值，如果通过其相关权重的组合和传递给他们的数据满足这个阈值的话，其将被解雇;发射神经元的组合导致“学习”。</p></li><li><p>输入&#x2F;输出&#x2F;隐藏层（Input &#x2F; Output &#x2F; Hidden Layer）——正如它们名字所代表的那样，输入层是接收输入那一层，本质上是网络的第一层。而输出层是生成输出的那一层，也可以说是网络的最终层。处理层是网络中的隐藏层。这些隐藏层是对传入数据执行特定任务并将其生成的输出传递到下一层的那些层。输入和输出层是我们可见的，而中间层则是隐藏的。</p></li><li><p>MLP（多层感知器）——单个神经元将无法执行高度复杂的任务。因此，我们使用堆栈的神经元来生成我们所需要的输出。在最简单的网络中，我们将有一个输入层、一个隐藏层和一个输出层。每个层都有多个神经元，并且每个层中的所有神经元都连接到下一层的所有神经元。这些网络也可以被称为完全连接的网络。</p></li><li><p>正向传播（Forward Propagation）——正向传播是指输入通过隐藏层到输出层的运动。在正向传播中，信息沿着一个单一方向前进。输入层将输入提供给隐藏层，然后生成输出。这过程中是没有反向运动的。</p></li><li><p>成本函数（Cost Function）——当我们建立一个网络时，网络试图将输出预测得尽可能靠近实际值。我们使用成本&#x2F;损失函数来衡量网络的准确性。而成本或损失函数会在发生错误时尝试惩罚网络。<br><br>我们在运行网络时的目标是提高我们的预测精度并减少误差，从而最大限度地降低成本。最优化的输出是那些成本或损失函数值最小的输出。<br><br>如果我将成本函数定义为均方误差，则可以写为：<br><br>C&#x3D; 1&#x2F;m ∑${(y–a)}^2$，<br><br>其中m是训练输入的数量，a是预测值，y是该特定示例的实际值。<br><br>学习过程围绕最小化成本来进行。</p></li><li><p>梯度下降（Gradient Descent）——梯度下降是一种最小化成本的优化算法。要直观地想一想，在爬山的时候，你应该会采取小步骤，一步一步走下来，而不是一下子跳下来。因此，我们所做的就是，如果我们从一个点x开始，我们向下移动一点，即Δh，并将我们的位置更新为x-Δh，并且我们继续保持一致，直到达到底部。考虑最低成本点。<br><br>在数学上，为了找到函数的局部最小值，我们通常采取与函数梯度的负数成比例的步长。</p></li><li><p>学习率（Learning Rate）——学习率被定义为每次迭代中成本函数中最小化的量。简单来说，我们下降到成本函数的最小值的速率是学习率。我们应该非常仔细地选择学习率，因为它不应该是非常大的，以至于最佳解决方案被错过，也不应该非常低，以至于网络需要融合。</p></li><li><p>反向传播（Backpropagation）——当我们定义神经网络时，我们为我们的节点分配随机权重和偏差值。一旦我们收到单次迭代的输出，我们就可以计算出网络的错误。然后将该错误与成本函数的梯度一起反馈给网络以更新网络的权重。 最后更新这些权重，以便减少后续迭代中的错误。使用成本函数的梯度的权重的更新被称为反向传播。<br><br>在反向传播中，网络的运动是向后的，错误随着梯度从外层通过隐藏层流回，权重被更新。</p></li><li><p>批次（Batches）——在训练神经网络的同时，不用一次发送整个输入，我们将输入分成几个随机大小相等的块。与整个数据集一次性馈送到网络时建立的模型相比，批量训练数据使得模型更加广义化。</p></li><li><p>周期（Epochs）——周期被定义为向前和向后传播中所有批次的单次训练迭代。这意味着1个周期是整个输入数据的单次向前和向后传递。<br><br>你可以选择你用来训练网络的周期数量，更多的周期将显示出更高的网络准确性，然而，网络融合也需要更长的时间。另外，你必须注意，如果周期数太高，网络可能会过度拟合。</p></li><li><p>丢弃（Dropout）——Dropout是一种正则化技术，可防止网络过度拟合套。顾名思义，在训练期间，隐藏层中的一定数量的神经元被随机地丢弃。这意味着训练发生在神经网络的不同组合的神经网络的几个架构上。你可以将Dropout视为一种综合技术，然后将多个网络的输出用于产生最终输出。</p></li><li><p>批量归一化（Batch Normalization）——作为一个概念，批量归一化可以被认为是我们在河流中设定为特定检查点的水坝。这样做是为了确保数据的分发与希望获得的下一层相同。当我们训练神经网络时，权重在梯度下降的每个步骤之后都会改变，这会改变数据的形状如何发送到下一层。<br><br>但是下一层预期分布类似于之前所看到的分布。 所以我们在将数据发送到下一层之前明确规范化数据。<br></p></li></ol><h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><ol start="17"><li><p>滤波器（Filters）——CNN中的滤波器与加权矩阵一样，它与输入图像的一部分相乘以产生一个回旋输出。我们假设有一个大小为28 * 28的图像，我们随机分配一个大小为3 * 3的滤波器，然后与图像不同的3 * 3部分相乘，形成所谓的卷积输出。滤波器尺寸通常小于原始图像尺寸。在成本最小化的反向传播期间，滤波器值被更新为重量值。</p></li><li><p>卷积神经网络（CNN）——卷积神经网络基本上应用于图像数据。假设我们有一个输入的大小（28 * 28 * 3），如果我们使用正常的神经网络，将有2352（28 * 28 * 3）参数。并且随着图像的大小增加参数的数量变得非常大。我们“卷积”图像以减少参数数量（如上面滤波器定义所示）。当我们将滤波器滑动到输入体积的宽度和高度时，将产生一个二维激活图，给出该滤波器在每个位置的输出。我们将沿深度尺寸堆叠这些激活图，并产生输出量。<br><br><img src="/2019/10/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/%E5%8D%B7%E7%A7%AF.png"></p></li><li><p>池化（Pooling）——通常在卷积层之间定期引入池层。这基本上是为了减少一些参数，并防止过度拟合。最常见的池化类型是使用MAX操作的滤波器尺寸（2,2）的池层。它会做的是，它将占用原始图像的每个4 * 4矩阵的最大值。<br><br><img src="/2019/10/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/%E6%B1%A0%E5%8C%96.png"><br><br>你还可以使用其他操作（如平均池）进行池化，但是最大池数量在实践中表现更好。</p></li><li><p>填充（Padding）——填充是指在图像之间添加额外的零层，以使输出图像的大小与输入相同。这被称为相同的填充。<br><br><img src="/2019/10/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/%E5%A1%AB%E5%85%85.png"><br><br>在应用滤波器之后，在相同填充的情况下，卷积层具有等于实际图像的大小。</p><br>有效填充是指将图像保持为具有实际或“有效”的图像的所有像素。在这种情况下，在应用滤波器之后，输出的长度和宽度的大小在每个卷积层处不断减小。</li><li><p>数据增强（Data Augmentation）——数据增强是指从给定数据导出的新数据的添加，这可能被证明对预测有益。例如，如果你使光线变亮，可能更容易在较暗的图像中看到猫，或者例如，数字识别中的9可能会稍微倾斜或旋转。在这种情况下，旋转将解决问题并提高我们的模型的准确性。通过旋转或增亮，我们正在提高数据的质量。这被称为数据增强。<br>循环神经网络</p></li></ol><h1 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h1><p><img src="/2019/10/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/%E5%BE%AA%E7%8E%AF.png"><br></p><ol start="22"><li><p>循环神经元（Recurrent Neuron）——循环神经元是在T时间内将神经元的输出发送回给它。如果你看图，输出将返回输入t次。展开的神经元看起来像连接在一起的t个不同的神经元。这个神经元的基本优点是它给出了更广义的输出。</p></li><li><p>循环神经网络（RNN）——循环神经网络特别用于顺序数据，其中先前的输出用于预测下一个输出。在这种情况下，网络中有循环。隐藏神经元内的循环使他们能够存储有关前一个单词的信息一段时间，以便能够预测输出。隐藏层的输出在t时间戳内再次发送到隐藏层。展开的神经元看起来像上图。只有在完成所有的时间戳后，循环神经元的输出才能进入下一层。发送的输出更广泛，以前的信息保留的时间也较长。<br><br>然后根据展开的网络将错误反向传播以更新权重。这被称为通过时间的反向传播（BPTT）。</p></li><li><p>消失梯度问题（Vanishing Gradient Problem）——激活函数的梯度非常小的情况下会出现消失梯度问题。在权重乘以这些低梯度时的反向传播过程中，它们往往变得非常小，并且随着网络进一步深入而“消失”。这使得神经网络忘记了长距离依赖。这对循环神经网络来说是一个问题，长期依赖对于网络来说是非常重要的。<br><br>这可以通过使用不具有小梯度的激活函数ReLu来解决。</p></li><li><p>激增梯度问题（Exploding Gradient Problem）——这与消失的梯度问题完全相反，激活函数的梯度过大。在反向传播期间，它使特定节点的权重相对于其他节点的权重非常高，这使得它们不重要。这可以通过剪切梯度来轻松解决，使其不超过一定值。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>监督学习之决策树</title>
      <link href="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/"/>
      <url>/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="监督学习之决策树"><a href="#监督学习之决策树" class="headerlink" title="监督学习之决策树"></a>监督学习之决策树</h1><span id="more"></span><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> mglearn<br><span class="hljs-keyword">import</span> os<br>%matplotlib inline<br></code></pre></td></tr></table></figure><p>决策树是广泛用于分类和回归任务的模型。本质上，它从一层层的 if&#x2F;else 问题中进行学<br>习，并得出结论。</p><p>这些问题类似于你在“20 Questions”游戏中可能会问的问题。想象一下，你想要区分下面这四种动物：熊、鹰、企鹅和海豚。你的目标是通过提出尽可能少的 if&#x2F;else 问题来得到正确答案。你可能首先会问：这种动物有没有羽毛，这个问题会将可能的动物减少到只有两种。如果答案是“有”，你可以问下一个问题，帮你区分鹰和企鹅。例如，你可以问这种动物会不会飞。如果这种动物没有羽毛，那么可能是海豚或熊，所以你需要问一个问题来区分这两种动物——比如问这种动物有没有鳍。</p><p>这一系列问题可以表示为一棵决策树,如下图所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mglearn.plots.plot_animal_tree()<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/output_4_0.png" alt="png"></p><p>在这张图中，树的每个结点代表一个问题或一个包含答案的终结点（也叫叶结点）。树的边将问题的答案与将问的下一个问题连接起来。</p><p>用机器学习的语言来说就是，为了区分四类动物（鹰、企鹅、海豚和熊），我们利用三个特征（“有没有羽毛”“会不会飞”和“有没有鳍”）来构建一个模型。我们可以利用监督学习从数据中学习模型，而无需人为构建模型。</p><h2 id="1-构造决策树"><a href="#1-构造决策树" class="headerlink" title="1.构造决策树"></a>1.构造决策树</h2><p>我们在下图所示的二维分类数据集上构造决策树。这个数据集由 2 个半月形组成，每个类别都包含 50 个数据点。我们将这个数据集称为 two_moons 。</p><p>学习决策树，就是学习一系列 if&#x2F;else 问题，使我们能够以最快的速度得到正确答案。在机器学习中，这些问题叫作测试（不要与测试集弄混，测试集是用来测试模型泛化性能的数据）。数据通常并不是像动物的例子那样具有二元特征（是 &#x2F; 否）的形式，而是表示为连续特征，比如图 2-23 所示的二维数据集。用于连续数据的测试形式是：“特征 i 的值是否大于 a ?”</p><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/2-23.png"></p><p>为了构造决策树，算法搜遍所有可能的测试，找出对目标变量来说信息量最大的那一个。图 2-24 展示了选出的第一个测试。将数据集在 x[1]&#x3D;0.0596 处垂直划分可以得到最多信息，它在最大程度上将类别 0 中的点与类别 1 中的点进行区分。顶结点（也叫根结点）表示整个数据集，包含属于类别 0 的 50 个点和属于类别 1 的 50 个点。通过测试 x[1] &lt;&#x3D;0.0596 的真假来对数据集进行划分，在图中表示为一条黑线。如果测试结果为真，那么将这个点分配给左结点，左结点里包含属于类别 0 的 2 个点和属于类别 1 的 32 个点。否则将这个点分配给右结点，右结点里包含属于类别 0 的 48 个点和属于类别 1 的 18 个点。这两个结点对应于图 2-24 中的顶部区域和底部区域。尽管第一次划分已经对两个类别做了很好的区分，但底部区域仍包含属于类别 0 的点，顶部区域也仍包含属于类别 1 的点。我们可以在两个区域中重复寻找最佳测试的过程，从而构建出更准确的模型。图 2-25 展示了信息量最大的下一次划分，这次划分是基于 x[0] 做出的，分为左右两个区域</p><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/2-2425.png"></p><p>这一递归过程生成一棵二元决策树，其中每个结点都包含一个测试。或者你可以将每个测试看成沿着一条轴对当前数据进行划分。这是一种将算法看作分层划分的观点。由于每个测试仅关注一个特征，所以划分后的区域边界始终与坐标轴平行。</p><p>对数据反复进行递归划分，直到划分后的每个区域（决策树的每个叶结点）只包含单一目标值（单一类别或单一回归值）。如果树中某个叶结点所包含数据点的目标值都相同，那么这个叶结点就是纯的（pure）。这个数据集的最终划分结果见图 2-26。</p><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/2-26.png"></p><h2 id="2-控制决策树的复杂度"><a href="#2-控制决策树的复杂度" class="headerlink" title="2.控制决策树的复杂度"></a>2.控制决策树的复杂度</h2><p>通常来说，构造决策树直到所有叶结点都是纯的叶结点，这会导致模型非常复杂，并且对训练数据高度过拟合。纯叶结点的存在说明这棵树在训练集上的精度是 100%。训练集中的每个数据点都位于分类正确的叶结点中。在图 2-26 的左图中可以看出过拟合。你可以看到，在所有属于类别 0 的点中间有一块属于类别 1 的区域。另一方面，有一小条属于类别 0 的区域，包围着最右侧属于类别 0 的那个点。这并不是人们想象中决策边界的样子，这个决策边界过于关注远离同类别其他点的单个异常点。</p><p>防止过拟合有两种常见的策略：一种是及早停止树的生长，也叫预剪枝（pre-pruning）；另一种是先构造树，但随后删除或折叠信息量很少的结点，也叫后剪枝（post-pruning）或剪枝（pruning）。预剪枝的限制条件可能包括限制树的最大深度、限制叶结点的最大数目，或者规定一个结点中数据点的最小数目来防止继续划分。</p><p>scikit-learn 的决策树在 DecisionTreeRegressor 类和 DecisionTreeClassifier 类中实现。scikit-learn 只实现了预剪枝，没有实现后剪枝。</p><p>我们在乳腺癌数据集上更详细地看一下预剪枝的效果。和前面一样，我们导入数据集并将其分为训练集和测试集。然后利用默认设置来构建模型，默认将树完全展开（树不断分支，直到所有叶结点都是纯的）。我们固定树的 random_state ，用于在内部解决平局问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeClassifier<br><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_breast_cancer<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>cancer=load_breast_cancer()<br>X_train,X_test,y_train,y_test=train_test_split(cancer.data,cancer.target,<br>                                              stratify=cancer.target,random_state=<span class="hljs-number">42</span>)<br>tree=DecisionTreeClassifier(random_state=<span class="hljs-number">0</span>).fit(X_train,y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on training set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(tree.score(X_train,y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on test set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(tree.score(X_test,y_test)))<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">Accuracy on training set: 1.000Accuracy on test set: 0.937</code></pre><p>不出所料，训练集上的精度是 100%，这是因为叶结点都是纯的，树的深度很大，足以完美地记住训练数据的所有标签。测试集精度比之前讲过的线性模型略低，线性模型的精度约为 95%。</p><p>如果我们不限制决策树的深度，它的深度和复杂度都可以变得特别大。因此，未剪枝的树容易过拟合，对新数据的泛化性能不佳。现在我们将预剪枝应用在决策树上，这可以在完美拟合训练数据之前阻止树的展开。一种选择是在到达一定深度后停止树的展开。这里我们设置 max_depth&#x3D;4 ，这意味着只可以连续问 4 个问题（参见图 2-24 和图 2-26）。限制树的深度可以减少过拟合。这会降低训练集的精度，但可以提高测试集的精度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">tree=DecisionTreeClassifier(max_depth=<span class="hljs-number">4</span>,random_state=<span class="hljs-number">0</span>).fit(X_train,y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on training set :&#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(tree.score(X_train,y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on test set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(tree.score(X_test,y_test)))<br>      <br></code></pre></td></tr></table></figure><pre><code class="hljs">Accuracy on training set :0.988Accuracy on test set: 0.951</code></pre><h2 id="3-分析决策树"><a href="#3-分析决策树" class="headerlink" title="3.分析决策树"></a>3.分析决策树</h2><p>我们可以利用 tree 模块的 export_graphviz 函数来将树可视化。这个函数会生成一个 .dot 格式的文件，这是一种用于保存图形的文本文件格式。我们设置为结点添加颜色的选项，颜色表示每个结点中的多数类别，同时传入类别名称和特征名称，这样可以对树正确标记：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> export_graphviz<br>export_graphviz(tree, out_file=<span class="hljs-string">&quot;tree.dot&quot;</span>, class_names=[<span class="hljs-string">&quot;malignant&quot;</span>,<span class="hljs-string">&quot;benign&quot;</span>],<br>    feature_names=cancer.feature_names, impurity=<span class="hljs-literal">False</span>, filled=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>我们可以利用 graphviz 模块读取这个文件并将其可视化（你也可以使用任何能够读取 .dot文件的程序）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> graphviz<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;tree.dot&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    dot_graph = f.read()<br>    graphviz.Source(dot_graph).view()<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/3.png"></p><p>树的可视化有助于深入理解算法是如何进行预测的，也是易于向非专家解释的机器学习算法的优秀示例。不过，即使这里树的深度只有 4 层，也有点太大了。深度更大的树（深度为 10 并不罕见）更加难以理解。一种观察树的方法可能有用，就是找出大部分数据的实际路径。图中每个结点的 samples 给出了该结点中的样本个数， values 给出的是每个类别的样本个数。观察 worst radius &lt;&#x3D; 16.795 分支右侧的子结点，我们发现它只包含8 个良性样本，但有 134 个恶性样本。树的这一侧的其余分支只是利用一些更精细的区别将这 8 个良性样本分离出来。在第一次划分右侧的 142 个样本中，几乎所有样本（132 个）最后都进入最右侧的叶结点中。</p><p>再来看一下根结点的左侧子结点，对于 worst radius &gt; 16.795 ，我们得到 25 个恶性样本和 259 个良性样本。几乎所有良性样本最终都进入左数第二个叶结点中，大部分其他叶结点都只包含很少的样本。</p><h2 id="4-树的特征重要性"><a href="#4-树的特征重要性" class="headerlink" title="4.树的特征重要性"></a>4.树的特征重要性</h2><p>查看整个树可能非常费劲，除此之外，我还可以利用一些有用的属性来总结树的工作原理。其中最常用的是特征重要性（feature importance），它为每个特征对树的决策的重要性进行排序。对于每个特征来说，它都是一个介于 0 和 1 之间的数字，其中 0 表示“根本没用到”，1 表示“完美预测目标值”。特征重要性的求和始终为 1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Feature importances:\n&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(tree.feature_importances_))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Feature importances:[0.         0.         0.         0.         0.         0. 0.         0.         0.         0.         0.01019737 0.04839825 0.         0.         0.0024156  0.         0.         0. 0.         0.         0.72682851 0.0458159  0.         0. 0.0141577  0.         0.018188   0.1221132  0.01188548 0.        ]</code></pre><p>我们可以将特征重要性可视化，与我们将线性模型的系数可视化的方法类似：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_feature_importance_cancer</span>(<span class="hljs-params">model</span>):<br>    n_features = cancer.data.shape[<span class="hljs-number">1</span>]<br>    plt.barh(<span class="hljs-built_in">range</span>(n_features), model.feature_importances_, align=<span class="hljs-string">&#x27;center&#x27;</span>)<br>    plt.yticks(np.arange(n_features), cancer.feature_names)<br>    plt.xlabel(<span class="hljs-string">&quot;Feature importance&quot;</span>)<br>    plt.ylabel(<span class="hljs-string">&quot;Feature&quot;</span>)<br><br>plot_feature_importance_cancer(tree)<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/output_25_0.png" alt="png"></p><p>这里我们看到，顶部划分用到的特征（“worst radius”）是最重要的特征。这也证实了我们在分析树时的观察结论，即第一层划分已经将两个类别区分得很好。</p><p>但是，如果某个特征的 feature_importance_ 很小，并不能说明这个特征没有提供任何信息。这只能说明该特征没有被树选中，可能是因为另一个特征也包含了同样的信息。</p><p>与线性模型的系数不同，特征重要性始终为正数，也不能说明该特征对应哪个类别。特征重要性告诉我们“worst radius”（最大半径）特征很重要，但并没有告诉我们半径大表示样本是良性还是恶性。事实上，在特征和类别之间可能没有这样简单的关系，你可以在下面的例子中看出这一点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tree=mglearn.plots.plot_tree_not_monotone()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Feature importances: [0. 1.]</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/output_27_1.png" alt="png"></p><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/4.png"></p><p>该图显示的是有两个特征和两个类别的数据集。这里所有信息都包含在 X[1] 中，没有用到X[0] 。但 X[1] 和输出类别之间并不是单调关系，即我们不能这么说：“较大的 X[1] 对应类别 0，较小的 X[1] 对应类别 1”（反之亦然）。</p><p>虽然我们主要讨论的是用于分类的决策树，但对用于回归的决策树来说，所有内容都是类似的，在 DecisionTreeRegressor 中实现。回归树的用法和分析与分类树非常类似。但在将基于树的模型用于回归时，我们想要指出它的一个特殊性质。 DecisionTreeRegressor（以及其他所有基于树的回归模型）不能外推（extrapolate），也不能在训练数据范围之外进行预测。</p><p>我们利用计算机内存（RAM）历史价格的数据集来更详细地研究这一点。下图给出了这个数据集的图像，x 轴为日期，y 轴为那一年 1 兆字节（MB）RAM 的价格：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>ram_prices=pd.read_csv(<span class="hljs-string">&quot;data/ram_price.csv&quot;</span>)<br>plt.semilogy(ram_prices.date,ram_prices.price)<br>plt.xlabel(<span class="hljs-string">&#x27;Year&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Price in $/Mbyte&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">help</span>(plt.semilogy))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Help on function semilogy in module matplotlib.pyplot:semilogy(*args, **kwargs)    Make a plot with log scaling on the y axis.        Call signatures::            semilogy([x], y, [fmt], data=None, **kwargs)        semilogy([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)        This is just a thin wrapper around `.plot` which additionally changes    the y-axis to log scaling. All of the concepts and parameters of plot    can be used here as well.        The additional parameters *basey*, *subsy* and *nonposy* control the    y-axis properties. They are just forwarded to `.Axes.set_yscale`.        Parameters    ----------    basey : scalar, optional, default 10        Base of the y logarithm.        subsy : array_like, optional        The location of the minor yticks. If *None*, reasonable locations        are automatically chosen depending on the number of decades in the        plot. See `.Axes.set_yscale` for details.        nonposy : &#123;&#39;mask&#39;, &#39;clip&#39;&#125;, optional, default &#39;mask&#39;        Non-positive values in y can be masked as invalid, or clipped to a        very small positive number.        Returns    -------    lines        A list of `~.Line2D` objects representing the plotted data.        Other Parameters    ----------------    **kwargs        All parameters supported by `.plot`.None</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/output_30_1.png" alt="png"></p><p>注意 y 轴的对数刻度。在用对数坐标绘图时，二者的线性关系看起来非常好，所以预测应该相对比较容易，除了一些不平滑之处之外。</p><p>我们将利用 2000 年前的历史数据来预测 2000 年后的价格，只用日期作为特征。我们将对比两个简单的模型： DecisionTreeRegressor 和 LinearRegression 。我们对价格取对数，使得二者关系的线性相对更好。这对 DecisionTreeRegressor 不会产生什么影响，但对LinearRegression 的影响却很大（我们将在第 4 章中进一步讨论）。训练模型并做出预测之后，我们应用指数映射来做对数变换的逆运算。为了便于可视化，我们这里对整个数据集进行预测，但如果是为了定量评估，我们将只考虑测试数据集：</p><p>首先说明下np.newwaxis用法，增加一维</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">x1 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;the shape of x1 is &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(x1.shape))<br>x1_new=x1[:,np.newaxis]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;the shape of x1 after newwaxis is &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(x1_new.shape))<br></code></pre></td></tr></table></figure><pre><code class="hljs">the shape of x1 is (5,)the shape of x1 after newwaxis is (5, 1)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeRegressor<br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br><span class="hljs-comment">#利用历史数据预测2000年后的价格</span><br>data_train=ram_prices[ram_prices.date&lt;<span class="hljs-number">2000</span>]<br>data_test=ram_prices[ram_prices.date&gt;=<span class="hljs-number">2000</span>]<br><span class="hljs-comment">#基于日期来预测价格</span><br>X_train=data_train.date[:,np.newaxis]<br><span class="hljs-comment">#利用对数变换来得到数据和目标之间更简单的关系</span><br>y_train=np.log(data_train.price)<br>tree=DecisionTreeRegressor().fit(X_train,y_train)<br>linear_reg=LinearRegression().fit(X_train,y_train)<br><span class="hljs-comment">#对所有数据进行预测</span><br>X_all=ram_prices.date[:,np.newaxis]<br>pred_tree=tree.predict(X_all)<br>pred_lr=linear_reg.predict(X_all)<br><span class="hljs-comment">#对数变换逆运算</span><br>price_tree=np.exp(pred_tree)<br>price_lr=np.exp(pred_lr)<br><span class="hljs-comment"># 将决策树和线性回归模型的预测结果与真实值进行对比</span><br>plt.semilogy(data_train.date,data_train.price,label=<span class="hljs-string">&quot;Training data&quot;</span>)<br>plt.semilogy(data_test.date,data_test.price,label=<span class="hljs-string">&quot;Test data&quot;</span>)<br><br>plt.semilogy(ram_prices.date,price_tree,label=<span class="hljs-string">&quot;Tree prediction&quot;</span>)<br>plt.semilogy(ram_prices.date,price_lr,label=<span class="hljs-string">&quot;Linear prediction&quot;</span>)<br>plt.legend()<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.legend.Legend at 0x2263aa048d0&gt;</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/output_34_1.png" alt="png"></p><p>两个模型之间的差异非常明显。线性模型用一条直线对数据做近似，这是我们所知道的。这条线对测试数据（2000 年后的价格）给出了相当好的预测，不过忽略了训练数据和测试数据中一些更细微的变化。与之相反，树模型完美预测了训练数据。由于我们没有限制树的复杂度，因此它记住了整个数据集。但是，一旦输入超出了模型训练数据的范围，模型就只能持续预测最后一个已知数据点。树不能在训练数据的范围之外生成“新的”响应。所有基于树的模型都有这个缺点。</p><h2 id="5-优点，缺点和参数"><a href="#5-优点，缺点和参数" class="headerlink" title="5.优点，缺点和参数"></a>5.优点，缺点和参数</h2><p>如前所述，控制决策树模型复杂度的参数是预剪枝参数,<br><br>它在树完全展开之前停止树的构造。<br><br>通常来说，选择一种预剪枝策略（设置 max_depth 、 max_leaf_nodes 或 min_samples_leaf ）足以防止过拟合。<br><br>与前面讨论过的许多算法相比，决策树有两个优点：<br></p><ul><li>得到的模型很容易可视化，非专家也很容易理解（至少对于较小的树而言）；</li><li>算法完全不受数据缩放的影响。由于每个特征被单独处理，而且数据的划分也不依赖于缩放，因此决策树算法不需要特征预处理，比如归一化或标准化。<br>特别是特征的尺度完全不一样时或者二元特征和连续特征同时存在时，决策树的效果很好。<br></li></ul><p>决策树的主要缺点在于，即使做了预剪枝，它也经常会过拟合，泛化性能很差。<br><br>因此，在大多数应用中，往往使用下面介绍的集成方法来替代单棵决策树。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>监督学习之线性模型</title>
      <link href="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="监督学习之线性模型"><a href="#监督学习之线性模型" class="headerlink" title="监督学习之线性模型"></a>监督学习之线性模型</h1><span id="more"></span><h2 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h2><p><span class="mark">回归</span>：统计学中，回归分析（regression analysis)指的是确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。回归分析按照涉及的变量的多少，分为一元回归和多元回归分析；按照因变量的多少，可分为简单回归分析和多重回归分析；按照自变量和因变量之间的关系类型，可分为线性回归分析和非线性回归分析。<br><br><span class="mark">线性回归</span>：<br><br>线性回归是利用数理统计中回归分析，来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法，运用十分广泛。其表达形式为y &#x3D; w’x+e，e为误差服从均值为0的正态分布。 <br><br>回归分析中，只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。如果回归分析中包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则称为多元线性回归分析。</p><p><span class="mark">python中shape简易用法</span>：<br><br>通过安装导入numpy库，矩阵（ndarray）的shape属性可以获取矩阵的形状（例如二维数组的行列），获取的结果是一个元组<br><br><span class="girk">shape[0] 行<br><br>shape[1] 列</span><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> mglearn<br>%matplotlib inline<br></code></pre></td></tr></table></figure><p><span class="mark">线性模型利用输入特征的线性函数进行预测</span></p><h2 id="1-用于回归的线性模型"><a href="#1-用于回归的线性模型" class="headerlink" title="1.用于回归的线性模型"></a>1.用于回归的线性模型</h2><p>对于回归问题，线性模型预测的一般公式如下：</p><p>ŷ&#x3D;w[0]∗x[0]+w[1]∗x[1]+…+w[p]∗x[p]+b</p><p>这里 x[0]<br>到 x[p] 表示单个数据点的特征（本例中特征个数为 p+1），w 和 b 是学习模型的<br>参数，ŷ</p><p>是模型的预测结果。对于单一特征的数据集，公式如下：</p><p>ŷ&#x3D;w[0]∗x[0]+b</p><p>你可能还记得，这就是高中数学里的直线方程。这里 w[0]<br>是斜率，b 是 y 轴偏移。对于有<br>更多特征的数据集，w 包含沿每个特征坐标轴的斜率。或者，你也可以将预测的响应值看<br>作输入特征的加权求和，权重由 w 的元素给出（可以取负值）。<br>下列代码可以在一维 wave 数据集上学习参数 w[0] 和 b：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mglearn.plots.plot_linear_regression_wave()<br></code></pre></td></tr></table></figure><pre><code class="hljs">w[0]: 0.393906  b: -0.031804</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_6_1.png" alt="png"></p><p>有许多不同的线性回归模型。<br><br>这些模型之间的区别在于如何从训练数据中学习参数 w 和 b，以及如何控制模型复杂度。<br><br>下面介绍最常见的线性回归模型。<br></p><h2 id="2-线性回归"><a href="#2-线性回归" class="headerlink" title="2.线性回归"></a>2.线性回归</h2><p>线性回归，或者普通最小二乘法（ordinary least squares，OLS），是回归问题最简单也最经典的线性方法。<br><br>线性回归寻找参数 w 和 b，使得对训练集的预测值与真实的回归目标值 y 之间的均方误差最小。<br><br>均方误差（mean squared error）是预测值与真实值之差的平方和除以样本数。<br><br>线性回归没有参数，这是一个优点，但也因此无法控制模型的复杂度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X,y=mglearn.datasets.make_wave(n_samples=<span class="hljs-number">60</span>)<br>X_train,X_test,y_train,y_test=train_test_split(X,y,random_state=<span class="hljs-number">42</span>)<br>lr=LinearRegression().fit(X_train,y_train)<br><br></code></pre></td></tr></table></figure><p>“斜率”参数（w，也叫作权重或系数）被保存在 coef_ 属性中，而偏移或截距（b）被保存在 intercept_ 属性中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;lr.coef_:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lr.coef_))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;lr.intercept_:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lr.intercept_))<br></code></pre></td></tr></table></figure><pre><code class="hljs">lr.coef_:[0.39390555]lr.intercept_:-0.031804343026759746</code></pre><p>你可能注意到了 coef_ 和 intercept_ 结尾处奇怪的下划线。scikit-learn 总是将从训练数据中得出的值保存在以下划线结尾的属性中。这是为了将其与用户设置的参数区分开。</p><p>intercept_ 属性是一个浮点数，而 coef_ 属性是一个 NumPy 数组，每个元素对应一个输入特征。由于 wave 数据集中只有一个输入特征，所以 lr.coef_ 中只有一个元素。我们来看一下训练集和测试集的性能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Training set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lr.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lr.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Training set score: 0.67Test set score: 0.66</code></pre><p>对于更高维的数据集（即有大量特征的数据集），线性模型将变得更加强大，过拟合的可能性也会变大。我们来看一下 LinearRegression 在更复杂的数据集上的表现，比如波士顿房价数据集。记住，这个数据集有 506 个样本和 105个导出特征。首先，加载数据集并将其分为训练集和测试集。然后像前面一样构建线性回归模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">X,y=mglearn.datasets.load_extended_boston()<br>X_train,X_test,y_train,y_test=train_test_split(X,y,random_state=<span class="hljs-number">0</span>)<br>lr=LinearRegression().fit(X_train, y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Trainnig set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lr.score(X_train,y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lr.score(X_test,y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Trainnig set score: 0.95Test set score: 0.61</code></pre><p><span class="girk">训练集和测试集之间的性能差异是过拟合的明显标志</span>，因此我们应该试图找到一个可以控制复杂度的模型。<span class="mark">标准线性回归最常用的替代方法之一就是岭回归（ridge regression）</span>，下面来看一下。<br><br><br><span class="mark">过拟合</span>：一个假设在训练数据上能够获得比其他假设更好的拟合， 但是在训练数据外的数据集上却不能很好地拟合数据，此时认为这个假设出现了过拟合的现象。出现这种现象的主要原因是训练数据中存在噪音或者训练数据太少。 </p><h2 id="3-岭回归"><a href="#3-岭回归" class="headerlink" title="3.岭回归"></a>3.岭回归</h2><p><span class="mark">岭回归也是一种用于回归的线性模型，因此它的预测公式与普通最小二乘法相同。</span>但在岭回归中，对系数（w）的选择不仅要在训练数据上得到好的预测结果，而且还要拟合附加约束。我们还希望<span class="girk">系数尽量小</span>。换句话说，w 的所有元素都应接近于 0。直观上来看，这意味着每个特征对输出的影响应尽可能小（即斜率很小），同时仍给出很好的预测结果。这种约束是所谓正则化（regularization）的一个例子。正则化是指对模型做显式约束，以避免过拟合。岭回归用到的这种被称为 <span class="girk">L2 正则化</span>。<br><br>岭回归在 <span class="burk">linear_model.Ridge</span> 中实现。来看一下它对扩展的波士顿房价数据集的效果如何</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Ridge<br>ridge=Ridge().fit(X_train,y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Training set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(ridge.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(ridge.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Training set score: 0.89Test set score: 0.75</code></pre><p>可以看出， Ridge 在训练集上的分数要低于 LinearRegression ，但在测试集上的分数更高。这和我们的预期一致。线性回归对数据存在过拟合。 Ridge 是一种约束更强的模型，所以更不容易过拟合。复杂度更小的模型意味着在训练集上的性能更差，但泛化性能更好。由于我们只对泛化性能感兴趣，所以应该选择 Ridge 模型而不是 LinearRegression 模型。</p><p>Ridge 模型在模型的简单性（系数都接近于 0）与训练集性能之间做出权衡。简单性和训练集性能二者对于模型的重要程度可以由<span class="mark">用户通过设置 alpha 参数来指定</span>。在前面的例子中，我们用的是默认参数 alpha&#x3D;1.0 。但没有理由认为这会给出最佳权衡。 alpha 的最佳设定值取决于用到的具体数据集。<span class="mark">增大 alpha 会使得系数更加趋向于 0，从而降低训练集性能，但可能会提高泛化性能</span>。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ridge10=Ridge(alpha=<span class="hljs-number">10</span>).fit(X_train,y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Training set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(ridge10.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(ridge10.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Training set score: 0.79Test set score: 0.64</code></pre><p><span class="mark">减小 alpha 可以让系数受到的限制更小</span>。对于非常小的 alpha 值，系数几乎没有受到限制，我们得到一个与 LinearRegression 类似的模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ridge01=Ridge(alpha=<span class="hljs-number">0.1</span>).fit(X_train,y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Training set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(ridge01.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(ridge01.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Training set score: 0.93Test set score: 0.77</code></pre><p>这里 alpha&#x3D;0.1 似乎效果不错。我们可以尝试进一步减小 alpha 以提高泛化性能。<br><br>我们还可以查看 alpha 取不同值时模型的 coef_ 属性，从而更加定性地理解 alpha 参数是如何改变模型的。更大的 alpha 表示约束更强的模型，所以我们预计大 alpha 对应的 coef_ 元素比小 alpha 对应的 coef_ 元素要小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.plot(ridge.coef_, <span class="hljs-string">&#x27;s&#x27;</span>, label=<span class="hljs-string">&quot;Ridge alpha=1&quot;</span>)<br>plt.plot(ridge10.coef_, <span class="hljs-string">&#x27;^&#x27;</span>, label=<span class="hljs-string">&quot;Ridge alpha=10&quot;</span>)<br>plt.plot(ridge01.coef_, <span class="hljs-string">&#x27;v&#x27;</span>, label=<span class="hljs-string">&quot;Ridge alpha=0.1&quot;</span>)<br>plt.plot(lr.coef_, <span class="hljs-string">&#x27;o&#x27;</span>, label=<span class="hljs-string">&quot;LinearRegression&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;Coefficient index&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Coefficient magnitude&quot;</span>)<br>plt.hlines(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(lr.coef_))<br>plt.ylim(-<span class="hljs-number">25</span>, <span class="hljs-number">25</span>)<br>plt.legend()<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_24_1.png" alt="png"></p><p>这里 x 轴对应 coef_ 的元素： x&#x3D;0 对应第一个特征的系数， x&#x3D;1 对应第二个特征的系数，以此类推，一直到 x&#x3D;100 。y 轴表示该系数的具体数值。这里需要记住的是，对于 alpha&#x3D;10 ，系数大多在 -3 和 3 之间。对于 alpha&#x3D;1 的 Ridge 模型，系数要稍大一点。对于 alpha&#x3D;0.1 ，点的范围更大。对于没有做正则化的线性回归（即 alpha&#x3D;0 ），点的范围很大，许多点都超出了图像的范围。</p><p>还有一种方法可以用来理解正则化的影响，就是固定 alpha 值，但改变训练数据量。我们对波士顿房价数据集做二次抽样，并在数据量逐渐增加的子数据集上分别对 LinearRegression 和 Ridge(alpha&#x3D;1) 两个模型进行评估（将模型性能作为数据集大小的函数进行绘图，这样的图像叫作学习曲线):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mglearn.plots.plot_ridge_n_samples()<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_26_0.png" alt="png"></p><h2 id="4-lasso"><a href="#4-lasso" class="headerlink" title="4.lasso"></a>4.lasso</h2><p>除了 Ridge ，还有一种正则化的线性回归是 Lasso 。与岭回归相同，<span class="girk">使用 lasso 也是约束系数使其接近于 0，但用到的方法不同，叫作 L1 正则化。L1 正则化的结果是，使用 lasso 时某些系数刚好为 0。这说明某些特征被模型完全忽略。</span>这可以看作是一种自动化的特征选择。某些系数刚好为 0，这样模型更容易解释，也可以呈现模型最重要的特征。</p><p>我们将 lasso 应用在扩展的波士顿房价数据集上：</div></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Lasso<br>lasso=Lasso().fit(X_train,y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Training set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lasso.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lasso.score(X_test, y_test)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Number of features used: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(np.<span class="hljs-built_in">sum</span>(lasso.coef_ != <span class="hljs-number">0</span>)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Number of all feature: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lasso.coef_.shape[<span class="hljs-number">0</span>]))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Training set score: 0.29Test set score: 0.21Number of features used: 4Number of all feature: 104</code></pre><p>如你所见， Lasso 在训练集与测试集上的表现都很差。这表示存在欠拟合，我们发现模型只用到了 105 个特征中的 4 个。与 Ridge 类似， <span class="mark">Lasso 也有一个正则化参数 alpha ，可以控制系数趋向于 0 的强度</span>。在上一个例子中，我们用的是默认值 alpha&#x3D;1.0 。为了降低欠拟合，我们尝试减小 alpha 。这么做的同时，我们还需要增加 max_iter 的值（运行迭代的最大次数）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 我们增大max_iter的值，否则模型会警告我们，说应该增大max_iter</span><br>lasso001 = Lasso(alpha=<span class="hljs-number">0.01</span>, max_iter=<span class="hljs-number">100000</span>).fit(X_train, y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Training set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lasso001.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lasso001.score(X_test, y_test)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Number of features used: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(np.<span class="hljs-built_in">sum</span>(lasso001.coef_ != <span class="hljs-number">0</span>)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Training set score: 0.90Test set score: 0.77Number of features used: 33</code></pre><p>alpha 值变小，我们可以拟合一个更复杂的模型，在训练集和测试集上的表现也更好。模型性能比使用 Ridge 时略好一点，而且我们只用到了 105 个特征中的 33 个。这样模型可能更容易理解。</p><p>但如果把 alpha 设得太小，那么就会消除正则化的效果，并出现过拟合，得到与LinearRegression 类似的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">lasso00001 = Lasso(alpha=<span class="hljs-number">0.0001</span>, max_iter=<span class="hljs-number">100000</span>).fit(X_train, y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Training set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lasso00001.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lasso00001.score(X_test, y_test)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Number of features used: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(np.<span class="hljs-built_in">sum</span>(lasso00001.coef_ != <span class="hljs-number">0</span>)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Training set score: 0.95Test set score: 0.64Number of features used: 96</code></pre><p>对不同模型的系数进行作图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.plot(lasso.coef_, <span class="hljs-string">&#x27;s&#x27;</span>, label=<span class="hljs-string">&quot;Lasso alpha=1&quot;</span>)<br>plt.plot(lasso001.coef_, <span class="hljs-string">&#x27;^&#x27;</span>, label=<span class="hljs-string">&quot;Lasso alpha=0.01&quot;</span>)<br>plt.plot(lasso00001.coef_, <span class="hljs-string">&#x27;v&#x27;</span>, label=<span class="hljs-string">&quot;Lasso alpha=0.0001&quot;</span>)<br>plt.plot(ridge01.coef_, <span class="hljs-string">&#x27;o&#x27;</span>, label=<span class="hljs-string">&quot;Ridge alpha=0.1&quot;</span>)<br>plt.legend(ncol=<span class="hljs-number">2</span>, loc=(<span class="hljs-number">0</span>, <span class="hljs-number">1.05</span>))<br>plt.ylim(-<span class="hljs-number">25</span>, <span class="hljs-number">25</span>)<br>plt.xlabel(<span class="hljs-string">&quot;Coefficient index&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Coefficient magnitude&quot;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Text(0, 0.5, &#39;Coefficient magnitude&#39;)</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_35_1.png" alt="png"></p><p>在 alpha&#x3D;1 时，我们发现不仅大部分系数都是 0（我们已经知道这一点），而且其他系数也都很小。将 alpha 减小至 0.01 ，我们得到图中向上的三角形，大部分特征等于 0。alpha&#x3D;0.0001 时，我们得到正则化很弱的模型，大部分系数都不为 0，并且还很大。为了便于比较，图中用圆形表示 Ridge 的最佳结果。 alpha&#x3D;0.1 的 Ridge 模型的预测性能与alpha&#x3D;0.01 的 Lasso 模型类似，但 Ridge 模型的所有系数都不为 0。</p><p><span class="mark">在实践中，在两个模型中一般首选岭回归</span>。但如果特征很多，你认为只有其中几个是重要的，那么选择 Lasso 可能更好。同样，如果你想要一个容易解释的模型， Lasso 可以给出更容易理解的模型，因为它只选择了一部分输入特征。 scikit-learn 还提供了 ElasticNet类，结合了 Lasso 和 Ridge 的惩罚项。在实践中，这种结合的效果最好，不过代价是要调节两个参数：一个用于 L1 正则化，一个用于 L2 正则化。</p><h2 id="5-用于分类的线性模型"><a href="#5-用于分类的线性模型" class="headerlink" title="5.用于分类的线性模型"></a>5.用于分类的线性模型</h2><p>线性模型也广泛应用于分类问题。我们首先来看二分类。这时可以利用下面的公式进行<br>预测：</p><p>ŷ &#x3D;w[0]∗x[0]+w[1]∗x[1]+…+w[p]∗x[p]+b&gt;0</p><p>这个公式看起来与线性回归的公式非常相似，但我们没有返回特征的加权求和，而是为预测设置了阈值（0）。如果函数值小于 0，我们就预测类别 -1；如果函数值大于 0，我们就预测类别 +1。对于所有用于分类的线性模型，这个预测规则都是通用的。同样，有很多种不同的方法来找出系数（w）和截距（b）。</p><p>对于用于回归的线性模型，输出 ŷ 是特征的线性函数，是直线、平面或超平面（对于更高维的数据集）。对于用于分类的线性模型，决策边界是输入的线性函数。换句话说，（二元）线性分类器是利用直线、平面或超平面来分开两个类别的分类器。本节我们将看到这方面的例子。</p><p>学习线性模型有很多种算法。这些算法的区别在于以下两点：</p><pre><code class="hljs">系数和截距的特定组合对训练数据拟合好坏的度量方法；是否使用正则化，以及使用哪种正则化方法。</code></pre><p>不同的算法使用不同的方法来度量“对训练集拟合好坏”。由于数学上的技术原因，不可能调节 w 和 b 使得算法产生的误分类数量最少。对于我们的目的，以及对于许多应用而言，上面第一点（称为损失函数）的选择并不重要。</p><p>最常见的两种线性分类算法是 <span class="mark">Logistic 回归（logistic regression）和线性支持向量机（linear support vector machine，线性 SVM）</span>，前者在 <span class="burk">linear_model.LogisticRegression</span> 中实现，后者在 <span class="burk">svm.LinearSVC</span> （SVC 代表支持向量分类器）中实现。虽然 LogisticRegression的名字中含有回归（regression），但它是一种分类算法，并不是回归算法，不应与LinearRegression 混淆。</p><p>我们可以将 LogisticRegression 和 LinearSVC 模型应用到 forge 数据集上，并将线性模型找到的决策边界可视化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> LinearSVC<br><span class="hljs-keyword">import</span> mglearn<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br>X,y=mglearn.datasets.make_forge()<br>figs,axes=plt.subplots(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">3</span>))<br><span class="hljs-keyword">for</span> model,ax <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>([LinearSVC(),LogisticRegression()],axes):<br>    clf=model.fit(X,y)<br>    mglearn.plots.plot_2d_separator(clf, X, fill=<span class="hljs-literal">False</span>, eps=<span class="hljs-number">0.5</span>, ax=ax, alpha=<span class="hljs-number">.7</span>)<br>    mglearn.discrete_scatter(X[:,<span class="hljs-number">0</span>], X[:,<span class="hljs-number">1</span>],y, ax=ax)<br>    ax.set_title(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(clf.__class__.__name__))<br>    ax.set_xlabel(<span class="hljs-string">&quot;Feature 0&quot;</span>)<br>    ax.set_ylabel(<span class="hljs-string">&quot;Feature 1&quot;</span>)<br>axes[<span class="hljs-number">0</span>].legend()  <span class="hljs-comment">#在第一个绘图区显示图例</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">help</span>(mglearn.plots.plot_2d_separator))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">help</span>(mglearn.discrete_scatter))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Help on function plot_2d_separator in module mglearn.plot_2d_separator:plot_2d_separator(classifier, X, fill=False, ax=None, eps=None, alpha=1, cm=&lt;matplotlib.colors.ListedColormap object at 0x0000025366254198&gt;, linewidth=None, threshold=None, linestyle=&#39;solid&#39;)NoneHelp on function discrete_scatter in module mglearn.plot_helpers:discrete_scatter(x1, x2, y=None, markers=None, s=10, ax=None, labels=None, padding=0.2, alpha=1, c=None, markeredgewidth=None)    Adaption of matplotlib.pyplot.scatter to plot classes or clusters.        Parameters    ----------        x1 : nd-array        input data, first axis        x2 : nd-array        input data, second axis        y : nd-array        input data, discrete labels        cmap : colormap        Colormap to use.        markers : list of string        List of markers to use, or None (which defaults to &#39;o&#39;).        s : int or float        Size of the marker        padding : float        Fraction of the dataset range to use for padding the axes.        alpha : float        Alpha value for all points.None</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_38_2.png" alt="png"></p><p>在这张图中， forge 数据集的第一个特征位于 x 轴，第二个特征位于 y 轴，与前面相同。图中分别展示了 LinearSVC 和 LogisticRegression 得到的决策边界，都是直线，将顶部归为类别 1 的区域和底部归为类别 0 的区域分开了。换句话说，对于每个分类器而言，位于黑线上方的新数据点都会被划为类别 1，而在黑线下方的点都会被划为类别 0。</p><p>两个模型得到了相似的决策边界。注意，两个模型中都有两个点的分类是错误的。两个模型都默认使用 L2 正则化，就像 Ridge 对回归所做的那样。</p><p>对于 <span class="mark">LogisticRegression 和 LinearSVC ，决定正则化强度的权衡参数叫作 C</span> 。 C 值越大，对应的正则化越弱。换句话说，<span class="girk">如果参数 C 值较大，那么 LogisticRegression 和LinearSVC 将尽可能将训练集拟合到最好，而如果 C 值较小，那么模型更强调使系数向量（w）接近于 0</span>。参数 C 的作用还有另一个有趣之处。较小的 C 值可以让算法尽量适应“大多数”数据点，而较大的 C 值更强调每个数据点都分类正确的重要性。下面是使用 LinearSVC 的图示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mglearn.plots.plot_linear_svc_regularization()<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_40_0.png" alt="png"></p><p>在左侧的图中， C 值很小，对应强正则化。大部分属于类别 0 的点都位于底部，大部分属于类别 1 的点都位于顶部。强正则化的模型会选择一条相对水平的线，有两个点分类错误。在中间的图中， C 值稍大，模型更关注两个分类错误的样本，使决策边界的斜率变大。最后，在右侧的图中，模型的 C 值非常大，使得决策边界的斜率也很大，现在模型对类别 0 中所有点的分类都是正确的。类别 1 中仍有一个点分类错误，这是因为对这个数据集来说，不可能用一条直线将所有点都分类正确。右侧图中的模型尽量使所有点的分类都正确，但可能无法掌握类别的整体分布。换句话说，这个模型很可能过拟合。</p><p>与回归的情况类似，用于分类的线性模型在低维空间中看起来可能非常受限，决策边界只能是直线或平面。同样，在高维空间中，用于分类的线性模型变得非常强大，当考虑更多特征时，避免过拟合变得越来越重要。</p><p>我们在乳腺癌数据集上详细分析 LogisticRegression ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_breast_cancer<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">help</span>(train_test_split))<br>cancer=load_breast_cancer()<br><span class="hljs-comment"># stratify  按某个层次分配</span><br>X_train,X_test,y_train,y_test=train_test_split(cancer.data,cancer.target,<br>                                               stratify=cancer.target,random_state=<span class="hljs-number">42</span>)<br>logreg=LogisticRegression().fit(X_train,y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Taining set score:&#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(logreg.score(X_train,y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score:&#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(logreg.score(X_test,y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Help on function train_test_split in module sklearn.model_selection._split:train_test_split(*arrays, **options)    Split arrays or matrices into random train and test subsets        Quick utility that wraps input validation and    ``next(ShuffleSplit().split(X, y))`` and application to input data    into a single call for splitting (and optionally subsampling) data in a    oneliner.        Read more in the :ref:`User Guide &lt;cross_validation&gt;`.        Parameters    ----------    *arrays : sequence of indexables with same length / shape[0]        Allowed inputs are lists, numpy arrays, scipy-sparse        matrices or pandas dataframes.        test_size : float, int or None, optional (default=None)        If float, should be between 0.0 and 1.0 and represent the proportion        of the dataset to include in the test split. If int, represents the        absolute number of test samples. If None, the value is set to the        complement of the train size. If ``train_size`` is also None, it will        be set to 0.25.        train_size : float, int, or None, (default=None)        If float, should be between 0.0 and 1.0 and represent the        proportion of the dataset to include in the train split. If        int, represents the absolute number of train samples. If None,        the value is automatically set to the complement of the test size.        random_state : int, RandomState instance or None, optional (default=None)        If int, random_state is the seed used by the random number generator;        If RandomState instance, random_state is the random number generator;        If None, the random number generator is the RandomState instance used        by `np.random`.        shuffle : boolean, optional (default=True)        Whether or not to shuffle the data before splitting. If shuffle=False        then stratify must be None.        stratify : array-like or None (default=None)        If not None, data is split in a stratified fashion, using this as        the class labels.        Returns    -------    splitting : list, length=2 * len(arrays)        List containing train-test split of inputs.            .. versionadded:: 0.16            If the input is sparse, the output will be a            ``scipy.sparse.csr_matrix``. Else, output type is the same as the            input type.        Examples    --------    &gt;&gt;&gt; import numpy as np    &gt;&gt;&gt; from sklearn.model_selection import train_test_split    &gt;&gt;&gt; X, y = np.arange(10).reshape((5, 2)), range(5)    &gt;&gt;&gt; X    array([[0, 1],           [2, 3],           [4, 5],           [6, 7],           [8, 9]])    &gt;&gt;&gt; list(y)    [0, 1, 2, 3, 4]        &gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split(    ...     X, y, test_size=0.33, random_state=42)    ...    &gt;&gt;&gt; X_train    array([[4, 5],           [0, 1],           [6, 7]])    &gt;&gt;&gt; y_train    [2, 0, 3]    &gt;&gt;&gt; X_test    array([[2, 3],           [8, 9]])    &gt;&gt;&gt; y_test    [1, 4]        &gt;&gt;&gt; train_test_split(y, shuffle=False)    [[0, 1, 2], [3, 4]]NoneTaining set score:0.955Test set score:0.958</code></pre><p>C&#x3D;1 的默认值给出了相当好的性能，在训练集和测试集上都达到 95% 的精度。但由于训练集和测试集的性能非常接近，所以模型很可能是欠拟合的。我们尝试增大 C 来拟合一个更灵活的模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">logreg100 = LogisticRegression(C=<span class="hljs-number">100</span>).fit(X_train, y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Training set score: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(logreg100.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(logreg100.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Training set score: 0.972Test set score: 0.965</code></pre><p>使用 C&#x3D;100 可以得到更高的训练集精度，也得到了稍高的测试集精度，这也证实了我们的直觉，即更复杂的模型应该性能更好。<br>我们还可以研究使用正则化更强的模型时会发生什么。设置 C&#x3D;0.01 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">logreg001 = LogisticRegression(C=<span class="hljs-number">0.01</span>).fit(X_train, y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Training set score: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(logreg001.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(logreg001.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Training set score: 0.934Test set score: 0.930</code></pre><p>最后，来看一下正则化参数 C 取三个不同的值时模型学到的系数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.plot(logreg.coef_.T, <span class="hljs-string">&#x27;o&#x27;</span>, label=<span class="hljs-string">&quot;C=1&quot;</span>)<br>plt.plot(logreg100.coef_.T, <span class="hljs-string">&#x27;^&#x27;</span>, label=<span class="hljs-string">&quot;C=100&quot;</span>)<br>plt.plot(logreg001.coef_.T, <span class="hljs-string">&#x27;v&#x27;</span>, label=<span class="hljs-string">&quot;C=0.001&quot;</span>)<br><span class="hljs-comment">#指定坐标轴的刻度</span><br>plt.xticks(<span class="hljs-built_in">range</span>(cancer.data.shape[<span class="hljs-number">1</span>]), cancer.feature_names, rotation=<span class="hljs-number">90</span>)<br><span class="hljs-comment">#matplotlib.pyplot.hlines(y, xmin, xmax)表示横线，参数(y的值，横线开始横坐标，横线结束横坐标)</span><br><span class="hljs-comment">#matplotlib.pyplot.vlines(y, xmin, xmax)表示竖线，参数(x的值，竖线开始纵坐标，竖线结束纵坐标)</span><br>plt.hlines(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, cancer.data.shape[<span class="hljs-number">1</span>])<br><span class="hljs-comment"># 指定y轴范围</span><br>plt.ylim(-<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)<br>plt.xlabel(<span class="hljs-string">&quot;Coefficient index&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Coefficient magnitude&quot;</span>)<br>plt.legend()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Help on function hlines in module matplotlib.pyplot:hlines(y, xmin, xmax, colors=&#39;k&#39;, linestyles=&#39;solid&#39;, label=&#39;&#39;, *, data=None, **kwargs)    Plot horizontal lines at each *y* from *xmin* to *xmax*.        Parameters    ----------    y : scalar or sequence of scalar        y-indexes where to plot the lines.        xmin, xmax : scalar or 1D array_like        Respective beginning and end of each line. If scalars are        provided, all lines will have same length.        colors : array_like of colors, optional, default: &#39;k&#39;        linestyles : &#123;&#39;solid&#39;, &#39;dashed&#39;, &#39;dashdot&#39;, &#39;dotted&#39;&#125;, optional        label : string, optional, default: &#39;&#39;        Returns    -------    lines : `~matplotlib.collections.LineCollection`        Other Parameters    ----------------    **kwargs :  `~matplotlib.collections.LineCollection` properties.        See also    --------    vlines : vertical lines    axhline: horizontal line across the axes        Notes    -----            .. note::        In addition to the above described arguments, this function can take a        **data** keyword argument. If such a **data** argument is given, the        following arguments are replaced by **data[&lt;arg&gt;]**:            * All arguments with the following names: &#39;colors&#39;, &#39;xmax&#39;, &#39;xmin&#39;, &#39;y&#39;.            Objects passed as **data** must support item access (``data[&lt;arg&gt;]``) and        membership test (``&lt;arg&gt; in data``).None</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_48_1.png" alt="png"></p><p>由于 LogisticRegression 默认应用 L2 正则化，所以其结果与图 2-12 中 Ridge 的结果类似。更强的正则化使得系数更趋向于 0，但系数永远不会正好等于 0。进一步观察图像，还可以在第 3 个系数那里发现有趣之处，这个系数是“平均周长”（mean perimeter）。C&#x3D;100 和 C&#x3D;1 时，这个系数为负，而C&#x3D;0.001 时这个系数为正，其绝对值比 C&#x3D;1 时还要大。在解释这样的模型时，人们可能会认为，系数可以告诉我们某个特征与哪个类别有关。例如，人们可能会认为高“纹理错误”（texture error）特征与“恶性”样本有关。但“平均周长”系数的正负号发生变化，说明较大的“平均周长”可以被当作“良性”的指标或“恶性”的指标，具体取决于我们考虑的是哪个模型。这也说明，对线性模型系数的解释应该始终持保留态度。</p><p>如果想要一个可解释性更强的模型，使用 L1 正则化可能更好，因为它约束模型只使用少<br>数几个特征。下面是使用 L1 正则化的系数图像和分类精度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> C, marker <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>([<span class="hljs-number">0.001</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>], [<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;^&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>]):<br>    lr_l1 = LogisticRegression(C=C, penalty=<span class="hljs-string">&quot;l1&quot;</span>).fit(X_train, y_train)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Training accuracy of l1 logreg with C=&#123;:.3f&#125;: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>    C, lr_l1.score(X_train, y_train)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test accuracy of l1 logreg with C=&#123;:.3f&#125;: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>    C, lr_l1.score(X_test, y_test)))<br>    plt.plot(lr_l1.coef_.T, marker, label=<span class="hljs-string">&quot;C=&#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(C))<br>plt.xticks(<span class="hljs-built_in">range</span>(cancer.data.shape[<span class="hljs-number">1</span>]), cancer.feature_names, rotation=<span class="hljs-number">90</span>)<br>plt.hlines(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, cancer.data.shape[<span class="hljs-number">1</span>])<br>plt.xlabel(<span class="hljs-string">&quot;Coefficient index&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Coefficient magnitude&quot;</span>)<br>plt.ylim(-<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)<br>plt.legend(loc=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Training accuracy of l1 logreg with C=0.001: 0.91Test accuracy of l1 logreg with C=0.001: 0.92Training accuracy of l1 logreg with C=1.000: 0.96Test accuracy of l1 logreg with C=1.000: 0.96Training accuracy of l1 logreg with C=100.000: 0.99Test accuracy of l1 logreg with C=100.000: 0.98</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_50_4.png" alt="png"></p><h2 id="6-用于多分类的线性模型"><a href="#6-用于多分类的线性模型" class="headerlink" title="6.用于多分类的线性模型"></a>6.用于多分类的线性模型</h2><p>许多线性分类模型只适用于二分类问题，不能轻易推广到多类别问题（除了 Logistic 回归）。将二分类算法推广到多分类算法的一种常见方法是“一对其余”（one-vs.-rest）方法。在“一对其余”方法中，对每个类别都学习一个二分类模型，将这个类别与所有其他类别尽量分开，这样就生成了与类别个数一样多的二分类模型。在测试点上运行所有二类分类器来进行预测。在对应类别上分数最高的分类器“胜出”，将这个类别标签返回作为预测结果。</p><p>每个类别都对应一个二类分类器，这样每个类别也都有一个系数（w）向量和一个截距（b）。下面给出的是分类置信方程，其结果中最大值对应的类别即为预测的类别标签：</p><p>w[0]∗x[0]+w[1]∗x[1]+…+w[p]∗x[p]+b</p><p>多分类 Logistic 回归背后的数学与“一对其余”方法稍有不同，但它也是对每个类别都有一个系数向量和一个截距，也使用了相同的预测方法。</p><p>我们将“一对其余”方法应用在一个简单的三分类数据集上。我们用到了一个二维数据集，每个类别的数据都是从一个高斯分布中采样得出的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> make_blobs<br>X,y=make_blobs(random_state=<span class="hljs-number">42</span>)<br>mglearn.discrete_scatter(X[:,<span class="hljs-number">0</span>],X[:,<span class="hljs-number">1</span>],y)<br>plt.xlabel(<span class="hljs-string">&quot;Feature 0&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Feature 1&quot;</span>)<br>plt.legend([<span class="hljs-string">&quot;Class 0&quot;</span>,<span class="hljs-string">&quot;Class 1&quot;</span>,<span class="hljs-string">&quot;Class 2&quot;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">help</span>(mglearn.discrete_scatter))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Help on function discrete_scatter in module mglearn.plot_helpers:discrete_scatter(x1, x2, y=None, markers=None, s=10, ax=None, labels=None, padding=0.2, alpha=1, c=None, markeredgewidth=None)    Adaption of matplotlib.pyplot.scatter to plot classes or clusters.        Parameters    ----------        x1 : nd-array        input data, first axis        x2 : nd-array        input data, second axis        y : nd-array        input data, discrete labels        cmap : colormap        Colormap to use.        markers : list of string        List of markers to use, or None (which defaults to &#39;o&#39;).        s : int or float        Size of the marker        padding : float        Fraction of the dataset range to use for padding the axes.        alpha : float        Alpha value for all points.None</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_52_1.png" alt="png"></p><p>现在，在这个数据集上训练一个 LinearSVC 分类器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">linear_svm=LinearSVC().fit(X,y)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Coefficient shape: &quot;</span>, linear_svm.coef_.shape)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Intercept shape: &quot;</span>, linear_svm.intercept_.shape)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Coefficient shape:  (3, 2)Intercept shape:  (3,)</code></pre><p>我们看到， coef_ 的形状是 (3, 2) ，说明 coef_ 每行包含三个类别之一的系数向量，每列包含某个特征（这个数据集有 2 个特征）对应的系数值。现在 intercept_ 是一维数组，保存每个类别的截距。</p><p>我们将这 3 个二类分类器给出的直线可视化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>mglearn.discrete_scatter(X[:, <span class="hljs-number">0</span>], X[:, <span class="hljs-number">1</span>], y)<br>line = np.linspace(-<span class="hljs-number">15</span>, <span class="hljs-number">15</span>)<br><span class="hljs-keyword">for</span> coef, intercept, color <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(linear_svm.coef_, linear_svm.intercept_, [<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>]):<br>    plt.plot(line, -(line*coef[<span class="hljs-number">0</span>]+intercept)/coef[<span class="hljs-number">1</span>], c=color)<br>plt.ylim(-<span class="hljs-number">10</span>,<span class="hljs-number">15</span>)<br>plt.xlim(-<span class="hljs-number">10</span>, <span class="hljs-number">8</span>)<br>plt.xlabel(<span class="hljs-string">&quot;Feature 0&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Feature 1&quot;</span>)<br>plt.legend([<span class="hljs-string">&#x27;Class 0&#x27;</span>, <span class="hljs-string">&#x27;Class 1&#x27;</span>, <span class="hljs-string">&#x27;Class 2&#x27;</span>, <span class="hljs-string">&#x27;Line class 0&#x27;</span>, <span class="hljs-string">&#x27;Line class 1&#x27;</span>,<br><span class="hljs-string">&#x27;Line class 2&#x27;</span>], loc=(<span class="hljs-number">1.01</span>, <span class="hljs-number">0.3</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.legend.Legend at 0x2537d7a06a0&gt;</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_56_1.png" alt="png"></p><p>你可以看到，训练集中所有属于类别 0 的点都在与类别 0 对应的直线上方，这说明它们位于这个二类分类器属于“类别 0”的那一侧。属于类别 0 的点位于与类别 2 对应的直线上方，这说明它们被类别 2 的二类分类器划为“其余”。属于类别 0 的点位于与类别 1 对应的直线左侧，这说明类别 1 的二元分类器将它们划为“其余”。因此，这一区域的所有点都会被最终分类器划为类别 0（类别 0 的分类器的分类置信方程的结果大于 0，其他两个类别对应的结果都小于 0）。</p><p>但<span class="mark">图像中间的三角形区域属于</span>哪一个类别呢，3 个二类分类器都将这一区域内的点划为“其余”。这里的点应该划归到哪一个类别呢？答案是<span class="mark">分类方程结果最大的那个类别，即最接近的那条线对应的类别</span>。下面的例子给出了二维空间中所有区域的预测结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">mglearn.plots.plot_2d_classification(linear_svm, X, fill=<span class="hljs-literal">True</span>, alpha=<span class="hljs-number">.6</span>)<br>mglearn.discrete_scatter(X[:, <span class="hljs-number">0</span>], X[:, <span class="hljs-number">1</span>], y)<br>line = np.linspace(-<span class="hljs-number">15</span>, <span class="hljs-number">15</span>)<br><span class="hljs-keyword">for</span> coef, intercept, color <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(linear_svm.coef_, linear_svm.intercept_,<br>[<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>]):<br>    plt.plot(line, -(line * coef[<span class="hljs-number">0</span>] + intercept) / coef[<span class="hljs-number">1</span>], c=color)<br>plt.legend([<span class="hljs-string">&#x27;Class 0&#x27;</span>, <span class="hljs-string">&#x27;Class 1&#x27;</span>, <span class="hljs-string">&#x27;Class 2&#x27;</span>, <span class="hljs-string">&#x27;Line class 0&#x27;</span>, <span class="hljs-string">&#x27;Line class 1&#x27;</span>,<br><span class="hljs-string">&#x27;Line class 2&#x27;</span>], loc=(<span class="hljs-number">1.01</span>, <span class="hljs-number">0.3</span>))<br>plt.xlabel(<span class="hljs-string">&quot;Feature 0&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Feature 1&quot;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Text(0, 0.5, &#39;Feature 1&#39;)</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/output_58_1.png" alt="png"></p><h2 id="7-优点，缺点和参数"><a href="#7-优点，缺点和参数" class="headerlink" title="7.优点，缺点和参数"></a>7.优点，缺点和参数</h2><p>线性模型的主要参数是正则化参数，在回归模型中叫作 alpha ，在 LinearSVC 和 Logistic-Regression 中叫作 C 。 alpha 值较大或 C 值较小，说明模型比较简单。特别是对于回归模型而言，调节这些参数非常重要。通常在对数尺度上对 C 和 alpha 进行搜索。你还需要确定的是用 L1 正则化还是 L2 正则化。如果你假定只有几个特征是真正重要的，那么你应该用L1 正则化，否则应默认使用 L2 正则化。如果模型的可解释性很重要的话，使用 L1 也会有帮助。由于 L1 只用到几个特征，所以更容易解释哪些特征对模型是重要的，以及这些特征的作用。</p><p>线性模型的训练速度非常快，预测速度也很快。这种模型可以推广到非常大的数据集，对稀疏数据也很有效。如果你的数据包含数十万甚至上百万个样本，你可能需要研究如何使用 LogisticRegression 和 Ridge 模型的 solver&#x3D;’sag’ 选项，在处理大型数据时，这一选项比默认值要更快。其他选项还有 SGDClassifier 类和 SGDRegressor 类，它们对本节介绍的线性模型实现了可扩展性更强的版本。</p><p>线性模型的另一个优点在于，利用我们之间见过的用于回归和分类的公式，理解如何进行预测是相对比较容易的。不幸的是，往往并不完全清楚系数为什么是这样的。如果你的数据集中包含高度相关的特征，这一问题尤为突出。在这种情况下，可能很难对系数做出解释。</p><p>如果<span class="mark">特征数量大于样本数量，线性模型的表现通常都很好</span>。它也常用于非常大的数据集，只是因为训练其他模型并不可行。但在更低维的空间中，其他模型的泛化性能可能更好。2.3.7 节会介绍几个线性模型不适用的例子。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>监督学习之决策树集成</title>
      <link href="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91%E9%9B%86%E6%88%90/"/>
      <url>/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h1 id="监督学习之决策树集成"><a href="#监督学习之决策树集成" class="headerlink" title="监督学习之决策树集成"></a>监督学习之决策树集成</h1><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> mglearn<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>%matplotlib inline<br></code></pre></td></tr></table></figure><p><span class="burk">集成（ensemble）是合并多个机器学习模型来构建更强大模型的方法</span>。在机器学习文献中有许多模型都属于这一类，但已证明有两种集成模型对大量分类和回归的数据集都是有效的，二者都以决策树为基础，分别是<span class="mark">随机森林（random forest</span>）和<span class="girk">梯度提升决策树</span>（gradient boosted decision tree）。</p><h2 id="1-随机森林"><a href="#1-随机森林" class="headerlink" title="1.随机森林"></a>1.随机森林</h2><p>我们刚刚说过，决策树的一个主要缺点在于经常对训练数据过拟合。随机森林是解决这个问题的一种方法。随机森林本质上是许多决策树的集合，其中每棵树都和其他树略有不同。随机森林背后的思想是，每棵树的预测可能都相对较好，但可能对部分数据过拟合。如果构造很多树，并且每棵树的预测都很好，但都以不同的方式过拟合，那么我们可以对这些树的结果取平均值来降低过拟合。既能减少过拟合又能保持树的预测能力，这可以在数学上严格证明。</p><p>为了实现这一策略，我们需要构造许多决策树。每棵树都应该对目标值做出可以接受的预测，还应该与其他树不同。随机森林的名字来自于将随机性添加到树的构造过程中，以确保每棵树都各不相同。随机森林中树的随机化方法有两种：一种是通过选择用于构造树的数据点，另一种是通过选择每次划分测试的特征。我们来更深入地研究这一过程。</p><h3 id="1-1-构造随机森林"><a href="#1-1-构造随机森林" class="headerlink" title="1.1 构造随机森林"></a>1.1 构造随机森林</h3><p>想要构造一个随机森林模型，你需要确定用于构造的树的个数（ RandomForestRegressor 或 RandomForestClassifier 的 n_estimators 参数）。比如我们想要构造 10 棵树。这些树在构造时彼此完全独立，算法对每棵树进行不同的随机选择，以确保树和树之间是有区别的。想要构造一棵树，<span class="mark">首先要对数据进行自助采样（bootstrap sample）</span>。也就是说，从 n_samples 个数据点中有放回地（即同一样本可以被多次抽取）重复随机抽取一个样本，共抽取n_samples 次。这样会创建一个与原数据集大小相同的数据集，但有些数据点会缺失（大约三分之一），有些会重复。</p><p>举例说明，比如我们想要创建列表 [‘a’, ‘b’, ‘c’, ‘d’] 的自助采样。一种可能的自主采样是 [‘b’, ‘d’, ‘d’, ‘c’] ，另一种可能的采样为 [‘d’, ‘a’, ‘d’, ‘a’] 。</p><p>接下来，基于这个新创建的数据集来构造决策树。但是，要对我们在介绍决策树时描述的算法稍作修改。<span class="mark">在每个结点处，算法随机选择特征的一个子集，并对其中<span class="girk">一个特征</span>寻找最佳测试</span>，而不是对每个结点都寻找最佳测试<span class="girk">。选择的特征个数由 max_features 参数来控制</span>。每个结点中特征子集的选择是相互独立的，这样树的每个结点可以使用特征的不同子集来做出决策。</p><p>由于使用了自助采样，随机森林中构造每棵决策树的数据集都是略有不同的。由于每个结点的特征选择，每棵树中的每次划分都是基于特征的不同子集。这两种方法共同保证随机森林中所有树都不相同。</p><p>在这个过程中的一个关键参数是 max_features 。如果我们设置 max_features 等于n_features ，那么每次划分都要考虑数据集的所有特征，在特征选择的过程中没有添加随机性（不过自助采样依然存在随机性）。如果设置 max_features 等于 1 ，那么在划分时将无法选择对哪个特征进行测试，只能对随机选择的某个特征搜索不同的阈值。因此，如果 max_features 较大，那么随机森林中的树将会十分相似，利用最独特的特征可以轻松拟合数据。如果 max_features 较小，那么随机森林中的树将会差异很大，为了很好地拟合数据，每棵树的深度都要很大。</p><p>想要利用随机森林进行预测，算法首先对森林中的每棵树进行预测。对于回归问题，我们可以对这些结果<span class="girk"><span class="girk"><span class="girk">取平均值</span></span></span>作为最终预测。对于<span class="mark">分类问题</span>，则用到了“软投票”（soft voting）策略。也就是说，每个算法做出“软”预测，<span class="mark">给出每个可能的输出标签的概率。对所有树的预测概率取平均值，然后将<span class="girk">概率最大</span>的类别作为预测结果</span></p><h3 id="1-2-分析随机森林"><a href="#1-2-分析随机森林" class="headerlink" title="1.2 分析随机森林"></a>1.2 分析随机森林</h3><p>下面将由5棵树组成的随机森林应用到前面研究过的two_moons数据集上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> make_moons<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X,y=make_moons(n_samples=<span class="hljs-number">100</span>,noise=<span class="hljs-number">0.25</span>,random_state=<span class="hljs-number">3</span>)<br>X_train,X_test,y_train,y_test=train_test_split(X,y,stratify=y,random_state=<span class="hljs-number">42</span>)<br>forest=RandomForestClassifier(n_estimators=<span class="hljs-number">5</span>,random_state=<span class="hljs-number">2</span>)<br>forest.fit(X_train,y_train)<br></code></pre></td></tr></table></figure><pre><code class="hljs">RandomForestClassifier(bootstrap=True, class_weight=None, criterion=&#39;gini&#39;,                       max_depth=None, max_features=&#39;auto&#39;, max_leaf_nodes=None,                       min_impurity_decrease=0.0, min_impurity_split=None,                       min_samples_leaf=1, min_samples_split=2,                       min_weight_fraction_leaf=0.0, n_estimators=5,                       n_jobs=None, oob_score=False, random_state=2, verbose=0,                       warm_start=False)</code></pre><p>作为随机森林的一部分，树被保存在 estimator_ 属性中。我们将每棵树学到的决策边界可视化，也将它们的总预测（即整个森林做出的预测）可视化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">fig,axes=plt.subplots(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))<br><span class="hljs-keyword">for</span> i,(ax,tree) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(axes.ravel(),forest.estimators_)):<br>    ax.set_title(<span class="hljs-string">&quot;Tree &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i))<br>    mglearn.plots.plot_tree_partition(X_train,y_train,tree,ax=ax)<br>mglearn.plots.plot_2d_separator(forest,X_train,fill=<span class="hljs-literal">True</span>,ax=axes[-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>],alpha=<span class="hljs-number">.4</span>)<br>axes[-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>].set_title(<span class="hljs-string">&quot;Random Forest&quot;</span>)<br>mglearn.discrete_scatter(X_train[:,<span class="hljs-number">0</span>],X_train[:,<span class="hljs-number">1</span>],y_train)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[&lt;matplotlib.lines.Line2D at 0x24c9b4de9e8&gt;, &lt;matplotlib.lines.Line2D at 0x24c9d400f28&gt;]</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91%E9%9B%86%E6%88%90/output_8_1.png" alt="png"></p><p>你可以清楚地看到，这 5 棵树学到的决策边界大不相同。每棵树都犯了一些错误，因为这里画出的一些训练点实际上并没有包含在这些树的训练集中，原因在于自助采样。</p><p>随机森林比单独每一棵树的过拟合都要小，给出的决策边界也更符合直觉。在任何实际应用中，我们会用到更多棵树（通常是几百或上千），从而得到更平滑的边界。</p><p>再举一个例子，我们将包含 100 棵树的随机森林应用在乳腺癌数据集上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_breast_cancer<br>cancer=load_breast_cancer()<br>X_train,X_test,y_train,y_test=train_test_split(cancer.data,cancer.target,random_state=<span class="hljs-number">0</span>)<br>forest=RandomForestClassifier(n_estimators=<span class="hljs-number">100</span>,random_state=<span class="hljs-number">0</span>)<br>forest.fit(X_train,y_train)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on training set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(forest.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on test set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(forest.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Accuracy on training set: 1.000Accuracy on test set: 0.972</code></pre><p>在没有调节任何参数的情况下，随机森林的精度为 97%，比线性模型或单棵决策树都要好。我们可以调节 max_features 参数，或者像单棵决策树那样进行预剪枝。但是，随机森林的默认参数通常就已经可以给出很好的结果。</p><p>与决策树类似，随机森林也可以给出特征重要性，计算方法是将森林中所有树的特征重要性求和并取平均。一般来说，随机森林给出的特征重要性要比单棵树给出的更为可靠。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_feature_importance_cancer</span>(<span class="hljs-params">model</span>):<br>    n_features = cancer.data.shape[<span class="hljs-number">1</span>]<br>    <span class="hljs-comment">#barh():绘制水平方向的条形图，基本使用方法为：barh(y, width, height=0.8,align=&#x27;center&#x27;)</span><br>    <span class="hljs-comment">#参数详情：y:代表直方图在y轴上的位置</span><br>    <span class="hljs-comment">#width:代表直方图的宽度，即每个直方图具体的数值</span><br>    plt.barh(<span class="hljs-built_in">range</span>(n_features), model.feature_importances_, align=<span class="hljs-string">&#x27;center&#x27;</span>)<br>    <span class="hljs-comment">#plt.xticks/yticks设置轴记号，人为设置坐标轴的刻度显示的值，</span><br>    <span class="hljs-comment">#第一个参数代表坐标轴的位置，第二个参数代表显示的值，</span><br>    <span class="hljs-comment">#np.arrange 均匀地等分区间，支持步长为小数</span><br>    plt.yticks(np.arange(n_features), cancer.feature_names)<br>    plt.xlabel(<span class="hljs-string">&quot;Feature importance&quot;</span>)<br>    plt.ylabel(<span class="hljs-string">&quot;Feature&quot;</span>)<br><br>plot_feature_importance_cancer(forest)<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91%E9%9B%86%E6%88%90/output_13_0.png" alt="png"></p><p>如你所见，与单棵树相比，随机森林中有更多特征的重要性不为零。与单棵决策树类似，随机森林也给了“worst radius”（最大半径）特征很大的重要性，但从总体来看，它实际上却选择“worst perimeter”（最大周长）作为信息量最大的特征。由于构造随机森林过程中的随机性，算法需要考虑多种可能的解释，结果就是随机森林比单棵树更能从总体把握数据的特征。</p><h3 id="1-3-优点，缺点和参数"><a href="#1-3-优点，缺点和参数" class="headerlink" title="1.3 优点，缺点和参数"></a>1.3 优点，缺点和参数</h3><p><span class="mark">用于回归和分类的随机森林是目前应用最广泛的机器学习方法之一。这种方法非常强大，通常不需要反复调节参数就可以给出很好的结果，也不需要对数据进<br>行缩放。</span></p><p>从本质上看，随机森林拥有决策树的所有优点，同时弥补了决策树的一些缺陷。仍然使用决策树的一个原因是需要决策过程的紧凑表示。基本上不可能对几十棵甚至上百棵树做出详细解释，随机森林中树的深度往往比决策树还要大（因为用到了特征子集）。因此，如果你需要以可视化的方式向非专家总结预测过程，那么选择单棵决策树可能更好。虽然在大型数据集上构建随机森林可能比较费时间，但在一台计算机的多个 CPU 内核上并行计算也很容易。如果你用的是多核处理器（几乎所有的现代化计算机都是），你可以用 n_jobs 参数来调节使用的内核个数。使用更多的 CPU 内核，可以让速度线性增加（使用 2 个内核，随机森林的训练速度会加倍），但设置 n_jobs 大于内核个数是没有用的。你<span class="mark">可以设置 n_jobs&#x3D;-1 来使用计算机的所有内核</span>。</p><p>你应该记住，随机森林本质上是随机的，设置不同的随机状态（或者不设置 random_state参数）可以彻底改变构建的模型。森林中的树越多，它对随机状态选择的鲁棒性就越好。<span class="mark">如果你希望结果可以重现，固定 random_state 是很重要的</span>。</p><p>对于维度非常高的稀疏数据（比如文本数据），随机森林的表现往往不是很好。对于这种数据，使用线性模型可能更合适。即使是非常大的数据集，随机森林的表现通常也很好，训练过程很容易并行在功能强大的计算机的多个 CPU 内核上。不过，随机森林需要更大的内存，训练和预测的速度也比线性模型要慢。对一个应用来说，如果时间和内存很重要的话，那么换用线性模型可能更为明智。</p><p><span class="mark">需要调节的重要参数有 n_estimators 和 max_features ，可能还包括预剪枝选项（如 max_depth ）。 n_estimators 总是越大越好。</span>对更多的树取平均可以降低过拟合，从而得到鲁棒性更好的集成。不过收益是递减的，而且树越多需要的内存也越多，训练时间也越长。常用的经验法则就是“在你的时间 &#x2F; 内存允许的情况下尽量多”。</p><p>前面说过， max_features 决定每棵树的随机性大小，较小的 max_features 可以降低过拟合。一般来说，好的经验就是使用默认值：<span class="mark">对于分类，默认值是 max_features&#x3D;sqrt(n_features) ；对于回归，默认值是 max_features&#x3D;n_features 。</span>增大 max_features 或 max_leaf_nodes 有时也可以提高性能。它还可以大大降低用于训练和预测的时间和空间要求。</p><h2 id="2-梯度提升回归树-梯度提升机"><a href="#2-梯度提升回归树-梯度提升机" class="headerlink" title="2.梯度提升回归树(梯度提升机)"></a>2.梯度提升回归树(梯度提升机)</h2><p>梯度提升回归树是另一种集成方法，通过合并多个决策树来构建一个更为强大的模型。虽然名字中含有“回归”，但这个模型既可以用于回归也可以用于分类。与随机森林方法不同，梯度提升采用<span class="mark"><span class="girk">连续</span></span>的方式构造树，<span class="mark">每棵树都试图纠正前一棵树的错误</span>。默认情况下，梯度提升回归树中没有随机化，而是用到了<span class="mark"><span class="burk">强预剪枝</span></span>。梯度提升树通常使用深度很小（1 到 5 之间）的树，这样模型占用的内存更少，预测速度也更快。</p><p>梯度提升背后的主要思想是合并许多简单的模型（在这个语境中叫作弱学习器），比如深度较小的树。每棵树只能对部分数据做出好的预测，因此，添加的树越来越多，可以不断迭代提高性能。</p><p>梯度提升树经常是机器学习竞赛的优胜者，并且广泛应用于业界。与随机森林相比，它通常对参数设置更为敏感，但如果参数设置正确的话，模型精度更高。</p><p><span class="mark">除了预剪枝与集成中树的数量之外，梯度提升的另一个重要参数是 <span class="girk">learning_rate （学习率）</span></span>，用于控制每棵树纠正前一棵树的错误的强度。较高的学习率意味着每棵树都可以做出较强的修正，这样模型更为复杂。通过增大 n_estimators 来向集成中添加更多树，也可以增加模型复杂度，因为模型有更多机会纠正训练集上的错误。</p><p>下面是在乳腺癌数据集上应用 GradientBoostingClassifier 的示例。默认使用 100 棵树，最大深度是 3，学习率为 0.1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> GradientBoostingClassifier<br>X_train,X_test,y_train,y_test=train_test_split(cancer.data,cancer.target,random_state=<span class="hljs-number">0</span>)<br>gbrt=GradientBoostingClassifier(random_state=<span class="hljs-number">0</span>)<br>gbrt.fit(X_train,y_train)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on training set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(gbrt.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on test set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(gbrt.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Accuracy on training set: 1.000Accuracy on test set: 0.965</code></pre><p>由于训练集精度达到 100%，所以很可能存在过拟合。为了降低过拟合，我们可以限制最大深度来加强预剪枝，也可以降低学习率：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">gbrt=GradientBoostingClassifier(random_state=<span class="hljs-number">0</span>,max_depth=<span class="hljs-number">1</span>)<br>gbrt.fit(X_train,y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on training set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(gbrt.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on test set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(gbrt.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Accuracy on training set: 0.991Accuracy on test set: 0.972</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">gbrt = GradientBoostingClassifier(random_state=<span class="hljs-number">0</span>, learning_rate=<span class="hljs-number">0.01</span>)<br>gbrt.fit(X_train, y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on training set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(gbrt.score(X_train, y_train)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on test set: &#123;:.3f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(gbrt.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Accuracy on training set: 0.988Accuracy on test set: 0.965</code></pre><p>降低模型复杂度的两种方法都降低了训练集精度，这和预期相同。在这个例子中，减小树的最大深度显著提升了模型性能，而降低学习率仅稍稍提高了泛化性能。</p><p>对于其他基于决策树的模型，我们也可以将特征重要性可视化，以便更好地理解模型<br><br>由于我们用到了 100 棵树，所以即使所有树的深度都是 1，查看所有树也是不现实的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">gbrt=GradientBoostingClassifier(random_state=<span class="hljs-number">0</span>,max_depth=<span class="hljs-number">1</span>)<br>gbrt.fit(X_train,y_train)<br>plot_feature_importance_cancer(gbrt)<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91%E9%9B%86%E6%88%90/output_22_0.png" alt="png"></p><p>可以看到，梯度提升树的特征重要性与随机森林的特征重要性有些类似，不过梯度提升完全忽略了某些特征。</p><p>由于梯度提升和随机森林两种方法在类似的数据上表现得都很好，因此一种常用的方法就是<span class="mark">先尝试随机森林</span>，它的鲁棒性很好。<span class="girk">如果随机森林效果很好，但预测时间太长，或者机器学习模型精度小数点后第二位的提高也很重要，那么切换成梯度提升通常会有用。</span></p><p>如果你想要将梯度提升应用在大规模问题上，可以研究一下 xgboost 包及其 Python 接口，在写作本书时，这个库在许多数据集上的速度都比 scikit-learn 对梯度提升的实现要快（有时调参也更简单）。</p><h2 id="2-1-优点，缺点和参数"><a href="#2-1-优点，缺点和参数" class="headerlink" title="2.1 优点，缺点和参数"></a>2.1 优点，缺点和参数</h2><p><span class="burk"><span class="girk"><span class="girk">梯度提升</span></span>决策树是监督学习中最强大也最常用的模型之一</span>。其主要缺点是需要仔细调参，而且训练时间可能会比较长。与其他基于树的模型类似，这一算法不需要对数据进行缩放就可以表现得很好，而且也适用于二元特征与连续特征同时存在的数据集。与其他基于树的模型相同，它也通常不适用于高维稀疏数据。（1是训练时间慢，2是特征选择会浪费大量的有效特征）</p><p><span class="mark">梯度提升树模型的主要参数包括树的数量 n_estimators 和学习率 learning_rate</span> ，后者用于控制每棵树对前一棵树的错误的纠正强度。这两个参数高度相关，因为 learning_rate 越低，就需要更多的树来构建具有相似复杂度的模型。<span class="mark">随机森林的 n_estimators 值总是越大越好</span>，但<span class="girk">梯度提升不同</span>，增大 n_estimators 会导致模型更加复杂，进而可能导致过拟合。通常的做法是根据时间和内存的预算选择<span class="girk">合适的 n_estimators ，然后对不同的learning_rate 进行遍历</span>。</p><p>另一个重要参数是 max_depth （或 max_leaf_nodes ），用于降低每棵树的复杂度。梯度提升模型的 <span class="mark">max_depth 通常都设置得很小，一般不超过 5。</span></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>监督学习之k近邻</title>
      <link href="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8Bk%E8%BF%91%E9%82%BB/"/>
      <url>/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8Bk%E8%BF%91%E9%82%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="监督学习之k近邻"><a href="#监督学习之k近邻" class="headerlink" title="监督学习之k近邻"></a>监督学习之k近邻</h1><span id="more"></span><h2 id="所需要的所有包"><a href="#所需要的所有包" class="headerlink" title="所需要的所有包"></a>所需要的所有包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> mglearn<br>%matplotlib inline<br><span class="hljs-comment"># 由于 %matplotlib inline 的存在，当输入plt.plot(x,y_1)后，不必再输入 plt.show()</span><br><span class="hljs-comment">#图像将自动显示出来</span><br><br></code></pre></td></tr></table></figure><h2 id="1-k近邻分类"><a href="#1-k近邻分类" class="headerlink" title="1.k近邻分类"></a>1.k近邻分类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> mglearn<br>%matplotlib inline<br>mglearn.plots.plot_knn_classification(n_neighbors=<span class="hljs-number">1</span>)<br><br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8Bk%E8%BF%91%E9%82%BB/output_3_0.png" alt="png"></p><p>除了仅考虑最近邻，我还可以考虑任意个（k 个）邻居。这也是 k 近邻算法名字的来历。在考虑多于一个邻居的情况时，我们<span class="burk">用“投票法”（voting）来指定标签</span>。也就是说，对于每个测试点，我们数一数多少个邻居属于类别 0，多少个邻居属于类别 1。然后将出现<span class="mark">次数更多的类别（也就是 k 个近邻中占多数的类别）作为预测结果</span>。下面的例子（图 2-5）用到了 3 个近邻：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mglearn.plots.plot_knn_classification(n_neighbors=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8Bk%E8%BF%91%E9%82%BB/output_5_0.png" alt="png"></p><p>通过scikit-learn来应用k近邻算法</p><ul><li>导入类并将其实例化。这时可以设定参数，如邻居的个数</li><li>利用训练集对这个分类器进行拟合</li><li>调用 predict 方法来对测试数据进行预测</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X,y=mglearn.datasets.make_forge()<br>X_train,X_test,y_train,y_test=train_test_split(X,y,random_state=<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br>clf=KNeighborsClassifier(n_neighbors=<span class="hljs-number">3</span>)<br>clf.fit(X_train,y_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set predictions: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(clf.predict(X_test)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set accuracy: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(clf.score(X_test,y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Test set predictions: [1 0 1 0 1 0 0]Test set accuracy: 0.86</code></pre><h2 id="2-分析KNeighborsClassifier"><a href="#2-分析KNeighborsClassifier" class="headerlink" title="2.分析KNeighborsClassifier"></a>2.分析KNeighborsClassifier</h2><p>对于二维数据集，我们还可以在 xy 平面上画出所有可能的测试点的预测结果。我们根据平面中每个点所属的类别对平面进行着色。这样可以查看决策边界（decision boundary），即算法对类别 0 和类别 1 的分界线。</p><p>zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。<br><br>zip 方法在 Python 2 和 Python 3 中的不同：在 Python 3.x 中为了减少内存，zip() 返回的是一个对象。如需展示列表，需手动 list() 转换。</p><p>subplots参数与subplots相似。<br><br>两者都可以规划figure划分为n个子图，但每条subplot命令只会创建一个子图，而一条subplots就可以将所有子图创建好。<br><br>subplots用法示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br> <br>x = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br><span class="hljs-comment">#划分子图</span><br>fig,axes=plt.subplots(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>ax1=axes[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>ax2=axes[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>ax3=axes[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>ax4=axes[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br> <br><span class="hljs-comment">#作图1</span><br>ax1.plot(x, x)<br><span class="hljs-comment">#作图2</span><br>ax2.plot(x, -x)<br><span class="hljs-comment">#作图3</span><br>ax3.plot(x, x ** <span class="hljs-number">2</span>)<br>ax3.grid(color=<span class="hljs-string">&#x27;r&#x27;</span>, linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, linewidth=<span class="hljs-number">1</span>,alpha=<span class="hljs-number">0.3</span>)<br><span class="hljs-comment">#作图4</span><br>ax4.plot(x, np.log(x))<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8Bk%E8%BF%91%E9%82%BB/output_11_1.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">fig,axes=plt.subplots(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">3</span>))<br><span class="hljs-keyword">for</span> n_neighbors,ax <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>],axes):<br>    clf=KNeighborsClassifier(n_neighbors=n_neighbors).fit(X,y)<br>    mglearn.plots.plot_2d_separator(clf,X,fill=<span class="hljs-literal">True</span>,eps=<span class="hljs-number">0.5</span>,ax=ax,alpha=<span class="hljs-number">.4</span>)<br>    mglearn.discrete_scatter(X[:,<span class="hljs-number">0</span>],X[:,<span class="hljs-number">1</span>],y,ax=ax)<br>    ax.set_title(<span class="hljs-string">&quot;&#123;&#125; neighbor(s)&quot;</span>.<span class="hljs-built_in">format</span>(n_neighbors))<br>    ax.set_xlabel(<span class="hljs-string">&quot;feature 0&quot;</span>)<br>    ax.set_ylabel(<span class="hljs-string">&quot;feature 1&quot;</span>)<br>axes[<span class="hljs-number">0</span>].legend(loc=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.legend.Legend at 0x242302ba9b0&gt;</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8Bk%E8%BF%91%E9%82%BB/output_12_1.png" alt="png"></p><p>用单一邻居绘制的决策边界紧跟着训练数据。随着邻居个数越来越多，决策边界也越来越平滑。更平滑的边界对应更简单的模型。换句话说，使用更少的邻居对应更高的模型复杂度，而使用更多的邻居对应更低的模型复杂度。假如考虑极端情况，即邻居个数等于训练集中所有数据点的个数，那么每个测试点的邻居都完全相同（即所有训练点），所有预测结果也完全相同（即训练集中出现次数最多的类别）。</p><p>在现实世界的乳腺癌数据集上进行研究，证实模型复杂度和泛化能力的关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_breast_cancer<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> neighbors<br>cancer=load_breast_cancer()  <span class="hljs-comment">#加载癌症数据集</span><br>X_train,X_test,y_train,y_test=train_test_split(cancer.data,cancer.target,<br>                                                stratify=cancer.target,random_state=<span class="hljs-number">66</span>)<br><br>training_accuracy=[]<br>test_accuracy=[]<br><br><span class="hljs-comment">#neighbors取值从1到10</span><br>neighbors_settings=<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>)<br><br><span class="hljs-keyword">for</span> n_neighbors <span class="hljs-keyword">in</span> neighbors_settings:<br>    clf=KNeighborsClassifier(n_neighbors=n_neighbors)<br>    clf.fit(X_train,y_train)<br>    training_accuracy.append(clf.score(X_train,y_train))<br>    test_accuracy.append(clf.score(X_test,y_test))<br>    <br>plt.plot(neighbors_settings,training_accuracy,label=<span class="hljs-string">&quot;trainning accuracy&quot;</span>)<br>plt.plot(neighbors_settings,test_accuracy,label=<span class="hljs-string">&quot;test_accuracy&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Accuracy&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;n_neighbors&quot;</span>)<br>plt.legend()<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.legend.Legend at 0x24230a4b5c0&gt;</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8Bk%E8%BF%91%E9%82%BB/output_15_1.png" alt="png"></p><p>仅考虑单一近邻时，训练集上的预测结果十分完美。但随着邻居个数的增多，模型变得更简单，训练集精度也随之下降。单一邻居时的测试集精度比使用更多邻居时要低，这表示单一近邻的模型过于复杂。与之相反，当考虑 10 个邻居时，模型又过于简单，性能甚至变得更差。最佳性能在中间的某处，邻居个数大约为 6。不过最好记住这张图的坐标轴刻度。最差的性能约为 88% 的精度，这个结果仍然可以接受。</p><h2 id="3-K近邻回归"><a href="#3-K近邻回归" class="headerlink" title="3.K近邻回归"></a>3.K近邻回归</h2><p>k近邻算法还可以用于回归(把邻居的平均值赋给目标)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mglearn.plots.plot_knn_regression(n_neighbors=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8Bk%E8%BF%91%E9%82%BB/output_18_0.png" alt="png"></p><p>用多个近邻进行回归,预测结果为这些邻居的平均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mglearn.plots.plot_knn_regression(n_neighbors=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8Bk%E8%BF%91%E9%82%BB/output_20_0.png" alt="png"></p><p>用于回归的k近邻算法在sklearn的KNeighborsRegressor类中实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsRegressor<br>X,y=mglearn.datasets.make_wave(n_samples=<span class="hljs-number">40</span>)<br><span class="hljs-comment"># 划分训练数据集</span><br>X_train,X_test,y_train,y_test=train_test_split(X,y,random_state=<span class="hljs-number">0</span>)<br><span class="hljs-comment"># 实例化模型，邻居设定为3</span><br>reg=KNeighborsRegressor(n_neighbors=<span class="hljs-number">3</span>)<br><span class="hljs-comment"># 拟合模型</span><br>reg.fit(X_train,y_train)<br><br><br></code></pre></td></tr></table></figure><pre><code class="hljs">KNeighborsRegressor(algorithm=&#39;auto&#39;, leaf_size=30, metric=&#39;minkowski&#39;,                    metric_params=None, n_jobs=None, n_neighbors=3, p=2,                    weights=&#39;uniform&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set predictions:\n&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(reg.predict(X_test)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set R^2:&#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(reg.score(X_test,y_test)))<br><br><br></code></pre></td></tr></table></figure><pre><code class="hljs">Test set predictions:[-0.05396539  0.35686046  1.13671923 -1.89415682 -1.13881398 -1.63113382  0.35686046  0.91241374 -0.44680446 -1.13881398]Test set R^2:0.83</code></pre><p>可以用score方法来评估模型，对于回归问题，这一方法返回的是$R^2$分数，也叫做决定系数，是回归模型预测的优度度量，位于0到1之间，1完美预测，0对于常数模型，即总是预测训练集响应(y_train)的平均值</p><h2 id="4-分析KNeigborsRegressor"><a href="#4-分析KNeigborsRegressor" class="headerlink" title="4.分析KNeigborsRegressor"></a>4.分析KNeigborsRegressor</h2><p>对于我们的一维数据集，可以查看所有特征取值对应的预测结果（图 2-10）。为了便于绘<br>图，我们创建一个由许多点组成的测试数据集</p><p>np reshape  array  linespace 用法：<br>numpy.arange(n).reshape(a, b); 依次生成n个自然数，并且以a行b列的数组形式显示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-built_in">print</span>(np.array([<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>))<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">[[1] [1] [1]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(np.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-number">2</span>).reshape(<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[  1.] [100.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">fig,axes=plt.subplots(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,figsize=(<span class="hljs-number">15</span>,<span class="hljs-number">4</span>))<br><span class="hljs-comment">#创建1000个数据点，在-3和3之间均匀分布</span><br>line=np.linspace(-<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1000</span>).reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> n_neighbors,ax <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>],axes):<br>    reg=KNeighborsRegressor(n_neighbors=n_neighbors)<br>    reg.fit(X_train,y_train)<br>    ax.plot(line,reg.predict(line))<br>    ax.plot(X_train,y_train,<span class="hljs-string">&#x27;^&#x27;</span>,c=mglearn.cm2(<span class="hljs-number">0</span>),markersize=<span class="hljs-number">8</span>)<br>    ax.plot(X_test,y_test,<span class="hljs-string">&#x27;v&#x27;</span>,c=mglearn.cm2(<span class="hljs-number">1</span>),markersize=<span class="hljs-number">8</span>)<br>    ax.set_title(<br>    <span class="hljs-string">&quot;&#123;&#125; neighbor(s) \n train score:&#123;:.2f&#125; test_score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>    n_neighbors,reg.score(X_train,y_train),reg.score(X_test,y_test)))<br>    ax.set_xlabel(<span class="hljs-string">&quot;Feature&quot;</span>)<br>    ax.set_ylabel(<span class="hljs-string">&quot;Target&quot;</span>)<br>axes[<span class="hljs-number">0</span>].legend([<span class="hljs-string">&quot;Model predictions&quot;</span>,<span class="hljs-string">&quot;Training data/target&quot;</span>,<br>               <span class="hljs-string">&quot;Test data/target&quot;</span>],loc=<span class="hljs-string">&quot;best&quot;</span>)<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.legend.Legend at 0x2422e47e5c0&gt;</code></pre><p><img src="/2019/10/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B9%8Bk%E8%BF%91%E9%82%BB/output_29_1.png" alt="png"></p><p>从图中可以看出，仅使用单一邻居，训练集中的每个点都对预测结果有显著影响，预测结果的图像经过所有数据点。这导致预测结果非常不稳定。考虑更多的邻居之后，预测结果变得更加平滑，但对训练数据的拟合也不好。</p><h2 id="5-优点，缺点和参数"><a href="#5-优点，缺点和参数" class="headerlink" title="5.优点，缺点和参数"></a>5.优点，缺点和参数</h2><p>一般来说， KNeighbors 分类器有 2 个重要参数：邻居个数与数据点之间距离的度量方法。在实践中，使用较小的邻居个数（比如 3 个或 5 个）往往可以得到比较好的结果，但你应该调节这个参数。选择合适的距离度量方法超出了本书的范围。默认使用欧式距离，它在许多情况下的效果都很好。</p><p>k-NN 的优点之一就是模型很容易理解，通常不需要过多调节就可以得到不错的性能。在考虑使用更高级的技术之前，尝试此算法是一种很好的基准方法。构建最近邻模型的速度通常很快，但如果训练集很大（特征数很多或者样本数很大），预测速度可能会比较慢。使用 k-NN 算法时，对数据进行预处理是很重要的（见第 3 章）。这一算法对于有很多特征（几百或更多）的数据集往往效果不好，对于大多数特征的大多数取值都为 0 的数据集（所谓的稀疏数据集）来说，这一算法的效果尤其不好。</p><p>虽然 k 近邻算法很容易理解，但由于预测速度慢且不能处理具有很多特征的数据集，所以在实践中往往不会用到</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>鸢尾花的例子</title>
      <link href="/2019/10/05/%E9%B8%A2%E5%B0%BE%E8%8A%B1%E7%9A%84%E4%BE%8B%E5%AD%90/"/>
      <url>/2019/10/05/%E9%B8%A2%E5%B0%BE%E8%8A%B1%E7%9A%84%E4%BE%8B%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="监督学习问题：预测花的品种"><a href="#监督学习问题：预测花的品种" class="headerlink" title="监督学习问题：预测花的品种"></a>监督学习问题：预测花的品种</h1><span id="more"></span><p>数据分类：花瓣：长度，宽度；花萼：长度，宽度   单位厘米<br>花的品种：setosa，versicolor，virginica<br>目标：构建机器学习模型，从已有的测量数据进行学习，预测新花的品种</p><h2 id="1-认识数据"><a href="#1-认识数据" class="headerlink" title="1.认识数据"></a>1.认识数据</h2><p>加载必要的库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <span class="hljs-comment">#矩阵运算</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt  <span class="hljs-comment">#绘图</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd  <span class="hljs-comment">#基于numpy的数据分析库</span><br><span class="hljs-keyword">import</span> mglearn <span class="hljs-comment">#美化图像</span><br></code></pre></td></tr></table></figure><p>鸢尾花(iris)数据集，是机器学习和统计学中一个经典的数据集<br><br>包含在scikit-learn的datasets模块中<br><br>可以通过调用load_iris函数来加载数据<br><br>scikit是一个建立在Scipy基础上用于机器学习的python模块，包含众多顶级机器学习算法<br><br>Scipy包含的功能有最优化、线性代数、积分、插值、拟合、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算<br>Scipy是一个用于数学、科学、工程领域的常用软件包，可以处理插值、积分、优化、图像处理、常微分方程数值解的求解、信号处理等问题。它用于有效计算Numpy矩阵，使Numpy和Scipy协同工作，高效解决问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris<br>iris_dataset=load_iris()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;keys of iris_dataset: \n&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(iris_dataset.keys()))<br></code></pre></td></tr></table></figure><pre><code class="hljs">keys of iris_dataset: dict_keys([&#39;data&#39;, &#39;target&#39;, &#39;target_names&#39;, &#39;DESCR&#39;, &#39;feature_names&#39;, &#39;filename&#39;])</code></pre><p>load_iris返回的iris对象是一个Bunch对象，包含键，值，以下输出各个键对应的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> iris_dataset.keys():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;对应值为：&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(iris_dataset[i],end=<span class="hljs-string">&#x27;\n&#x27;</span>)<br>    <br><br></code></pre></td></tr></table></figure><pre><code class="hljs">data对应值为：[[5.1 3.5 1.4 0.2] [4.9 3.  1.4 0.2] [4.7 3.2 1.3 0.2] [4.6 3.1 1.5 0.2] [5.  3.6 1.4 0.2] [5.4 3.9 1.7 0.4] [4.6 3.4 1.4 0.3] [5.  3.4 1.5 0.2] [4.4 2.9 1.4 0.2] [4.9 3.1 1.5 0.1] [5.4 3.7 1.5 0.2] [4.8 3.4 1.6 0.2] [4.8 3.  1.4 0.1] [4.3 3.  1.1 0.1] [5.8 4.  1.2 0.2] [5.7 4.4 1.5 0.4] [5.4 3.9 1.3 0.4] [5.1 3.5 1.4 0.3] [5.7 3.8 1.7 0.3] [5.1 3.8 1.5 0.3] [5.4 3.4 1.7 0.2] [5.1 3.7 1.5 0.4] [4.6 3.6 1.  0.2] [5.1 3.3 1.7 0.5] [4.8 3.4 1.9 0.2] [5.  3.  1.6 0.2] [5.  3.4 1.6 0.4] [5.2 3.5 1.5 0.2] [5.2 3.4 1.4 0.2] [4.7 3.2 1.6 0.2] [4.8 3.1 1.6 0.2] [5.4 3.4 1.5 0.4] [5.2 4.1 1.5 0.1] [5.5 4.2 1.4 0.2] [4.9 3.1 1.5 0.2] [5.  3.2 1.2 0.2] [5.5 3.5 1.3 0.2] [4.9 3.6 1.4 0.1] [4.4 3.  1.3 0.2] [5.1 3.4 1.5 0.2] [5.  3.5 1.3 0.3] [4.5 2.3 1.3 0.3] [4.4 3.2 1.3 0.2] [5.  3.5 1.6 0.6] [5.1 3.8 1.9 0.4] [4.8 3.  1.4 0.3] [5.1 3.8 1.6 0.2] [4.6 3.2 1.4 0.2] [5.3 3.7 1.5 0.2] [5.  3.3 1.4 0.2] [7.  3.2 4.7 1.4] [6.4 3.2 4.5 1.5] [6.9 3.1 4.9 1.5] [5.5 2.3 4.  1.3] [6.5 2.8 4.6 1.5] [5.7 2.8 4.5 1.3] [6.3 3.3 4.7 1.6] [4.9 2.4 3.3 1. ] [6.6 2.9 4.6 1.3] [5.2 2.7 3.9 1.4] [5.  2.  3.5 1. ] [5.9 3.  4.2 1.5] [6.  2.2 4.  1. ] [6.1 2.9 4.7 1.4] [5.6 2.9 3.6 1.3] [6.7 3.1 4.4 1.4] [5.6 3.  4.5 1.5] [5.8 2.7 4.1 1. ] [6.2 2.2 4.5 1.5] [5.6 2.5 3.9 1.1] [5.9 3.2 4.8 1.8] [6.1 2.8 4.  1.3] [6.3 2.5 4.9 1.5] [6.1 2.8 4.7 1.2] [6.4 2.9 4.3 1.3] [6.6 3.  4.4 1.4] [6.8 2.8 4.8 1.4] [6.7 3.  5.  1.7] [6.  2.9 4.5 1.5] [5.7 2.6 3.5 1. ] [5.5 2.4 3.8 1.1] [5.5 2.4 3.7 1. ] [5.8 2.7 3.9 1.2] [6.  2.7 5.1 1.6] [5.4 3.  4.5 1.5] [6.  3.4 4.5 1.6] [6.7 3.1 4.7 1.5] [6.3 2.3 4.4 1.3] [5.6 3.  4.1 1.3] [5.5 2.5 4.  1.3] [5.5 2.6 4.4 1.2] [6.1 3.  4.6 1.4] [5.8 2.6 4.  1.2] [5.  2.3 3.3 1. ] [5.6 2.7 4.2 1.3] [5.7 3.  4.2 1.2] [5.7 2.9 4.2 1.3] [6.2 2.9 4.3 1.3] [5.1 2.5 3.  1.1] [5.7 2.8 4.1 1.3] [6.3 3.3 6.  2.5] [5.8 2.7 5.1 1.9] [7.1 3.  5.9 2.1] [6.3 2.9 5.6 1.8] [6.5 3.  5.8 2.2] [7.6 3.  6.6 2.1] [4.9 2.5 4.5 1.7] [7.3 2.9 6.3 1.8] [6.7 2.5 5.8 1.8] [7.2 3.6 6.1 2.5] [6.5 3.2 5.1 2. ] [6.4 2.7 5.3 1.9] [6.8 3.  5.5 2.1] [5.7 2.5 5.  2. ] [5.8 2.8 5.1 2.4] [6.4 3.2 5.3 2.3] [6.5 3.  5.5 1.8] [7.7 3.8 6.7 2.2] [7.7 2.6 6.9 2.3] [6.  2.2 5.  1.5] [6.9 3.2 5.7 2.3] [5.6 2.8 4.9 2. ] [7.7 2.8 6.7 2. ] [6.3 2.7 4.9 1.8] [6.7 3.3 5.7 2.1] [7.2 3.2 6.  1.8] [6.2 2.8 4.8 1.8] [6.1 3.  4.9 1.8] [6.4 2.8 5.6 2.1] [7.2 3.  5.8 1.6] [7.4 2.8 6.1 1.9] [7.9 3.8 6.4 2. ] [6.4 2.8 5.6 2.2] [6.3 2.8 5.1 1.5] [6.1 2.6 5.6 1.4] [7.7 3.  6.1 2.3] [6.3 3.4 5.6 2.4] [6.4 3.1 5.5 1.8] [6.  3.  4.8 1.8] [6.9 3.1 5.4 2.1] [6.7 3.1 5.6 2.4] [6.9 3.1 5.1 2.3] [5.8 2.7 5.1 1.9] [6.8 3.2 5.9 2.3] [6.7 3.3 5.7 2.5] [6.7 3.  5.2 2.3] [6.3 2.5 5.  1.9] [6.5 3.  5.2 2. ] [6.2 3.4 5.4 2.3] [5.9 3.  5.1 1.8]]target对应值为：[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2]target_names对应值为：[&#39;setosa&#39; &#39;versicolor&#39; &#39;virginica&#39;]DESCR对应值为：.. _iris_dataset:Iris plants dataset--------------------**Data Set Characteristics:**    :Number of Instances: 150 (50 in each of three classes)    :Number of Attributes: 4 numeric, predictive attributes and the class    :Attribute Information:        - sepal length in cm        - sepal width in cm        - petal length in cm        - petal width in cm        - class:                - Iris-Setosa                - Iris-Versicolour                - Iris-Virginica                    :Summary Statistics:    ============== ==== ==== ======= ===== ====================                    Min  Max   Mean    SD   Class Correlation    ============== ==== ==== ======= ===== ====================    sepal length:   4.3  7.9   5.84   0.83    0.7826    sepal width:    2.0  4.4   3.05   0.43   -0.4194    petal length:   1.0  6.9   3.76   1.76    0.9490  (high!)    petal width:    0.1  2.5   1.20   0.76    0.9565  (high!)    ============== ==== ==== ======= ===== ====================    :Missing Attribute Values: None    :Class Distribution: 33.3% for each of 3 classes.    :Creator: R.A. Fisher    :Donor: Michael Marshall (MARSHALL%PLU@io.arc.nasa.gov)    :Date: July, 1988The famous Iris database, first used by Sir R.A. Fisher. The dataset is takenfrom Fisher&#39;s paper. Note that it&#39;s the same as in R, but not as in the UCIMachine Learning Repository, which has two wrong data points.This is perhaps the best known database to be found in thepattern recognition literature.  Fisher&#39;s paper is a classic in the field andis referenced frequently to this day.  (See Duda &amp; Hart, for example.)  Thedata set contains 3 classes of 50 instances each, where each class refers to atype of iris plant.  One class is linearly separable from the other 2; thelatter are NOT linearly separable from each other... topic:: References   - Fisher, R.A. &quot;The use of multiple measurements in taxonomic problems&quot;     Annual Eugenics, 7, Part II, 179-188 (1936); also in &quot;Contributions to     Mathematical Statistics&quot; (John Wiley, NY, 1950).   - Duda, R.O., &amp; Hart, P.E. (1973) Pattern Classification and Scene Analysis.     (Q327.D83) John Wiley &amp; Sons.  ISBN 0-471-22361-1.  See page 218.   - Dasarathy, B.V. (1980) &quot;Nosing Around the Neighborhood: A New System     Structure and Classification Rule for Recognition in Partially Exposed     Environments&quot;.  IEEE Transactions on Pattern Analysis and Machine     Intelligence, Vol. PAMI-2, No. 1, 67-71.   - Gates, G.W. (1972) &quot;The Reduced Nearest Neighbor Rule&quot;.  IEEE Transactions     on Information Theory, May 1972, 431-433.   - See also: 1988 MLC Proceedings, 54-64.  Cheeseman et al&quot;s AUTOCLASS II     conceptual clustering system finds 3 classes in the data.   - Many, many more ...feature_names对应值为：[&#39;sepal length (cm)&#39;, &#39;sepal width (cm)&#39;, &#39;petal length (cm)&#39;, &#39;petal width (cm)&#39;]filename对应值为：E:\Python\Anaconda\lib\site-packages\sklearn\datasets\data\iris.csv</code></pre><p>对数据进行说明：<br>data：每一行4个数对应花瓣的长宽，花萼的长宽<br><br>target：每一朵花对应的类别，0,1,2对应target_name的下标<br><br>target_name:花的类别集合<br><br>DESCR：数据集的简要说明<br><br>feature_name：数据说明，声明每一个特征<br><br>(机器学习中的个体叫做样本，其属性叫做特征)<br></p><h2 id="2-训练和测试数据"><a href="#2-训练和测试数据" class="headerlink" title="2.训练和测试数据"></a>2.训练和测试数据</h2><p>构建机器学习模型<br><br>已有数据集分为两部分，一部分构建模型，一部分测试模型<br><br>scikit-learn中的train_test_split函数可以打乱数据集并进行拆分<br><br>将75%的行数据及对应标签作为训练集，25%作为训练集，这是推荐分配方式<br><br>scikit-learn 中的数据通常用大写的 X 表示，而标签用小写的 y 表示。<br><br>这是受到了数学标准公式 f(x)&#x3D;y 的启发，其中 x 是函数的输入，y 是输出。我们用大写的 X 是因为数据是一个二维数组（矩阵），用小写的 y 是因为目标是一个一维数组（向量），这也是数学中的约定。</p><h3 id="对数据调用train-test-split划分数据集"><a href="#对数据调用train-test-split划分数据集" class="headerlink" title="对数据调用train_test_split划分数据集"></a>对数据调用train_test_split划分数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X_train,X_test,y_train,y_test=train_test_split(iris_dataset[<span class="hljs-string">&#x27;data&#x27;</span>],<br>iris_dataset[<span class="hljs-string">&#x27;target&#x27;</span>],random_state=<span class="hljs-number">0</span>) <span class="hljs-comment">#为了保证多次运行同一函数能得到相同输出，利用random_state指定了生成随机参数的种子</span><br><span class="hljs-comment">#输出的结果都是Numpy数组</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;X_train shape: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(X_train.shape))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;y_train shape: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(y_train.shape))<br></code></pre></td></tr></table></figure><pre><code class="hljs">X_train shape: (112, 4)y_train shape: (112,)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x_test shape: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(X_test.shape))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;y_test shape: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(y_test.shape))<br></code></pre></td></tr></table></figure><pre><code class="hljs">x_test shape: (38, 4)y_test shape: (38,)</code></pre><h2 id="3-观察数据"><a href="#3-观察数据" class="headerlink" title="3.观察数据"></a>3.观察数据</h2><p>构建机器学习模型之前，检测数据，排查异常数据<br><br>利用数据可视化：</p><ul><li>绘制散点图：分为x，y轴，一次只能绘制两个特征</li><li>绘制散点图矩阵：无法同时显示所有特征之间的关系</li></ul><h3 id="利用pandas的scatter-matrix函数绘制散点图矩阵"><a href="#利用pandas的scatter-matrix函数绘制散点图矩阵" class="headerlink" title="利用pandas的scatter_matrix函数绘制散点图矩阵"></a>利用pandas的scatter_matrix函数绘制散点图矩阵</h3><h4 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释:"></a>参数解释:</h4><p>frame：数据的dataframe,本例为4<em>150的矩阵;<br><br>c是颜色,本例中按照y_train的不同来分配不同的颜色;<br><br>figsize设置图片的尺寸;<br><br>marker是散点的形状,’o’是圆形,’</em>‘是星形 ;<br><br>hist_kwds是直方图的相关参数,{‘bins’:20}是生成包含20个长条的直方图;<br><br>s是大图的尺寸 ; <br><br>alpha是图的透明度;<br><br>cmap是colourmap,就是颜色板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> mglearn<br><span class="hljs-comment">#利用X_train中的数据创建DataFrame</span><br><span class="hljs-comment">#利用iris_dataset.feature_names中的字符串对数据列进行标记</span><br>iris_dataframe=pd.DataFrame(X_train,columns=iris_dataset.feature_names)<br><span class="hljs-comment">#利用DataFrame创建散点图矩阵，按y_train着色</span><br>grr=pd.plotting.scatter_matrix(iris_dataframe,c=y_train,figsize=(<span class="hljs-number">15</span>,<span class="hljs-number">15</span>),marker=<span class="hljs-string">&#x27;o&#x27;</span>,<br>                              hist_kwds=&#123;<span class="hljs-string">&#x27;bins&#x27;</span>:<span class="hljs-number">20</span>&#125;,s=<span class="hljs-number">60</span>,alpha=<span class="hljs-number">.8</span>,cmap=mglearn.cm3)<br></code></pre></td></tr></table></figure><p><img src="/2019/10/05/%E9%B8%A2%E5%B0%BE%E8%8A%B1%E7%9A%84%E4%BE%8B%E5%AD%90/output_18_0.png" alt="png"></p><h2 id="4-KNN算法"><a href="#4-KNN算法" class="headerlink" title="4.KNN算法"></a>4.KNN算法</h2><p>开始构建机器学习模型<br><br>skikit-learn中有许多<br>可用的分类算法<br><br>这里采用k近邻算法：<br>考虑训练集中与新数据点最近的任意 k 个邻居（比如说，距离最近的 3 个或 5 个邻居），而不是只考虑最近的那一个。然后，我们可以用这些邻居中数量最多的类别做出预测<br><br>scikit-learn 中所有的机器学习模型都在各自的类中实现，这些类被称为 Estimator类。k 近邻分类算法是在 neighbors 模块的 KNeighborsClassifier 类中实现的。我们需要将这个类实例化为一个对象，然后才能使用这个模型。这时我们需要设置模型的参数。KNeighborsClassifier 最重要的参数就是邻居的数目，这里我们设为 1 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br>knn=KNeighborsClassifier(n_neighbors=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>想要基于训练集来构建模型，需要调用 knn 对象的 fit 方法，输入参数为 X_train 和 y_train<br><br>二者都是 NumPy 数组，前者包含训练数据，后者包含相应的训练标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">knn.fit(X_train,y_train)<br></code></pre></td></tr></table></figure><pre><code class="hljs">KNeighborsClassifier(algorithm=&#39;auto&#39;, leaf_size=30, metric=&#39;minkowski&#39;,                     metric_params=None, n_jobs=None, n_neighbors=1, p=2,                     weights=&#39;uniform&#39;)</code></pre><h2 id="5-预测和评估"><a href="#5-预测和评估" class="headerlink" title="5.预测和评估"></a>5.预测和评估</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">y_pred=knn.predict(X_test)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set predictions:\n &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(y_pred))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Test set predictions: [2 1 0 2 0 2 0 1 1 1 2 1 1 1 1 0 1 1 0 0 2 1 0 0 2 0 0 1 1 0 2 1 0 2 2 1 0 2]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(np.mean(y_pred==y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Test set score: 0.97</code></pre><p>对于这个模型来说，测试集的精度约为 0.97，也就是说，对于测试集中的鸢尾花，我们的预测有 97% 是正确的。根据一些数学假设，对于新的鸢尾花，可以认为我们的模型预测结果有 97% 都是正确的。</p><h2 id="完整代码如下："><a href="#完整代码如下：" class="headerlink" title="完整代码如下："></a>完整代码如下：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <span class="hljs-comment">#矩阵运算</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt  <span class="hljs-comment">#绘图</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd  <span class="hljs-comment">#基于numpy的数据分析库</span><br><span class="hljs-keyword">import</span> mglearn <span class="hljs-comment">#美化图像</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br>iris_dataset=load_iris()<br>X_train,X_test,y_train,y_test=train_test_split(iris_dataset[<span class="hljs-string">&#x27;data&#x27;</span>],<br>iris_dataset[<span class="hljs-string">&#x27;target&#x27;</span>],random_state=<span class="hljs-number">0</span>) <span class="hljs-comment">#为了保证多次运行同一函数能得到相同输出，利用random_state指定了生成随机参数的种子</span><br><span class="hljs-comment">#输出的结果都是Numpy数组</span><br><span class="hljs-comment">#利用X_train中的数据创建DataFrame</span><br><span class="hljs-comment">#利用iris_dataset.feature_names中的字符串对数据列进行标记</span><br>iris_dataframe=pd.DataFrame(X_train,columns=iris_dataset.feature_names)<br><span class="hljs-comment">#利用DataFrame创建散点图矩阵，按y_train着色</span><br>grr=pd.plotting.scatter_matrix(iris_dataframe,c=y_train,figsize=(<span class="hljs-number">15</span>,<span class="hljs-number">15</span>),marker=<span class="hljs-string">&#x27;o&#x27;</span>,<br>                              hist_kwds=&#123;<span class="hljs-string">&#x27;bins&#x27;</span>:<span class="hljs-number">20</span>&#125;,s=<span class="hljs-number">60</span>,alpha=<span class="hljs-number">.8</span>,cmap=mglearn.cm3)<br>knn=KNeighborsClassifier(n_neighbors=<span class="hljs-number">1</span>)<br>knn.fit(X_train,y_train)<br>y_pred=knn.predict(X_test)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(np.mean(y_pred==y_test)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Test set score: 0.97</code></pre><p><img src="/%E9%B8%A2%E5%B0%BE%E8%8A%B1%E7%9A%84%E4%BE%8B%E5%AD%90%5Coutput_28_1.png" alt="png"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter Notebook的使用</title>
      <link href="/2019/10/01/Jupyter-Notebook%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/10/01/Jupyter-Notebook%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Jupyter Notebook的配置与使用</p><span id="more"></span><p>亲测实用有效教程：<br></p><p><a href="https://blog.csdn.net/weixin_42814873/article/details/82842925">配置juster notebook全步骤，更改默认路径</a></p><p><a href="http://baijiahao.baidu.com/s?id=1601883438842526311&wfr=spider&for=pc">入门｜始于Jupyter Notebooks：一份全面的初学者实用指南(这个最全几乎解决了基础的所有问题)</a></p><p>快捷键：<br><br>Jupyter Notebooks 提供了两种不同的键盘输入模式——命令和编辑<br><br>命令模式是将键盘和笔记本层面的命令绑定起来，并且由带有蓝色左边距的灰色单元边框表示。<br><br>编辑模式让你可以在活动单元中输入文本（或代码），用绿色单元边框表示。<br></p><p>可以分别使用 Esc 和 Enter 在命令模式和编辑模式之间跳跃。<br></p><p>进入命令模式之后（此时你没有活跃单元），你可以尝试以下快捷键：</p><table><thead><tr><th>按键</th><th>作用</th></tr></thead><tbody><tr><td>A</td><td>会在活跃单元之上插入一个新的单元</td></tr><tr><td>B</td><td>会在活跃单元之下插入一个新单元</td></tr><tr><td>连续按两次 D</td><td>可以删除一个单元。</td></tr><tr><td>Z</td><td>撤销被删除的单元</td></tr><tr><td>Y</td><td>会将当前活跃的单元变成一个代码单元</td></tr><tr><td>Shift +上或下箭头</td><td>选择多个单元</td></tr><tr><td>在多选模式时，按住 Shift + M</td><td>可合并你的选择</td></tr><tr><td>F</td><td>会弹出「查找和替换」菜单。</td></tr></tbody></table><p>处于编辑模式时（在命令模式时按 Enter 会进入编辑模式），你会发现下列快捷键很有用：</p><table><thead><tr><th>按键</th><th>作用</th></tr></thead><tbody><tr><td>Ctrl + Home</td><td>到达单元起始位置</td></tr><tr><td>Ctrl + S</td><td>保存进度</td></tr><tr><td>Ctrl + Enter</td><td>运行整个单元块</td></tr><tr><td>Alt + Enter</td><td>不止会运行单元块，还会在下面添加一个新单元</td></tr><tr><td>Ctrl + Shift + F</td><td>打开命令面板。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客添加代码高亮,代码复制与评论系统</title>
      <link href="/2019/09/27/hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE-%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/09/27/hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE-%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>此配置针对next主题，进行代码高亮，代码块复制，评论系统相关操作</p><span id="more"></span><h1 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h1><p>在主题的_config.yml搜索</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Code</span> Highlight theme<br><br></code></pre></td></tr></table></figure><p>找到代码块对highlight_theme进行配置更改主题</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># Code Highlight theme</span><br><span class="hljs-meta"># Available values: normal | night | night eighties | night blue | night bright</span><br><span class="hljs-meta"># https:<span class="hljs-comment">//github.com/chriskempson/tomorrow-theme</span></span><br><span class="hljs-symbol">highlight_theme:</span> night bright<br><br></code></pre></td></tr></table></figure><h1 id="代码复制"><a href="#代码复制" class="headerlink" title="代码复制"></a>代码复制</h1><p><a href="http://www.zhyong.cn/posts/ca02/">http://www.zhyong.cn/posts/ca02/</a><br><br>有一点问题：<br>复制按钮显示异常<br></p><p>修改</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>: inline-block;<br><br></code></pre></td></tr></table></figure><p>为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><br><span class="hljs-attribute">display</span>: block;<br><br></code></pre></td></tr></table></figure><p>修改后对应代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs css"><br>//代码块复制按钮<br><span class="hljs-selector-class">.highlight</span>&#123;<br>  //方便copy代码按钮（btn-copy）的定位<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.btn-copy</span> &#123;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">cursor</span>: pointer;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#eee</span>;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">#fcfcfc</span>,<span class="hljs-number">#eee</span>);<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#d5d5d5</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;<br>    -webkit-user-select: none;<br>    -moz-user-select: none;<br>    -ms-user-select: none;<br>    user-select: none;<br>    -webkit-appearance: none;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">13px</span>;<br>    <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">700</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>    -webkit-<span class="hljs-attribute">transition</span>: opacity .<span class="hljs-number">3s</span> ease-in-out;<br>    -o-<span class="hljs-attribute">transition</span>: opacity .<span class="hljs-number">3s</span> ease-in-out;<br>    <span class="hljs-attribute">transition</span>: opacity .<span class="hljs-number">3s</span> ease-in-out;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">2px</span> <span class="hljs-number">6px</span>;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.btn-copy</span> <span class="hljs-selector-tag">span</span> &#123;<br>    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">5px</span>;<br>&#125;<br><span class="hljs-selector-class">.highlight</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.btn-copy</span>&#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="添加评论系统"><a href="#添加评论系统" class="headerlink" title="添加评论系统"></a>添加评论系统</h1><ol><li><a href="http://houyimin.cn/2017/05/26/Hexo%E7%9A%84NexT%E4%B8%BB%E9%A2%98%EF%BC%9A%E6%B7%BB%E5%8A%A0%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA/">添加来必力评论系统</a></li><li><a href="https://me.idealli.com/post/3453c710.html">进行修改优化</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> hexo博客相关配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本排序算法</title>
      <link href="/2019/09/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/09/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>排序算法是最基本的算法，本文使用语言为C&#x2F;C++<br><br>详细了解参考以下链接：<br><br><a href="https://github.com/hustcc/JS-Sorting-Algorithm">十大排序算法</a><br><br>个人认为应该牢记的是归并排序，快速排序，基本的冒泡排序以及sort()函数的使用方法，这些是在比赛和做题时经常遇到的。</p><span id="more"></span><h1 id="各排序算法分析"><a href="#各排序算法分析" class="headerlink" title="各排序算法分析"></a>各排序算法分析</h1><p><img src="/2019/09/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/sort.png"></p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>是稳定的排序算法，适用于大规模的基本有序的数据<br></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>不断地划分区间，一分二，二分四，直到最后一个小数组只有一个元素，然后开始逐层向上合并，合并时要按想要的顺序(从小到大，或是从大到小)进行选择然后合并，因此要用到递归<br></p><p>原理动图如下：<br></p><p><img src="/2019/09/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/mergeSort.gif"></p><p>算法采用C++实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//合并函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> mid,<span class="hljs-type">int</span> R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> len=R-L+<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> *t=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span> [len+<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> i=L,j=mid+<span class="hljs-number">1</span>,k=<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//比较，选择小的一个</span><br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=R)<br>    &#123;<br>        t[k++]=a[i]&lt;a[j]?a[i++]:a[j++];<br>    &#125;<br>    <span class="hljs-comment">//比较完后如果有剩余元素，都添加进数组中</span><br>    <span class="hljs-keyword">while</span>(i&lt;=mid)<br>    &#123;<br>        t[k++]=a[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j&lt;=R)<br>    &#123;<br>        t[k++]=a[j++];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m=L;m&lt;=R;m++)<br>    &#123;<br>        a[m]=t[m-L+<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">delete</span> [] t;<br>&#125;<br><span class="hljs-comment">//用来递归成小区间进行排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(L&gt;=R)<span class="hljs-comment">//这个条件不能忘记，否则会死循环</span><br>    <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> mid=(L+R+<span class="hljs-number">0.5</span>)/<span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">MergeSort</span>(a,L,mid);<br>        <span class="hljs-built_in">MergeSort</span>(a,mid+<span class="hljs-number">1</span>,R);<br>        <span class="hljs-built_in">Merge</span>(a,L,mid,R);<br>    &#125;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cout&lt;&lt;<span class="hljs-string">&quot;input num of items:&quot;</span>;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> *a=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">MergeSort</span>(a,<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">delete</span> [] a;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>对完全无序的数据执行结果最优<br></p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>在一组数据中选择一个基准数，一个左标记，一个右标记，将所有比这个数小的数放在左边，比这个数大的数放在其右侧，不断重复此过程，直至左标记与右标记重合，最后让基准数归位。<br>原理的动图如下：<br></p><p><img src="/2019/09/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quickSort.gif"></p><p>用C++实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *x,<span class="hljs-type">int</span> *y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> temp=*x;<br>    *x=*y;<br>    *y=temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> base=a[L];<br>    <span class="hljs-keyword">while</span>(L&lt;R)  <br>    &#123; <br>        <span class="hljs-comment">//从右标记开始先找，之后左标记找，然后交换</span><br>        <span class="hljs-keyword">while</span>(R&gt;L&amp;&amp;a[R]&gt;base)<br>        R--;<br>        <span class="hljs-keyword">while</span>(L&lt;R&amp;&amp;a[L]&lt;base)<br>        L++;<br>        <span class="hljs-built_in">swap</span>(a[R],a[L]);<br>    &#125;<br>    a[L]=base;<span class="hljs-comment">//基准数归位</span><br>    <span class="hljs-keyword">return</span> L;<span class="hljs-comment">//返回这个基准数的位置，之后排序它左右的两个小区间</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(L&gt;=R) <span class="hljs-comment">//这个条件不能忘记，否则会死循环</span><br>    <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid=<span class="hljs-built_in">sort</span>(a,L,R);<br>    <span class="hljs-built_in">QuickSort</span>(a,L,mid<span class="hljs-number">-1</span>);<span class="hljs-comment">//排序左区间</span><br>    <span class="hljs-built_in">QuickSort</span>(a,mid+<span class="hljs-number">1</span>,R);<span class="hljs-comment">//排序右区间</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> N;<br>    cin&gt;&gt;N;<br>    <span class="hljs-type">int</span> *a=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[N+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)<br>    cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">QuickSort</span>(a,<span class="hljs-number">1</span>,N);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)<br>    cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">delete</span> [] a;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="sort的基础用法"><a href="#sort的基础用法" class="headerlink" title="sort的基础用法"></a>sort的基础用法</h1><p>包含在头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">&lt;algorithm&gt;<br></code></pre></td></tr></table></figure><p>中<br><br>有三个参数</p><ul><li>第一个是要排序的数组的起始地址。</li><li>第二个是结束的地址（最后一位要排序的地址的下一地址）</li><li>第三个参数是排序的方法，可以是从大到小也可是从小到大，还可以不写第三个参数，此时默认的排序方法是从小到大排序。</li></ul><p> 第一种用法：直接比较<br><br> 第二种：传入一个返回值为布尔类型的比较函数，用来进行比较<br></p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>原理：前后两个元素进行比较<br><br>原理动图：</p><p><img src="/2019/09/26/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/bubbleSort.gif"></p><p>采用C++实现情况如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *x, <span class="hljs-type">int</span> *y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = *x;<br>    *x = *y;<br>    *y = t;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> *a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; a[i];<br>    <span class="hljs-comment">//最外面代表一共要进行n-1趟排序，第n趟时实际已经排好了</span><br>    <span class="hljs-comment">//j&lt;=n-i是因为每一趟排序最后都会累积一个排好的数，可见图</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n - i; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (a[j] &gt; a[j + <span class="hljs-number">1</span>])<br>                <span class="hljs-built_in">swap</span>(a[j], a[j+<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span>[] a;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解计算机系统学习记录1</title>
      <link href="/2019/09/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/"/>
      <url>/2019/09/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
      
        <content type="html"><![CDATA[<h1 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h1><p>学习《深入理解计算机系统》第二章，记录个人觉得重要的点</p><span id="more"></span><ol><li>二进制，十进制，16进制之间的转换<br><br>按四位一组划分二进制可转换为16进制<br><br>转换表：<br></li></ol><table><thead><tr><th>二进制</th><th>10进制</th><th>16进制</th></tr></thead><tbody><tr><td>0000</td><td>0</td><td>0</td></tr><tr><td>0001</td><td>1</td><td>1</td></tr><tr><td>0010</td><td>2</td><td>2</td></tr><tr><td>0011</td><td>3</td><td>3</td></tr><tr><td>0100</td><td>4</td><td>4</td></tr><tr><td>0101</td><td>5</td><td>5</td></tr><tr><td>0110</td><td>6</td><td>6</td></tr><tr><td>0111</td><td>7</td><td>7</td></tr><tr><td>1000</td><td>8</td><td>8</td></tr><tr><td>1001</td><td>9</td><td>9</td></tr><tr><td>1010</td><td>10</td><td>A</td></tr><tr><td>1011</td><td>11</td><td>B</td></tr><tr><td>1100</td><td>12</td><td>C</td></tr><tr><td>1101</td><td>13</td><td>D</td></tr><tr><td>1110</td><td>14</td><td>E</td></tr><tr><td>1111</td><td>15</td><td>F</td></tr></tbody></table><blockquote><p>十六进制数字0代表4个二进制0。所以，当n表示为i+4j的形式，其中0&lt;&#x3D;i&lt;&#x3D;3，我们可以把x写成开头的十六进制数字为<br>(i&#x3D;0)，2(i&#x3D;1)，4(i&#x3D;2)或者8(i&#x3D;3)，后面跟随着j个十六进制的0。比如，x&#x3D;2048&#x3D;2^11，我们有n&#x3D;11&#x3D;3+4*2，从而得到0x800</p></blockquote><ol start="2"><li><p>.C语言格式化输出<br><br>%d,%c,%x,%u,%f,%.2x</p></li><li><p>指针和数组<br><br>C语言中指针和数组可以互相表示<br></p></li><li><blockquote><p>C语言中字符串被编码成一个以null，值为0的字符结尾的字符数组。十进制数字x的ASCII码正好是0x3x，而终止字节的试卷进制为0x00.在使用ASCII码的任何系统上都将得到相同结果，与字节顺序和字大小无关，因此文本数据比二进制数据具有更强的平台独立性</p></blockquote></li><li><p>utf-8表示将每个字符编码成一个字节序列，java编程语言使用Unicode来表示字符串<br></p></li><li><p>逻辑运算和位运算<br><br>逻辑运算：与&amp;&amp;，或||，非！<br><br>位运算：&amp;，|，^<br><br>要分清区别:<br><br>按位运算只有在特殊情况下，也就是参数限制为0，1时才与其对应的逻辑运算有相同的行为，逻辑运算符&amp;&amp;，||与位级运算&amp;，|之间重要的区别就是如果对第一个参数求值就能确定表达式的结果，那么逻辑运算就不会对第二个参数求值<br></p></li><li><p>C语言中的移位运算<br></p></li><li><p>左移K位 &lt;&lt; k: 丢弃最高的k位，并在右端补k个0<br><br>右移k位 &gt;&gt; k:<br><br>有两种形式：逻辑右移和算术右移<br></p></li></ol><ul><li>逻辑右移，补0</li><li>算术右移，补最高有效位的值，即1</li></ul><p>而C语言对这点并没有明确规定<br><br>实际上所有的编译器&#x2F;机器组合都对有符号数使用算术右移，且许多程序员也都假设机器会使用这种右移，另一方面，对于无符号数，右移是必须的。与c相比，java对于如何进行右移有明确的定义，<strong>逻辑右移：x&gt;&gt;&gt;k，算术右移：x&gt;&gt;k</strong>  <br><br>9. C&#x2F;C++都支持有符号(默认)和无符号数，java只支持有符号数<br><br>10. 无符号编码，补码编码具有唯一性<br></p>]]></content>
      
      
      <categories>
          
          <category> 深入理解计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同时部署hexo到github和coding上</title>
      <link href="/2019/09/25/%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2hexo%E5%88%B0github%E5%92%8Ccoding%E4%B8%8A/"/>
      <url>/2019/09/25/%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2hexo%E5%88%B0github%E5%92%8Ccoding%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<p>同时部署hexo到github和coding上而不是一次只能布置一个，至于具体的对github，coding各自的布置方法请自行查找</p><span id="more"></span><p>采用以下方法：<br>修改hexo博客_config.xml：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">deploy:<br>  type: git<br>  repository: <br>    github: https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/3422878082/</span><span class="hljs-number">3422878082</span>.github.io.git<br>    coding: https:<span class="hljs-regexp">//</span>dev.tencent.com<span class="hljs-regexp">/u/</span>shanhainanhua<span class="hljs-regexp">/p/</span>shanhainanhua.coding.me.git<br>  branch: master<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo博客相关配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据关联分析</title>
      <link href="/2019/09/24/%E6%95%B0%E6%8D%AE%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/"/>
      <url>/2019/09/24/%E6%95%B0%E6%8D%AE%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>数据关联分析</p><span id="more"></span><p>今日学习了第三章和第四章<br><br>第三章数据可视化暂且不提<br></p><h1 id="第四章数据关联分析"><a href="#第四章数据关联分析" class="headerlink" title="第四章数据关联分析"></a>第四章数据关联分析</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>频繁模式和关联规则的广泛应用为数据分析的研究和机器学习的发展起到了极大的推动作用<br><br>频繁模式可以进一步描述成数据对象间的关联规则<br><br>判断序列模式是否频繁使用两个基本的度量：<br><br><strong>支持度</strong>：模式的有用性<br><br><strong>置信度</strong>：规则的确定性<br>频繁项集和关联规则<br><br><strong>项集</strong>：项的集合,<br>包含k个项的项集称为k项集，项集的出现频数是包含项集的事务数<br><br><strong>支持度</strong>：在所有的事务中同时出现某项的概率：<br><br>  support(A)&#x3D;${count(A \in T)} \over{|D|}$<br><br><br>频繁项集：出现次数到一定程度，大于最小支持度阈值<br><br>关联规则：A→B中A，B分别称为关联规则的前件，后件<br><br>在事务集D中，对某条关联规则而言，其支持度s表示在所有的事务中同时出现A和B的概率，<br>即P(AB),support(A&#x3D;&gt;B)&#x3D;${count(A \cup B)} \over {|D|}$<br><br>置信度：又称可信度，对A-&gt;B而言，置信度表示A出现同时B出现概率，即P(B|A)<br><br>confidence(A&#x3D;&gt;B)&#x3D;${support(A \cup B)} \over {support(A)}$<br><br><br>如果某个关联规则同时满足最小支持度阈值和最小置信度阈值，则认为这个关联规则是有趣的<br><br>如果同时满足&gt;&#x3D;,是强关联，否则是弱关联<br><img src="/2019/09/24/%E6%95%B0%E6%8D%AE%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/1.jpg"><br>Aprior算法：寻找所有支持度不小于min_sup的频繁项集<br><img src="/2019/09/24/%E6%95%B0%E6%8D%AE%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/2.jpg" alt="Aprior算法实例"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据挖掘及应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统第二章-进程</title>
      <link href="/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B/"/>
      <url>/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程的控制和描述"><a href="#进程的控制和描述" class="headerlink" title="进程的控制和描述"></a>进程的控制和描述</h1><p><img src="/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6.png" alt="总图"></p><h2 id="前驱图和程序执行"><a href="#前驱图和程序执行" class="headerlink" title="前驱图和程序执行"></a>前驱图和程序执行</h2><p><img src="/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B/%E5%89%8D%E9%A9%B1%E5%9B%BE%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C.png" alt="前驱图和程序执行"><br> <font color="#97FFF"> 有向无循环图 DAG</font></p><ul><li>用于描述进程之间执行的先后顺序</li><li>图中每个节点可以用来表示一个进程或程序段，乃至一条语句</li><li>节点的有向边表示两个节点之间存在的偏序关系，，用→表示</li><li>把没有前驱的结点称为初始结点，对应有终止结点</li><li>每个结点有一个重量，用于表示该结点所含有的程序量或程序的执行时间</li></ul><h2 id="进程描述"><a href="#进程描述" class="headerlink" title="进程描述"></a>进程描述</h2><p><img src="/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0.png" alt="进程描述"></p><h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><p><img src="/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB.png" alt="PCB"></p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p><img src="/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6.png" alt="进程控制"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统第一章-引论</title>
      <link href="/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"/>
      <url>/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA.jpg" alt="操作系统引论"><br><img src="/2019/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD.png" alt="操作系统主要功能"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown进阶</title>
      <link href="/2019/09/22/markdown%E8%BF%9B%E9%98%B6/"/>
      <url>/2019/09/22/markdown%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h1><p>Markdown颜色对应二进制表<br><img src="/2019/09/22/markdown%E8%BF%9B%E9%98%B6/rgb.png" alt="rgb颜色对应表"></p><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>Markdown公式手册<br><img src="/2019/09/22/markdown%E8%BF%9B%E9%98%B6/%E5%85%AC%E5%BC%8F.png" alt="公式"></p>]]></content>
      
      
      <categories>
          
          <category> 各种搭建配置坑的记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组习题纠错总结</title>
      <link href="/2019/09/22/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%BA%A0%E9%94%99%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/22/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%BA%A0%E9%94%99%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>例2.6 某机字长32位，浮点表示时，指数部分（即阶码）占8位（含一位符号位），尾数部分占24位（含一位符号位），问:</p></blockquote><ol><li>带符号定点小数的最大表示范围是多少？</li><li>带符号定点整数的最大表示范围是多少？</li><li>浮点表示时，最大正数是多少？</li><li>浮点表示时，最大负数是多少？</li><li>浮点表示时，最小的规格化正数是多少？</li></ol><p>分析：<br><br>采用补码表示时，可表示的数据范围最大。因此本题可用补码来求解。<br><br><font color="#FF7F24">带符号的定点小数通常就是浮点数。</font><br>浮点数据表示阶码占8位，尾数占24位，各包含一位符号位。此时阶码的表示范围为：-128 ～ 127；尾数的表示范围为：-1 ～ 1-$2 ^{– 23}$。<br><br>带符号的定点整数其符号位1位，其余位均用来表示数据。此时的表示范围为：-$2^{31}$ ～ $2^{31}$-1。<br><br>浮点表示时，最大正数为阶码最大，尾数最大的正数。最大负数为阶码最小，尾数最小的负数。<br>采用规格化数据表示时要注意尾数必须保证大于等于0.5，小于1。因此，浮点表示时，最小的规格化正数阶码最小，尾数最小为0.5。<br><br>解：<br><br>采用补码进行数据表示的范围最大。整数表示时符号位1位，数据位31位。浮点表示时，阶码占8位，尾数占24位，各包含一位符号位。因此：<br></p><ol><li>带符号定点小数的最大表示范围为：-1×$2^{127}$ ～ （1-$2^{-23}$）×$2^{127}$。</li><li>   带符号定点整数的最大表示范围为：-$2^{31}$ ～ $2^{31}$-1。</li><li>   浮点表示时，最大正数为：（1-$2^{-23}$）×$2^{127}$。</li><li>   浮点表示时，最大负数为：-$2^{-23}$×$2^{-128}$。</li><li>   浮点表示时，最小的规格化正数为：0.5×$2^{-128}$。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo next主题 markdown数学公式不正常显示问题</title>
      <link href="/2019/09/18/hexo-next%E4%B8%BB%E9%A2%98-markdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8D%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"/>
      <url>/2019/09/18/hexo-next%E4%B8%BB%E9%A2%98-markdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8D%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>近期写博客，遇到有些地方需要写数学公式，因为一直没用过所以初次使用遇到了问题。<br><br>使用markdown编写的公式在hexo博客中并不会正常显示出来。<br>网上查阅后发现原因如下：</p><blockquote><p>Hexo默认使用”hexo-renderer-marked”引擎渲染网页，该引擎会把一些特殊的markdown符号转换为相应的html标签，比如在markdown语法中，下划线’<em>‘代表斜体，会被渲染引擎处理为<em>标签。<br>因为类Latex格式书写的数学公式下划线 ‘</em>‘ 表示下标，有特殊的含义，如果被强制转换为<em>标签，那么MathJax引擎在渲染数学公式的时候就会出错。例如，$x_i$在开始被渲染的时候，处理为$x<em>i</em>$，这样MathJax引擎就认为该公式有语法错误，因为不会渲染。<br>类似的语义冲突的符号还包括’*’, ‘{‘, ‘}’, ‘&#39;等。<br><a href="https://www.jianshu.com/p/d87d7d2dcea9">https://www.jianshu.com/p/d87d7d2dcea9</a></p></blockquote><p>解决方法：</p><ol><li>首先需要安装Mathjax插件：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> hexo-<span class="hljs-keyword">math</span> --save<br></code></pre></td></tr></table></figure></li><li>接着更换Hexo的Markdown渲染引擎<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm uninstall hexo-renderer-marked <span class="hljs-comment">--save</span><br>npm install hexo-renderer-kramed <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure></li><li>之后进入博客根目录下的node_modules\kramed\lib\rules\inline.js<br>找到escape，将其后的内容改为：<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs r">escape<span class="hljs-operator">:</span> <span class="hljs-operator">/</span><span class="hljs-operator">^</span><span class="hljs-punctuation">\</span><span class="hljs-punctuation">\</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">[</span>`*\[\]()#$+\-.!_&gt;])/,<br></code></pre></td></tr></table></figure>  同理，修改em为：<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,<br></code></pre></td></tr></table></figure></li><li>最后进入主题下的_config.yml配置文件中，搜索math，我的在497行<br> 修改enable为true，如果不修改的话也行，那就是默认每个页面都需要渲染，而改为true之后在写文章时<br> 在文章头部加上 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mathjax:</span> <span class="hljs-literal">true</span> <br></code></pre></td></tr></table></figure> 这样可以调高访问速度</li></ol>]]></content>
      
      
      <categories>
          
          <category> 各种搭建配置坑的记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置环境 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载与反射</title>
      <link href="/2019/09/15/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
      <url>/2019/09/15/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><h2 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h2><p>java.lang.Class类封装一个对象和接口运行时的状态。<br><br>当加载类时Class类型的对象将自动创建，通过Class对象就可以访问JVM中类的所有信息。<br><br>Class类没有公共构造方法，其对象是JVM在加载类时通过类加载器中的defineClass（）方法自动构造的，因此不能显式地构造一个Class对象。<br><br>可以获取所有构造方法，方法，变量，内部类，外部类，对应类的修饰符，并且判断类型。<br><br>获取Class对象有三种方法:</p><ol><li>Class.forName(“所需类的全限定类名”)</li><li>调用某个类的class方法  Float.class</li><li>调用某个对象的getClass（）方法   a.getClass()</li></ol><h2 id="类加载步骤"><a href="#类加载步骤" class="headerlink" title="类加载步骤"></a>类加载步骤</h2><p>当程序主动使用某个类时，如果该类还未被加载到内存中，系统将通过加载，连接和初始化三个步骤对类进行初始化。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器负责将磁盘或者网络上的.class文件加载到内存中，并为之生成对应的java.lang.Class对象<br><br>类加载器负责加载所有的类,JVM启动时，会形成由三个类加载器组成的初始类加载器层次结构：</p><ul><li>Bootstrap ClassLoader：根类加载器，负责加载Java的核心类库</li><li>Extension ClassLoader：扩展类加载器，负责加载JRE的扩展目录中的jar包</li><li>System ClassLoader：系统类加载器，负责在JVM启动时加载来自Java命令的-classpath选项，java.class.path系统属性，或CLASSPATH环境变量所指定的jar包和类路径</li><li>用户也可以自定义加载器<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">根类加载器<br>    <span class="hljs-string">|</span><br>扩展类加载器<br>    <span class="hljs-string">|</span><br>系统类加载器<br>    <span class="hljs-string">| </span><br>用户类加载器<br></code></pre></td></tr></table></figure></li></ul><p><strong>tips：类加载机制：全盘负责，父类委托，缓存机制</strong></p><h2 id="ClassLoader类"><a href="#ClassLoader类" class="headerlink" title="ClassLoader类"></a>ClassLoader类</h2><p>java.lang.ClassLoader是一个抽象类，通过继承ClassLoader类来实现自定义的用户类加载器，重写方法<br>实现自定义的类加载器可以通过重写ClassLoader类的loadClass()或findClass（）方法来实现。推荐重写findClass()避免覆盖默认类加载器的父类委托，缓冲机制两种策略</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>java中有许多对象在运行时都会出现两种类型：编译时类型和运行时类型，<br><br>某些情况下程序会在运行时接收到外部传入的一个对象，该对象的编译时类型和运行时类型不同，<br>但程序需要调用该对象运行时类型的方法，在无法预知该对象属于哪些类的情况下，必须通过反射来发现该对象和类的真实信息。<br><br>反射机制允许程序在运行时借助Reflection API取得任何类的内部信息，并能直接操作对象的内部属性和方法。反射被视为动态语言的关键。<br><br>java反射机制主要提供了以下功能：</p><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时获取任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法</li><li>生成动态代理</li></ul><p>Reflection API提供了Constructor，Field和Method类，这三个类定义在java.lang.reflect包中，分别用于描述类的构造方法，属性和方法<br><br>java.lang.reflect包下的Executable抽象类，该对象代表可执行的类成员。<br>Executable抽象类派生了Constructor和Method两个子类。</p><p>Executable抽象类提供了大量方法来获取参数，修饰符或注解等信息<br><br>Executable方法列表</p><table><thead><tr><th>方法</th><th>功能描述</th></tr></thead><tbody><tr><td>Parameter[] getParameters()</td><td>获取所有形参，返回一个Parameter[]数组</td></tr><tr><td>int getParameterCount()</td><td>获取形参个数</td></tr><tr><td>abstract int getModifiers</td><td>获取修饰符，返回的整数是修饰符所对应的常量</td></tr><tr><td>boolean isVarArgs（）</td><td>判断是否包含数量可变的形参</td></tr></tbody></table><p>Constructor类用于表示类的构造方法，通过调用Class对象的getConstructor()方法可以获取当前类的构造方法的集合<br><br>Constructor类方法列表</p><table><thead><tr><th>方法</th><th>功能描述</th></tr></thead><tbody><tr><td>String getName()</td><td>返回构造方法的名称</td></tr><tr><td>Class[] getParameterTypes()</td><td>返回当前构造方法的参数类型</td></tr><tr><td>int  getModifiers()</td><td>返回修饰符的整型标识，返回的整数是修饰符public，protected，private，final，static，abstract等关键字所对应的常量，需要使用Modifier工具类的方法解码后才能获得真实的修饰符</td></tr></tbody></table><p>Method类用于封装方法的信息，调用Class对象的getMethods（）方法或getMethod（）可以获取当前类的所有方法或指定方法<br>Method类常用方法</p><table><thead><tr><th>方法</th><th>功能描述</th></tr></thead><tbody><tr><td>String getName（）</td><td>返回方法的名称</td></tr><tr><td>Class[] getParameterTypes（）</td><td>返回当前方法的参数类型</td></tr><tr><td>int getModifiers（）</td><td>返回修饰符的整型标识</td></tr><tr><td>Class getReturnType（）</td><td>返回当前方法的返回类型</td></tr></tbody></table><p>Field类用于封装属性的信息，调用Class对象的getFields（）或getField（）方法可以获得当前类的所有属性或指定属性。<br><br>Field类常用方法</p><table><thead><tr><th>方法</th><th>功能描述</th></tr></thead><tbody><tr><td>String getName（）</td><td>返回属性的名称</td></tr><tr><td>int getModifiers（）</td><td>返回修饰符的整型标识</td></tr><tr><td>getXxx（Object obj）</td><td>获取属性的值，此处的Xxx对应java中基本类型；如果属性是引用类型，则直接使用get（Object obj）</td></tr><tr><td>setXxx（Object obj，Xxx val）</td><td>设置属性值；set（Object obj，Object val）</td></tr><tr><td>Class []  getType（）</td><td>返回当前属性的类型</td></tr></tbody></table><p>Parameter类，每个Parameter对象代表方法的一个参数。Parameter类中提供了许多方法来获取参数信息。<br><br>Parameter类常用方法</p><table><thead><tr><th>方法</th><th>功能描述</th></tr></thead><tbody><tr><td>int getModifiers（）</td><td>获取参数的修饰符</td></tr><tr><td>String getName（）</td><td>获取参数的形参名</td></tr><tr><td>Type getParameterizedType（）</td><td>获取带泛型的形参类型</td></tr><tr><td>Class&lt;?&gt;getType（）</td><td>获取形参类型</td></tr><tr><td>boolean isVarArgs（）</td><td>判断该参数是否是可变参数</td></tr><tr><td>boolean isNamePresent（）</td><td>判断.class文件中是否包含方法的形参名信息</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 数据认知与预处理</title>
      <link href="/2019/09/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%AE%A4%E7%9F%A5%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/"/>
      <url>/2019/09/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%AE%A4%E7%9F%A5%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="属性的定义"><a href="#属性的定义" class="headerlink" title="属性的定义"></a>属性的定义</h2><p>是一个字段，表示数据对象的一个特征<br><br>属性的取值范围决定了属性的类型，通常可以分为两大类：</p><ul><li>定性描述：标称属性，布尔属性，序值属性</li><li>定量描述：数值属性</li></ul><h2 id="标称属性"><a href="#标称属性" class="headerlink" title="标称属性"></a>标称属性</h2><p>标称属性取值仅是一些不同的符号或事物的名称，每个值提供了足够的信息以区分对象<br>可以将这些值看成枚举的，如邮政编码，学生ID，头发颜色等</p><h2 id="二元属性"><a href="#二元属性" class="headerlink" title="二元属性"></a>二元属性</h2><p>是只有两个可选值的属性  </p><h2 id="序值属性"><a href="#序值属性" class="headerlink" title="序值属性"></a>序值属性</h2><ul><li>提供了足够的信息确定数据对象之间的序，但是值之间的差是未知的，例如产品的优，良，差</li><li>数值属性可以转换为序值属性——通过值域的离散化</li><li>序值属性可以定义众数，中位数，百分位数，但是不能定义均值</li></ul><h2 id="数值属性"><a href="#数值属性" class="headerlink" title="数值属性"></a>数值属性</h2><p>可度量，用整数或实数值来表示，定量地描述对象<br>一些文献中将数值属性又划分为区间标度或比率标度属性</p><h1 id="数据的统计描述方法"><a href="#数据的统计描述方法" class="headerlink" title="数据的统计描述方法"></a>数据的统计描述方法</h1><p>主要讨论两种基本统计描述：</p><ol><li>度量整个数据集合的中心趋势的方法：均值，中位数，众数，中列数</li><li>度量整个数据集的离散趋势的方法：极差，分位数，五数概括，方差，标准差</li></ol><h2 id="中心趋势度量"><a href="#中心趋势度量" class="headerlink" title="中心趋势度量"></a>中心趋势度量</h2><p>均值，众数，<br>中位数：<br><br>中列数：数据集最大值和最小值的平均值</p><h2 id="离散趋势度量"><a href="#离散趋势度量" class="headerlink" title="离散趋势度量"></a>离散趋势度量</h2><h3 id="极差（全距"><a href="#极差（全距" class="headerlink" title="极差（全距)"></a>极差（全距)</h3><p> 一组数据中的最大值和最小值之差</p><h3 id="k分位数（以四分位数为例）"><a href="#k分位数（以四分位数为例）" class="headerlink" title="k分位数（以四分位数为例）"></a>k分位数（以四分位数为例）</h3><p>将有序数据集分为4个间距相等的部分，这时产生三个数据点，称之为四分位数<br><br>假设12个数据：<br></p><ul><li>Q1（12+1）*0.25</li><li>Q2 （12+1）*0.5</li><li>Q3（12+1）*0.75</li><li>四分位距：IOR&#x3D;Q3-Q1</li><li>最小观测值：min&#x3D;Q1-1.5*IQR</li><li>最大观测值：max&#x3D;Q3+1.5*IQR</li></ul><p><strong>以上Q1,Q1,Q3计算结果均取整</strong></p><h3 id="五数概括与盒图"><a href="#五数概括与盒图" class="headerlink" title="五数概括与盒图"></a>五数概括与盒图</h3><p>为了完整地描述数据的分布情况，引入五数概括：中位数，四分位数（Q1和Q3），最大和最小观测值<br><br>一般按次序：min，Q1，中位数，Q3，max写出<br><br>通常使用盒图来直观地对五数进行可视化表示：</p><ol><li>盒的端点在四分位数上，下端点是Q1，上端点是Q3，盒的长度是IQR</li><li>中位数在盒内用横线进行标记</li><li>盒外用两条虚线分别延伸至最小和最大观测值，这两条虚线又称为胡须</li></ol><h1 id="数据对象关系的计算方法"><a href="#数据对象关系的计算方法" class="headerlink" title="数据对象关系的计算方法"></a>数据对象关系的计算方法</h1><h2 id="数据相似性计算方法"><a href="#数据相似性计算方法" class="headerlink" title="数据相似性计算方法"></a>数据相似性计算方法</h2><h3 id="标称属性相似性"><a href="#标称属性相似性" class="headerlink" title="标称属性相似性"></a>标称属性相似性</h3><p>假设标称属性的状态数目是M，p是刻画对象的属性总数，m是两个对象取值相同的属性数，则计算公式如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">d（i，j）<span class="hljs-operator">=</span>（p-m）/p<br></code></pre></td></tr></table></figure><h3 id="二元属性相似性"><a href="#二元属性相似性" class="headerlink" title="二元属性相似性"></a>二元属性相似性</h3><p>分为对称的和非对陈两种情况<br><br>假设：  q是对象i，j都取1的二元属性数；r是i&#x3D;1，j&#x3D;0；s是i&#x3D;0，j&#x3D;1；t是i&#x3D;j&#x3D;0<br>则对称的话： </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">d（i，j）=（<span class="hljs-built_in">r</span>+s）/（q+<span class="hljs-built_in">r</span>+s+t）<br></code></pre></td></tr></table></figure><p>如果非对陈且当属性值为1时权重最高，则t可忽略：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">d（i，j）=（<span class="hljs-built_in">r</span>+s）/（q+<span class="hljs-built_in">r</span>+s）<br></code></pre></td></tr></table></figure><h3 id="数值属性相似性"><a href="#数值属性相似性" class="headerlink" title="数值属性相似性"></a>数值属性相似性</h3><ul><li><p>欧式距离<br><img src="/2019/09/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%AE%A4%E7%9F%A5%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/os.jpeg" alt="欧式距离"></p></li><li><p>曼哈顿距离（街区距离）<br><img src="/2019/09/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%AE%A4%E7%9F%A5%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB.jpeg" alt="欧式距离"></p></li><li><p>切比雪夫距离（确界距离）<br><img src="/2019/09/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%AE%A4%E7%9F%A5%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB.jpeg" alt="欧式距离"></p></li><li><p>闵可夫斯基距离<br><img src="/2019/09/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%AE%A4%E7%9F%A5%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E8%B7%9D%E7%A6%BB.jpeg" alt="欧式距离"></p></li><li><p>标准化欧式距离<br><img src="/2019/09/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%AE%A4%E7%9F%A5%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/%E6%A0%87%E5%87%86%E5%8C%96%E6%AC%A7%E5%BC%8F%E8%B7%9D%E7%A6%BB.jpeg" alt="欧式距离"></p></li></ul><h3 id="序值属性相似性"><a href="#序值属性相似性" class="headerlink" title="序值属性相似性"></a>序值属性相似性</h3><p>将数值属性的值域划分为有限个类别，再离散化数值属性得到序值属性。<br><br>比如  苹果，梨，白菜，桃子<br><br> 对应的品级分别为·优 优，良，良<br><br>而值域类别为优 ，良，中，差。<br><br>假设f是用于描述n个对象的一组序值属性之一，关于f的邻近性计算步骤如下：<br></p><ol><li>第i个对象的f值为Xif，属性f有Mf个有序的状态，表示排位1，2，..Mf,<br>对应的排位rif{1，2,…Mf}取代Xif</li><li>用Zif代替第i个对象的rif来实现数据标准化<br></li></ol><p>  $Z_if$&#x3D;${r_if-1 \over M_f-1}$</p><p>苹果 &#x3D;优 ,$r_if$&#x3D;1 , $Z_if$&#x3D;${1-1 \over 4-1}$&#x3D;0  <br><br>白菜 $X_if$&#x3D;良，$r_if$&#x3D;2 , $Z_if$&#x3D;${2-1 \over 4-1}$</p><h3 id="Jaccard相似性"><a href="#Jaccard相似性" class="headerlink" title="Jaccard相似性"></a>Jaccard相似性</h3><p>通过获得两个对象的特征集合的交集的大小来获得集合之间的相似性。<br><br>两个集合A，B<br>sim（A，B）&#x3D;${A \cap B  \over  A \cup B}$</p><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><p>字符串A到B的编辑距离等于将字符串A变换为字符串B所需要的单字符插入及删除等操作的最小数目</p><h3 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h3><p>两个向量中值不相同分量的个数</p><h3 id="余弦相似度"><a href="#余弦相似度" class="headerlink" title="余弦相似度"></a>余弦相似度</h3><p>sim（A，B）&#x3D;${AB \over ||A||X||B| |}$</p><h2 id="数据相关性计算方法"><a href="#数据相关性计算方法" class="headerlink" title="数据相关性计算方法"></a>数据相关性计算方法</h2><h3 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h3><p>一组数据的期望值E(X)即为数据的均值<br><br>期望值分别为E(X)&#x3D;u,E(Y)&#x3D;v的两个实数随机变量X与Y之间的协方差定义为：<br><br>cov(x,y)&#x3D;E((X-u)(Y-v))<br>            &#x3D;E(XY)-uv<br><br>E(XY)等于x，y对应位置数据相乘之和&#x2F;一组数据的数据个数</p><h1 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h1><p>数据收集——数据预处理——数据挖掘——数据应用<br><br>数据预处理包括：数据清洗与集成，数据归纳，数据转换<br></p><h2 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h2><p>分箱法：</p><pre><code class="hljs">• 等深分箱 ：数据从小到大排序，等分为k部分• 等宽分箱 ：变量的取值范围分为k个等宽区间，每个区间当做一个分箱• 平滑技术：箱均值平滑，箱中位数平滑，箱边界平滑（箱中所有值用最近的边界值替换）</code></pre><h2 id="数据归纳"><a href="#数据归纳" class="headerlink" title="数据归纳"></a>数据归纳</h2><p>得到数据集的一个简化版本  放回的随机抽样，不放回的随机抽样，分层抽样</p><h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><p>数据规范化：</p><ol><li>最小—最大规范化</li><li>z分数规范化</li></ol><p><img src="/2019/09/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%AE%A4%E7%9F%A5%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/%E8%A7%84%E8%8C%83%E5%8C%96.jpeg" alt="数据规范化"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据挖掘及应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章</title>
      <link href="/2019/09/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2019/09/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="真值和机器数"><a href="#真值和机器数" class="headerlink" title="真值和机器数"></a>真值和机器数</h2><p><strong>真值</strong>：正负符号加二进制绝对值<br><br><strong>机器数</strong>:正负号分别用0和1来代替，一般放在最高位<br><br><strong>数的机器码表示：在远离小数点的位置补0</strong></p><h2 id="原码表示法"><a href="#原码表示法" class="headerlink" title="原码表示法"></a>原码表示法</h2><ul><li><p>纯小数时</p><ul><li>正数：本身数值</li><li>负数：本身数值加上符号位 0为正，1为负</li></ul></li><li><p>纯整数时</p><ul><li>正数：本身数值</li><li>负数：本身数值加上2的n-1次方（n为字长）</li></ul></li></ul><h2 id="补码表示法"><a href="#补码表示法" class="headerlink" title="补码表示法"></a>补码表示法</h2><p>补码中1.0000000表示负1，补码的零只有一个<br><br>对于n位数来说，其模的大小为n位数全为1后再在最末位加1<br><br>如果某一数有n位整数（包括符号位），则它的模为2^n<br><br>如果是n位小数，它的模总是是2</p><ul><li>纯小数时<ul><li>正数：本身数值</li><li>负数：2-本身数值</li></ul></li><li>纯整数时：<ul><li>正数：本身数值</li><li>负数：2^n-本身数值</li></ul></li></ul><h2 id="反码表示法"><a href="#反码表示法" class="headerlink" title="反码表示法"></a>反码表示法</h2><ul><li>正数：本身数值</li><li>负数：本身数值按位取反</li><li>+0反码：00000000</li><li>-0反码：11111111</li></ul><h2 id="移码表示法"><a href="#移码表示法" class="headerlink" title="移码表示法"></a>移码表示法</h2><p>将补码符号位求反<br></p><h2 id="数的定点表示"><a href="#数的定点表示" class="headerlink" title="数的定点表示"></a>数的定点表示</h2><p><strong>定点小数：用于尾数（表示数值）</strong><br><strong>定点整数：用于阶码（表示指数）</strong></p><h2 id="数的浮点表示法"><a href="#数的浮点表示法" class="headerlink" title="数的浮点表示法"></a>数的浮点表示法</h2><h3 id="浮点数的表示格式"><a href="#浮点数的表示格式" class="headerlink" title="浮点数的表示格式"></a>浮点数的表示格式</h3><ul><li>阶码+尾数：其中阶码是定点整数，用补码表示；尾数是定点小数，用补码显示</li><li>尾数符+阶码+尾数值：其中阶码是定点整数，用移码表示；尾数值是定点小数，用补码表示</li></ul><h3 id="浮点数的规格化"><a href="#浮点数的规格化" class="headerlink" title="浮点数的规格化"></a>浮点数的规格化</h3><p>可以提高数据的精度，—–&gt;提高精度可以有两种方法</p><ol><li>尾数位数增加</li><li>尾数规格化<br><br>所谓规格化就是调整阶码使其尾数满足如下形式：</li></ol><ul><li>原码规格化后：正数为0.1开头，负数为1.1开头</li><li>补码规格化后：正数为0.1开头，负数为1.0开头</li></ul><h3 id="浮点数规格化习题示例"><a href="#浮点数规格化习题示例" class="headerlink" title="浮点数规格化习题示例"></a>浮点数规格化习题示例</h3><p>某机器用32位表示一个数，阶码部分占8位（含一个符号位），尾数部分占24位（含一个符号位）<br>设x1&#x3D;-256.5，x2&#x3D;127&#x2F;256，试写出x1和x2的两种浮点数表示格式：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dns">首先分析x1<br>x1真值为-<span class="hljs-number">256</span>.<span class="hljs-number">5</span><br>写成原码就是二进制真值就是-（<span class="hljs-number">100000000.1</span>）<br>因为规格化后要满足：正数为<span class="hljs-number">0</span>.<span class="hljs-number">1</span>开头，负数为<span class="hljs-number">1</span>.<span class="hljs-number">0</span>开头<br>所以可以写成-<span class="hljs-number">2</span>^<span class="hljs-number">9</span>*<span class="hljs-number">0</span>.<span class="hljs-number">1000000001</span>，也就是<span class="hljs-number">2</span>^<span class="hljs-number">9</span>*<span class="hljs-number">1</span>.<span class="hljs-number">1000000001</span>(接下来取补码后成为<span class="hljs-number">1</span>.<span class="hljs-number">0</span>开头）<br>先计算阶码：<br>阶码的原码为<span class="hljs-number">9</span><br>所以阶码的补码为：<span class="hljs-number">1001</span>，占<span class="hljs-number">8</span>位，所以在远离小数点的地方补<span class="hljs-number">0</span>，最后可得<span class="hljs-number">00001001</span><br>移码为补码的符号位取反，所以移码为<span class="hljs-number">10001001</span><br>接着计算尾数：<br>尾数的补码为：<span class="hljs-number">1</span>.<span class="hljs-number">01111111110000000000000</span><br>接着组合写成格式即可<br><br>再来分析x2<br>x<span class="hljs-number">2=127/256</span>可以写成<span class="hljs-number">1111111*2</span>^(-<span class="hljs-number">8</span>)=<span class="hljs-number">0.1111111*2</span>^(-<span class="hljs-number">1</span>)<br>阶码的补码为：-<span class="hljs-number">1</span>的补码=<span class="hljs-number">11111111</span><br>阶码的移码为：<span class="hljs-number">01111111</span><br>尾数为：<span class="hljs-number">0</span>.<span class="hljs-number">11111110000000000000000</span><br>组合即可<br></code></pre></td></tr></table></figure><h3 id="浮点数的表示范围（设阶码和尾数均为n位）"><a href="#浮点数的表示范围（设阶码和尾数均为n位）" class="headerlink" title="浮点数的表示范围（设阶码和尾数均为n位）"></a>浮点数的表示范围（设阶码和尾数均为n位）</h3><ol><li>阶码表示范围</li></ol><table><thead><tr><th>————</th><th>最小负数</th><th>最大负数</th><th>最小正数</th><th>最大正数</th></tr></thead><tbody><tr><td>二进制补码</td><td>100…0(共n位，最小则全为0）</td><td>111…1(共n位，首位的1代表负，最大则剩下的全补1)</td><td>000…1(共n位，第一位0为符号位)</td><td>011…1(共n位，第一位0为符号位)</td></tr><tr><td>十进制真值</td><td>计算可得</td><td>计算可得</td><td>计算可得</td><td>计算可得</td></tr><tr><td>2. 规格化尾数表示范围（补码规格化后正数为0.1…形式，负数为1.0…形式）</td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>—————</th><th>最小负数</th><th>最大负数</th><th>最小正数</th><th>最大正数</th></tr></thead><tbody><tr><td>二进制补码</td><td>1.0….0</td><td>1.011..1</td><td>0.10…0</td><td>0.11…1</td></tr><tr><td>十进制真值</td><td>计算可得</td><td>计算可得</td><td>计算可得</td><td>计算可得</td></tr><tr><td>3. 规格化浮点数表示范围</td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>最小负数</th><th>最大负数</th><th>最小正数</th><th>最大正数</th></tr></thead><tbody><tr><td>尾数负最小*2^(正阶码最大)</td><td>尾数负最大*2^(负阶码最小)</td><td>尾数正最小*2^(负阶码最小)</td><td>尾数正最大*2^(正阶码最大)</td></tr></tbody></table><h2 id="非数值数据的表示"><a href="#非数值数据的表示" class="headerlink" title="非数值数据的表示"></a>非数值数据的表示</h2><h3 id="字符表示"><a href="#字符表示" class="headerlink" title="字符表示"></a>字符表示</h3><p>ASCII码（美国信息交换标准码）：<br>共有128个字符，即2^7，因此占据7位，最高位为0，而汉字编码最高位为1<br>所以可以根据最高位来区分是否为汉字编码</p><h3 id="汉字的表示"><a href="#汉字的表示" class="headerlink" title="汉字的表示"></a>汉字的表示</h3><p>区位码(不唯一)→十进制区位码→十六进制+2020H→国标码十六进制+8080H→机内码(唯一)<br>一个汉字用两个字节表示区内码<br><br><img src="/2019/09/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0/hz.png"></p><h2 id="定点加减法运算"><a href="#定点加减法运算" class="headerlink" title="定点加减法运算"></a>定点加减法运算</h2><p>在计算机中，常将数值转化为补码后再进行加减运算，优点是可以将减法运算转化为加法运算<br></p><h3 id="加减法运算规则："><a href="#加减法运算规则：" class="headerlink" title="加减法运算规则："></a>加减法运算规则：</h3><ol><li>补码运算</li><li>数值位和符号位一同参与运算</li><li>求差时，将减数求补，用求和代替求差</li><li>运算结果为补码，符号位0表示正数，符号位1表示负数</li><li>符号位的进位为模值，应该丢掉</li></ol><h3 id="加法运算："><a href="#加法运算：" class="headerlink" title="加法运算："></a>加法运算：</h3><p> [X]补+[Y]补&#x3D;[X+Y]补</p><h3 id="减法运算"><a href="#减法运算" class="headerlink" title="减法运算"></a>减法运算</h3><p>[X]补-[Y]补&#x3D;[X+(-Y)]补&#x3D;[X]补+[-Y]补<br>因为[-Y]补+[Y]补&#x3D;[0]补&#x3D;0<br>所以[-Y]补&#x3D;-[Y]补<br>所以只要能通过[Y]补求得[-Y]补，就可以将补码减法运算化为补码加法运算<br>已知[Y]补，求[-Y]补的法则是：<br>对[Y]补各位(包括符号位)求反，然后在末位加上1<br>例如：[Y]补&#x3D;1.1010 ，则[-Y]补&#x3D;0.0110</p><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p>求负数的补码：把它的原码自低位向高位看去，遇到的第一个’1’及其右边的’0’都不变，将左边的所有位按位取反，符号位不变。</p><h3 id="溢出判断法："><a href="#溢出判断法：" class="headerlink" title="溢出判断法："></a>溢出判断法：</h3><p>在运算结果超出机器所能表示的数值范围后，就会产生溢出。<br><br>溢出有两种判断的方法：双符号法和进位判断法<br></p><h4 id="双符号法："><a href="#双符号法：" class="headerlink" title="双符号法："></a>双符号法：</h4><p>也叫做变形补码法，模4补码法<br><br>采用的方法是用两个相同的符号位表示一个数的符号，左边第一位为第一符号位，第二位为第二符号位<br><br>第一符号位始终表示真正的符号，如果计算结果超出模值，则丢掉<br></p><table><thead><tr><th>符号</th><th>表示</th></tr></thead><tbody><tr><td>00</td><td>正数</td></tr><tr><td>01</td><td>正溢出</td></tr><tr><td>10</td><td>负溢出</td></tr><tr><td>11</td><td>负数</td></tr></tbody></table><h4 id="进位判断法："><a href="#进位判断法：" class="headerlink" title="进位判断法："></a>进位判断法：</h4><p>当两个单符号位的补码进行加减运算时，若最高数值位向符号位的进位值C与符号位产生的进位输出值S相同则没有溢出发生，否则，有溢出发生<br><br>用异或的方式进行判断</p><h2 id="基本的二进制加，减法器"><a href="#基本的二进制加，减法器" class="headerlink" title="基本的二进制加，减法器"></a>基本的二进制加，减法器</h2><p><img src="/2019/09/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%8A%A0%E5%87%8F%E6%B3%95%E5%99%A8.png" alt="基本的加减法器"></p><ol><li><p>加法的实现<br><br><img src="/2019/09/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%AE%9E%E7%8E%B0.png" alt="实现的图片"></p><ol><li>p&#x3D;0</li><li>设$Y_{n-1}$&#x3D;0，异或门输出为0；设$Y_{n-1}$为1，异或门输出为1。</li><li>总结：异或门输出&#x3D;$Y_{n-1}$</li><li>加法：[X]补+[Y]补&#x3D;[X+Y]补</li></ol></li><li><p>减法的实现<br><br><img src="/2019/09/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%AE%9E%E7%8E%B0.png" alt="实现的图片"></p><ol><li>p&#x3D;1</li><li>设$Y_{n-1}$&#x3D;0，异或门输出为1；反之为0；</li><li>总结：异或门输出&#x3D;$Y_{n-1}$取反</li><li>减法实现：[X]补-[Y]补&#x3D;[X]补+[Y]补取反+$2 ^{-n}$  (n是小数点之后的位数，+$2 ^{-n}$的意思是在末尾+1)</li><li>末尾的加1来源于一开始的Cn，Cn&#x3D;p&#x3D;1 （设计巧妙）</li></ol></li></ol><h2 id="定点乘法运算"><a href="#定点乘法运算" class="headerlink" title="定点乘法运算"></a>定点乘法运算</h2><h3 id="原码一位乘法"><a href="#原码一位乘法" class="headerlink" title="原码一位乘法"></a>原码一位乘法</h3><h4 id="乘法的本质："><a href="#乘法的本质：" class="headerlink" title="乘法的本质："></a>乘法的本质：</h4><p>将乘法变成加法和右移运算的结果</p><h4 id="运算法则："><a href="#运算法则：" class="headerlink" title="运算法则："></a>运算法则：</h4><ol><li>被乘数和乘数均取绝对值参加运算，符号位单独考虑</li><li>被乘数取双符号位，部分积的长度与被乘数的长度相同，初值为0</li><li>从乘数的最低位的$y_n$位开始对乘数进行判断：若$y_n$&#x3D;1，则部分积加上被乘数|X|，然后右移一位；若$y_n$&#x3D;0，则部分积加上0，然后右移一位</li><li>重复3的判断n次</li></ol><h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><p><img src="/%E7%AC%AC%E4%BA%8C%E7%AB%A0%5C%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95.jpg" alt="原码一位乘法"></p><p>之后符号位就是x，y的符号位进行异或运算为0，数值位就是|X|.|Y|&#x3D;0.10001111<br>所以最后结果为0.10001111</p><h3 id="补码一位乘法"><a href="#补码一位乘法" class="headerlink" title="补码一位乘法"></a>补码一位乘法</h3><h4 id="运算规则："><a href="#运算规则：" class="headerlink" title="运算规则："></a>运算规则：</h4><ol><li>符号位参与运算，运算的数均以补码表示</li><li>被乘数一般取双符号位参与运算，部分积初始值为0</li><li>看乘数小数点位数决定移多少次</li><li>乘数末位增设附加位$y_{n+1}$，且初值为0</li><li>按下表进行操作</li></ol><table><thead><tr><th>$y_n$(高位)</th><th>$y_{n+1}$(低位)</th><th>操作</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>部分积右移一位</td></tr><tr><td>0</td><td>1</td><td>部分积加[x]补，右移一位</td></tr><tr><td>1</td><td>0</td><td>部分积加[-x]补，右移一位</td></tr><tr><td>1</td><td>1</td><td>部分积右移一位</td></tr></tbody></table><h4 id="例题：-1"><a href="#例题：-1" class="headerlink" title="例题："></a>例题：</h4><p><img src="/%E7%AC%AC%E4%BA%8C%E7%AB%A0%5C%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95.jpg" alt="补码一位乘法"></p><h3 id="补码两位乘法"><a href="#补码两位乘法" class="headerlink" title="补码两位乘法"></a>补码两位乘法</h3><p>减少运算步骤，提高运算速度<br><br>运算规则如下：<br><br>符号位参与运算，两数均以补码表示<br><br>部分积与被乘数均采用<strong>3位符号</strong>表示，乘数<strong>末位增加一位</strong>$y_{n+1}$，其初值为0<br></p><table><thead><tr><th>$Y_{n-1}$</th><th>$Y_n$</th><th>$Y_{n+1}$</th><th>操作</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>加0，右移两位</td></tr><tr><td>0</td><td>0</td><td>1</td><td>加[x]补，右移两位</td></tr><tr><td>0</td><td>1</td><td>0</td><td>加[x]补，右移两位</td></tr><tr><td>0</td><td>1</td><td>1</td><td>加2[x]补，右移两位</td></tr><tr><td>1</td><td>0</td><td>0</td><td>加2[-x]补，右移两位</td></tr><tr><td>1</td><td>0</td><td>1</td><td>加[-x]补，右移两位</td></tr><tr><td>1</td><td>1</td><td>0</td><td>加[-x]补，右移两位</td></tr><tr><td>1</td><td>1</td><td>1</td><td>加0，右移两位</td></tr></tbody></table><p>总结：<br><br>$Y_{n-1}$为0，代表正，即“+”，之后看1的个数决定加几个[x]补<br><br>$Y_{n-1}$为1，代表负，即“-”，之后看0的个数决定加几个[-x]补<br><br>若尾数n为偶数，则乘数用两位符号，最后一步不移位；<br><br>若尾数n为奇数，则乘数用一位符号，最后一步移一位<br><br>示例：<br>第一题：<br><img src="/%E7%AC%AC%E4%BA%8C%E7%AB%A0%5C%E8%A1%A5%E7%A0%81%E4%B8%A4%E4%BD%8D%E4%B9%98%E6%B3%951.jpg" alt="第二章\补码两位乘法1.jpg"><br>第二题：<br><img src="/%E7%AC%AC%E4%BA%8C%E7%AB%A0%5C%E8%A1%A5%E7%A0%81%E4%B8%A4%E4%BD%8D%E4%B9%98%E6%B3%952.jpg" alt="第二章\补码两位乘法2.jpg"></p><h2 id="定点除法运算"><a href="#定点除法运算" class="headerlink" title="定点除法运算"></a>定点除法运算</h2><h3 id="补码一位除法"><a href="#补码一位除法" class="headerlink" title="补码一位除法"></a>补码一位除法</h3><p>本质：加法和左移<br><br>三个规则：</p><ul><li>比较上商规则：比较被除数与除数符号，余数和除数符号</li><li>商的校正规则</li><li>余数校正规则<br>补码不恢复余数法的算法规则；</li></ul><ol><li>符号位参加运算，除数与被除数均用双符号位补码表示</li><li>当被除数与除数同号时，用被除数减去除数；被除数与除数异号时，用被除数加上除数；商符号位的取值见3</li><li>当余数与除数同号时，商上1，余数左移一位减去除数；余数与除数异号时，商上0，余数左移一位加上除数</li><li>余数左移加上或减去除数后就得到了新余数</li><li>采用校正法包括符号位在内，规则3应重复n+1次</li></ol><p>商的校正原则：</p><ol><li>当刚好能除尽(即运算过程中任一步余数为0)时，</li></ol><ul><li>若除数为正，则商不必校正；</li><li>若除数为负，则商需要校正，即加$2^{-n}$进行修正</li></ul><ol start="2"><li>当不能除尽时，</li></ol><ul><li>若商为正，则不必校正；</li><li>若商为负，则商需要加$2^{-n}$校正</li></ul><p>余数之所以要校正，是因为在补码不恢复余数除法运算过程中先比较后上商的缘故<br><br>余数的校正方法：</p><ul><li>若商为正，则当余数与被除数异号时，应将余数加上除数进行校正才能获得正确的余数</li><li>若商为负，则当余数与被除数异号时，余数需要减去除数进行校正</li></ul><p>商校正，能除尽，看除数；不能除尽，看商，正的不必校正<br>余数校正，看被除数，同号不校正；异号看商，正加，负减除数<br>思维导图示例：<br><img src="/%E7%AC%AC%E4%BA%8C%E7%AB%A0%5C%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E9%99%A4%E6%B3%95%E6%A0%A1%E6%AD%A3.png" alt="补码一位除法思维导图"><br>习题示例：<br><img src="/%E7%AC%AC%E4%BA%8C%E7%AB%A0%5C%E8%A1%A5%E7%A0%81%E9%99%A4%E6%B3%95.jpg" alt="补码除法习题"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10下安装Linux子系统</title>
      <link href="/2019/09/08/Win10%E4%B8%8B%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/09/08/Win10%E4%B8%8B%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步-打开更新和安全选项"><a href="#第一步-打开更新和安全选项" class="headerlink" title="第一步 打开更新和安全选项"></a>第一步 打开更新和安全选项</h2><p><img src="/2019/09/08/Win10%E4%B8%8B%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/step1.png" alt="step1"></p><h2 id="第二步-开启开发人员模式"><a href="#第二步-开启开发人员模式" class="headerlink" title="第二步 开启开发人员模式"></a>第二步 开启开发人员模式</h2><p><img src="/2019/09/08/Win10%E4%B8%8B%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/step2.png" alt="step2"></p><h2 id="第三步-打开应用与功能选项，找到相关设置"><a href="#第三步-打开应用与功能选项，找到相关设置" class="headerlink" title="第三步  打开应用与功能选项，找到相关设置"></a>第三步  打开应用与功能选项，找到相关设置</h2><p><img src="/2019/09/08/Win10%E4%B8%8B%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/step3.png" alt="step3"></p><h2 id="第四步-启动或关闭Windows功能"><a href="#第四步-启动或关闭Windows功能" class="headerlink" title="第四步 启动或关闭Windows功能"></a>第四步 启动或关闭Windows功能</h2><p><img src="/2019/09/08/Win10%E4%B8%8B%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/step4.png" alt="step4"></p><h2 id="第五步-勾选适用于Linux的Windows子系统"><a href="#第五步-勾选适用于Linux的Windows子系统" class="headerlink" title="第五步  勾选适用于Linux的Windows子系统"></a>第五步  勾选适用于Linux的Windows子系统</h2><p><img src="/2019/09/08/Win10%E4%B8%8B%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/step5.png" alt="step5"></p><h2 id="第六步-按提示重启电脑-之后打开Windows商店"><a href="#第六步-按提示重启电脑-之后打开Windows商店" class="headerlink" title="第六步  按提示重启电脑,之后打开Windows商店"></a>第六步  按提示重启电脑,之后打开Windows商店</h2><p><img src="/2019/09/08/Win10%E4%B8%8B%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/step6-2.png" alt="step6"></p><h2 id="第七步-搜索，安装-启动"><a href="#第七步-搜索，安装-启动" class="headerlink" title="第七步 搜索，安装,启动"></a>第七步 搜索，安装,启动</h2><p><img src="/2019/09/08/Win10%E4%B8%8B%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/step.png" alt="step7"></p><h2 id="第七步-启动后设置用户名，密码"><a href="#第七步-启动后设置用户名，密码" class="headerlink" title="第七步 启动后设置用户名，密码"></a>第七步 启动后设置用户名，密码</h2><p><img src="/2019/09/08/Win10%E4%B8%8B%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/step7.png" alt="step7"></p>]]></content>
      
      
      <categories>
          
          <category> 各种搭建配置坑的记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用gulp优化hexo</title>
      <link href="/2019/09/08/%E4%BD%BF%E7%94%A8gulp%E4%BC%98%E5%8C%96hexo/"/>
      <url>/2019/09/08/%E4%BD%BF%E7%94%A8gulp%E4%BC%98%E5%8C%96hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法:"></a>主要方法:<br></h1><p>参考这位博主的文章：<br><br><a href="https://segmentfault.com/a/1190000019842178">Hexo博客使用gulp压缩静态资源</a><br><br>以下插件如果安装过慢参考：<br><br><a href="https://www.cnblogs.com/sddai/p/9388261.html">https://www.cnblogs.com/sddai/p/9388261.html</a></p><h2 id="1、全局安装gulp"><a href="#1、全局安装gulp" class="headerlink" title="1、全局安装gulp"></a>1、全局安装gulp</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> gulp -g<br><span class="hljs-comment"># 查看版本</span><br>gulp -v<br></code></pre></td></tr></table></figure><h2 id="2、安装gulp插件"><a href="#2、安装gulp插件" class="headerlink" title="2、安装gulp插件"></a>2、安装gulp插件</h2><p>在hexo根目录下安装</p><ul><li><p>npm install gulp –save</p></li><li><p>npm install gulp-minify-css –save</p></li><li><p>npm install gulp-uglify –save</p></li><li><p>npm install gulp-htmlmin –save</p></li><li><p>npm install gulp-htmlclean –save</p></li><li><p>npm install gulp-imagemin –save</p><br>*解决【Gulp打包问题】 GulpUglifyError: unable to minify JavaScript*<br>*解决 gulp-uglify 压缩JavaScript 不兼容 es5 语法的问题*<br></li><li><p>npm install <a href="mailto:&#x62;&#97;&#98;&#101;&#108;&#x2d;&#99;&#x6f;&#114;&#x65;&#x40;&#x36;&#x2e;&#x32;&#x36;&#x2e;&#51;">&#x62;&#97;&#98;&#101;&#108;&#x2d;&#99;&#x6f;&#114;&#x65;&#x40;&#x36;&#x2e;&#x32;&#x36;&#x2e;&#51;</a> –save</p></li><li><p>npm install <a href="mailto:&#103;&#x75;&#108;&#112;&#45;&#98;&#x61;&#x62;&#x65;&#x6c;&#x40;&#55;&#x2e;&#x30;&#46;&#x31;">&#103;&#x75;&#108;&#112;&#45;&#98;&#x61;&#x62;&#x65;&#x6c;&#x40;&#55;&#x2e;&#x30;&#46;&#x31;</a> –save</p></li><li><p>npm install <a href="mailto:&#x62;&#97;&#x62;&#x65;&#108;&#45;&#x70;&#114;&#x65;&#x73;&#x65;&#x74;&#x2d;&#101;&#115;&#x32;&#48;&#49;&#53;&#64;&#x36;&#46;&#x32;&#52;&#46;&#49;">&#x62;&#97;&#x62;&#x65;&#108;&#45;&#x70;&#114;&#x65;&#x73;&#x65;&#x74;&#x2d;&#101;&#115;&#x32;&#48;&#49;&#53;&#64;&#x36;&#46;&#x32;&#52;&#46;&#49;</a> –save<br><br><em>gulp-babel 取消严格模式方法(“use strict”)</em></p></li><li><p>npm install babel-plugin-transform-remove-strict-mode –save</p><p>  问题：如果安装gulp-imagemin错误请执行以下语句<br>  sudo npm i gulp-imagemin –unsafe-perms</p></li></ul><h2 id="3、创建gulpfile-js文件"><a href="#3、创建gulpfile-js文件" class="headerlink" title="3、创建gulpfile.js文件"></a>3、创建gulpfile.js文件</h2><p>在 Hexo 站点下新建gulpfile.js文件，文件内容如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs awk">var gulp = require(<span class="hljs-string">&#x27;gulp&#x27;</span>);<br>var minifycss = require(<span class="hljs-string">&#x27;gulp-minify-css&#x27;</span>);<br>var uglify = require(<span class="hljs-string">&#x27;gulp-uglify&#x27;</span>);<br>var htmlmin = require(<span class="hljs-string">&#x27;gulp-htmlmin&#x27;</span>);<br>var htmlclean = require(<span class="hljs-string">&#x27;gulp-htmlclean&#x27;</span>);<br>var imagemin = require(<span class="hljs-string">&#x27;gulp-imagemin&#x27;</span>);<br>var babel = require(<span class="hljs-string">&#x27;gulp-babel&#x27;</span>);<br><br><span class="hljs-regexp">//</span> 压缩css文件<br>gulp.task(<span class="hljs-string">&#x27;minify-css&#x27;</span>, <span class="hljs-keyword">function</span> (done) &#123;<br>    return gulp.src(<span class="hljs-string">&#x27;./public/**/*.css&#x27;</span>)<br>        .pipe(minifycss())<br>        .pipe(gulp.dest(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>    done();<br>&#125;);<br><br><span class="hljs-regexp">//</span> 压缩html文件<br>gulp.task(<span class="hljs-string">&#x27;minify-html&#x27;</span>, <span class="hljs-keyword">function</span> (done) &#123;<br>    return gulp.src(<span class="hljs-string">&#x27;./public/**/*.html&#x27;</span>)<br>        .pipe(htmlclean())<br>        .pipe(htmlmin(&#123;<br>            removeComments: true,<br>            minifyJS: true,<br>            minifyCSS: true,<br>            minifyURLs: true,<br>        &#125;))<br>        .pipe(gulp.dest(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>    done();<br>&#125;);<br><br><span class="hljs-regexp">//</span> 压缩js文件<br>gulp.task(<span class="hljs-string">&#x27;minify-js&#x27;</span>, <span class="hljs-keyword">function</span> (done) &#123;<br>    return gulp.src([<span class="hljs-string">&#x27;./public/**/*.js&#x27;</span>, <span class="hljs-string">&#x27;!./public/**/*.min.js&#x27;</span>])<br>        .pipe(babel(&#123;<br>            <span class="hljs-regexp">//</span>将ES6代码转译为可执行的JS代码<br>            presets: [<span class="hljs-string">&#x27;es2015&#x27;</span>] <span class="hljs-regexp">//</span> es5检查机制<br>        &#125;))<br>        .pipe(uglify())<br>        .pipe(gulp.dest(<span class="hljs-string">&#x27;./public&#x27;</span>));<br>    done();<br>&#125;);<br><br><span class="hljs-regexp">//</span> 压缩 public/images 目录内图片(Version&lt;<span class="hljs-number">3</span>)<br><span class="hljs-regexp">//</span> gulp.task(<span class="hljs-string">&#x27;minify-images&#x27;</span>, <span class="hljs-keyword">function</span> () &#123;<br><span class="hljs-regexp">//</span>     gulp.src(<span class="hljs-string">&#x27;./public/images/**/*.*&#x27;</span>)<br><span class="hljs-regexp">//</span>         .pipe(imagemin(&#123;<br><span class="hljs-regexp">//</span>             optimizationLevel: <span class="hljs-number">5</span>, <span class="hljs-regexp">//</span>类型：Number  默认：<span class="hljs-number">3</span>  取值范围：<span class="hljs-number">0</span>-<span class="hljs-number">7</span>（优化等级）<br><span class="hljs-regexp">//</span>             progressive: true, <span class="hljs-regexp">//</span>类型：Boolean 默认：false 无损压缩jpg图片<br><span class="hljs-regexp">//</span>             interlaced: false, <span class="hljs-regexp">//</span>类型：Boolean 默认：false 隔行扫描gif进行渲染<br><span class="hljs-regexp">//</span>             multipass: false, <span class="hljs-regexp">//</span>类型：Boolean 默认：false 多次优化svg直到完全优化<br><span class="hljs-regexp">//</span>         &#125;))<br><span class="hljs-regexp">//</span>         .pipe(gulp.dest(<span class="hljs-string">&#x27;./public/images&#x27;</span>));<br><span class="hljs-regexp">//</span> &#125;);<br><br><span class="hljs-regexp">//</span> 压缩 public/images 目录内图片(Version&gt;<span class="hljs-number">3</span>)<br>gulp.task(<span class="hljs-string">&#x27;minify-images&#x27;</span>, <span class="hljs-keyword">function</span> (done) &#123;<br>    gulp.src(<span class="hljs-string">&#x27;./public/images/**/*.*&#x27;</span>)<br>        .pipe(imagemin([<br>            imagemin.gifsicle(&#123;interlaced: true&#125;),<br>            imagemin.jpegtran(&#123;progressive: true&#125;),<br>            imagemin.optipng(&#123;optimizationLevel: <span class="hljs-number">5</span>&#125;),<br>            imagemin.svgo(&#123;<br>                plugins: [<br>                    &#123;removeViewBox: true&#125;,<br>                    &#123;cleanupIDs: false&#125;<br>                ]<br>            &#125;)<br>        ]))<br>        .pipe(gulp.dest(<span class="hljs-string">&#x27;./public/images&#x27;</span>));<br>    done();<br>&#125;);<br><br><span class="hljs-regexp">//</span><span class="hljs-number">4.0</span>以前的写法 <br><span class="hljs-regexp">//gu</span>lp.task(<span class="hljs-string">&#x27;default&#x27;</span>, [<br><span class="hljs-regexp">//</span>  <span class="hljs-string">&#x27;minify-html&#x27;</span>, <span class="hljs-string">&#x27;minify-css&#x27;</span>, <span class="hljs-string">&#x27;minify-js&#x27;</span>, <span class="hljs-string">&#x27;minify-images&#x27;</span><br><span class="hljs-regexp">//</span>]);<br><span class="hljs-regexp">//</span><span class="hljs-number">4.0</span>以后的写法<br><span class="hljs-regexp">//</span> 执行 gulp 命令时执行的任务<br>gulp.task(<span class="hljs-string">&#x27;default&#x27;</span>, gulp.series(gulp.parallel(<span class="hljs-string">&#x27;minify-html&#x27;</span>, <span class="hljs-string">&#x27;minify-css&#x27;</span>, <span class="hljs-string">&#x27;minify-js&#x27;</span>, <span class="hljs-string">&#x27;minify-images&#x27;</span>)), <span class="hljs-keyword">function</span> () &#123;<br>    console.log(<span class="hljs-string">&quot;----------gulp Finished----------&quot;</span>);<br>    <span class="hljs-regexp">//</span> Do something after a, b, and c are finished.<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="4、创建-babelrc文件"><a href="#4、创建-babelrc文件" class="headerlink" title="4、创建.babelrc文件"></a>4、创建.babelrc文件</h2><p>在 Hexo 站点下新建.babelrc文件，文件内容如下：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>    <span class="hljs-string">&#x27;presets&#x27;</span>: [<span class="hljs-string">&#x27;es2015&#x27;</span>],<br>    <span class="hljs-string">&quot;plugins&quot;</span>: [<span class="hljs-string">&quot;transform-remove-strict-mode&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、静态资源压缩"><a href="#5、静态资源压缩" class="headerlink" title="5、静态资源压缩"></a>5、静态资源压缩</h2><pre><code class="hljs">只需要每次在执行 generate 命令后执行 gulp 就可以实现对静态资源的压缩</code></pre><p>hexo g<br>gulp</p><h2 id="6、补充："><a href="#6、补充：" class="headerlink" title="6、补充："></a>6、补充：</h2><h3 id="1-windows下创建-babelrc文件"><a href="#1-windows下创建-babelrc文件" class="headerlink" title="1.windows下创建.babelrc文件"></a>1.windows下创建.babelrc文件</h3><p>在windows系统下无法直接创建.babelrc文件，需要进入进入cmd窗口，进入hexo所在路径，使用<code>type nul&gt;名称 </code>来创建文件</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">type</span> <span class="hljs-built_in">nul</span>&gt;.babelrc<br></code></pre></td></tr></table></figure><h3 id="2-解决npm速度过慢问题"><a href="#2-解决npm速度过慢问题" class="headerlink" title="2.解决npm速度过慢问题"></a>2.解决npm速度过慢问题</h3><p><a href="https://www.cnblogs.com/sddai/p/9388261.html">npm过慢的解决方案</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo博客相关配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程(3)</title>
      <link href="/2019/09/07/%E7%BA%BF%E7%A8%8B-3/"/>
      <url>/2019/09/07/%E7%BA%BF%E7%A8%8B-3/</url>
      
        <content type="html"><![CDATA[<h2 id="Timer和Swing-Timer"><a href="#Timer和Swing-Timer" class="headerlink" title="Timer和Swing Timer"></a>Timer和Swing Timer</h2><ul><li>java提供了Timer和Swing Timer控件，用于执行规划好的任务或循环任务 *</li></ul><h3 id="Timer："><a href="#Timer：" class="headerlink" title="Timer："></a>Timer：</h3><p>使用步骤：</p><ol><li>定义一个类继承TimerTask，重写其中的run（）方法，这个方法就是所要执行的任务代码</li><li>创建Timer对象，通常使用不带参数的构造方法Timer（）直接实例化</li><li>调用Timer对象的schedule（）方法安排任务，传递一个TimerTask对象作为参数</li></ol><ul><li>schedule（TimerTask task，Date time）：在指定的时间执行任务</li><li>schedule（TimerTask task，Date firstTime，long period）：第一次到达指定时间firsttime时执行特定任务，并且每隔period参数指定的时间（毫秒）重复执行该任务</li><li>schedule（TimerTask task，long delay，long period）：延迟delay时间第一次执行任务，并且每隔period时间重复执行该任务</li></ul><ol start="4"><li>为取消一个规划好的任务，调用Timer对象的cancel方法</li></ol><h3 id="Swing-Timer："><a href="#Swing-Timer：" class="headerlink" title="Swing Timer："></a>Swing Timer：</h3><p>功能与Timer类一样，但只能在Swing应用程序中使用，可以处理线程共享，且不用将规划好的任务放在TimerTask子类的run（）方法中，而是在actionPerformed（）方法中编写所要执行的任务代码。<br><br>当要取消某个任务时，只需调用stop（）方法即可<br></p><h4 id="语法格式："><a href="#语法格式：" class="headerlink" title="语法格式："></a>语法格式：</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Timer（<span class="hljs-type">int</span> delay，ActionListener listener）<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>参数delay用于规定从调用start（）方法开始到第一次执行该任务的时间间隔（单位为毫秒）</li><li>参数listener指定监听对象，即ActionListener类的实例</li></ul><h4 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h4><ol><li>定义一个监听类，实现ActionListener监听接口，并重写actionPerformed方法，在该方法中编写所执行任务的代码</li><li>创建javax.swing.Timer对象</li><li>调用start（）方法启动Swing Timer</li><li>取消任务时可以调用stop（）方法停止Swing Timer</li></ol><h2 id="代码实例："><a href="#代码实例：" class="headerlink" title="代码实例："></a>代码实例：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 线程;<br><span class="hljs-keyword">import</span> java.awt.Color;<br><span class="hljs-keyword">import</span> java.awt.Font;<br><span class="hljs-keyword">import</span> java.awt.event.ActionEvent;<br><span class="hljs-keyword">import</span> java.awt.event.ActionListener;<br><span class="hljs-keyword">import</span> java.util.Timer;<br><span class="hljs-keyword">import</span> java.util.TimerTask;<br><br><span class="hljs-keyword">import</span> javax.swing.JButton;<br><span class="hljs-keyword">import</span> javax.swing.JFrame;<br><span class="hljs-keyword">import</span> javax.swing.JLabel;<br><span class="hljs-comment">//多线程案例，采用三种方法实现窗口背景，标签文字，不断变化，按钮左右移动</span><br><span class="hljs-keyword">import</span> javax.swing.JPanel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MutilThreadDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JFrame</span>&#123;<br>    <span class="hljs-comment">// 定义窗口，标签，按钮</span><br>JPanel jPanel=<span class="hljs-literal">null</span>;<br>JLabel jLabel=<span class="hljs-literal">null</span>;<br>JButton jButton=<span class="hljs-literal">null</span>;<br>String word[]= &#123;<span class="hljs-string">&quot;桐乃&quot;</span>,<span class="hljs-string">&quot;小埋&quot;</span>,<span class="hljs-string">&quot;宫子&quot;</span>,<span class="hljs-string">&quot;日向&quot;</span>&#125;;<br>    <span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> movex=<span class="hljs-number">5</span>;<br><span class="hljs-comment">//构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">MutilThreadDemo</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>jPanel=<span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>();<br>jLabel=<span class="hljs-keyword">new</span> <span class="hljs-title class_">JLabel</span>(word[<span class="hljs-number">0</span>]);<br>jButton=<span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">&quot;左右横移&quot;</span>);<br>jLabel.setFont(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>(<span class="hljs-string">&quot;黑体&quot;</span>,Font.BOLD,<span class="hljs-number">28</span>));<br>jLabel.setBounds(<span class="hljs-number">80</span>,<span class="hljs-number">50</span>,<span class="hljs-number">250</span>,<span class="hljs-number">50</span>);<br>jButton.setBounds(<span class="hljs-number">0</span>,<span class="hljs-number">150</span>,<span class="hljs-number">120</span>,<span class="hljs-number">25</span>);<br>jPanel.add(jLabel);<br>jPanel.add(jButton);<br><span class="hljs-built_in">this</span>.add(jPanel);<br><span class="hljs-built_in">this</span>.setSize(<span class="hljs-number">500</span>,<span class="hljs-number">300</span>);<br><span class="hljs-built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br><span class="hljs-comment">//采用Thread改变背景</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ChangeColor</span>().start();<br><span class="hljs-comment">//采用Timer改变文字</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>().schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChangeWord</span>(), <span class="hljs-number">0</span>,<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//采用Swing Timer改变按钮位置</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">javax</span>.swing.Timer(<span class="hljs-number">100</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChangePos</span>()).start();<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeColor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.isAlive()) &#123;<br><span class="hljs-type">int</span> r=(<span class="hljs-type">int</span>)(Math.random()*<span class="hljs-number">256</span>);<br><span class="hljs-type">int</span> g=(<span class="hljs-type">int</span>)(Math.random()*<span class="hljs-number">256</span>);<br><span class="hljs-type">int</span> b=(<span class="hljs-type">int</span>)(Math.random()*<span class="hljs-number">256</span>);<br>jPanel.setBackground(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(r,g,b));<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeWord</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TimerTask</span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>    jLabel.setText(word[index++]);<br>    <span class="hljs-keyword">if</span>(index==word.length)<br>    index=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangePos</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ActionListener</span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span><span class="hljs-params">(ActionEvent arg0)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>   <span class="hljs-type">int</span> x=jButton.getX()+movex;<br>   <span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-number">0</span>) &#123;<br>   <span class="hljs-comment">//换方向</span><br>   x=<span class="hljs-number">0</span>;<br>   movex=-movex;<br>   &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&gt;=getWidth()-jButton.getWidth()) &#123;<br>   x=getWidth()-jButton.getWidth();<br>   movex=-movex;<br>   &#125;<br>  jButton.setLocation(x,jButton.getY());<br>&#125;<br>&#125;<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>MutilThreadDemo mutilThreadDemo=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MutilThreadDemo</span>();<br>mutilThreadDemo.setVisible(<span class="hljs-literal">true</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：<br><br><img src="/2019/09/07/%E7%BA%BF%E7%A8%8B-3/output.gif" alt="运行结果"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程(2)</title>
      <link href="/2019/09/06/%E7%BA%BF%E7%A8%8B-2/"/>
      <url>/2019/09/06/%E7%BA%BF%E7%A8%8B-2/</url>
      
        <content type="html"><![CDATA[<h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>线程具有生命周期，当线程被创建并启动后，不会立即进入执行状态，也不会一直处于执行状态。<br><br>在线程的生命周期中，要经过5种状态:</p><pre><code class="hljs">• 新建 • 就绪• 运行 • 阻塞• 死亡</code></pre><h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><pre><code class="hljs">• 只能对新建状态的线程调用start方法，且只能调用一次• 如果调用start（）方法后需要线程立即开始执行，可以使用Thread.sleep（1）来让当前运行的主线程休眠1毫秒，此时子线程处于就绪状态的子线程• 被阻塞的线程阻塞解除后进入就绪状态</code></pre><h3 id="相关的一些方法："><a href="#相关的一些方法：" class="headerlink" title="相关的一些方法："></a>相关的一些方法：</h3><ul><li>sleep（）：暂停执行的方法，参数以毫秒为单位，注意抛出异常</li><li>如果一个线程包含了很长的循环，在循环的每次迭代之后把该线程切换到sleep休眠状态时一种很好的策略，这可以保证其他线程不必等待很长时间就能轮到处理器执行。</li><li>isALive（）：判断线程是否处于执行状态，当处于就绪，运行，阻塞状态时返回true</li><li>stop（）：直接停止线程，容易导致死锁，通常不推荐使用</li><li>join（）：可以让一个线程等待另一个线程完成后，继续执行原线程中的任务。当在某个程序执行流中调用其他线程的join方法时，当前线程将会被阻塞，直到另一个线程执行完成为止。</li></ul><h3 id="关于join的使用的实例："><a href="#关于join的使用的实例：" class="headerlink" title="关于join的使用的实例："></a>关于join的使用的实例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 线程;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JoinThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">JoinThread</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated constructor stub</span><br><span class="hljs-built_in">super</span>(name);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10</span>; i++)<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + i);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JoinDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// 输出当前线程的名称，发现为main</span><br>System.out.println(Thread.currentThread().getName());<br><span class="hljs-type">JoinThread</span> <span class="hljs-variable">jThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JoinThread</span>(<span class="hljs-string">&quot;子线程&quot;</span>);<br>jThread.start();<br><span class="hljs-comment">// 输出当前线程的名称,发现依然为main  jThread只是就绪</span><br>System.out.println(Thread.currentThread().getName());<br><span class="hljs-keyword">try</span> &#123;<br>jThread.join();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">// 输出当前线程的名称，发现为main</span><br>System.out.println(Thread.currentThread().getName());<br><span class="hljs-comment">// 输出当前子线程的状态</span><br>System.out.println(jThread.isAlive());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：<br><br><img src="/2019/09/06/%E7%BA%BF%E7%A8%8B-2/JoinDemo.PNG" alt="JoinDemo运行结果"></p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><ul><li>每个线程执行时都有一定的优先级，系统根据优先级调度线程</li><li>每个线程都有默认的优先级，与父线程相同</li><li>主线程具有普通优先级</li><li>Thread类提供三个静态常量来标识线程的优先级<ul><li>MAX_PRIORITY  最高优先级，其值为10</li><li>NORM_PRIORITY 普通优先级，其值为5，默认优先级</li><li>MIN_PRIORITY  最低优先级，值为1</li></ul></li><li>优先级高的线程提前获得执行的机会也会更多</li></ul><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>多线程访问同一资源会带来安全问题，java中提供了线程同步的概念来保证某个资源在<br>某一时刻只能由一个线程访问，保证共享数据的一致性<br>线程同步通常采用以下三种方式：</p><ul><li>同步代码块</li><li>同步方法</li><li>同步锁</li></ul><h3 id="同步代码块："><a href="#同步代码块：" class="headerlink" title="同步代码块："></a>同步代码块：</h3><p>将对实例的访问语句放入一个同步块中，语法格式如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>（object）&#123;<br><span class="hljs-comment">//需要同步的代码块</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中synchronized是关键字，object是监视器<br>实例，客户在银行中存钱，账户唯一，用线程进行存取钱操作，初始余额5000.<br><br>假设客户进行了5次操作，如果没有同步，可能执行时候每个操作都以初始值5000为起点，最后得到的值是错的;<br>而执行同步操作后，每次只进行一种操作，以上次操作结果为起点，可以保证操作的正确性</p><h3 id="同步方法："><a href="#同步方法：" class="headerlink" title="同步方法："></a>同步方法：</h3><p>使用synchronized关键字修饰需要同步的方法，语法格式如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">[访问修饰符]<span class="hljs-keyword">synchronized</span> 返回类型 方法名（参数）&#123;<br><span class="hljs-comment">//方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一个具有同步方法的类也被称为“线程安全类”<br><br>synchronized锁定的是对象，而不是代码块或方法，也可以修饰类</p><h3 id="同步锁："><a href="#同步锁：" class="headerlink" title="同步锁："></a>同步锁：</h3><p>Lock是控制多个线程对共享资源进行访问的工具，能够对共享资源进行独占访问<br><br>有ReentrantLock（可重入锁）实现类<br>步骤：</p><ol><li>定义一个ReentrantLock锁对象，该对象是final常量</li><li>在需要保证线程安全的代码之前增加“加锁”操作</li><li>在执行完线程安全的代码后释放锁</li></ol><h3 id="代码示例-使用同步方法，同步锁-："><a href="#代码示例-使用同步方法，同步锁-：" class="headerlink" title="代码示例(使用同步方法，同步锁)："></a>代码示例(使用同步方法，同步锁)：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 线程;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-comment">//银行账户</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span> &#123;<br><span class="hljs-comment">// 银行账户</span><br><span class="hljs-keyword">private</span> String bankNo;<br><span class="hljs-comment">// 银行余额</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">double</span> balance;<br>    <span class="hljs-comment">//定义锁对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock lock=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">BankAccount</span><span class="hljs-params">(String bankNO, <span class="hljs-type">double</span> balance)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated constructor stub</span><br><span class="hljs-built_in">this</span>.bankNo = bankNO;<br><span class="hljs-built_in">this</span>.balance = balance;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> balance;<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBankNo</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> bankNo;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBalance</span><span class="hljs-params">(<span class="hljs-type">double</span> balance)</span> &#123;<br><span class="hljs-built_in">this</span>.balance = balance;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBankNo</span><span class="hljs-params">(String bankNo)</span> &#123;<br><span class="hljs-built_in">this</span>.bankNo = bankNo;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">access</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-comment">//lock.lock();</span><br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span>(money&lt;<span class="hljs-number">0</span>&amp;balance&lt;-money)<br>&#123;<br>System.out.println(<span class="hljs-string">&quot;余额不足，操作失败&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>balance+=money;<br>System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;操作成功，目前余额为：&quot;</span>+balance);<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1</span>);<br>&#125;<span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>e.printStackTrace();<br>&#125;<span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">//lock.unlock();</span><br>&#125;<br>&#125;<br><br>&#125;<br><br><br><span class="hljs-keyword">package</span> 线程;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BankLock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><span class="hljs-keyword">private</span> BankAccount account;<br><span class="hljs-keyword">private</span> <span class="hljs-type">double</span> money;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">BankLock</span><span class="hljs-params">(String name, BankAccount account, <span class="hljs-type">double</span> money)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated constructor stub</span><br><span class="hljs-built_in">super</span>(name);<br><span class="hljs-built_in">this</span>.money = money;<br><span class="hljs-built_in">this</span>.account = account;<br>&#125;<br><br><span class="hljs-comment">// 线程任务</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-built_in">this</span>.account.access(money);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// 创建账户，启动线程</span><br><span class="hljs-type">BankAccount</span> <span class="hljs-variable">cAccount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankAccount</span>(<span class="hljs-string">&quot;WT&quot;</span>, <span class="hljs-number">5000</span>);<br><span class="hljs-type">BankLock</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankLock</span>(<span class="hljs-string">&quot;task1&quot;</span>, cAccount, -<span class="hljs-number">3000</span>);<br><span class="hljs-type">BankLock</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankLock</span>(<span class="hljs-string">&quot;task2&quot;</span>, cAccount, -<span class="hljs-number">3000</span>);<br><span class="hljs-type">BankLock</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankLock</span>(<span class="hljs-string">&quot;task3&quot;</span>, cAccount, <span class="hljs-number">1000</span>);<br><span class="hljs-type">BankLock</span> <span class="hljs-variable">t4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankLock</span>(<span class="hljs-string">&quot;task4&quot;</span>, cAccount, -<span class="hljs-number">2000</span>);<br><span class="hljs-type">BankLock</span> <span class="hljs-variable">t5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankLock</span>(<span class="hljs-string">&quot;task5&quot;</span>, cAccount, <span class="hljs-number">2000</span>);<br>t1.start();<br>t2.start();<br>t3.start();<br>t4.start();<br>t5.start();<br><span class="hljs-keyword">try</span> &#123;<br>t1.join();<br>t2.join();<br>t3.join();<br>t4.join();<br>t5.join();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>e.printStackTrace();<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;账户：&quot;</span> + cAccount.getBankNo());<br>System.out.println(<span class="hljs-string">&quot;余额：&quot;</span> + cAccount.getBalance());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>加入目前系统中有生产和消费两个线程，系统要求不断重复生产，消费操作，并要求每当一个线程生产后，另一个线程立即进行消费，不允许连续两次生产，也不允许连续两次消费，实现这种功能，可以采用线程间的通信技术<br>相关方法：</p><ul><li>wait（）方法</li><li>notify（）方法</li><li>notifyAll（）方法<br>详细的解释:<br><br><a href="https://blog.csdn.net/u011635492/article/details/83043212">https://blog.csdn.net/u011635492/article/details/83043212</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程</title>
      <link href="/2019/09/05/%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/09/05/%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="线程和进程："><a href="#线程和进程：" class="headerlink" title="线程和进程："></a>线程和进程：</h2><h3 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h3><p>在操作系统中，每个独立运行的程序就是一个进程，当一个程序进入内存运行时，即变成一个进程。<br><br>进程是操作系统进行资源分配和调度的一个独立单位，进程之间资源不共享，多进程之间通过信号，管道进行交互。<br></p><h3 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h3><p>是进程的组成部分，一个进程可以有多个线程，至少有一个。线程是最小的处理单位，可以拥有自己的堆栈，计数器，局部变量，但不能拥有系统资源，多线程之间数据块可以共享</p><h2 id="java线程模型"><a href="#java线程模型" class="headerlink" title="java线程模型"></a>java线程模型</h2><p>java线程模型提供线程所必需的功能支持，基本的java线程模型有<strong>Thread类，Runnable接口，Callable接口和Future接口</strong>等。</p><h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><h3 id="主要方法："><a href="#主要方法：" class="headerlink" title="主要方法："></a>主要方法：</h3><ul><li>Thread构造方法，包含多个重载类型</li><li>getName（）获取线程名称</li><li>setName（）设置线程名称</li><li>isAlive（） 判断线程是否处于激活状态，返回boolean值</li><li>getId（）获取线程ID</li><li>setPriority（）设置线程优先级</li><li>getPriority（） 获取线程优先级</li><li>join（）等待线程死亡</li><li>sleep（）将线程挂起一段时间，以毫秒为单位</li><li>run（）线程的执行方法</li><li>start（）开始线程</li><li>stop（）停止线程，已过期</li><li>interrput（）中断线程</li><li>activeCount（）返回激活的线程数</li></ul><h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><p>在java语言中，每个能够独立运行的Java程序都至少有一个主线程，且在程序启动时，JVM会自动创建一个主线程来执行该程序中的main（）方法<br><br>在多线程编程时，main（）方法的方法体就是主线程的执行体，main（）方法中的代码就是主线程要完成的任务</p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>三种方法：</p><ul><li>继承Thread类，重写Thread类中的run（）方法，直接创建线程</li><li>实现Runnable接口，再通过Thread类和Runnable的实现类间接创建一个线程</li><li>使用Callable和Future的接口间接创建线程</li></ul><p>上述三种方式从本质上是一致的，最终都是通过Thread类来建立线程，提供接口是由与java不支持多继承，用这种方法还可以继承其他类。</p><h3 id="1-继承Thread类："><a href="#1-继承Thread类：" class="headerlink" title="1.继承Thread类："></a>1.继承Thread类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 线程;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>   <span class="hljs-comment">//重新run方法</span><br>     <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">10</span>;i++) &#123;<br>    System.out.println(<span class="hljs-built_in">this</span>.getName()+<span class="hljs-string">&quot; : &quot;</span>+i);<br>    &#125;<br>    &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Thread1 thread1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread1</span>();<br><span class="hljs-comment">//启动线程</span><br>thread1.start();<br><span class="hljs-comment">//主线程任务</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1000</span>;i&lt;=<span class="hljs-number">1010</span>;i++) &#123;<br>System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; : &quot;</span>+i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：<br><br><img src="/2019/09/05/%E7%BA%BF%E7%A8%8B/Thread1.PNG" alt="继承Threadd类实现线程的结果"></p><h3 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2.实现Runnable接口"></a>2.实现Runnable接口</h3><p>Runnable接口中只有一个run（）方法，一个类实现Runnable接口后，并不代表该类是个“线程类”，不能直接启动线程，必须通过Thread类的实例来创建并启动线程<br>步骤如下：</p><pre><code class="hljs">1 定义一个类实现Runnable接口，并实现run（）方法2 以实现类为参数创建一个Thread类的实例3 调用Thread对象的start（）方法启动线程</code></pre><p>实例如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 线程;<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>   <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-comment">//使用Runnable接口时，只能使用Thread.currentThread()获取当前线程</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">10</span>;i++)<br>   System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; : &quot;</span>+i);<br>&#125;<br>   &#125;<br>   <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread2</span> &#123;<br>  <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Thread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>());<br>thread.start();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1000</span>;i&lt;=<span class="hljs-number">1010</span>;i++)<br>System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; : &quot;</span>+i);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：<br><br><img src="/2019/09/05/%E7%BA%BF%E7%A8%8B/Thread2.PNG" alt="使用Runnable接口实现线程"></p><h3 id="3-使用Callable和Future接口"><a href="#3-使用Callable和Future接口" class="headerlink" title="3.使用Callable和Future接口"></a>3.使用Callable和Future接口</h3><p>Callable接口提供一个call（）方法作为线程的执行体，该方法的返回值使用Future接口来代表。使用Callable和Future接口的最大优势在于可以在线程执行完任务之后获取执行结果，步骤如下：</p><pre><code class="hljs">1 创建Callable接口的实现类，并实现call（）方法，该方法将作为线程的执行体，并且有返回值；然后创建Callable实现类的实例2 使用FutureTask类来包装Callable对象，在FutureTask对象中封装了Callable对象的call（）方法的返回值3 使用FutureTask对象作为Thread对象的target，创建并启动新线程4 调用FutureTask对象的get（）方法来获得子线程执行结束后的返回值</code></pre><p>实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 线程;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-comment">//1.创建Callable接口的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-keyword">for</span> (; i &lt;= <span class="hljs-number">10</span>; i++)<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + i);<br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread3</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br><span class="hljs-comment">// 2.使用FutureTask类包装Callable实现类的实例</span><br>FutureTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;Integer&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>());<br><span class="hljs-comment">// 3.创建线程，使用FutureTask对象task作为Thread对象的Target，并调用start方法启动线程</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;子线程&quot;</span>).start();<br><span class="hljs-comment">// 4.调用FutureTask对象task的get()方法获取子线程执行结束后的返回值</span><br>System.out.println(<span class="hljs-string">&quot;子线程返回值：&quot;</span> + task.get());<br><span class="hljs-comment">// 主线程任务</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>; i &lt;= <span class="hljs-number">1010</span>; i++) &#123;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + i);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：<br><br><img src="/2019/09/05/%E7%BA%BF%E7%A8%8B/Thread3.PNG" alt="采用Callable和Future接口实现线程"><br>从java8开始可以直接使用Lambda表达式创建Callable对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 线程;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread4</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException  &#123;<br>FutureTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;Integer&gt;(<br>(Callable&lt;Integer&gt;)()-&gt;&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; i &lt;= <span class="hljs-number">10</span>; i++)<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + i);<br><span class="hljs-keyword">return</span> i;<br>&#125;<br>);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;子线程&quot;</span>).start();<br>System.out.println(<span class="hljs-string">&quot;子线程返回值：&quot;</span> + task.get());<br><span class="hljs-comment">// 主线程任务</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>; i &lt;= <span class="hljs-number">1010</span>; i++) &#123;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果同上</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2019/09/04/JDBC/"/>
      <url>/2019/09/04/JDBC/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>JDBC（Java Database Connectivity，Java 数据库连接）是一种执行SQL语句的Java API。程序可以通过JDBC API连接到关系数据库，并使用SQL结构化查询语言来完成对数据库的增删改查操作。<br><br>基本工作：</p><pre><code class="hljs">• 建立与数据库的连接• 执行SQL语句• 获取执行结果</code></pre><h2 id="JDBC驱动："><a href="#JDBC驱动：" class="headerlink" title="JDBC驱动："></a>JDBC驱动：</h2><p>数据库驱动程序负责将JDBC调用映射成特定的数据库调用</p><pre><code class="hljs">• JDBC-ODBC桥• 本地API驱动• 网络协议驱动• 本地协议驱动</code></pre><h2 id="JDBC-API："><a href="#JDBC-API：" class="headerlink" title="JDBC API："></a>JDBC API：</h2><pre><code class="hljs"> 1. DriverManger类：用于管理JDBC驱动的服务类，主要功能是加载和卸载各种驱动程序，建立数据库的连接并获取连接对象。包含的方法有：• getConnection（url，user，password）：获取指定URL的数据库连接• getDriver（url）：返回能够打开url所指定的数据库的驱动程序2. Connection接口：用于连接数据库，通过DriverManager类的getConnection方法返回一个Connection对象，该对象中提供了创建SQL语句的方法，以完成基本的SQL操作，同时为数据库事务提供了提交和回滚的方法：</code></pre><p> <img src="/2019/09/04/JDBC/connetion.jpg" alt="Connection的常用方法"></p><pre><code class="hljs"> Statement接口：一般用于执行SQL语句，接口中提供的createStatement（），prepareStatement（），prepareCall（）方法分别返回一个用于执行SQL语句的Statement对象，PreparedStatement对象，CallableStatement对象，对应三种查询方式：一般查询，参数查询，存储过程&lt;br&gt;</code></pre><p><img src="/2019/09/04/JDBC/jc.png"></p><p><img src="/2019/09/04/JDBC/statement.jpg" alt="Statement常用方法"></p><p>ResultSet接口：用于封装结果集对象，该对象包含访问查询结果的方法，提供了一套getXXX（）方法对结果集中的数据进行访问，这些方法可以通过列索引或列名获得数据</p><p><img src="/2019/09/04/JDBC/resultset.jpg" alt="ResultSet常用方法"></p><p>具体操作流程为：</p><pre><code class="hljs">1. 通过java Class类加载驱动2. 使用DriverManger类的getConnection方法获取数据库连接对象3. 创建Statement对象，三种4. 执行SQL语句：ececuteQuery（）返回结果集，executeUpdate（）执行语句，execute（）：execute几乎可以执行任何SQL语句，返回boolean值，若返回值为true，可以通过getResultSet（）方法获得结果集5. 访问结果集 getXXX（）6. 最后关闭结果集，关闭对象，结束连接   close（）</code></pre><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><a href="https://github.com/3422878082/Learn-JDBC">https://github.com/3422878082/Learn-JDBC</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdbc </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章</title>
      <link href="/2019/09/03/%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2019/09/03/%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>习题<br><br>冯诺依曼计算机体系的基本思想是什么？<br><br>按此思想设计的计算机硬件系统应由哪些部件组成？<br><br>各起什么作用？<br></p><p>1 计算机由五部分组成：输入设备，存储器，运算器，控制器，输出设备</p><ul><li>首先是输入设备，负责输入程序，数据，将信息转换为机器能识别的形式</li><li>之后将信息存在存储器中，并且按地址顺序地存放</li><li>运算器负责进行算数运算和逻辑运算，而控制器负责指挥程序运行，</li><li>最后输出设备负责将结果转换为人们熟悉的形式</li></ul><p>2 计算机内部应采用二进制来表示指令和数据</p><p>3 编好的程序顺序自动执行</p><pre><code class="hljs">• PC（程序计数器） 装入程序首地址• PC+1→PC</code></pre><p>4 程序跳跃用指令实现</p><p>执行示意图：<br><br><br><img src="/2019/09/03/%E7%AC%AC%E4%B8%80%E7%AB%A0/zhixing.PNG" alt="执行流程图"><br><br></p><p>计算机发展经过了几代？每一代的基本特征是什么？<br></p><pre><code class="hljs">1. 电子管2. 晶体管3. 中小规模集成电路 MSI，SSI4. 大规模集成电路和超大规模集成电路 LSI，VLSI</code></pre><p>计算机系统从功能上可划分为哪些层次？各层次在计算机系统中起什么作用？<br><br><br><img src="/2019/09/03/%E7%AC%AC%E4%B8%80%E7%AB%A0/cengci.PNG" alt="计算机功能层次图"></p><p><strong>各层次作用</strong>：</p><ul><li>第一级是微程序设计级，微程序直接由硬件执行，属于硬件级</li><li>第二级是一般机器级，一条机器指令对应着一段微程序，属于硬件级</li><li>第三级是操作系统级，由操作系统程序实现。这些操作系统由机器指令和广义指令组成，这些广义指令是操作系统定义和解释的软件指令，所以这一级也称为混合级。</li><li>第四级是汇编语言级，给程序人员提供一种符号形式语言，以减少程序编写的复杂性。这一级由汇编程序支持和执行，属于软件级</li><li>第五级是高级语言级，这是面向用户的，为方便用户编写应用程序而设置的，属于软件级</li></ul><p>计算机内部有哪两股信息在流动？它们彼此有什么关系？<br><br>信息流，控制流<br><br>信息流受控制流的控制<br><br></p><p>固件：<br><br>固件(Firmware)就是写入EPROM（可擦写可编程只读存储器）或EEPROM(电可擦可编程只读存储器)中的程序。<br><br>固件是指设备内部保存的设备“驱动程序”，通过固件，操作系统才能按照标准的设备驱动实现特定机器的运行动作，比如光驱、刻录机等都有内部固件。<br><br>固件是担任着一个系统最基础最底层工作的软件。而在硬件设备中，固件就是硬件设备的灵魂，因为一些硬件设备除了固件以外没有其它软件组成，因此固件也就决定着硬件设备的功能及性能。<br></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java网络编程</title>
      <link href="/2019/09/03/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/09/03/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>java中有关网络方面的功能定义都在java.net包中</strong></p><h2 id="InetAddress类封装IP或域名"><a href="#InetAddress类封装IP或域名" class="headerlink" title="InetAddress类封装IP或域名"></a>InetAddress类封装IP或域名</h2><p>包含的方法：</p><pre><code class="hljs">* 获取本机对应的InetAdress对象：getLocalHost* 根据主机获得对应的InetAdress对象，参数为String类型，可以是ip地址或域名：getByName（String ）* 根据主机获得具有相同名字的一组InetAddress对象：getAllByName（String）* 获取addr所封装的IP地址对应的InetAddress对象：getByAddress（byte[] addr）* 获取ip地址：getHostAddress* 获取域名：getHostName* 判断是否可以到达该地址：isReachable</code></pre><h2 id="URL类（Uniform-Resource-Locator，统一资源定位器"><a href="#URL类（Uniform-Resource-Locator，统一资源定位器" class="headerlink" title="URL类（Uniform Resource Locator，统一资源定位器)"></a>URL类（Uniform Resource Locator，统一资源定位器)</h2><p>通常语法格式：  协议名：&#x2F;&#x2F;主机名：端口号&#x2F;资源名 <br><br>getXXX（）返回相应信息<br></p><h2 id="URI类-统一资源标识符"><a href="#URI类-统一资源标识符" class="headerlink" title="URI类  统一资源标识符"></a>URI类  统一资源标识符</h2><p>唯一作用就是解析  可以将URL理解成URI的特例<br><br>创建URL对象需要抛出异常<br><br>openConnection方法用于返回一个URLConnection对象，URLConnection类提供一些更强的方法</p><pre><code class="hljs">• 获得文件的长度，类型，创建时间，修改时间  getXXX（）• 获得输入流，以便读取文件的数据  getInputStream（）• 获得输出流，以便输出数据 getOutputStream（）• 设置请求属性值：setRequestProperty（String key，String value）</code></pre><h2 id="基于TCP的网络编程-关于套接字-socket"><a href="#基于TCP的网络编程-关于套接字-socket" class="headerlink" title="基于TCP的网络编程  关于套接字 socket"></a>基于TCP的网络编程  关于套接字 socket</h2><p>使用TCP&#x2F;IP协议进行通信时，会在通信的两端各建立一个Socket（套接字），从而形成虚拟链路<br><br>使用Socket对象封装了两端的通信端口，屏蔽了底层细节，其允许用户将网络连接当成一个IO流，<br><br>读写数据<br><br>主要使用java.net包下的两个类：</p><p>   <strong>ServeSocket</strong>类：服务器套接字<br><br>   <strong>Socket</strong>类：客户端套接字<br><br><strong>都必须抛出异常</strong></p><hr><p>基础用法：<br><br><strong>客户端</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 网络编程;<br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.io.PrintStream;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//创建连接到本机对象</span><br>Socket socket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;10.0.218.101&quot;</span>,<span class="hljs-number">28888</span>);<br><span class="hljs-comment">//将socket对应的输出对象包装成printstream</span><br>PrintStream printStream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(socket.getOutputStream());<br><span class="hljs-comment">//往服务器发送信息</span><br>printStream.println(<span class="hljs-string">&quot;我是客户&quot;</span>);<br>printStream.flush();<br><span class="hljs-comment">//获取服务器的信息,将socket对应的输入流包装成bufferreader</span><br><span class="hljs-comment">//BufferedInputStream bufferedInputStream=new BufferedInputStream(socket.getInputStream());</span><br>    BufferedReader bufferedReader=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream()));<br>    String line=bufferedReader.readLine();<br>    System.out.println(<span class="hljs-string">&quot;来自服务器的数据：&quot;</span>+line);<br>    <span class="hljs-comment">//关闭</span><br>    bufferedReader.close();<br>    printStream.close();<br>    socket.close();<br>&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>e.printStackTrace();<br>&#125;<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>服务端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 网络编程;<br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.io.PrintStream;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>ServerSocket server;<br><span class="hljs-comment">// 计数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Server</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 创建serversocket，用于监听客户端对应的端口号是否有socket</span><br><span class="hljs-keyword">try</span> &#123;<br>server = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">28888</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">// 启动当前线程，执行run方法</span><br><span class="hljs-built_in">this</span>.start();<br>System.out.println(<span class="hljs-string">&quot;服务器启动&quot;</span>);<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.isAlive()) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 首先接受客户端的Socket</span><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> server.accept();<br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream()));<br><span class="hljs-comment">// 读客户端发送的消息并显示</span><br><span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> bufferedReader.readLine();<br>System.out.println(<span class="hljs-string">&quot;客户端发送的消息为：&quot;</span> + line);<br><span class="hljs-comment">// 将socket对应的输出流包装成为printstream</span><br><span class="hljs-type">PrintStream</span> <span class="hljs-variable">printStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(socket.getOutputStream());<br><span class="hljs-comment">// 往客户端发送消息</span><br>printStream.println(<span class="hljs-string">&quot;您是第&quot;</span> + (++num) + <span class="hljs-string">&quot;个访问服务器的用户！&quot;</span>);<br>printStream.close();<br>bufferedReader.close();<br>socket.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>应用：实现一个简易的聊天室</strong></p><pre><code class="java">客户端：package 网络编程;import java.awt.BorderLayout;import java.awt.Label;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.PrintStream;import java.net.Socket;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JPanel;import javax.swing.JScrollPane;import javax.swing.JTextArea;import javax.swing.JTextField;public class chatClient extends JFrame &#123;    Socket socket = null;    PrintStream pStream = null;    BufferedReader bReader = null;    JPanel jPanelbottom = null;    JScrollPane jScrollPane = null;    JLabel label_name = null;    JLabel label_txt = null;    JButton send = null;    JTextArea maintxt = null;    JTextField txt_name = null;    JTextField txt_input = null;    public chatClient() &#123;        // TODO Auto-generated constructor stub        // 组装底部一栏        super(&quot;聊天室&quot;);        label_name = new JLabel(&quot;昵称&quot;);        txt_name = new JTextField(5);        label_txt = new JLabel(&quot;输入消息&quot;);        txt_input = new JTextField(20);        send = new JButton(&quot;发送&quot;);        jPanelbottom = new JPanel();        jPanelbottom.add(label_name);        jPanelbottom.add(txt_name);        jPanelbottom.add(label_txt);        jPanelbottom.add(txt_input);        jPanelbottom.add(send);        this.add(jPanelbottom, BorderLayout.SOUTH);        // 组装显示主界面        maintxt = new JTextArea();        maintxt.setEditable(false);        jScrollPane = new JScrollPane(maintxt);        this.add(jScrollPane);        this.setSize(500, 300);        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        try &#123;            // 创建socket对象            socket = new Socket(&quot;10.0.218.101&quot;, 28888);            // 创建一个往socket里写数据的管道            pStream = new PrintStream(socket.getOutputStream());            // 创建一个从socket里读数据的管道            bReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));        &#125; catch (Exception e) &#123;            e.printStackTrace();// TODO: handle exception        &#125;        // 为发送按钮注册监听        send.addActionListener(new ActionListener() &#123;            @Override            public void actionPerformed(ActionEvent arg0) &#123;                // TODO Auto-generated method stub                String name = txt_name.getText();                String msg = txt_input.getText();                if (!msg.equals(&quot;&quot;)) &#123;                    pStream.println(name + &quot;说：&quot; + msg);                    pStream.flush();                    // 发送完毕清空输入框                    txt_input.setText(&quot;&quot;);                &#125;            &#125;        &#125;);        // 启动线程        new GetMsg().start();    &#125;    // 接收服务器返回信息的线程    class GetMsg extends Thread &#123;        public void run() &#123;            while (this.isAlive()) &#123;                try &#123;                    String getMsg = bReader.readLine();                    if (getMsg != null) &#123;                        // 主窗口显示信息并换行                        maintxt.append(getMsg + &quot;\n&quot;);                    &#125;                    Thread.sleep(50);                &#125; catch (Exception e) &#123;                    e.printStackTrace();// TODO: handle exception                &#125;            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        new chatClient().setVisible(true);    &#125;&#125;服务端：package 网络编程;import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.LinkedList;import javax.swing.JFrame;public class chatServer extends JFrame &#123;    // 声明服务器端套接字    ServerSocket serverSocket;    // 输入流列表集合    ArrayList&lt;BufferedReader&gt; bReaders = new ArrayList&lt;BufferedReader&gt;();    // 输出流列表集合    ArrayList&lt;PrintWriter&gt; pStreams = new ArrayList&lt;PrintWriter&gt;();    // 聊天信息链表集合    LinkedList&lt;String&gt; msgList = new LinkedList&lt;String&gt;();    public chatServer() &#123;        try &#123;            serverSocket = new ServerSocket(28888);        &#125; catch (Exception e) &#123;            e.printStackTrace();// TODO: handle exception        &#125;        // 创建接收客户端Socket的线程实例，并启动        new getMsg().start();        // 创建给客户端发送消息的线程实例，并启动        new SendMag().start();        System.out.println(&quot;服务器已经启动&quot;);    &#125;    // 接收客户端消息线程    class getMsg extends Thread &#123;        @Override        public void run() &#123;            // TODO Auto-generated method stub            while (this.isAlive()) &#123;                try &#123;                    // 接收一个客户端socket对象                    Socket socket = serverSocket.accept();                    if (socket != null) &#123;                        // 获取socket对象的输入流                        BufferedReader bReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));                        // 将输入流添加入输入流列表集合中                        bReaders.add(bReader);                        // 开启一个线程接收该客户的聊天信息                        new getMsg1(bReader).start();                        // 获取socket对象的输出流，并将其加入输出流列表中                        pStreams.add(new PrintWriter(socket.getOutputStream()));                    &#125;                &#125; catch (Exception e) &#123;                    e.printStackTrace();// TODO: handle exception                &#125;            &#125;        &#125;    &#125;    // 接收客户聊天信息的线程    class getMsg1 extends Thread &#123;        BufferedReader bReader;        public getMsg1(BufferedReader bReader) &#123;            this.bReader = bReader;        &#125;        @Override        public void run() &#123;            while (this.isAlive()) &#123;                try &#123;                    // 从输入流中读取一行消息                    String strMsg = bReader.readLine();                    if (strMsg != null) &#123;                        SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);                        String strTime = dateFormat.format(new Date());                        msgList.addFirst(&quot;&lt;== &quot; + strTime + &quot; ==&gt;\n&quot; + strMsg);                    &#125;                &#125; catch (Exception e) &#123;                    e.printStackTrace();// TODO: handle exception                &#125;            &#125;        &#125;    &#125;    // 给所有客户发送聊天信息的线程    class SendMag extends Thread &#123;        @Override        public void run() &#123;            while (this.isAlive()) &#123;                try &#123;                    // 如果信息链表不为空 发送                    if (!msgList.isEmpty()) &#123;                        String msg = msgList.removeLast();                        for (int i = 0; i &lt; pStreams.size(); i++) &#123;                            pStreams.get(i).println(msg);                            pStreams.get(i).flush();                        &#125;                    &#125;                &#125; catch (Exception e) &#123;                    // TODO: handle exception                &#125;            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        new chatServer();    &#125;&#125; </code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse连接MySQL数据库</title>
      <link href="/2019/05/21/Eclipse%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/05/21/Eclipse%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>其实很简单，但还是应该记录一下<br>参考了这个作者的<a href="http://www.cnblogs.com/fnng/archive/2011/07/18/2110023.html">博客</a><br></p><p>MySQL我选择了Navicat for MySQL这个软件，中文版，挺好用的</p>]]></content>
      
      
      <categories>
          
          <category> 各种搭建配置坑的记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录hexo博客的建立</title>
      <link href="/2019/05/19/%E8%AE%B0%E5%BD%95hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
      <url>/2019/05/19/%E8%AE%B0%E5%BD%95hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B/</url>
      
        <content type="html"><![CDATA[<p>一直想有个自己单独的博客，这几天呢，踩了大大小小的坑，终于把它给弄好了，配置的过程参考了很多人的博客，在此记录:<br><br>1.<a href="https://www.bilibili.com/video/av44544186?from=search&seid=2380386286865002522/" title="手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo">首先是B站一个up主的视频</a><br><br>up主介绍的虽然比较详细，但是所演示的环境并非在windows之下，然后我在视频评论中找到了这个老哥的链接<br><br>2.<a href="https://caiyantao.gitee.io/2019/04/13/Hexo-%E4%B8%80/#more/" title="Hexo学习">windows下的讲解</a><br><br>一路走下去还算顺利，中间遇到了一个错误，解决方法在这:<a href="https://www.v2ex.com/t/175940/" title="可能其他人不会遇到，仅提醒，可以试一下">错误解决</a>,之后老哥是部署到Coding上的，我注册时出现问题，就没成功，于是接着找了其他人的教程（当然了，最后我在github和Coding上都部署成功了）<br><br>3.<a href="https://zhuanlan.zhihu.com/p/26625249/" title="GitHub+Hexo 搭建个人网站详细教程">知乎教程</a><br><br>这份教程特别详细，其实可以完全从一开始就按上面来.部署成功后自然是选择主题，优化主题，经过试错后选择了最多人用的next主题，简洁又不简单，资料又好找，之后可能会多尝试其他主题，不过呢，在安装next主题时注意安装目前的新版，此教程中的是旧版，可能会与某些插件有不兼容的问题<br><br>4.<a href="https://blog.csdn.net/qq_36759224/article/details/85420403/" title="Hexo 博客优化之博客美化（看板娘/鼠标点击爱心字体烟花爆炸效果/自定义鼠标指针样式/彩色滚动变换字体/背景音乐/网页标题恶搞/动态线条/人体时钟挂件/雪花飘落/背景动态彩带......）">主题配置和优化</a><br><br>这方面网上教程特别多，不过看一两篇就够了，因为内容大多一样 <br><br>5.<a href="https://gaomf.cn/2015/11/01/Hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6/" title="Hexo博客优化加载速度">优化博客访问速度</a> <br><br>因为一开始是部署到Github上的，实在是有些慢，所以还是尝试部署在国内平台，参考了这位博主的教程成功了<br><br><br>在写博客时，有些特定的博客不想让其他人看见，我们可以加密自己的博客，具体参考<a href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md">这里</a><br>这样其他人就需要输入密码才能访问我们的博客<br><br>在写博客时，markdown编辑器的话，我用的是vs code ,装Markdown All in One 这个插件就够了，其他的按自己需要，感觉是目前用过的最好用的了.</p>]]></content>
      
      
      <categories>
          
          <category> hexo博客相关配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置环境 </tag>
            
            <tag> 总结 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
